/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/apexcharts/dist/apexcharts.js":
/*!****************************************************!*\
  !*** ./node_modules/apexcharts/dist/apexcharts.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * ApexCharts v3.43.2\n * (c) 2018-2023 ApexCharts\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n\n      if (enumerableOnly) {\n        symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      }\n\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    } else if (call !== void 0) {\n      throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n\n    var _s, _e;\n\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  /*\n   ** Generic functions which are not dependent on ApexCharts\n   */\n  var Utils$1 = /*#__PURE__*/function () {\n    function Utils() {\n      _classCallCheck(this, Utils);\n    }\n\n    _createClass(Utils, [{\n      key: \"shadeRGBColor\",\n      value: function shadeRGBColor(percent, color) {\n        var f = color.split(','),\n            t = percent < 0 ? 0 : 255,\n            p = percent < 0 ? percent * -1 : percent,\n            R = parseInt(f[0].slice(4), 10),\n            G = parseInt(f[1], 10),\n            B = parseInt(f[2], 10);\n        return 'rgb(' + (Math.round((t - R) * p) + R) + ',' + (Math.round((t - G) * p) + G) + ',' + (Math.round((t - B) * p) + B) + ')';\n      }\n    }, {\n      key: \"shadeHexColor\",\n      value: function shadeHexColor(percent, color) {\n        var f = parseInt(color.slice(1), 16),\n            t = percent < 0 ? 0 : 255,\n            p = percent < 0 ? percent * -1 : percent,\n            R = f >> 16,\n            G = f >> 8 & 0x00ff,\n            B = f & 0x0000ff;\n        return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);\n      } // beautiful color shading blending code\n      // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\n\n    }, {\n      key: \"shadeColor\",\n      value: function shadeColor(p, color) {\n        if (Utils.isColorHex(color)) {\n          return this.shadeHexColor(p, color);\n        } else {\n          return this.shadeRGBColor(p, color);\n        }\n      }\n    }], [{\n      key: \"bind\",\n      value: function bind(fn, me) {\n        return function () {\n          return fn.apply(me, arguments);\n        };\n      }\n    }, {\n      key: \"isObject\",\n      value: function isObject(item) {\n        return item && _typeof(item) === 'object' && !Array.isArray(item) && item != null;\n      } // Type checking that works across different window objects\n\n    }, {\n      key: \"is\",\n      value: function is(type, val) {\n        return Object.prototype.toString.call(val) === '[object ' + type + ']';\n      }\n    }, {\n      key: \"listToArray\",\n      value: function listToArray(list) {\n        var i,\n            array = [];\n\n        for (i = 0; i < list.length; i++) {\n          array[i] = list[i];\n        }\n\n        return array;\n      } // to extend defaults with user options\n      // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873\n\n    }, {\n      key: \"extend\",\n      value: function extend(target, source) {\n        var _this = this;\n\n        if (typeof Object.assign !== 'function') {\n\n          (function () {\n            Object.assign = function (target) {\n\n              if (target === undefined || target === null) {\n                throw new TypeError('Cannot convert undefined or null to object');\n              }\n\n              var output = Object(target);\n\n              for (var index = 1; index < arguments.length; index++) {\n                var _source = arguments[index];\n\n                if (_source !== undefined && _source !== null) {\n                  for (var nextKey in _source) {\n                    if (_source.hasOwnProperty(nextKey)) {\n                      output[nextKey] = _source[nextKey];\n                    }\n                  }\n                }\n              }\n\n              return output;\n            };\n          })();\n        }\n\n        var output = Object.assign({}, target);\n\n        if (this.isObject(target) && this.isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (_this.isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(output, _defineProperty({}, key, source[key]));\n              } else {\n                output[key] = _this.extend(target[key], source[key]);\n              }\n            } else {\n              Object.assign(output, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n\n        return output;\n      }\n    }, {\n      key: \"extendArray\",\n      value: function extendArray(arrToExtend, resultArr) {\n        var extendedArr = [];\n        arrToExtend.map(function (item) {\n          extendedArr.push(Utils.extend(resultArr, item));\n        });\n        arrToExtend = extendedArr;\n        return arrToExtend;\n      } // If month counter exceeds 12, it starts again from 1\n\n    }, {\n      key: \"monthMod\",\n      value: function monthMod(month) {\n        return month % 12;\n      }\n    }, {\n      key: \"clone\",\n      value: function clone(source) {\n        if (Utils.is('Array', source)) {\n          var cloneResult = [];\n\n          for (var i = 0; i < source.length; i++) {\n            cloneResult[i] = this.clone(source[i]);\n          }\n\n          return cloneResult;\n        } else if (Utils.is('Null', source)) {\n          // fixes an issue where null values were converted to {}\n          return null;\n        } else if (Utils.is('Date', source)) {\n          return source;\n        } else if (_typeof(source) === 'object') {\n          var _cloneResult = {};\n\n          for (var prop in source) {\n            if (source.hasOwnProperty(prop)) {\n              _cloneResult[prop] = this.clone(source[prop]);\n            }\n          }\n\n          return _cloneResult;\n        } else {\n          return source;\n        }\n      }\n    }, {\n      key: \"log10\",\n      value: function log10(x) {\n        return Math.log(x) / Math.LN10;\n      }\n    }, {\n      key: \"roundToBase10\",\n      value: function roundToBase10(x) {\n        return Math.pow(10, Math.floor(Math.log10(x)));\n      }\n    }, {\n      key: \"roundToBase\",\n      value: function roundToBase(x, base) {\n        return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)));\n      }\n    }, {\n      key: \"parseNumber\",\n      value: function parseNumber(val) {\n        if (val === null) return val;\n        return parseFloat(val);\n      }\n    }, {\n      key: \"stripNumber\",\n      value: function stripNumber(num) {\n        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n        return Number.isInteger(num) ? num : parseFloat(num.toPrecision(precision));\n      }\n    }, {\n      key: \"randomId\",\n      value: function randomId() {\n        return (Math.random() + 1).toString(36).substring(4);\n      }\n    }, {\n      key: \"noExponents\",\n      value: function noExponents(val) {\n        var data = String(val).split(/[eE]/);\n        if (data.length === 1) return data[0];\n        var z = '',\n            sign = val < 0 ? '-' : '',\n            str = data[0].replace('.', ''),\n            mag = Number(data[1]) + 1;\n\n        if (mag < 0) {\n          z = sign + '0.';\n\n          while (mag++) {\n            z += '0';\n          }\n\n          return z + str.replace(/^-/, '');\n        }\n\n        mag -= str.length;\n\n        while (mag--) {\n          z += '0';\n        }\n\n        return str + z;\n      }\n    }, {\n      key: \"getDimensions\",\n      value: function getDimensions(el) {\n        var computedStyle = getComputedStyle(el, null);\n        var elementHeight = el.clientHeight;\n        var elementWidth = el.clientWidth;\n        elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n        elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n        return [elementWidth, elementHeight];\n      }\n    }, {\n      key: \"getBoundingClientRect\",\n      value: function getBoundingClientRect(element) {\n        var rect = element.getBoundingClientRect();\n        return {\n          top: rect.top,\n          right: rect.right,\n          bottom: rect.bottom,\n          left: rect.left,\n          width: element.clientWidth,\n          height: element.clientHeight,\n          x: rect.left,\n          y: rect.top\n        };\n      }\n    }, {\n      key: \"getLargestStringFromArr\",\n      value: function getLargestStringFromArr(arr) {\n        return arr.reduce(function (a, b) {\n          if (Array.isArray(b)) {\n            b = b.reduce(function (aa, bb) {\n              return aa.length > bb.length ? aa : bb;\n            });\n          }\n\n          return a.length > b.length ? a : b;\n        }, 0);\n      } // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275\n\n    }, {\n      key: \"hexToRgba\",\n      value: function hexToRgba() {\n        var hex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#999999';\n        var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.6;\n\n        if (hex.substring(0, 1) !== '#') {\n          hex = '#999999';\n        }\n\n        var h = hex.replace('#', '');\n        h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));\n\n        for (var i = 0; i < h.length; i++) {\n          h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16);\n        }\n\n        if (typeof opacity !== 'undefined') h.push(opacity);\n        return 'rgba(' + h.join(',') + ')';\n      }\n    }, {\n      key: \"getOpacityFromRGBA\",\n      value: function getOpacityFromRGBA(rgba) {\n        return parseFloat(rgba.replace(/^.*,(.+)\\)/, '$1'));\n      }\n    }, {\n      key: \"rgb2hex\",\n      value: function rgb2hex(rgb) {\n        rgb = rgb.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n        return rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';\n      }\n    }, {\n      key: \"isColorHex\",\n      value: function isColorHex(color) {\n        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(color);\n      }\n    }, {\n      key: \"getPolygonPos\",\n      value: function getPolygonPos(size, dataPointsLen) {\n        var dotsArray = [];\n        var angle = Math.PI * 2 / dataPointsLen;\n\n        for (var i = 0; i < dataPointsLen; i++) {\n          var curPos = {};\n          curPos.x = size * Math.sin(i * angle);\n          curPos.y = -size * Math.cos(i * angle);\n          dotsArray.push(curPos);\n        }\n\n        return dotsArray;\n      }\n    }, {\n      key: \"polarToCartesian\",\n      value: function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n        return {\n          x: centerX + radius * Math.cos(angleInRadians),\n          y: centerY + radius * Math.sin(angleInRadians)\n        };\n      }\n    }, {\n      key: \"escapeString\",\n      value: function escapeString(str) {\n        var escapeWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n        var newStr = str.toString().slice();\n        newStr = newStr.replace(/[` ~!@#$%^&*()|+\\=?;:'\",.<>{}[\\]\\\\/]/gi, escapeWith);\n        return newStr;\n      }\n    }, {\n      key: \"negToZero\",\n      value: function negToZero(val) {\n        return val < 0 ? 0 : val;\n      }\n    }, {\n      key: \"moveIndexInArray\",\n      value: function moveIndexInArray(arr, old_index, new_index) {\n        if (new_index >= arr.length) {\n          var k = new_index - arr.length + 1;\n\n          while (k--) {\n            arr.push(undefined);\n          }\n        }\n\n        arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);\n        return arr;\n      }\n    }, {\n      key: \"extractNumber\",\n      value: function extractNumber(s) {\n        return parseFloat(s.replace(/[^\\d.]*/g, ''));\n      }\n    }, {\n      key: \"findAncestor\",\n      value: function findAncestor(el, cls) {\n        while ((el = el.parentElement) && !el.classList.contains(cls)) {\n        }\n\n        return el;\n      }\n    }, {\n      key: \"setELstyles\",\n      value: function setELstyles(el, styles) {\n        for (var key in styles) {\n          if (styles.hasOwnProperty(key)) {\n            el.style.key = styles[key];\n          }\n        }\n      }\n    }, {\n      key: \"isNumber\",\n      value: function isNumber(value) {\n        return !isNaN(value) && parseFloat(Number(value)) === value && !isNaN(parseInt(value, 10));\n      }\n    }, {\n      key: \"isFloat\",\n      value: function isFloat(n) {\n        return Number(n) === n && n % 1 !== 0;\n      }\n    }, {\n      key: \"isSafari\",\n      value: function isSafari() {\n        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      }\n    }, {\n      key: \"isFirefox\",\n      value: function isFirefox() {\n        return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n      }\n    }, {\n      key: \"isIE11\",\n      value: function isIE11() {\n        if (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.appVersion.indexOf('Trident/') > -1) {\n          return true;\n        }\n      }\n    }, {\n      key: \"isIE\",\n      value: function isIE() {\n        var ua = window.navigator.userAgent;\n        var msie = ua.indexOf('MSIE ');\n\n        if (msie > 0) {\n          // IE 10 or older => return version number\n          return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n        }\n\n        var trident = ua.indexOf('Trident/');\n\n        if (trident > 0) {\n          // IE 11 => return version number\n          var rv = ua.indexOf('rv:');\n          return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n        }\n\n        var edge = ua.indexOf('Edge/');\n\n        if (edge > 0) {\n          // Edge (IE 12+) => return version number\n          return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n        } // other browser\n\n\n        return false;\n      }\n    }]);\n\n    return Utils;\n  }();\n\n  /**\n   * ApexCharts Animation Class.\n   *\n   * @module Animations\n   **/\n\n  var Animations = /*#__PURE__*/function () {\n    function Animations(ctx) {\n      _classCallCheck(this, Animations);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.setEasingFunctions();\n    }\n\n    _createClass(Animations, [{\n      key: \"setEasingFunctions\",\n      value: function setEasingFunctions() {\n        var easing;\n        if (this.w.globals.easing) return;\n        var userDefinedEasing = this.w.config.chart.animations.easing;\n\n        switch (userDefinedEasing) {\n          case 'linear':\n            {\n              easing = '-';\n              break;\n            }\n\n          case 'easein':\n            {\n              easing = '<';\n              break;\n            }\n\n          case 'easeout':\n            {\n              easing = '>';\n              break;\n            }\n\n          case 'easeinout':\n            {\n              easing = '<>';\n              break;\n            }\n\n          case 'swing':\n            {\n              easing = function easing(pos) {\n                var s = 1.70158;\n                var ret = (pos -= 1) * pos * ((s + 1) * pos + s) + 1;\n                return ret;\n              };\n\n              break;\n            }\n\n          case 'bounce':\n            {\n              easing = function easing(pos) {\n                var ret = '';\n\n                if (pos < 1 / 2.75) {\n                  ret = 7.5625 * pos * pos;\n                } else if (pos < 2 / 2.75) {\n                  ret = 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;\n                } else if (pos < 2.5 / 2.75) {\n                  ret = 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;\n                } else {\n                  ret = 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;\n                }\n\n                return ret;\n              };\n\n              break;\n            }\n\n          case 'elastic':\n            {\n              easing = function easing(pos) {\n                if (pos === !!pos) return pos;\n                return Math.pow(2, -10 * pos) * Math.sin((pos - 0.075) * (2 * Math.PI) / 0.3) + 1;\n              };\n\n              break;\n            }\n\n          default:\n            {\n              easing = '<>';\n            }\n        }\n\n        this.w.globals.easing = easing;\n      }\n    }, {\n      key: \"animateLine\",\n      value: function animateLine(el, from, to, speed) {\n        el.attr(from).animate(speed).attr(to);\n      }\n      /*\n       ** Animate radius of a circle element\n       */\n\n    }, {\n      key: \"animateMarker\",\n      value: function animateMarker(el, from, to, speed, easing, cb) {\n        if (!from) from = 0;\n        el.attr({\n          r: from,\n          width: from,\n          height: from\n        }).animate(speed, easing).attr({\n          r: to,\n          width: to.width,\n          height: to.height\n        }).afterAll(function () {\n          cb();\n        });\n      }\n      /*\n       ** Animate radius and position of a circle element\n       */\n\n    }, {\n      key: \"animateCircle\",\n      value: function animateCircle(el, from, to, speed, easing) {\n        el.attr({\n          r: from.r,\n          cx: from.cx,\n          cy: from.cy\n        }).animate(speed, easing).attr({\n          r: to.r,\n          cx: to.cx,\n          cy: to.cy\n        });\n      }\n      /*\n       ** Animate rect properties\n       */\n\n    }, {\n      key: \"animateRect\",\n      value: function animateRect(el, from, to, speed, fn) {\n        el.attr(from).animate(speed).attr(to).afterAll(function () {\n          return fn();\n        });\n      }\n    }, {\n      key: \"animatePathsGradually\",\n      value: function animatePathsGradually(params) {\n        var el = params.el,\n            realIndex = params.realIndex,\n            j = params.j,\n            fill = params.fill,\n            pathFrom = params.pathFrom,\n            pathTo = params.pathTo,\n            speed = params.speed,\n            delay = params.delay;\n        var me = this;\n        var w = this.w;\n        var delayFactor = 0;\n\n        if (w.config.chart.animations.animateGradually.enabled) {\n          delayFactor = w.config.chart.animations.animateGradually.delay;\n        }\n\n        if (w.config.chart.animations.dynamicAnimation.enabled && w.globals.dataChanged && w.config.chart.type !== 'bar') {\n          // disabled due to this bug - https://github.com/apexcharts/vue-apexcharts/issues/75\n          delayFactor = 0;\n        }\n\n        me.morphSVG(el, realIndex, j, w.config.chart.type === 'line' && !w.globals.comboCharts ? 'stroke' : fill, pathFrom, pathTo, speed, delay * delayFactor);\n      }\n    }, {\n      key: \"showDelayedElements\",\n      value: function showDelayedElements() {\n        this.w.globals.delayedElements.forEach(function (d) {\n          var ele = d.el;\n          ele.classList.remove('apexcharts-element-hidden');\n          ele.classList.add('apexcharts-hidden-element-shown');\n        });\n      }\n    }, {\n      key: \"animationCompleted\",\n      value: function animationCompleted(el) {\n        var w = this.w;\n        if (w.globals.animationEnded) return;\n        w.globals.animationEnded = true;\n        this.showDelayedElements();\n\n        if (typeof w.config.chart.events.animationEnd === 'function') {\n          w.config.chart.events.animationEnd(this.ctx, {\n            el: el,\n            w: w\n          });\n        }\n      } // SVG.js animation for morphing one path to another\n\n    }, {\n      key: \"morphSVG\",\n      value: function morphSVG(el, realIndex, j, fill, pathFrom, pathTo, speed, delay) {\n        var _this = this;\n\n        var w = this.w;\n\n        if (!pathFrom) {\n          pathFrom = el.attr('pathFrom');\n        }\n\n        if (!pathTo) {\n          pathTo = el.attr('pathTo');\n        }\n\n        var disableAnimationForCorrupPath = function disableAnimationForCorrupPath(path) {\n          if (w.config.chart.type === 'radar') {\n            // radar chart drops the path to bottom and hence a corrup path looks ugly\n            // therefore, disable animation for such a case\n            speed = 1;\n          }\n\n          return \"M 0 \".concat(w.globals.gridHeight);\n        };\n\n        if (!pathFrom || pathFrom.indexOf('undefined') > -1 || pathFrom.indexOf('NaN') > -1) {\n          pathFrom = disableAnimationForCorrupPath();\n        }\n\n        if (!pathTo || pathTo.indexOf('undefined') > -1 || pathTo.indexOf('NaN') > -1) {\n          pathTo = disableAnimationForCorrupPath();\n        }\n\n        if (!w.globals.shouldAnimate) {\n          speed = 1;\n        }\n\n        el.plot(pathFrom).animate(1, w.globals.easing, delay).plot(pathFrom).animate(speed, w.globals.easing, delay).plot(pathTo).afterAll(function () {\n          // a flag to indicate that the original mount function can return true now as animation finished here\n          if (Utils$1.isNumber(j)) {\n            if (j === w.globals.series[w.globals.maxValsInArrayIndex].length - 2 && w.globals.shouldAnimate) {\n              _this.animationCompleted(el);\n            }\n          } else if (fill !== 'none' && w.globals.shouldAnimate) {\n            if (!w.globals.comboCharts && realIndex === w.globals.series.length - 1 || w.globals.comboCharts) {\n              _this.animationCompleted(el);\n            }\n          }\n\n          _this.showDelayedElements();\n        });\n      }\n    }]);\n\n    return Animations;\n  }();\n\n  /**\n   * ApexCharts Filters Class for setting hover/active states on the paths.\n   *\n   * @module Formatters\n   **/\n\n  var Filters = /*#__PURE__*/function () {\n    function Filters(ctx) {\n      _classCallCheck(this, Filters);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    } // create a re-usable filter which can be appended other filter effects and applied to multiple elements\n\n\n    _createClass(Filters, [{\n      key: \"getDefaultFilter\",\n      value: function getDefaultFilter(el, i) {\n        var w = this.w;\n        el.unfilter(true);\n        var filter = new window.SVG.Filter();\n        filter.size('120%', '180%', '-5%', '-40%');\n\n        if (w.config.states.normal.filter !== 'none') {\n          this.applyFilter(el, i, w.config.states.normal.filter.type, w.config.states.normal.filter.value);\n        } else {\n          if (w.config.chart.dropShadow.enabled) {\n            this.dropShadow(el, w.config.chart.dropShadow, i);\n          }\n        }\n      }\n    }, {\n      key: \"addNormalFilter\",\n      value: function addNormalFilter(el, i) {\n        var w = this.w; // revert shadow if it was there\n        // but, ignore marker as marker don't have dropshadow yet\n\n        if (w.config.chart.dropShadow.enabled && !el.node.classList.contains('apexcharts-marker')) {\n          this.dropShadow(el, w.config.chart.dropShadow, i);\n        }\n      } // appends dropShadow to the filter object which can be chained with other filter effects\n\n    }, {\n      key: \"addLightenFilter\",\n      value: function addLightenFilter(el, i, attrs) {\n        var _this = this;\n\n        var w = this.w;\n        var intensity = attrs.intensity;\n        el.unfilter(true);\n        var filter = new window.SVG.Filter();\n        el.filter(function (add) {\n          var shadowAttr = w.config.chart.dropShadow;\n\n          if (shadowAttr.enabled) {\n            filter = _this.addShadow(add, i, shadowAttr);\n          } else {\n            filter = add;\n          }\n\n          filter.componentTransfer({\n            rgb: {\n              type: 'linear',\n              slope: 1.5,\n              intercept: intensity\n            }\n          });\n        });\n        el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n\n        this._scaleFilterSize(el.filterer.node);\n      } // appends dropShadow to the filter object which can be chained with other filter effects\n\n    }, {\n      key: \"addDarkenFilter\",\n      value: function addDarkenFilter(el, i, attrs) {\n        var _this2 = this;\n\n        var w = this.w;\n        var intensity = attrs.intensity;\n        el.unfilter(true);\n        var filter = new window.SVG.Filter();\n        el.filter(function (add) {\n          var shadowAttr = w.config.chart.dropShadow;\n\n          if (shadowAttr.enabled) {\n            filter = _this2.addShadow(add, i, shadowAttr);\n          } else {\n            filter = add;\n          }\n\n          filter.componentTransfer({\n            rgb: {\n              type: 'linear',\n              slope: intensity\n            }\n          });\n        });\n        el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n\n        this._scaleFilterSize(el.filterer.node);\n      }\n    }, {\n      key: \"applyFilter\",\n      value: function applyFilter(el, i, filter) {\n        var intensity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n\n        switch (filter) {\n          case 'none':\n            {\n              this.addNormalFilter(el, i);\n              break;\n            }\n\n          case 'lighten':\n            {\n              this.addLightenFilter(el, i, {\n                intensity: intensity\n              });\n              break;\n            }\n\n          case 'darken':\n            {\n              this.addDarkenFilter(el, i, {\n                intensity: intensity\n              });\n              break;\n            }\n        }\n      } // appends dropShadow to the filter object which can be chained with other filter effects\n\n    }, {\n      key: \"addShadow\",\n      value: function addShadow(add, i, attrs) {\n        var blur = attrs.blur,\n            top = attrs.top,\n            left = attrs.left,\n            color = attrs.color,\n            opacity = attrs.opacity;\n        var shadowBlur = add.flood(Array.isArray(color) ? color[i] : color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);\n        return add.blend(add.source, shadowBlur);\n      } // directly adds dropShadow to the element and returns the same element.\n      // the only way it is different from the addShadow() function is that addShadow is chainable to other filters, while this function discards all filters and add dropShadow\n\n    }, {\n      key: \"dropShadow\",\n      value: function dropShadow(el, attrs) {\n        var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var top = attrs.top,\n            left = attrs.left,\n            blur = attrs.blur,\n            color = attrs.color,\n            opacity = attrs.opacity,\n            noUserSpaceOnUse = attrs.noUserSpaceOnUse;\n        var w = this.w;\n        el.unfilter(true);\n\n        if (Utils$1.isIE() && w.config.chart.type === 'radialBar') {\n          // in radialbar charts, dropshadow is clipping actual drawing in IE\n          return el;\n        }\n\n        color = Array.isArray(color) ? color[i] : color;\n        el.filter(function (add) {\n          var shadowBlur = null;\n\n          if (Utils$1.isSafari() || Utils$1.isFirefox() || Utils$1.isIE()) {\n            // safari/firefox/IE have some alternative way to use this filter\n            shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur);\n          } else {\n            shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);\n          }\n\n          add.blend(add.source, shadowBlur);\n        });\n\n        if (!noUserSpaceOnUse) {\n          el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n        }\n\n        this._scaleFilterSize(el.filterer.node);\n\n        return el;\n      }\n    }, {\n      key: \"setSelectionFilter\",\n      value: function setSelectionFilter(el, realIndex, dataPointIndex) {\n        var w = this.w;\n\n        if (typeof w.globals.selectedDataPoints[realIndex] !== 'undefined') {\n          if (w.globals.selectedDataPoints[realIndex].indexOf(dataPointIndex) > -1) {\n            el.node.setAttribute('selected', true);\n            var activeFilter = w.config.states.active.filter;\n\n            if (activeFilter !== 'none') {\n              this.applyFilter(el, realIndex, activeFilter.type, activeFilter.value);\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_scaleFilterSize\",\n      value: function _scaleFilterSize(el) {\n        var setAttributes = function setAttributes(attrs) {\n          for (var key in attrs) {\n            if (attrs.hasOwnProperty(key)) {\n              el.setAttribute(key, attrs[key]);\n            }\n          }\n        };\n\n        setAttributes({\n          width: '200%',\n          height: '200%',\n          x: '-50%',\n          y: '-50%'\n        });\n      }\n    }]);\n\n    return Filters;\n  }();\n\n  /**\n   * ApexCharts Graphics Class for all drawing operations.\n   *\n   * @module Graphics\n   **/\n\n  var Graphics = /*#__PURE__*/function () {\n    function Graphics(ctx) {\n      _classCallCheck(this, Graphics);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n    /*****************************************************************************\n     *                                                                            *\n     *  SVG Path Rounding Function                                                *\n     *  Copyright (C) 2014 Yona Appletree                                         *\n     *                                                                            *\n     *  Licensed under the Apache License, Version 2.0 (the \"License\");           *\n     *  you may not use this file except in compliance with the License.          *\n     *  You may obtain a copy of the License at                                   *\n     *                                                                            *\n     *      http://www.apache.org/licenses/LICENSE-2.0                            *\n     *                                                                            *\n     *  Unless required by applicable law or agreed to in writing, software       *\n     *  distributed under the License is distributed on an \"AS IS\" BASIS,         *\n     *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *\n     *  See the License for the specific language governing permissions and       *\n     *  limitations under the License.                                            *\n     *                                                                            *\n     *****************************************************************************/\n\n    /**\n     * SVG Path rounding function. Takes an input path string and outputs a path\n     * string where all line-line corners have been rounded. Only supports absolute\n     * commands at the moment.\n     *\n     * @param pathString The SVG input path\n     * @param radius The amount to round the corners, either a value in the SVG\n     *               coordinate space, or, if useFractionalRadius is true, a value\n     *               from 0 to 1.\n     * @returns A new SVG path string with the rounding\n     */\n\n\n    _createClass(Graphics, [{\n      key: \"roundPathCorners\",\n      value: function roundPathCorners(pathString, radius) {\n        if (pathString.indexOf('NaN') > -1) pathString = '';\n\n        function moveTowardsLength(movingPoint, targetPoint, amount) {\n          var width = targetPoint.x - movingPoint.x;\n          var height = targetPoint.y - movingPoint.y;\n          var distance = Math.sqrt(width * width + height * height);\n          return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));\n        }\n\n        function moveTowardsFractional(movingPoint, targetPoint, fraction) {\n          return {\n            x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,\n            y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction\n          };\n        } // Adjusts the ending position of a command\n\n\n        function adjustCommand(cmd, newPoint) {\n          if (cmd.length > 2) {\n            cmd[cmd.length - 2] = newPoint.x;\n            cmd[cmd.length - 1] = newPoint.y;\n          }\n        } // Gives an {x, y} object for a command's ending position\n\n\n        function pointForCommand(cmd) {\n          return {\n            x: parseFloat(cmd[cmd.length - 2]),\n            y: parseFloat(cmd[cmd.length - 1])\n          };\n        } // Split apart the path, handing concatonated letters and numbers\n\n\n        var pathParts = pathString.split(/[,\\s]/).reduce(function (parts, part) {\n          var match = part.match('([a-zA-Z])(.+)');\n\n          if (match) {\n            parts.push(match[1]);\n            parts.push(match[2]);\n          } else {\n            parts.push(part);\n          }\n\n          return parts;\n        }, []); // Group the commands with their arguments for easier handling\n\n        var commands = pathParts.reduce(function (commands, part) {\n          if (parseFloat(part) == part && commands.length) {\n            commands[commands.length - 1].push(part);\n          } else {\n            commands.push([part]);\n          }\n\n          return commands;\n        }, []); // The resulting commands, also grouped\n\n        var resultCommands = [];\n\n        if (commands.length > 1) {\n          var startPoint = pointForCommand(commands[0]); // Handle the close path case with a \"virtual\" closing line\n\n          var virtualCloseLine = null;\n\n          if (commands[commands.length - 1][0] == 'Z' && commands[0].length > 2) {\n            virtualCloseLine = ['L', startPoint.x, startPoint.y];\n            commands[commands.length - 1] = virtualCloseLine;\n          } // We always use the first command (but it may be mutated)\n\n\n          resultCommands.push(commands[0]);\n\n          for (var cmdIndex = 1; cmdIndex < commands.length; cmdIndex++) {\n            var prevCmd = resultCommands[resultCommands.length - 1];\n            var curCmd = commands[cmdIndex]; // Handle closing case\n\n            var nextCmd = curCmd == virtualCloseLine ? commands[1] : commands[cmdIndex + 1]; // Nasty logic to decide if this path is a candidite.\n\n            if (nextCmd && prevCmd && prevCmd.length > 2 && curCmd[0] == 'L' && nextCmd.length > 2 && nextCmd[0] == 'L') {\n              // Calc the points we're dealing with\n              var prevPoint = pointForCommand(prevCmd);\n              var curPoint = pointForCommand(curCmd);\n              var nextPoint = pointForCommand(nextCmd); // The start and end of the cuve are just our point moved towards the previous and next points, respectivly\n\n              var curveStart, curveEnd;\n              curveStart = moveTowardsLength(curPoint, prevPoint, radius);\n              curveEnd = moveTowardsLength(curPoint, nextPoint, radius); // Adjust the current command and add it\n\n              adjustCommand(curCmd, curveStart);\n              curCmd.origPoint = curPoint;\n              resultCommands.push(curCmd); // The curve control points are halfway between the start/end of the curve and\n              // the original point\n\n              var startControl = moveTowardsFractional(curveStart, curPoint, 0.5);\n              var endControl = moveTowardsFractional(curPoint, curveEnd, 0.5); // Create the curve\n\n              var curveCmd = ['C', startControl.x, startControl.y, endControl.x, endControl.y, curveEnd.x, curveEnd.y]; // Save the original point for fractional calculations\n\n              curveCmd.origPoint = curPoint;\n              resultCommands.push(curveCmd);\n            } else {\n              // Pass through commands that don't qualify\n              resultCommands.push(curCmd);\n            }\n          } // Fix up the starting point and restore the close path if the path was orignally closed\n\n\n          if (virtualCloseLine) {\n            var newStartPoint = pointForCommand(resultCommands[resultCommands.length - 1]);\n            resultCommands.push(['Z']);\n            adjustCommand(resultCommands[0], newStartPoint);\n          }\n        } else {\n          resultCommands = commands;\n        }\n\n        return resultCommands.reduce(function (str, c) {\n          return str + c.join(' ') + ' ';\n        }, '');\n      }\n    }, {\n      key: \"drawLine\",\n      value: function drawLine(x1, y1, x2, y2) {\n        var lineColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#a8a8a8';\n        var dashArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n        var strokeWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n        var strokeLineCap = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'butt';\n        var w = this.w;\n        var line = w.globals.dom.Paper.line().attr({\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          stroke: lineColor,\n          'stroke-dasharray': dashArray,\n          'stroke-width': strokeWidth,\n          'stroke-linecap': strokeLineCap\n        });\n        return line;\n      }\n    }, {\n      key: \"drawRect\",\n      value: function drawRect() {\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n        var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#fefefe';\n        var opacity = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;\n        var strokeWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n        var strokeColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n        var strokeDashArray = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n        var w = this.w;\n        var rect = w.globals.dom.Paper.rect();\n        rect.attr({\n          x: x1,\n          y: y1,\n          width: x2 > 0 ? x2 : 0,\n          height: y2 > 0 ? y2 : 0,\n          rx: radius,\n          ry: radius,\n          opacity: opacity,\n          'stroke-width': strokeWidth !== null ? strokeWidth : 0,\n          stroke: strokeColor !== null ? strokeColor : 'none',\n          'stroke-dasharray': strokeDashArray\n        }); // fix apexcharts.js#1410\n\n        rect.node.setAttribute('fill', color);\n        return rect;\n      }\n    }, {\n      key: \"drawPolygon\",\n      value: function drawPolygon(polygonString) {\n        var stroke = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#e1e1e1';\n        var strokeWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var fill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n        var w = this.w;\n        var polygon = w.globals.dom.Paper.polygon(polygonString).attr({\n          fill: fill,\n          stroke: stroke,\n          'stroke-width': strokeWidth\n        });\n        return polygon;\n      }\n    }, {\n      key: \"drawCircle\",\n      value: function drawCircle(radius) {\n        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var w = this.w;\n        if (radius < 0) radius = 0;\n        var c = w.globals.dom.Paper.circle(radius * 2);\n\n        if (attrs !== null) {\n          c.attr(attrs);\n        }\n\n        return c;\n      }\n    }, {\n      key: \"drawPath\",\n      value: function drawPath(_ref) {\n        var _ref$d = _ref.d,\n            d = _ref$d === void 0 ? '' : _ref$d,\n            _ref$stroke = _ref.stroke,\n            stroke = _ref$stroke === void 0 ? '#a8a8a8' : _ref$stroke,\n            _ref$strokeWidth = _ref.strokeWidth,\n            strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,\n            fill = _ref.fill,\n            _ref$fillOpacity = _ref.fillOpacity,\n            fillOpacity = _ref$fillOpacity === void 0 ? 1 : _ref$fillOpacity,\n            _ref$strokeOpacity = _ref.strokeOpacity,\n            strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,\n            classes = _ref.classes,\n            _ref$strokeLinecap = _ref.strokeLinecap,\n            strokeLinecap = _ref$strokeLinecap === void 0 ? null : _ref$strokeLinecap,\n            _ref$strokeDashArray = _ref.strokeDashArray,\n            strokeDashArray = _ref$strokeDashArray === void 0 ? 0 : _ref$strokeDashArray;\n        var w = this.w;\n\n        if (strokeLinecap === null) {\n          strokeLinecap = w.config.stroke.lineCap;\n        }\n\n        if (d.indexOf('undefined') > -1 || d.indexOf('NaN') > -1) {\n          d = \"M 0 \".concat(w.globals.gridHeight);\n        }\n\n        var p = w.globals.dom.Paper.path(d).attr({\n          fill: fill,\n          'fill-opacity': fillOpacity,\n          stroke: stroke,\n          'stroke-opacity': strokeOpacity,\n          'stroke-linecap': strokeLinecap,\n          'stroke-width': strokeWidth,\n          'stroke-dasharray': strokeDashArray,\n          class: classes\n        });\n        return p;\n      }\n    }, {\n      key: \"group\",\n      value: function group() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var w = this.w;\n        var g = w.globals.dom.Paper.group();\n\n        if (attrs !== null) {\n          g.attr(attrs);\n        }\n\n        return g;\n      }\n    }, {\n      key: \"move\",\n      value: function move(x, y) {\n        var move = ['M', x, y].join(' ');\n        return move;\n      }\n    }, {\n      key: \"line\",\n      value: function line(x, y) {\n        var hORv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var line = null;\n\n        if (hORv === null) {\n          line = [' L', x, y].join(' ');\n        } else if (hORv === 'H') {\n          line = [' H', x].join(' ');\n        } else if (hORv === 'V') {\n          line = [' V', y].join(' ');\n        }\n\n        return line;\n      }\n    }, {\n      key: \"curve\",\n      value: function curve(x1, y1, x2, y2, x, y) {\n        var curve = ['C', x1, y1, x2, y2, x, y].join(' ');\n        return curve;\n      }\n    }, {\n      key: \"quadraticCurve\",\n      value: function quadraticCurve(x1, y1, x, y) {\n        var curve = ['Q', x1, y1, x, y].join(' ');\n        return curve;\n      }\n    }, {\n      key: \"arc\",\n      value: function arc(rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y) {\n        var relative = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n        var coord = 'A';\n        if (relative) coord = 'a';\n        var arc = [coord, rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y].join(' ');\n        return arc;\n      }\n      /**\n       * @memberof Graphics\n       * @param {object}\n       *  i = series's index\n       *  realIndex = realIndex is series's actual index when it was drawn time. After several redraws, the iterating \"i\" may change in loops, but realIndex doesn't\n       *  pathFrom = existing pathFrom to animateTo\n       *  pathTo = new Path to which d attr will be animated from pathFrom to pathTo\n       *  stroke = line Color\n       *  strokeWidth = width of path Line\n       *  fill = it can be gradient, single color, pattern or image\n       *  animationDelay = how much to delay when starting animation (in milliseconds)\n       *  dataChangeSpeed = for dynamic animations, when data changes\n       *  className = class attribute to add\n       * @return {object} svg.js path object\n       **/\n\n    }, {\n      key: \"renderPaths\",\n      value: function renderPaths(_ref2) {\n        var j = _ref2.j,\n            realIndex = _ref2.realIndex,\n            pathFrom = _ref2.pathFrom,\n            pathTo = _ref2.pathTo,\n            stroke = _ref2.stroke,\n            strokeWidth = _ref2.strokeWidth,\n            strokeLinecap = _ref2.strokeLinecap,\n            fill = _ref2.fill,\n            animationDelay = _ref2.animationDelay,\n            initialSpeed = _ref2.initialSpeed,\n            dataChangeSpeed = _ref2.dataChangeSpeed,\n            className = _ref2.className,\n            _ref2$shouldClipToGri = _ref2.shouldClipToGrid,\n            shouldClipToGrid = _ref2$shouldClipToGri === void 0 ? true : _ref2$shouldClipToGri,\n            _ref2$bindEventsOnPat = _ref2.bindEventsOnPaths,\n            bindEventsOnPaths = _ref2$bindEventsOnPat === void 0 ? true : _ref2$bindEventsOnPat,\n            _ref2$drawShadow = _ref2.drawShadow,\n            drawShadow = _ref2$drawShadow === void 0 ? true : _ref2$drawShadow;\n        var w = this.w;\n        var filters = new Filters(this.ctx);\n        var anim = new Animations(this.ctx);\n        var initialAnim = this.w.config.chart.animations.enabled;\n        var dynamicAnim = initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n        var d;\n        var shouldAnimate = !!(initialAnim && !w.globals.resized || dynamicAnim && w.globals.dataChanged && w.globals.shouldAnimate);\n\n        if (shouldAnimate) {\n          d = pathFrom;\n        } else {\n          d = pathTo;\n          w.globals.animationEnded = true;\n        }\n\n        var strokeDashArrayOpt = w.config.stroke.dashArray;\n        var strokeDashArray = 0;\n\n        if (Array.isArray(strokeDashArrayOpt)) {\n          strokeDashArray = strokeDashArrayOpt[realIndex];\n        } else {\n          strokeDashArray = w.config.stroke.dashArray;\n        }\n\n        var el = this.drawPath({\n          d: d,\n          stroke: stroke,\n          strokeWidth: strokeWidth,\n          fill: fill,\n          fillOpacity: 1,\n          classes: className,\n          strokeLinecap: strokeLinecap,\n          strokeDashArray: strokeDashArray\n        });\n        el.attr('index', realIndex);\n\n        if (shouldClipToGrid) {\n          el.attr({\n            'clip-path': \"url(#gridRectMask\".concat(w.globals.cuid, \")\")\n          });\n        } // const defaultFilter = el.filterer\n\n\n        if (w.config.states.normal.filter.type !== 'none') {\n          filters.getDefaultFilter(el, realIndex);\n        } else {\n          if (w.config.chart.dropShadow.enabled && drawShadow) {\n            if (!w.config.chart.dropShadow.enabledOnSeries || w.config.chart.dropShadow.enabledOnSeries && w.config.chart.dropShadow.enabledOnSeries.indexOf(realIndex) !== -1) {\n              var shadow = w.config.chart.dropShadow;\n              filters.dropShadow(el, shadow, realIndex);\n            }\n          }\n        }\n\n        if (bindEventsOnPaths) {\n          el.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, el));\n          el.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, el));\n          el.node.addEventListener('mousedown', this.pathMouseDown.bind(this, el));\n        }\n\n        el.attr({\n          pathTo: pathTo,\n          pathFrom: pathFrom\n        });\n        var defaultAnimateOpts = {\n          el: el,\n          j: j,\n          realIndex: realIndex,\n          pathFrom: pathFrom,\n          pathTo: pathTo,\n          fill: fill,\n          strokeWidth: strokeWidth,\n          delay: animationDelay\n        };\n\n        if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n          anim.animatePathsGradually(_objectSpread2(_objectSpread2({}, defaultAnimateOpts), {}, {\n            speed: initialSpeed\n          }));\n        } else {\n          if (w.globals.resized || !w.globals.dataChanged) {\n            anim.showDelayedElements();\n          }\n        }\n\n        if (w.globals.dataChanged && dynamicAnim && shouldAnimate) {\n          anim.animatePathsGradually(_objectSpread2(_objectSpread2({}, defaultAnimateOpts), {}, {\n            speed: dataChangeSpeed\n          }));\n        }\n\n        return el;\n      }\n    }, {\n      key: \"drawPattern\",\n      value: function drawPattern(style, width, height) {\n        var stroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#a8a8a8';\n        var strokeWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n        var w = this.w;\n        var p = w.globals.dom.Paper.pattern(width, height, function (add) {\n          if (style === 'horizontalLines') {\n            add.line(0, 0, height, 0).stroke({\n              color: stroke,\n              width: strokeWidth + 1\n            });\n          } else if (style === 'verticalLines') {\n            add.line(0, 0, 0, width).stroke({\n              color: stroke,\n              width: strokeWidth + 1\n            });\n          } else if (style === 'slantedLines') {\n            add.line(0, 0, width, height).stroke({\n              color: stroke,\n              width: strokeWidth\n            });\n          } else if (style === 'squares') {\n            add.rect(width, height).fill('none').stroke({\n              color: stroke,\n              width: strokeWidth\n            });\n          } else if (style === 'circles') {\n            add.circle(width).fill('none').stroke({\n              color: stroke,\n              width: strokeWidth\n            });\n          }\n        });\n        return p;\n      }\n    }, {\n      key: \"drawGradient\",\n      value: function drawGradient(style, gfrom, gto, opacityFrom, opacityTo) {\n        var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n        var stops = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n        var colorStops = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n        var i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n        var w = this.w;\n        var g;\n\n        if (gfrom.length < 9 && gfrom.indexOf('#') === 0) {\n          // if the hex contains alpha and is of 9 digit, skip the opacity\n          gfrom = Utils$1.hexToRgba(gfrom, opacityFrom);\n        }\n\n        if (gto.length < 9 && gto.indexOf('#') === 0) {\n          gto = Utils$1.hexToRgba(gto, opacityTo);\n        }\n\n        var stop1 = 0;\n        var stop2 = 1;\n        var stop3 = 1;\n        var stop4 = null;\n\n        if (stops !== null) {\n          stop1 = typeof stops[0] !== 'undefined' ? stops[0] / 100 : 0;\n          stop2 = typeof stops[1] !== 'undefined' ? stops[1] / 100 : 1;\n          stop3 = typeof stops[2] !== 'undefined' ? stops[2] / 100 : 1;\n          stop4 = typeof stops[3] !== 'undefined' ? stops[3] / 100 : null;\n        }\n\n        var radial = !!(w.config.chart.type === 'donut' || w.config.chart.type === 'pie' || w.config.chart.type === 'polarArea' || w.config.chart.type === 'bubble');\n\n        if (colorStops === null || colorStops.length === 0) {\n          g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {\n            stop.at(stop1, gfrom, opacityFrom);\n            stop.at(stop2, gto, opacityTo);\n            stop.at(stop3, gto, opacityTo);\n\n            if (stop4 !== null) {\n              stop.at(stop4, gfrom, opacityFrom);\n            }\n          });\n        } else {\n          g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {\n            var gradientStops = Array.isArray(colorStops[i]) ? colorStops[i] : colorStops;\n            gradientStops.forEach(function (s) {\n              stop.at(s.offset / 100, s.color, s.opacity);\n            });\n          });\n        }\n\n        if (!radial) {\n          if (style === 'vertical') {\n            g.from(0, 0).to(0, 1);\n          } else if (style === 'diagonal') {\n            g.from(0, 0).to(1, 1);\n          } else if (style === 'horizontal') {\n            g.from(0, 1).to(1, 1);\n          } else if (style === 'diagonal2') {\n            g.from(1, 0).to(0, 1);\n          }\n        } else {\n          var offx = w.globals.gridWidth / 2;\n          var offy = w.globals.gridHeight / 2;\n\n          if (w.config.chart.type !== 'bubble') {\n            g.attr({\n              gradientUnits: 'userSpaceOnUse',\n              cx: offx,\n              cy: offy,\n              r: size\n            });\n          } else {\n            g.attr({\n              cx: 0.5,\n              cy: 0.5,\n              r: 0.8,\n              fx: 0.2,\n              fy: 0.2\n            });\n          }\n        }\n\n        return g;\n      }\n    }, {\n      key: \"getTextBasedOnMaxWidth\",\n      value: function getTextBasedOnMaxWidth(_ref3) {\n        var text = _ref3.text,\n            maxWidth = _ref3.maxWidth,\n            fontSize = _ref3.fontSize,\n            fontFamily = _ref3.fontFamily;\n        var tRects = this.getTextRects(text, fontSize, fontFamily);\n        var wordWidth = tRects.width / text.length;\n        var wordsBasedOnWidth = Math.floor(maxWidth / wordWidth);\n\n        if (maxWidth < tRects.width) {\n          return text.slice(0, wordsBasedOnWidth - 3) + '...';\n        }\n\n        return text;\n      }\n    }, {\n      key: \"drawText\",\n      value: function drawText(_ref4) {\n        var _this = this;\n\n        var x = _ref4.x,\n            y = _ref4.y,\n            text = _ref4.text,\n            textAnchor = _ref4.textAnchor,\n            fontSize = _ref4.fontSize,\n            fontFamily = _ref4.fontFamily,\n            fontWeight = _ref4.fontWeight,\n            foreColor = _ref4.foreColor,\n            opacity = _ref4.opacity,\n            maxWidth = _ref4.maxWidth,\n            _ref4$cssClass = _ref4.cssClass,\n            cssClass = _ref4$cssClass === void 0 ? '' : _ref4$cssClass,\n            _ref4$isPlainText = _ref4.isPlainText,\n            isPlainText = _ref4$isPlainText === void 0 ? true : _ref4$isPlainText;\n        var w = this.w;\n        if (typeof text === 'undefined') text = '';\n        var truncatedText = text;\n\n        if (!textAnchor) {\n          textAnchor = 'start';\n        }\n\n        if (!foreColor || !foreColor.length) {\n          foreColor = w.config.chart.foreColor;\n        }\n\n        fontFamily = fontFamily || w.config.chart.fontFamily;\n        fontSize = fontSize || '11px';\n        fontWeight = fontWeight || 'regular';\n        var commonProps = {\n          maxWidth: maxWidth,\n          fontSize: fontSize,\n          fontFamily: fontFamily\n        };\n        var elText;\n\n        if (Array.isArray(text)) {\n          elText = w.globals.dom.Paper.text(function (add) {\n            for (var i = 0; i < text.length; i++) {\n              truncatedText = text[i];\n\n              if (maxWidth) {\n                truncatedText = _this.getTextBasedOnMaxWidth(_objectSpread2({\n                  text: text[i]\n                }, commonProps));\n              }\n\n              i === 0 ? add.tspan(truncatedText) : add.tspan(truncatedText).newLine();\n            }\n          });\n        } else {\n          if (maxWidth) {\n            truncatedText = this.getTextBasedOnMaxWidth(_objectSpread2({\n              text: text\n            }, commonProps));\n          }\n\n          elText = isPlainText ? w.globals.dom.Paper.plain(text) : w.globals.dom.Paper.text(function (add) {\n            return add.tspan(truncatedText);\n          });\n        }\n\n        elText.attr({\n          x: x,\n          y: y,\n          'text-anchor': textAnchor,\n          'dominant-baseline': 'auto',\n          'font-size': fontSize,\n          'font-family': fontFamily,\n          'font-weight': fontWeight,\n          fill: foreColor,\n          class: 'apexcharts-text ' + cssClass\n        });\n        elText.node.style.fontFamily = fontFamily;\n        elText.node.style.opacity = opacity;\n        return elText;\n      }\n    }, {\n      key: \"drawMarker\",\n      value: function drawMarker(x, y, opts) {\n        x = x || 0;\n        var size = opts.pSize || 0;\n        var elPoint = null;\n\n        if (opts.shape === 'square' || opts.shape === 'rect') {\n          var radius = opts.pRadius === undefined ? size / 2 : opts.pRadius;\n\n          if (y === null || !size) {\n            size = 0;\n            radius = 0;\n          }\n\n          var nSize = size * 1.2 + radius;\n          var p = this.drawRect(nSize, nSize, nSize, nSize, radius);\n          p.attr({\n            x: x - nSize / 2,\n            y: y - nSize / 2,\n            cx: x,\n            cy: y,\n            class: opts.class ? opts.class : '',\n            fill: opts.pointFillColor,\n            'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,\n            stroke: opts.pointStrokeColor,\n            'stroke-width': opts.pointStrokeWidth ? opts.pointStrokeWidth : 0,\n            'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1\n          });\n          elPoint = p;\n        } else if (opts.shape === 'circle' || !opts.shape) {\n          if (!Utils$1.isNumber(y)) {\n            size = 0;\n            y = 0;\n          } // let nSize = size - opts.pRadius / 2 < 0 ? 0 : size - opts.pRadius / 2\n\n\n          elPoint = this.drawCircle(size, {\n            cx: x,\n            cy: y,\n            class: opts.class ? opts.class : '',\n            stroke: opts.pointStrokeColor,\n            fill: opts.pointFillColor,\n            'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,\n            'stroke-width': opts.pointStrokeWidth ? opts.pointStrokeWidth : 0,\n            'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1\n          });\n        }\n\n        return elPoint;\n      }\n    }, {\n      key: \"pathMouseEnter\",\n      value: function pathMouseEnter(path, e) {\n        var w = this.w;\n        var filters = new Filters(this.ctx);\n        var i = parseInt(path.node.getAttribute('index'), 10);\n        var j = parseInt(path.node.getAttribute('j'), 10);\n\n        if (typeof w.config.chart.events.dataPointMouseEnter === 'function') {\n          w.config.chart.events.dataPointMouseEnter(e, this.ctx, {\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        }\n\n        this.ctx.events.fireEvent('dataPointMouseEnter', [e, this.ctx, {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        }]);\n\n        if (w.config.states.active.filter.type !== 'none') {\n          if (path.node.getAttribute('selected') === 'true') {\n            return;\n          }\n        }\n\n        if (w.config.states.hover.filter.type !== 'none') {\n          if (!w.globals.isTouchDevice) {\n            var hoverFilter = w.config.states.hover.filter;\n            filters.applyFilter(path, i, hoverFilter.type, hoverFilter.value);\n          }\n        }\n      }\n    }, {\n      key: \"pathMouseLeave\",\n      value: function pathMouseLeave(path, e) {\n        var w = this.w;\n        var filters = new Filters(this.ctx);\n        var i = parseInt(path.node.getAttribute('index'), 10);\n        var j = parseInt(path.node.getAttribute('j'), 10);\n\n        if (typeof w.config.chart.events.dataPointMouseLeave === 'function') {\n          w.config.chart.events.dataPointMouseLeave(e, this.ctx, {\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        }\n\n        this.ctx.events.fireEvent('dataPointMouseLeave', [e, this.ctx, {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        }]);\n\n        if (w.config.states.active.filter.type !== 'none') {\n          if (path.node.getAttribute('selected') === 'true') {\n            return;\n          }\n        }\n\n        if (w.config.states.hover.filter.type !== 'none') {\n          filters.getDefaultFilter(path, i);\n        }\n      }\n    }, {\n      key: \"pathMouseDown\",\n      value: function pathMouseDown(path, e) {\n        var w = this.w;\n        var filters = new Filters(this.ctx);\n        var i = parseInt(path.node.getAttribute('index'), 10);\n        var j = parseInt(path.node.getAttribute('j'), 10);\n        var selected = 'false';\n\n        if (path.node.getAttribute('selected') === 'true') {\n          path.node.setAttribute('selected', 'false');\n\n          if (w.globals.selectedDataPoints[i].indexOf(j) > -1) {\n            var index = w.globals.selectedDataPoints[i].indexOf(j);\n            w.globals.selectedDataPoints[i].splice(index, 1);\n          }\n        } else {\n          if (!w.config.states.active.allowMultipleDataPointsSelection && w.globals.selectedDataPoints.length > 0) {\n            w.globals.selectedDataPoints = [];\n            var elPaths = w.globals.dom.Paper.select('.apexcharts-series path').members;\n            var elCircles = w.globals.dom.Paper.select('.apexcharts-series circle, .apexcharts-series rect').members;\n\n            var deSelect = function deSelect(els) {\n              Array.prototype.forEach.call(els, function (el) {\n                el.node.setAttribute('selected', 'false');\n                filters.getDefaultFilter(el, i);\n              });\n            };\n\n            deSelect(elPaths);\n            deSelect(elCircles);\n          }\n\n          path.node.setAttribute('selected', 'true');\n          selected = 'true';\n\n          if (typeof w.globals.selectedDataPoints[i] === 'undefined') {\n            w.globals.selectedDataPoints[i] = [];\n          }\n\n          w.globals.selectedDataPoints[i].push(j);\n        }\n\n        if (selected === 'true') {\n          var activeFilter = w.config.states.active.filter;\n\n          if (activeFilter !== 'none') {\n            filters.applyFilter(path, i, activeFilter.type, activeFilter.value);\n          } else {\n            // Reapply the hover filter in case it was removed by `deselect`when there is no active filter and it is not a touch device\n            if (w.config.states.hover.filter !== 'none') {\n              if (!w.globals.isTouchDevice) {\n                var hoverFilter = w.config.states.hover.filter;\n                filters.applyFilter(path, i, hoverFilter.type, hoverFilter.value);\n              }\n            }\n          }\n        } else {\n          // If the item was deselected, apply hover state filter if it is not a touch device\n          if (w.config.states.active.filter.type !== 'none') {\n            if (w.config.states.hover.filter.type !== 'none' && !w.globals.isTouchDevice) {\n              var hoverFilter = w.config.states.hover.filter;\n              filters.applyFilter(path, i, hoverFilter.type, hoverFilter.value);\n            } else {\n              filters.getDefaultFilter(path, i);\n            }\n          }\n        }\n\n        if (typeof w.config.chart.events.dataPointSelection === 'function') {\n          w.config.chart.events.dataPointSelection(e, this.ctx, {\n            selectedDataPoints: w.globals.selectedDataPoints,\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        }\n\n        if (e) {\n          this.ctx.events.fireEvent('dataPointSelection', [e, this.ctx, {\n            selectedDataPoints: w.globals.selectedDataPoints,\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          }]);\n        }\n      }\n    }, {\n      key: \"rotateAroundCenter\",\n      value: function rotateAroundCenter(el) {\n        var coord = {};\n\n        if (el && typeof el.getBBox === 'function') {\n          coord = el.getBBox();\n        }\n\n        var x = coord.x + coord.width / 2;\n        var y = coord.y + coord.height / 2;\n        return {\n          x: x,\n          y: y\n        };\n      }\n    }, {\n      key: \"getTextRects\",\n      value: function getTextRects(text, fontSize, fontFamily, transform) {\n        var useBBox = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var w = this.w;\n        var virtualText = this.drawText({\n          x: -200,\n          y: -200,\n          text: text,\n          textAnchor: 'start',\n          fontSize: fontSize,\n          fontFamily: fontFamily,\n          foreColor: '#fff',\n          opacity: 0\n        });\n\n        if (transform) {\n          virtualText.attr('transform', transform);\n        }\n\n        w.globals.dom.Paper.add(virtualText);\n        var rect = virtualText.bbox();\n\n        if (!useBBox) {\n          rect = virtualText.node.getBoundingClientRect();\n        }\n\n        virtualText.remove();\n        return {\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      /**\n       * append ... to long text\n       * http://stackoverflow.com/questions/9241315/trimming-text-to-a-given-pixel-width-in-svg\n       * @memberof Graphics\n       **/\n\n    }, {\n      key: \"placeTextWithEllipsis\",\n      value: function placeTextWithEllipsis(textObj, textString, width) {\n        if (typeof textObj.getComputedTextLength !== 'function') return;\n        textObj.textContent = textString;\n\n        if (textString.length > 0) {\n          // ellipsis is needed\n          if (textObj.getComputedTextLength() >= width / 1.1) {\n            for (var x = textString.length - 3; x > 0; x -= 3) {\n              if (textObj.getSubStringLength(0, x) <= width / 1.1) {\n                textObj.textContent = textString.substring(0, x) + '...';\n                return;\n              }\n            }\n\n            textObj.textContent = '.'; // can't place at all\n          }\n        }\n      }\n    }], [{\n      key: \"setAttrs\",\n      value: function setAttrs(el, attrs) {\n        for (var key in attrs) {\n          if (attrs.hasOwnProperty(key)) {\n            el.setAttribute(key, attrs[key]);\n          }\n        }\n      }\n    }]);\n\n    return Graphics;\n  }();\n\n  /*\n   ** Util functions which are dependent on ApexCharts instance\n   */\n  var CoreUtils = /*#__PURE__*/function () {\n    function CoreUtils(ctx) {\n      _classCallCheck(this, CoreUtils);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(CoreUtils, [{\n      key: \"getStackedSeriesTotals\",\n      value:\n      /**\n       * @memberof CoreUtils\n       * returns the sum of all individual values in a multiple stacked series\n       * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]\n       *  @return [34,36,48,13]\n       **/\n      function getStackedSeriesTotals() {\n        var excludedSeriesIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var w = this.w;\n        var total = [];\n        if (w.globals.series.length === 0) return total;\n\n        for (var i = 0; i < w.globals.series[w.globals.maxValsInArrayIndex].length; i++) {\n          var t = 0;\n\n          for (var j = 0; j < w.globals.series.length; j++) {\n            if (typeof w.globals.series[j][i] !== 'undefined' && excludedSeriesIndices.indexOf(j) === -1) {\n              t += w.globals.series[j][i];\n            }\n          }\n\n          total.push(t);\n        }\n\n        return total;\n      } // get total of the all values inside all series\n\n    }, {\n      key: \"getSeriesTotalByIndex\",\n      value: function getSeriesTotalByIndex() {\n        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        if (index === null) {\n          // non-plot chart types - pie / donut / circle\n          return this.w.config.series.reduce(function (acc, cur) {\n            return acc + cur;\n          }, 0);\n        } else {\n          // axis charts - supporting multiple series\n          return this.w.globals.series[index].reduce(function (acc, cur) {\n            return acc + cur;\n          }, 0);\n        }\n      }\n    }, {\n      key: \"isSeriesNull\",\n      value: function isSeriesNull() {\n        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var r = [];\n\n        if (index === null) {\n          // non-plot chart types - pie / donut / circle\n          r = this.w.config.series.filter(function (d) {\n            return d !== null;\n          });\n        } else {\n          // axis charts - supporting multiple series\n          r = this.w.config.series[index].data.filter(function (d) {\n            return d !== null;\n          });\n        }\n\n        return r.length === 0;\n      }\n    }, {\n      key: \"seriesHaveSameValues\",\n      value: function seriesHaveSameValues(index) {\n        return this.w.globals.series[index].every(function (val, i, arr) {\n          return val === arr[0];\n        });\n      }\n    }, {\n      key: \"getCategoryLabels\",\n      value: function getCategoryLabels(labels) {\n        var w = this.w;\n        var catLabels = labels.slice();\n\n        if (w.config.xaxis.convertedCatToNumeric) {\n          catLabels = labels.map(function (i, li) {\n            return w.config.xaxis.labels.formatter(i - w.globals.minX + 1);\n          });\n        }\n\n        return catLabels;\n      } // maxValsInArrayIndex is the index of series[] which has the largest number of items\n\n    }, {\n      key: \"getLargestSeries\",\n      value: function getLargestSeries() {\n        var w = this.w;\n        w.globals.maxValsInArrayIndex = w.globals.series.map(function (a) {\n          return a.length;\n        }).indexOf(Math.max.apply(Math, w.globals.series.map(function (a) {\n          return a.length;\n        })));\n      }\n    }, {\n      key: \"getLargestMarkerSize\",\n      value: function getLargestMarkerSize() {\n        var w = this.w;\n        var size = 0;\n        w.globals.markers.size.forEach(function (m) {\n          size = Math.max(size, m);\n        });\n\n        if (w.config.markers.discrete && w.config.markers.discrete.length) {\n          w.config.markers.discrete.forEach(function (m) {\n            size = Math.max(size, m.size);\n          });\n        }\n\n        if (size > 0) {\n          size += w.config.markers.hover.sizeOffset + 1;\n        }\n\n        w.globals.markers.largestSize = size;\n        return size;\n      }\n      /**\n       * @memberof Core\n       * returns the sum of all values in a series\n       * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]\n       *  @return [120, 11]\n       **/\n\n    }, {\n      key: \"getSeriesTotals\",\n      value: function getSeriesTotals() {\n        var w = this.w;\n        w.globals.seriesTotals = w.globals.series.map(function (ser, index) {\n          var total = 0;\n\n          if (Array.isArray(ser)) {\n            for (var j = 0; j < ser.length; j++) {\n              total += ser[j];\n            }\n          } else {\n            // for pie/donuts/gauges\n            total += ser;\n          }\n\n          return total;\n        });\n      }\n    }, {\n      key: \"getSeriesTotalsXRange\",\n      value: function getSeriesTotalsXRange(minX, maxX) {\n        var w = this.w;\n        var seriesTotalsXRange = w.globals.series.map(function (ser, index) {\n          var total = 0;\n\n          for (var j = 0; j < ser.length; j++) {\n            if (w.globals.seriesX[index][j] > minX && w.globals.seriesX[index][j] < maxX) {\n              total += ser[j];\n            }\n          }\n\n          return total;\n        });\n        return seriesTotalsXRange;\n      }\n      /**\n       * @memberof CoreUtils\n       * returns the percentage value of all individual values which can be used in a 100% stacked series\n       * Eg. w.globals.series = [[32, 33, 43, 12], [2, 3, 5, 1]]\n       *  @return [[94.11, 91.66, 89.58, 92.30], [5.88, 8.33, 10.41, 7.7]]\n       **/\n\n    }, {\n      key: \"getPercentSeries\",\n      value: function getPercentSeries() {\n        var w = this.w;\n        w.globals.seriesPercent = w.globals.series.map(function (ser, index) {\n          var seriesPercent = [];\n\n          if (Array.isArray(ser)) {\n            for (var j = 0; j < ser.length; j++) {\n              var total = w.globals.stackedSeriesTotals[j];\n              var percent = 0;\n\n              if (total) {\n                percent = 100 * ser[j] / total;\n              }\n\n              seriesPercent.push(percent);\n            }\n          } else {\n            var _total = w.globals.seriesTotals.reduce(function (acc, val) {\n              return acc + val;\n            }, 0);\n\n            var _percent = 100 * ser / _total;\n\n            seriesPercent.push(_percent);\n          }\n\n          return seriesPercent;\n        });\n      }\n    }, {\n      key: \"getCalculatedRatios\",\n      value: function getCalculatedRatios() {\n        var gl = this.w.globals;\n        var yRatio = [];\n        var invertedYRatio = 0;\n        var xRatio = 0;\n        var initialXRatio = 0;\n        var invertedXRatio = 0;\n        var zRatio = 0;\n        var baseLineY = [];\n        var baseLineInvertedY = 0.1;\n        var baseLineX = 0;\n        gl.yRange = [];\n\n        if (gl.isMultipleYAxis) {\n          for (var i = 0; i < gl.minYArr.length; i++) {\n            gl.yRange.push(Math.abs(gl.minYArr[i] - gl.maxYArr[i]));\n            baseLineY.push(0);\n          }\n        } else {\n          gl.yRange.push(Math.abs(gl.minY - gl.maxY));\n        }\n\n        gl.xRange = Math.abs(gl.maxX - gl.minX);\n        gl.zRange = Math.abs(gl.maxZ - gl.minZ); // multiple y axis\n\n        for (var _i = 0; _i < gl.yRange.length; _i++) {\n          yRatio.push(gl.yRange[_i] / gl.gridHeight);\n        }\n\n        xRatio = gl.xRange / gl.gridWidth;\n        initialXRatio = Math.abs(gl.initialMaxX - gl.initialMinX) / gl.gridWidth;\n        invertedYRatio = gl.yRange / gl.gridWidth;\n        invertedXRatio = gl.xRange / gl.gridHeight;\n        zRatio = gl.zRange / gl.gridHeight * 16;\n\n        if (!zRatio) {\n          zRatio = 1;\n        }\n\n        if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {\n          // Negative numbers present in series\n          gl.hasNegs = true;\n        }\n\n        if (gl.isMultipleYAxis) {\n          baseLineY = []; // baseline variables is the 0 of the yaxis which will be needed when there are negatives\n\n          for (var _i2 = 0; _i2 < yRatio.length; _i2++) {\n            baseLineY.push(-gl.minYArr[_i2] / yRatio[_i2]);\n          }\n        } else {\n          baseLineY.push(-gl.minY / yRatio[0]);\n\n          if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {\n            baseLineInvertedY = -gl.minY / invertedYRatio; // this is for bar chart\n\n            baseLineX = gl.minX / xRatio;\n          }\n        }\n\n        return {\n          yRatio: yRatio,\n          invertedYRatio: invertedYRatio,\n          zRatio: zRatio,\n          xRatio: xRatio,\n          initialXRatio: initialXRatio,\n          invertedXRatio: invertedXRatio,\n          baseLineInvertedY: baseLineInvertedY,\n          baseLineY: baseLineY,\n          baseLineX: baseLineX\n        };\n      }\n    }, {\n      key: \"getLogSeries\",\n      value: function getLogSeries(series) {\n        var _this = this;\n\n        var w = this.w;\n        w.globals.seriesLog = series.map(function (s, i) {\n          if (w.config.yaxis[i] && w.config.yaxis[i].logarithmic) {\n            return s.map(function (d) {\n              if (d === null) return null;\n              return _this.getLogVal(w.config.yaxis[i].logBase, d, i);\n            });\n          } else {\n            return s;\n          }\n        });\n        return w.globals.invalidLogScale ? series : w.globals.seriesLog;\n      }\n    }, {\n      key: \"getBaseLog\",\n      value: function getBaseLog(base, value) {\n        return Math.log(value) / Math.log(base);\n      }\n    }, {\n      key: \"getLogVal\",\n      value: function getLogVal(b, d, yIndex) {\n        if (d === 0) {\n          return 0;\n        }\n\n        var w = this.w;\n        var min_log_val = w.globals.minYArr[yIndex] === 0 ? -1 // make sure we dont calculate log of 0\n        : this.getBaseLog(b, w.globals.minYArr[yIndex]);\n        var max_log_val = w.globals.maxYArr[yIndex] === 0 ? 0 // make sure we dont calculate log of 0\n        : this.getBaseLog(b, w.globals.maxYArr[yIndex]);\n        var number_of_height_levels = max_log_val - min_log_val;\n        if (d < 1) return d / number_of_height_levels;\n        var log_height_value = this.getBaseLog(b, d) - min_log_val;\n        return log_height_value / number_of_height_levels;\n      }\n    }, {\n      key: \"getLogYRatios\",\n      value: function getLogYRatios(yRatio) {\n        var _this2 = this;\n\n        var w = this.w;\n        var gl = this.w.globals;\n        gl.yLogRatio = yRatio.slice();\n        gl.logYRange = gl.yRange.map(function (yRange, i) {\n          if (w.config.yaxis[i] && _this2.w.config.yaxis[i].logarithmic) {\n            var maxY = -Number.MAX_VALUE;\n            var minY = Number.MIN_VALUE;\n            var range = 1;\n            gl.seriesLog.forEach(function (s, si) {\n              s.forEach(function (v) {\n                if (w.config.yaxis[si] && w.config.yaxis[si].logarithmic) {\n                  maxY = Math.max(v, maxY);\n                  minY = Math.min(v, minY);\n                }\n              });\n            });\n            range = Math.pow(gl.yRange[i], Math.abs(minY - maxY) / gl.yRange[i]);\n            gl.yLogRatio[i] = range / gl.gridHeight;\n            return range;\n          }\n        });\n        return gl.invalidLogScale ? yRatio.slice() : gl.yLogRatio;\n      } // Some config objects can be array - and we need to extend them correctly\n\n    }], [{\n      key: \"checkComboSeries\",\n      value: function checkComboSeries(series) {\n        var comboCharts = false;\n        var comboBarCount = 0;\n        var comboCount = 0; // if user specified a type in series too, turn on comboCharts flag\n\n        if (series.length && typeof series[0].type !== 'undefined') {\n          series.forEach(function (s) {\n            if (s.type === 'bar' || s.type === 'column' || s.type === 'candlestick' || s.type === 'boxPlot') {\n              comboBarCount++;\n            }\n\n            if (typeof s.type !== 'undefined') {\n              comboCount++;\n            }\n          });\n        }\n\n        if (comboCount > 0) {\n          comboCharts = true;\n        }\n\n        return {\n          comboBarCount: comboBarCount,\n          comboCharts: comboCharts\n        };\n      }\n    }, {\n      key: \"extendArrayProps\",\n      value: function extendArrayProps(configInstance, options, w) {\n        if (options.yaxis) {\n          options = configInstance.extendYAxis(options, w);\n        }\n\n        if (options.annotations) {\n          if (options.annotations.yaxis) {\n            options = configInstance.extendYAxisAnnotations(options);\n          }\n\n          if (options.annotations.xaxis) {\n            options = configInstance.extendXAxisAnnotations(options);\n          }\n\n          if (options.annotations.points) {\n            options = configInstance.extendPointAnnotations(options);\n          }\n        }\n\n        return options;\n      }\n    }]);\n\n    return CoreUtils;\n  }();\n\n  var Helpers$4 = /*#__PURE__*/function () {\n    function Helpers(annoCtx) {\n      _classCallCheck(this, Helpers);\n\n      this.w = annoCtx.w;\n      this.annoCtx = annoCtx;\n    }\n\n    _createClass(Helpers, [{\n      key: \"setOrientations\",\n      value: function setOrientations(anno) {\n        var annoIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var w = this.w;\n\n        if (anno.label.orientation === 'vertical') {\n          var i = annoIndex !== null ? annoIndex : 0;\n          var xAnno = w.globals.dom.baseEl.querySelector(\".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='\".concat(i, \"']\"));\n\n          if (xAnno !== null) {\n            var xAnnoCoord = xAnno.getBoundingClientRect();\n            xAnno.setAttribute('x', parseFloat(xAnno.getAttribute('x')) - xAnnoCoord.height + 4);\n\n            if (anno.label.position === 'top') {\n              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) + xAnnoCoord.width);\n            } else {\n              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) - xAnnoCoord.width);\n            }\n\n            var annoRotatingCenter = this.annoCtx.graphics.rotateAroundCenter(xAnno);\n            var x = annoRotatingCenter.x;\n            var y = annoRotatingCenter.y;\n            xAnno.setAttribute('transform', \"rotate(-90 \".concat(x, \" \").concat(y, \")\"));\n          }\n        }\n      }\n    }, {\n      key: \"addBackgroundToAnno\",\n      value: function addBackgroundToAnno(annoEl, anno) {\n        var w = this.w;\n        if (!annoEl || typeof anno.label.text === 'undefined' || typeof anno.label.text !== 'undefined' && !String(anno.label.text).trim()) return null;\n        var elGridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect();\n        var coords = annoEl.getBoundingClientRect();\n        var pleft = anno.label.style.padding.left;\n        var pright = anno.label.style.padding.right;\n        var ptop = anno.label.style.padding.top;\n        var pbottom = anno.label.style.padding.bottom;\n\n        if (anno.label.orientation === 'vertical') {\n          ptop = anno.label.style.padding.left;\n          pbottom = anno.label.style.padding.right;\n          pleft = anno.label.style.padding.top;\n          pright = anno.label.style.padding.bottom;\n        }\n\n        var x1 = coords.left - elGridRect.left - pleft;\n        var y1 = coords.top - elGridRect.top - ptop;\n        var elRect = this.annoCtx.graphics.drawRect(x1 - w.globals.barPadForNumericAxis, y1, coords.width + pleft + pright, coords.height + ptop + pbottom, anno.label.borderRadius, anno.label.style.background, 1, anno.label.borderWidth, anno.label.borderColor, 0);\n\n        if (anno.id) {\n          // don't escapeString for this ID as it causes duplicate rects\n          elRect.node.classList.add(anno.id);\n        }\n\n        return elRect;\n      }\n    }, {\n      key: \"annotationsBackground\",\n      value: function annotationsBackground() {\n        var _this = this;\n\n        var w = this.w;\n\n        var add = function add(anno, i, type) {\n          var annoLabel = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations .apexcharts-\").concat(type, \"-annotation-label[rel='\").concat(i, \"']\"));\n\n          if (annoLabel) {\n            var parent = annoLabel.parentNode;\n\n            var elRect = _this.addBackgroundToAnno(annoLabel, anno);\n\n            if (elRect) {\n              parent.insertBefore(elRect.node, annoLabel);\n\n              if (anno.label.mouseEnter) {\n                elRect.node.addEventListener('mouseenter', anno.label.mouseEnter.bind(_this, anno));\n              }\n\n              if (anno.label.mouseLeave) {\n                elRect.node.addEventListener('mouseleave', anno.label.mouseLeave.bind(_this, anno));\n              }\n\n              if (anno.label.click) {\n                elRect.node.addEventListener('click', anno.label.click.bind(_this, anno));\n              }\n            }\n          }\n        };\n\n        w.config.annotations.xaxis.map(function (anno, i) {\n          add(anno, i, 'xaxis');\n        });\n        w.config.annotations.yaxis.map(function (anno, i) {\n          add(anno, i, 'yaxis');\n        });\n        w.config.annotations.points.map(function (anno, i) {\n          add(anno, i, 'point');\n        });\n      }\n    }, {\n      key: \"getY1Y2\",\n      value: function getY1Y2(type, anno) {\n        var y = type === 'y1' ? anno.y : anno.y2;\n        var yP;\n        var w = this.w;\n\n        if (this.annoCtx.invertAxis) {\n          var catIndex = w.globals.labels.indexOf(y);\n\n          if (w.config.xaxis.convertedCatToNumeric) {\n            catIndex = w.globals.categoryLabels.indexOf(y);\n          }\n\n          var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n\n          if (xLabel) {\n            yP = parseFloat(xLabel.getAttribute('y'));\n          }\n        } else {\n          var yPos;\n\n          if (w.config.yaxis[anno.yAxisIndex].logarithmic) {\n            var coreUtils = new CoreUtils(this.annoCtx.ctx);\n            y = coreUtils.getLogVal(y, anno.yAxisIndex);\n            yPos = y / w.globals.yLogRatio[anno.yAxisIndex];\n          } else {\n            yPos = (y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n          }\n\n          yP = w.globals.gridHeight - yPos;\n\n          if (anno.marker && (anno.y === undefined || anno.y === null)) {\n            // point annotation\n            yP = 0;\n          }\n\n          if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {\n            yP = yPos;\n          }\n        }\n\n        if (typeof y === 'string' && y.indexOf('px') > -1) {\n          yP = parseFloat(y);\n        }\n\n        return yP;\n      }\n    }, {\n      key: \"getX1X2\",\n      value: function getX1X2(type, anno) {\n        var w = this.w;\n        var min = this.annoCtx.invertAxis ? w.globals.minY : w.globals.minX;\n        var max = this.annoCtx.invertAxis ? w.globals.maxY : w.globals.maxX;\n        var range = this.annoCtx.invertAxis ? w.globals.yRange[0] : w.globals.xRange;\n        var x1 = (anno.x - min) / (range / w.globals.gridWidth);\n\n        if (this.annoCtx.inversedReversedAxis) {\n          x1 = (max - anno.x) / (range / w.globals.gridWidth);\n        }\n\n        if ((w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) && !this.annoCtx.invertAxis && !w.globals.dataFormatXNumeric) {\n          x1 = this.getStringX(anno.x);\n        }\n\n        var x2 = (anno.x2 - min) / (range / w.globals.gridWidth);\n\n        if (this.annoCtx.inversedReversedAxis) {\n          x2 = (max - anno.x2) / (range / w.globals.gridWidth);\n        }\n\n        if ((w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) && !this.annoCtx.invertAxis && !w.globals.dataFormatXNumeric) {\n          x2 = this.getStringX(anno.x2);\n        }\n\n        if ((anno.x === undefined || anno.x === null) && anno.marker) {\n          // point annotation in a horizontal chart\n          x1 = w.globals.gridWidth;\n        }\n\n        if (type === 'x1' && typeof anno.x === 'string' && anno.x.indexOf('px') > -1) {\n          x1 = parseFloat(anno.x);\n        }\n\n        if (type === 'x2' && typeof anno.x2 === 'string' && anno.x2.indexOf('px') > -1) {\n          x2 = parseFloat(anno.x2);\n        }\n\n        return type === 'x1' ? x1 : x2;\n      }\n    }, {\n      key: \"getStringX\",\n      value: function getStringX(x) {\n        var w = this.w;\n        var rX = x;\n\n        if (w.config.xaxis.convertedCatToNumeric && w.globals.categoryLabels.length) {\n          x = w.globals.categoryLabels.indexOf(x) + 1;\n        }\n\n        var catIndex = w.globals.labels.indexOf(x);\n        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n\n        if (xLabel) {\n          rX = parseFloat(xLabel.getAttribute('x'));\n        }\n\n        return rX;\n      }\n    }]);\n\n    return Helpers;\n  }();\n\n  var XAnnotations = /*#__PURE__*/function () {\n    function XAnnotations(annoCtx) {\n      _classCallCheck(this, XAnnotations);\n\n      this.w = annoCtx.w;\n      this.annoCtx = annoCtx;\n      this.invertAxis = this.annoCtx.invertAxis;\n      this.helpers = new Helpers$4(this.annoCtx);\n    }\n\n    _createClass(XAnnotations, [{\n      key: \"addXaxisAnnotation\",\n      value: function addXaxisAnnotation(anno, parent, index) {\n        var w = this.w;\n        var x1 = this.helpers.getX1X2('x1', anno);\n        var x2;\n        var text = anno.label.text;\n        var strokeDashArray = anno.strokeDashArray;\n        if (!Utils$1.isNumber(x1)) return;\n\n        if (anno.x2 === null || typeof anno.x2 === 'undefined') {\n          var line = this.annoCtx.graphics.drawLine(x1 + anno.offsetX, // x1\n          0 + anno.offsetY, // y1\n          x1 + anno.offsetX, // x2\n          w.globals.gridHeight + anno.offsetY, // y2\n          anno.borderColor, // lineColor\n          strokeDashArray, //dashArray\n          anno.borderWidth);\n          parent.appendChild(line.node);\n\n          if (anno.id) {\n            line.node.classList.add(anno.id);\n          }\n        } else {\n          x2 = this.helpers.getX1X2('x2', anno);\n\n          if (x2 < x1) {\n            var temp = x1;\n            x1 = x2;\n            x2 = temp;\n          }\n\n          var rect = this.annoCtx.graphics.drawRect(x1 + anno.offsetX, // x1\n          0 + anno.offsetY, // y1\n          x2 - x1, // x2\n          w.globals.gridHeight + anno.offsetY, // y2\n          0, // radius\n          anno.fillColor, // color\n          anno.opacity, // opacity,\n          1, // strokeWidth\n          anno.borderColor, // strokeColor\n          strokeDashArray // stokeDashArray\n          );\n          rect.node.classList.add('apexcharts-annotation-rect');\n          rect.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n          parent.appendChild(rect.node);\n\n          if (anno.id) {\n            rect.node.classList.add(anno.id);\n          }\n        }\n\n        var textRects = this.annoCtx.graphics.getTextRects(text, parseFloat(anno.label.style.fontSize));\n        var textY = anno.label.position === 'top' ? 4 : anno.label.position === 'center' ? w.globals.gridHeight / 2 + (anno.label.orientation === 'vertical' ? textRects.width / 2 : 0) : w.globals.gridHeight;\n        var elText = this.annoCtx.graphics.drawText({\n          x: x1 + anno.label.offsetX,\n          y: textY + anno.label.offsetY - (anno.label.orientation === 'vertical' ? anno.label.position === 'top' ? textRects.width / 2 - 12 : -textRects.width / 2 : 0),\n          text: text,\n          textAnchor: anno.label.textAnchor,\n          fontSize: anno.label.style.fontSize,\n          fontFamily: anno.label.style.fontFamily,\n          fontWeight: anno.label.style.fontWeight,\n          foreColor: anno.label.style.color,\n          cssClass: \"apexcharts-xaxis-annotation-label \".concat(anno.label.style.cssClass, \" \").concat(anno.id ? anno.id : '')\n        });\n        elText.attr({\n          rel: index\n        });\n        parent.appendChild(elText.node); // after placing the annotations on svg, set any vertically placed annotations\n\n        this.annoCtx.helpers.setOrientations(anno, index);\n      }\n    }, {\n      key: \"drawXAxisAnnotations\",\n      value: function drawXAxisAnnotations() {\n        var _this = this;\n\n        var w = this.w;\n        var elg = this.annoCtx.graphics.group({\n          class: 'apexcharts-xaxis-annotations'\n        });\n        w.config.annotations.xaxis.map(function (anno, index) {\n          _this.addXaxisAnnotation(anno, elg.node, index);\n        });\n        return elg;\n      }\n    }]);\n\n    return XAnnotations;\n  }();\n\n  var YAnnotations = /*#__PURE__*/function () {\n    function YAnnotations(annoCtx) {\n      _classCallCheck(this, YAnnotations);\n\n      this.w = annoCtx.w;\n      this.annoCtx = annoCtx;\n      this.helpers = new Helpers$4(this.annoCtx);\n    }\n\n    _createClass(YAnnotations, [{\n      key: \"addYaxisAnnotation\",\n      value: function addYaxisAnnotation(anno, parent, index) {\n        var w = this.w;\n        var strokeDashArray = anno.strokeDashArray;\n        var y1 = this.helpers.getY1Y2('y1', anno);\n        var y2;\n        var text = anno.label.text;\n\n        if (anno.y2 === null || typeof anno.y2 === 'undefined') {\n          var line = this.annoCtx.graphics.drawLine(0 + anno.offsetX, // x1\n          y1 + anno.offsetY, // y1\n          this._getYAxisAnnotationWidth(anno), // x2\n          y1 + anno.offsetY, // y2\n          anno.borderColor, // lineColor\n          strokeDashArray, // dashArray\n          anno.borderWidth);\n          parent.appendChild(line.node);\n\n          if (anno.id) {\n            line.node.classList.add(anno.id);\n          }\n        } else {\n          y2 = this.helpers.getY1Y2('y2', anno);\n\n          if (y2 > y1) {\n            var temp = y1;\n            y1 = y2;\n            y2 = temp;\n          }\n\n          var rect = this.annoCtx.graphics.drawRect(0 + anno.offsetX, // x1\n          y2 + anno.offsetY, // y1\n          this._getYAxisAnnotationWidth(anno), // x2\n          y1 - y2, // y2\n          0, // radius\n          anno.fillColor, // color\n          anno.opacity, // opacity,\n          1, // strokeWidth\n          anno.borderColor, // strokeColor\n          strokeDashArray // stokeDashArray\n          );\n          rect.node.classList.add('apexcharts-annotation-rect');\n          rect.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n          parent.appendChild(rect.node);\n\n          if (anno.id) {\n            rect.node.classList.add(anno.id);\n          }\n        }\n\n        var textX = anno.label.position === 'right' ? w.globals.gridWidth : anno.label.position === 'center' ? w.globals.gridWidth / 2 : 0;\n        var elText = this.annoCtx.graphics.drawText({\n          x: textX + anno.label.offsetX,\n          y: (y2 != null ? y2 : y1) + anno.label.offsetY - 3,\n          text: text,\n          textAnchor: anno.label.textAnchor,\n          fontSize: anno.label.style.fontSize,\n          fontFamily: anno.label.style.fontFamily,\n          fontWeight: anno.label.style.fontWeight,\n          foreColor: anno.label.style.color,\n          cssClass: \"apexcharts-yaxis-annotation-label \".concat(anno.label.style.cssClass, \" \").concat(anno.id ? anno.id : '')\n        });\n        elText.attr({\n          rel: index\n        });\n        parent.appendChild(elText.node);\n      }\n    }, {\n      key: \"_getYAxisAnnotationWidth\",\n      value: function _getYAxisAnnotationWidth(anno) {\n        // issue apexcharts.js#2009\n        var w = this.w;\n        var width = w.globals.gridWidth;\n\n        if (anno.width.indexOf('%') > -1) {\n          width = w.globals.gridWidth * parseInt(anno.width, 10) / 100;\n        } else {\n          width = parseInt(anno.width, 10);\n        }\n\n        return width + anno.offsetX;\n      }\n    }, {\n      key: \"drawYAxisAnnotations\",\n      value: function drawYAxisAnnotations() {\n        var _this = this;\n\n        var w = this.w;\n        var elg = this.annoCtx.graphics.group({\n          class: 'apexcharts-yaxis-annotations'\n        });\n        w.config.annotations.yaxis.map(function (anno, index) {\n          _this.addYaxisAnnotation(anno, elg.node, index);\n        });\n        return elg;\n      }\n    }]);\n\n    return YAnnotations;\n  }();\n\n  var PointAnnotations = /*#__PURE__*/function () {\n    function PointAnnotations(annoCtx) {\n      _classCallCheck(this, PointAnnotations);\n\n      this.w = annoCtx.w;\n      this.annoCtx = annoCtx;\n      this.helpers = new Helpers$4(this.annoCtx);\n    }\n\n    _createClass(PointAnnotations, [{\n      key: \"addPointAnnotation\",\n      value: function addPointAnnotation(anno, parent, index) {\n        this.w;\n        var x = this.helpers.getX1X2('x1', anno);\n        var y = this.helpers.getY1Y2('y1', anno);\n        if (!Utils$1.isNumber(x)) return;\n        var optsPoints = {\n          pSize: anno.marker.size,\n          pointStrokeWidth: anno.marker.strokeWidth,\n          pointFillColor: anno.marker.fillColor,\n          pointStrokeColor: anno.marker.strokeColor,\n          shape: anno.marker.shape,\n          pRadius: anno.marker.radius,\n          class: \"apexcharts-point-annotation-marker \".concat(anno.marker.cssClass, \" \").concat(anno.id ? anno.id : '')\n        };\n        var point = this.annoCtx.graphics.drawMarker(x + anno.marker.offsetX, y + anno.marker.offsetY, optsPoints);\n        parent.appendChild(point.node);\n        var text = anno.label.text ? anno.label.text : '';\n        var elText = this.annoCtx.graphics.drawText({\n          x: x + anno.label.offsetX,\n          y: y + anno.label.offsetY - anno.marker.size - parseFloat(anno.label.style.fontSize) / 1.6,\n          text: text,\n          textAnchor: anno.label.textAnchor,\n          fontSize: anno.label.style.fontSize,\n          fontFamily: anno.label.style.fontFamily,\n          fontWeight: anno.label.style.fontWeight,\n          foreColor: anno.label.style.color,\n          cssClass: \"apexcharts-point-annotation-label \".concat(anno.label.style.cssClass, \" \").concat(anno.id ? anno.id : '')\n        });\n        elText.attr({\n          rel: index\n        });\n        parent.appendChild(elText.node); // TODO: deprecate this as we will use custom\n\n        if (anno.customSVG.SVG) {\n          var g = this.annoCtx.graphics.group({\n            class: 'apexcharts-point-annotations-custom-svg ' + anno.customSVG.cssClass\n          });\n          g.attr({\n            transform: \"translate(\".concat(x + anno.customSVG.offsetX, \", \").concat(y + anno.customSVG.offsetY, \")\")\n          });\n          g.node.innerHTML = anno.customSVG.SVG;\n          parent.appendChild(g.node);\n        }\n\n        if (anno.image.path) {\n          var imgWidth = anno.image.width ? anno.image.width : 20;\n          var imgHeight = anno.image.height ? anno.image.height : 20;\n          point = this.annoCtx.addImage({\n            x: x + anno.image.offsetX - imgWidth / 2,\n            y: y + anno.image.offsetY - imgHeight / 2,\n            width: imgWidth,\n            height: imgHeight,\n            path: anno.image.path,\n            appendTo: '.apexcharts-point-annotations'\n          });\n        }\n\n        if (anno.mouseEnter) {\n          point.node.addEventListener('mouseenter', anno.mouseEnter.bind(this, anno));\n        }\n\n        if (anno.mouseLeave) {\n          point.node.addEventListener('mouseleave', anno.mouseLeave.bind(this, anno));\n        }\n\n        if (anno.click) {\n          point.node.addEventListener('click', anno.click.bind(this, anno));\n        }\n      }\n    }, {\n      key: \"drawPointAnnotations\",\n      value: function drawPointAnnotations() {\n        var _this = this;\n\n        var w = this.w;\n        var elg = this.annoCtx.graphics.group({\n          class: 'apexcharts-point-annotations'\n        });\n        w.config.annotations.points.map(function (anno, index) {\n          _this.addPointAnnotation(anno, elg.node, index);\n        });\n        return elg;\n      }\n    }]);\n\n    return PointAnnotations;\n  }();\n\n  const name = \"en\";\n  const options = {\n  \tmonths: [\n  \t\t\"January\",\n  \t\t\"February\",\n  \t\t\"March\",\n  \t\t\"April\",\n  \t\t\"May\",\n  \t\t\"June\",\n  \t\t\"July\",\n  \t\t\"August\",\n  \t\t\"September\",\n  \t\t\"October\",\n  \t\t\"November\",\n  \t\t\"December\"\n  \t],\n  \tshortMonths: [\n  \t\t\"Jan\",\n  \t\t\"Feb\",\n  \t\t\"Mar\",\n  \t\t\"Apr\",\n  \t\t\"May\",\n  \t\t\"Jun\",\n  \t\t\"Jul\",\n  \t\t\"Aug\",\n  \t\t\"Sep\",\n  \t\t\"Oct\",\n  \t\t\"Nov\",\n  \t\t\"Dec\"\n  \t],\n  \tdays: [\n  \t\t\"Sunday\",\n  \t\t\"Monday\",\n  \t\t\"Tuesday\",\n  \t\t\"Wednesday\",\n  \t\t\"Thursday\",\n  \t\t\"Friday\",\n  \t\t\"Saturday\"\n  \t],\n  \tshortDays: [\n  \t\t\"Sun\",\n  \t\t\"Mon\",\n  \t\t\"Tue\",\n  \t\t\"Wed\",\n  \t\t\"Thu\",\n  \t\t\"Fri\",\n  \t\t\"Sat\"\n  \t],\n  \ttoolbar: {\n  \t\texportToSVG: \"Download SVG\",\n  \t\texportToPNG: \"Download PNG\",\n  \t\texportToCSV: \"Download CSV\",\n  \t\tmenu: \"Menu\",\n  \t\tselection: \"Selection\",\n  \t\tselectionZoom: \"Selection Zoom\",\n  \t\tzoomIn: \"Zoom In\",\n  \t\tzoomOut: \"Zoom Out\",\n  \t\tpan: \"Panning\",\n  \t\treset: \"Reset Zoom\"\n  \t}\n  };\n  var en = {\n  \tname: name,\n  \toptions: options\n  };\n\n  var Options = /*#__PURE__*/function () {\n    function Options() {\n      _classCallCheck(this, Options);\n\n      this.yAxis = {\n        show: true,\n        showAlways: false,\n        showForNullSeries: true,\n        seriesName: undefined,\n        opposite: false,\n        reversed: false,\n        logarithmic: false,\n        logBase: 10,\n        tickAmount: undefined,\n        forceNiceScale: false,\n        max: undefined,\n        min: undefined,\n        floating: false,\n        decimalsInFloat: undefined,\n        labels: {\n          show: true,\n          minWidth: 0,\n          maxWidth: 160,\n          offsetX: 0,\n          offsetY: 0,\n          align: undefined,\n          rotate: 0,\n          padding: 20,\n          style: {\n            colors: [],\n            fontSize: '11px',\n            fontWeight: 400,\n            fontFamily: undefined,\n            cssClass: ''\n          },\n          formatter: undefined\n        },\n        axisBorder: {\n          show: false,\n          color: '#e0e0e0',\n          width: 1,\n          offsetX: 0,\n          offsetY: 0\n        },\n        axisTicks: {\n          show: false,\n          color: '#e0e0e0',\n          width: 6,\n          offsetX: 0,\n          offsetY: 0\n        },\n        title: {\n          text: undefined,\n          rotate: -90,\n          offsetY: 0,\n          offsetX: 0,\n          style: {\n            color: undefined,\n            fontSize: '11px',\n            fontWeight: 900,\n            fontFamily: undefined,\n            cssClass: ''\n          }\n        },\n        tooltip: {\n          enabled: false,\n          offsetX: 0\n        },\n        crosshairs: {\n          show: true,\n          position: 'front',\n          stroke: {\n            color: '#b6b6b6',\n            width: 1,\n            dashArray: 0\n          }\n        }\n      };\n      this.pointAnnotation = {\n        id: undefined,\n        x: 0,\n        y: null,\n        yAxisIndex: 0,\n        seriesIndex: 0,\n        mouseEnter: undefined,\n        mouseLeave: undefined,\n        click: undefined,\n        marker: {\n          size: 4,\n          fillColor: '#fff',\n          strokeWidth: 2,\n          strokeColor: '#333',\n          shape: 'circle',\n          offsetX: 0,\n          offsetY: 0,\n          radius: 2,\n          cssClass: ''\n        },\n        label: {\n          borderColor: '#c2c2c2',\n          borderWidth: 1,\n          borderRadius: 2,\n          text: undefined,\n          textAnchor: 'middle',\n          offsetX: 0,\n          offsetY: 0,\n          mouseEnter: undefined,\n          mouseLeave: undefined,\n          click: undefined,\n          style: {\n            background: '#fff',\n            color: undefined,\n            fontSize: '11px',\n            fontFamily: undefined,\n            fontWeight: 400,\n            cssClass: '',\n            padding: {\n              left: 5,\n              right: 5,\n              top: 2,\n              bottom: 2\n            }\n          }\n        },\n        customSVG: {\n          // this will be deprecated in the next major version as it is going to be replaced with a better alternative below\n          SVG: undefined,\n          cssClass: undefined,\n          offsetX: 0,\n          offsetY: 0\n        },\n        image: {\n          path: undefined,\n          width: 20,\n          height: 20,\n          offsetX: 0,\n          offsetY: 0\n        }\n      };\n      this.yAxisAnnotation = {\n        id: undefined,\n        y: 0,\n        y2: null,\n        strokeDashArray: 1,\n        fillColor: '#c2c2c2',\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        opacity: 0.3,\n        offsetX: 0,\n        offsetY: 0,\n        width: '100%',\n        yAxisIndex: 0,\n        label: {\n          borderColor: '#c2c2c2',\n          borderWidth: 1,\n          borderRadius: 2,\n          text: undefined,\n          textAnchor: 'end',\n          position: 'right',\n          offsetX: 0,\n          offsetY: -3,\n          mouseEnter: undefined,\n          mouseLeave: undefined,\n          click: undefined,\n          style: {\n            background: '#fff',\n            color: undefined,\n            fontSize: '11px',\n            fontFamily: undefined,\n            fontWeight: 400,\n            cssClass: '',\n            padding: {\n              left: 5,\n              right: 5,\n              top: 2,\n              bottom: 2\n            }\n          }\n        }\n      };\n      this.xAxisAnnotation = {\n        id: undefined,\n        x: 0,\n        x2: null,\n        strokeDashArray: 1,\n        fillColor: '#c2c2c2',\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        opacity: 0.3,\n        offsetX: 0,\n        offsetY: 0,\n        label: {\n          borderColor: '#c2c2c2',\n          borderWidth: 1,\n          borderRadius: 2,\n          text: undefined,\n          textAnchor: 'middle',\n          orientation: 'vertical',\n          position: 'top',\n          offsetX: 0,\n          offsetY: 0,\n          mouseEnter: undefined,\n          mouseLeave: undefined,\n          click: undefined,\n          style: {\n            background: '#fff',\n            color: undefined,\n            fontSize: '11px',\n            fontFamily: undefined,\n            fontWeight: 400,\n            cssClass: '',\n            padding: {\n              left: 5,\n              right: 5,\n              top: 2,\n              bottom: 2\n            }\n          }\n        }\n      };\n      this.text = {\n        x: 0,\n        y: 0,\n        text: '',\n        textAnchor: 'start',\n        foreColor: undefined,\n        fontSize: '13px',\n        fontFamily: undefined,\n        fontWeight: 400,\n        appendTo: '.apexcharts-annotations',\n        backgroundColor: 'transparent',\n        borderColor: '#c2c2c2',\n        borderRadius: 0,\n        borderWidth: 0,\n        paddingLeft: 4,\n        paddingRight: 4,\n        paddingTop: 2,\n        paddingBottom: 2\n      };\n    }\n\n    _createClass(Options, [{\n      key: \"init\",\n      value: function init() {\n        return {\n          annotations: {\n            yaxis: [this.yAxisAnnotation],\n            xaxis: [this.xAxisAnnotation],\n            points: [this.pointAnnotation],\n            texts: [],\n            images: [],\n            shapes: []\n          },\n          chart: {\n            animations: {\n              enabled: true,\n              easing: 'easeinout',\n              // linear, easeout, easein, easeinout, swing, bounce, elastic\n              speed: 800,\n              animateGradually: {\n                delay: 150,\n                enabled: true\n              },\n              dynamicAnimation: {\n                enabled: true,\n                speed: 350\n              }\n            },\n            background: 'transparent',\n            locales: [en],\n            defaultLocale: 'en',\n            dropShadow: {\n              enabled: false,\n              enabledOnSeries: undefined,\n              top: 2,\n              left: 2,\n              blur: 4,\n              color: '#000',\n              opacity: 0.35\n            },\n            events: {\n              animationEnd: undefined,\n              beforeMount: undefined,\n              mounted: undefined,\n              updated: undefined,\n              click: undefined,\n              mouseMove: undefined,\n              mouseLeave: undefined,\n              xAxisLabelClick: undefined,\n              legendClick: undefined,\n              markerClick: undefined,\n              selection: undefined,\n              dataPointSelection: undefined,\n              dataPointMouseEnter: undefined,\n              dataPointMouseLeave: undefined,\n              beforeZoom: undefined,\n              beforeResetZoom: undefined,\n              zoomed: undefined,\n              scrolled: undefined,\n              brushScrolled: undefined\n            },\n            foreColor: '#373d3f',\n            fontFamily: 'Helvetica, Arial, sans-serif',\n            height: 'auto',\n            parentHeightOffset: 15,\n            redrawOnParentResize: true,\n            redrawOnWindowResize: true,\n            id: undefined,\n            group: undefined,\n            offsetX: 0,\n            offsetY: 0,\n            selection: {\n              enabled: false,\n              type: 'x',\n              // selectedPoints: undefined, // default datapoints that should be selected automatically\n              fill: {\n                color: '#24292e',\n                opacity: 0.1\n              },\n              stroke: {\n                width: 1,\n                color: '#24292e',\n                opacity: 0.4,\n                dashArray: 3\n              },\n              xaxis: {\n                min: undefined,\n                max: undefined\n              },\n              yaxis: {\n                min: undefined,\n                max: undefined\n              }\n            },\n            sparkline: {\n              enabled: false\n            },\n            brush: {\n              enabled: false,\n              autoScaleYaxis: true,\n              target: undefined,\n              targets: undefined\n            },\n            stacked: false,\n            stackType: 'normal',\n            toolbar: {\n              show: true,\n              offsetX: 0,\n              offsetY: 0,\n              tools: {\n                download: true,\n                selection: true,\n                zoom: true,\n                zoomin: true,\n                zoomout: true,\n                pan: true,\n                reset: true,\n                customIcons: []\n              },\n              export: {\n                csv: {\n                  filename: undefined,\n                  columnDelimiter: ',',\n                  headerCategory: 'category',\n                  headerValue: 'value',\n                  dateFormatter: function dateFormatter(timestamp) {\n                    return new Date(timestamp).toDateString();\n                  }\n                },\n                png: {\n                  filename: undefined\n                },\n                svg: {\n                  filename: undefined\n                }\n              },\n              autoSelected: 'zoom' // accepts -> zoom, pan, selection\n\n            },\n            type: 'line',\n            width: '100%',\n            zoom: {\n              enabled: true,\n              type: 'x',\n              autoScaleYaxis: false,\n              zoomedArea: {\n                fill: {\n                  color: '#90CAF9',\n                  opacity: 0.4\n                },\n                stroke: {\n                  color: '#0D47A1',\n                  opacity: 0.4,\n                  width: 1\n                }\n              }\n            }\n          },\n          plotOptions: {\n            area: {\n              fillTo: 'origin'\n            },\n            bar: {\n              horizontal: false,\n              columnWidth: '70%',\n              // should be in percent 0 - 100\n              barHeight: '70%',\n              // should be in percent 0 - 100\n              distributed: false,\n              borderRadius: 0,\n              borderRadiusApplication: 'around',\n              // [around, end]\n              borderRadiusWhenStacked: 'last',\n              // [all, last]\n              rangeBarOverlap: true,\n              rangeBarGroupRows: false,\n              hideZeroBarsWhenGrouped: false,\n              isDumbbell: false,\n              dumbbellColors: undefined,\n              isFunnel: false,\n              isFunnel3d: true,\n              colors: {\n                ranges: [],\n                backgroundBarColors: [],\n                backgroundBarOpacity: 1,\n                backgroundBarRadius: 0\n              },\n              dataLabels: {\n                position: 'top',\n                // top, center, bottom\n                maxItems: 100,\n                hideOverflowingLabels: true,\n                orientation: 'horizontal',\n                total: {\n                  enabled: false,\n                  formatter: undefined,\n                  offsetX: 0,\n                  offsetY: 0,\n                  style: {\n                    color: '#373d3f',\n                    fontSize: '12px',\n                    fontFamily: undefined,\n                    fontWeight: 600\n                  }\n                }\n              }\n            },\n            bubble: {\n              zScaling: true,\n              minBubbleRadius: undefined,\n              maxBubbleRadius: undefined\n            },\n            candlestick: {\n              colors: {\n                upward: '#00B746',\n                downward: '#EF403C'\n              },\n              wick: {\n                useFillColor: true\n              }\n            },\n            boxPlot: {\n              colors: {\n                upper: '#00E396',\n                lower: '#008FFB'\n              }\n            },\n            heatmap: {\n              radius: 2,\n              enableShades: true,\n              shadeIntensity: 0.5,\n              reverseNegativeShade: false,\n              distributed: false,\n              useFillColorAsStroke: false,\n              colorScale: {\n                inverse: false,\n                ranges: [],\n                min: undefined,\n                max: undefined\n              }\n            },\n            treemap: {\n              enableShades: true,\n              shadeIntensity: 0.5,\n              distributed: false,\n              reverseNegativeShade: false,\n              useFillColorAsStroke: false,\n              dataLabels: {\n                format: 'scale' // scale | truncate\n\n              },\n              colorScale: {\n                inverse: false,\n                ranges: [],\n                min: undefined,\n                max: undefined\n              }\n            },\n            radialBar: {\n              inverseOrder: false,\n              startAngle: 0,\n              endAngle: 360,\n              offsetX: 0,\n              offsetY: 0,\n              hollow: {\n                margin: 5,\n                size: '50%',\n                background: 'transparent',\n                image: undefined,\n                imageWidth: 150,\n                imageHeight: 150,\n                imageOffsetX: 0,\n                imageOffsetY: 0,\n                imageClipped: true,\n                position: 'front',\n                dropShadow: {\n                  enabled: false,\n                  top: 0,\n                  left: 0,\n                  blur: 3,\n                  color: '#000',\n                  opacity: 0.5\n                }\n              },\n              track: {\n                show: true,\n                startAngle: undefined,\n                endAngle: undefined,\n                background: '#f2f2f2',\n                strokeWidth: '97%',\n                opacity: 1,\n                margin: 5,\n                // margin is in pixels\n                dropShadow: {\n                  enabled: false,\n                  top: 0,\n                  left: 0,\n                  blur: 3,\n                  color: '#000',\n                  opacity: 0.5\n                }\n              },\n              dataLabels: {\n                show: true,\n                name: {\n                  show: true,\n                  fontSize: '16px',\n                  fontFamily: undefined,\n                  fontWeight: 600,\n                  color: undefined,\n                  offsetY: 0,\n                  formatter: function formatter(val) {\n                    return val;\n                  }\n                },\n                value: {\n                  show: true,\n                  fontSize: '14px',\n                  fontFamily: undefined,\n                  fontWeight: 400,\n                  color: undefined,\n                  offsetY: 16,\n                  formatter: function formatter(val) {\n                    return val + '%';\n                  }\n                },\n                total: {\n                  show: false,\n                  label: 'Total',\n                  fontSize: '16px',\n                  fontWeight: 600,\n                  fontFamily: undefined,\n                  color: undefined,\n                  formatter: function formatter(w) {\n                    return w.globals.seriesTotals.reduce(function (a, b) {\n                      return a + b;\n                    }, 0) / w.globals.series.length + '%';\n                  }\n                }\n              }\n            },\n            pie: {\n              customScale: 1,\n              offsetX: 0,\n              offsetY: 0,\n              startAngle: 0,\n              endAngle: 360,\n              expandOnClick: true,\n              dataLabels: {\n                // These are the percentage values which are displayed on slice\n                offset: 0,\n                // offset by which labels will move outside\n                minAngleToShowLabel: 10\n              },\n              donut: {\n                size: '65%',\n                background: 'transparent',\n                labels: {\n                  // These are the inner labels appearing inside donut\n                  show: false,\n                  name: {\n                    show: true,\n                    fontSize: '16px',\n                    fontFamily: undefined,\n                    fontWeight: 600,\n                    color: undefined,\n                    offsetY: -10,\n                    formatter: function formatter(val) {\n                      return val;\n                    }\n                  },\n                  value: {\n                    show: true,\n                    fontSize: '20px',\n                    fontFamily: undefined,\n                    fontWeight: 400,\n                    color: undefined,\n                    offsetY: 10,\n                    formatter: function formatter(val) {\n                      return val;\n                    }\n                  },\n                  total: {\n                    show: false,\n                    showAlways: false,\n                    label: 'Total',\n                    fontSize: '16px',\n                    fontWeight: 400,\n                    fontFamily: undefined,\n                    color: undefined,\n                    formatter: function formatter(w) {\n                      return w.globals.seriesTotals.reduce(function (a, b) {\n                        return a + b;\n                      }, 0);\n                    }\n                  }\n                }\n              }\n            },\n            polarArea: {\n              rings: {\n                strokeWidth: 1,\n                strokeColor: '#e8e8e8'\n              },\n              spokes: {\n                strokeWidth: 1,\n                connectorColors: '#e8e8e8'\n              }\n            },\n            radar: {\n              size: undefined,\n              offsetX: 0,\n              offsetY: 0,\n              polygons: {\n                // strokeColor: '#e8e8e8', // should be deprecated in the minor version i.e 3.2\n                strokeWidth: 1,\n                strokeColors: '#e8e8e8',\n                connectorColors: '#e8e8e8',\n                fill: {\n                  colors: undefined\n                }\n              }\n            }\n          },\n          colors: undefined,\n          dataLabels: {\n            enabled: true,\n            enabledOnSeries: undefined,\n            formatter: function formatter(val) {\n              return val !== null ? val : '';\n            },\n            textAnchor: 'middle',\n            distributed: false,\n            offsetX: 0,\n            offsetY: 0,\n            style: {\n              fontSize: '12px',\n              fontFamily: undefined,\n              fontWeight: 600,\n              colors: undefined\n            },\n            background: {\n              enabled: true,\n              foreColor: '#fff',\n              borderRadius: 2,\n              padding: 4,\n              opacity: 0.9,\n              borderWidth: 1,\n              borderColor: '#fff',\n              dropShadow: {\n                enabled: false,\n                top: 1,\n                left: 1,\n                blur: 1,\n                color: '#000',\n                opacity: 0.45\n              }\n            },\n            dropShadow: {\n              enabled: false,\n              top: 1,\n              left: 1,\n              blur: 1,\n              color: '#000',\n              opacity: 0.45\n            }\n          },\n          fill: {\n            type: 'solid',\n            colors: undefined,\n            // array of colors\n            opacity: 0.85,\n            gradient: {\n              shade: 'dark',\n              type: 'horizontal',\n              shadeIntensity: 0.5,\n              gradientToColors: undefined,\n              inverseColors: true,\n              opacityFrom: 1,\n              opacityTo: 1,\n              stops: [0, 50, 100],\n              colorStops: []\n            },\n            image: {\n              src: [],\n              width: undefined,\n              // optional\n              height: undefined // optional\n\n            },\n            pattern: {\n              style: 'squares',\n              // String | Array of Strings\n              width: 6,\n              height: 6,\n              strokeWidth: 2\n            }\n          },\n          forecastDataPoints: {\n            count: 0,\n            fillOpacity: 0.5,\n            strokeWidth: undefined,\n            dashArray: 4\n          },\n          grid: {\n            show: true,\n            borderColor: '#e0e0e0',\n            strokeDashArray: 0,\n            position: 'back',\n            xaxis: {\n              lines: {\n                show: false\n              }\n            },\n            yaxis: {\n              lines: {\n                show: true\n              }\n            },\n            row: {\n              colors: undefined,\n              // takes as array which will be repeated on rows\n              opacity: 0.5\n            },\n            column: {\n              colors: undefined,\n              // takes an array which will be repeated on columns\n              opacity: 0.5\n            },\n            padding: {\n              top: 0,\n              right: 10,\n              bottom: 0,\n              left: 12\n            }\n          },\n          labels: [],\n          legend: {\n            show: true,\n            showForSingleSeries: false,\n            showForNullSeries: true,\n            showForZeroSeries: true,\n            floating: false,\n            position: 'bottom',\n            // whether to position legends in 1 of 4\n            // direction - top, bottom, left, right\n            horizontalAlign: 'center',\n            // when position top/bottom, you can specify whether to align legends left, right or center\n            inverseOrder: false,\n            fontSize: '12px',\n            fontFamily: undefined,\n            fontWeight: 400,\n            width: undefined,\n            height: undefined,\n            formatter: undefined,\n            tooltipHoverFormatter: undefined,\n            offsetX: -20,\n            offsetY: 4,\n            customLegendItems: [],\n            labels: {\n              colors: undefined,\n              useSeriesColors: false\n            },\n            markers: {\n              width: 12,\n              height: 12,\n              strokeWidth: 0,\n              fillColors: undefined,\n              strokeColor: '#fff',\n              radius: 12,\n              customHTML: undefined,\n              offsetX: 0,\n              offsetY: 0,\n              onClick: undefined\n            },\n            itemMargin: {\n              horizontal: 5,\n              vertical: 2\n            },\n            onItemClick: {\n              toggleDataSeries: true\n            },\n            onItemHover: {\n              highlightDataSeries: true\n            }\n          },\n          markers: {\n            discrete: [],\n            size: 0,\n            colors: undefined,\n            //strokeColor: '#fff', // TODO: deprecate in major version 4.0\n            strokeColors: '#fff',\n            strokeWidth: 2,\n            strokeOpacity: 0.9,\n            strokeDashArray: 0,\n            fillOpacity: 1,\n            shape: 'circle',\n            width: 8,\n            // only applicable when shape is rect/square\n            height: 8,\n            // only applicable when shape is rect/square\n            radius: 2,\n            offsetX: 0,\n            offsetY: 0,\n            onClick: undefined,\n            onDblClick: undefined,\n            showNullDataPoints: true,\n            hover: {\n              size: undefined,\n              sizeOffset: 3\n            }\n          },\n          noData: {\n            text: undefined,\n            align: 'center',\n            verticalAlign: 'middle',\n            offsetX: 0,\n            offsetY: 0,\n            style: {\n              color: undefined,\n              fontSize: '14px',\n              fontFamily: undefined\n            }\n          },\n          responsive: [],\n          // breakpoints should follow ascending order 400, then 700, then 1000\n          series: undefined,\n          states: {\n            normal: {\n              filter: {\n                type: 'none',\n                value: 0\n              }\n            },\n            hover: {\n              filter: {\n                type: 'lighten',\n                value: 0.1\n              }\n            },\n            active: {\n              allowMultipleDataPointsSelection: false,\n              filter: {\n                type: 'darken',\n                value: 0.5\n              }\n            }\n          },\n          title: {\n            text: undefined,\n            align: 'left',\n            margin: 5,\n            offsetX: 0,\n            offsetY: 0,\n            floating: false,\n            style: {\n              fontSize: '14px',\n              fontWeight: 900,\n              fontFamily: undefined,\n              color: undefined\n            }\n          },\n          subtitle: {\n            text: undefined,\n            align: 'left',\n            margin: 5,\n            offsetX: 0,\n            offsetY: 30,\n            floating: false,\n            style: {\n              fontSize: '12px',\n              fontWeight: 400,\n              fontFamily: undefined,\n              color: undefined\n            }\n          },\n          stroke: {\n            show: true,\n            curve: 'smooth',\n            // \"smooth\" / \"straight\" / \"monotoneCubic\" / \"stepline\"\n            lineCap: 'butt',\n            // round, butt , square\n            width: 2,\n            colors: undefined,\n            // array of colors\n            dashArray: 0,\n            // single value or array of values\n            fill: {\n              type: 'solid',\n              colors: undefined,\n              // array of colors\n              opacity: 0.85,\n              gradient: {\n                shade: 'dark',\n                type: 'horizontal',\n                shadeIntensity: 0.5,\n                gradientToColors: undefined,\n                inverseColors: true,\n                opacityFrom: 1,\n                opacityTo: 1,\n                stops: [0, 50, 100],\n                colorStops: []\n              }\n            }\n          },\n          tooltip: {\n            enabled: true,\n            enabledOnSeries: undefined,\n            shared: true,\n            followCursor: false,\n            // when disabled, the tooltip will show on top of the series instead of mouse position\n            intersect: false,\n            // when enabled, tooltip will only show when user directly hovers over point\n            inverseOrder: false,\n            custom: undefined,\n            fillSeriesColor: false,\n            theme: 'light',\n            cssClass: '',\n            style: {\n              fontSize: '12px',\n              fontFamily: undefined\n            },\n            onDatasetHover: {\n              highlightDataSeries: false\n            },\n            x: {\n              // x value\n              show: true,\n              format: 'dd MMM',\n              // dd/MM, dd MMM yy, dd MMM yyyy\n              formatter: undefined // a custom user supplied formatter function\n\n            },\n            y: {\n              formatter: undefined,\n              title: {\n                formatter: function formatter(seriesName) {\n                  return seriesName ? seriesName + ': ' : '';\n                }\n              }\n            },\n            z: {\n              formatter: undefined,\n              title: 'Size: '\n            },\n            marker: {\n              show: true,\n              fillColors: undefined\n            },\n            items: {\n              display: 'flex'\n            },\n            fixed: {\n              enabled: false,\n              position: 'topRight',\n              // topRight, topLeft, bottomRight, bottomLeft\n              offsetX: 0,\n              offsetY: 0\n            }\n          },\n          xaxis: {\n            type: 'category',\n            categories: [],\n            convertedCatToNumeric: false,\n            // internal property which should not be altered outside\n            offsetX: 0,\n            offsetY: 0,\n            overwriteCategories: undefined,\n            labels: {\n              show: true,\n              rotate: -45,\n              rotateAlways: false,\n              hideOverlappingLabels: true,\n              trim: false,\n              minHeight: undefined,\n              maxHeight: 120,\n              showDuplicates: true,\n              style: {\n                colors: [],\n                fontSize: '12px',\n                fontWeight: 400,\n                fontFamily: undefined,\n                cssClass: ''\n              },\n              offsetX: 0,\n              offsetY: 0,\n              format: undefined,\n              formatter: undefined,\n              // custom formatter function which will override format\n              datetimeUTC: true,\n              datetimeFormatter: {\n                year: 'yyyy',\n                month: \"MMM 'yy\",\n                day: 'dd MMM',\n                hour: 'HH:mm',\n                minute: 'HH:mm:ss',\n                second: 'HH:mm:ss'\n              }\n            },\n            group: {\n              groups: [],\n              style: {\n                colors: [],\n                fontSize: '12px',\n                fontWeight: 400,\n                fontFamily: undefined,\n                cssClass: ''\n              }\n            },\n            axisBorder: {\n              show: true,\n              color: '#e0e0e0',\n              width: '100%',\n              height: 1,\n              offsetX: 0,\n              offsetY: 0\n            },\n            axisTicks: {\n              show: true,\n              color: '#e0e0e0',\n              height: 6,\n              offsetX: 0,\n              offsetY: 0\n            },\n            tickAmount: undefined,\n            tickPlacement: 'on',\n            min: undefined,\n            max: undefined,\n            range: undefined,\n            floating: false,\n            decimalsInFloat: undefined,\n            position: 'bottom',\n            title: {\n              text: undefined,\n              offsetX: 0,\n              offsetY: 0,\n              style: {\n                color: undefined,\n                fontSize: '12px',\n                fontWeight: 900,\n                fontFamily: undefined,\n                cssClass: ''\n              }\n            },\n            crosshairs: {\n              show: true,\n              width: 1,\n              // tickWidth/barWidth or an integer\n              position: 'back',\n              opacity: 0.9,\n              stroke: {\n                color: '#b6b6b6',\n                width: 1,\n                dashArray: 3\n              },\n              fill: {\n                type: 'solid',\n                // solid, gradient\n                color: '#B1B9C4',\n                gradient: {\n                  colorFrom: '#D8E3F0',\n                  colorTo: '#BED1E6',\n                  stops: [0, 100],\n                  opacityFrom: 0.4,\n                  opacityTo: 0.5\n                }\n              },\n              dropShadow: {\n                enabled: false,\n                left: 0,\n                top: 0,\n                blur: 1,\n                opacity: 0.4\n              }\n            },\n            tooltip: {\n              enabled: true,\n              offsetY: 0,\n              formatter: undefined,\n              style: {\n                fontSize: '12px',\n                fontFamily: undefined\n              }\n            }\n          },\n          yaxis: this.yAxis,\n          theme: {\n            mode: 'light',\n            palette: 'palette1',\n            // If defined, it will overwrite globals.colors variable\n            monochrome: {\n              // monochrome allows you to select just 1 color and fill out the rest with light/dark shade (intensity can be selected)\n              enabled: false,\n              color: '#008FFB',\n              shadeTo: 'light',\n              shadeIntensity: 0.65\n            }\n          }\n        };\n      }\n    }]);\n\n    return Options;\n  }();\n\n  /**\n   * ApexCharts Annotations Class for drawing lines/rects on both xaxis and yaxis.\n   *\n   * @module Annotations\n   **/\n\n  var Annotations = /*#__PURE__*/function () {\n    function Annotations(ctx) {\n      _classCallCheck(this, Annotations);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.graphics = new Graphics(this.ctx);\n\n      if (this.w.globals.isBarHorizontal) {\n        this.invertAxis = true;\n      }\n\n      this.helpers = new Helpers$4(this);\n      this.xAxisAnnotations = new XAnnotations(this);\n      this.yAxisAnnotations = new YAnnotations(this);\n      this.pointsAnnotations = new PointAnnotations(this);\n\n      if (this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed) {\n        this.inversedReversedAxis = true;\n      }\n\n      this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;\n    }\n\n    _createClass(Annotations, [{\n      key: \"drawAxesAnnotations\",\n      value: function drawAxesAnnotations() {\n        var w = this.w;\n\n        if (w.globals.axisCharts) {\n          var yAnnotations = this.yAxisAnnotations.drawYAxisAnnotations();\n          var xAnnotations = this.xAxisAnnotations.drawXAxisAnnotations();\n          var pointAnnotations = this.pointsAnnotations.drawPointAnnotations();\n          var initialAnim = w.config.chart.animations.enabled;\n          var annoArray = [yAnnotations, xAnnotations, pointAnnotations];\n          var annoElArray = [xAnnotations.node, yAnnotations.node, pointAnnotations.node];\n\n          for (var i = 0; i < 3; i++) {\n            w.globals.dom.elGraphical.add(annoArray[i]);\n\n            if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n              // fixes apexcharts/apexcharts.js#685\n              if (w.config.chart.type !== 'scatter' && w.config.chart.type !== 'bubble' && w.globals.dataPoints > 1) {\n                annoElArray[i].classList.add('apexcharts-element-hidden');\n              }\n            }\n\n            w.globals.delayedElements.push({\n              el: annoElArray[i],\n              index: 0\n            });\n          } // background sizes needs to be calculated after text is drawn, so calling them last\n\n\n          this.helpers.annotationsBackground();\n        }\n      }\n    }, {\n      key: \"drawImageAnnos\",\n      value: function drawImageAnnos() {\n        var _this = this;\n\n        var w = this.w;\n        w.config.annotations.images.map(function (s, index) {\n          _this.addImage(s, index);\n        });\n      }\n    }, {\n      key: \"drawTextAnnos\",\n      value: function drawTextAnnos() {\n        var _this2 = this;\n\n        var w = this.w;\n        w.config.annotations.texts.map(function (t, index) {\n          _this2.addText(t, index);\n        });\n      }\n    }, {\n      key: \"addXaxisAnnotation\",\n      value: function addXaxisAnnotation(anno, parent, index) {\n        this.xAxisAnnotations.addXaxisAnnotation(anno, parent, index);\n      }\n    }, {\n      key: \"addYaxisAnnotation\",\n      value: function addYaxisAnnotation(anno, parent, index) {\n        this.yAxisAnnotations.addYaxisAnnotation(anno, parent, index);\n      }\n    }, {\n      key: \"addPointAnnotation\",\n      value: function addPointAnnotation(anno, parent, index) {\n        this.pointsAnnotations.addPointAnnotation(anno, parent, index);\n      }\n    }, {\n      key: \"addText\",\n      value: function addText(params, index) {\n        var x = params.x,\n            y = params.y,\n            text = params.text,\n            textAnchor = params.textAnchor,\n            foreColor = params.foreColor,\n            fontSize = params.fontSize,\n            fontFamily = params.fontFamily,\n            fontWeight = params.fontWeight,\n            cssClass = params.cssClass,\n            backgroundColor = params.backgroundColor,\n            borderWidth = params.borderWidth,\n            strokeDashArray = params.strokeDashArray,\n            borderRadius = params.borderRadius,\n            borderColor = params.borderColor,\n            _params$appendTo = params.appendTo,\n            appendTo = _params$appendTo === void 0 ? '.apexcharts-annotations' : _params$appendTo,\n            _params$paddingLeft = params.paddingLeft,\n            paddingLeft = _params$paddingLeft === void 0 ? 4 : _params$paddingLeft,\n            _params$paddingRight = params.paddingRight,\n            paddingRight = _params$paddingRight === void 0 ? 4 : _params$paddingRight,\n            _params$paddingBottom = params.paddingBottom,\n            paddingBottom = _params$paddingBottom === void 0 ? 2 : _params$paddingBottom,\n            _params$paddingTop = params.paddingTop,\n            paddingTop = _params$paddingTop === void 0 ? 2 : _params$paddingTop;\n        var w = this.w;\n        var elText = this.graphics.drawText({\n          x: x,\n          y: y,\n          text: text,\n          textAnchor: textAnchor || 'start',\n          fontSize: fontSize || '12px',\n          fontWeight: fontWeight || 'regular',\n          fontFamily: fontFamily || w.config.chart.fontFamily,\n          foreColor: foreColor || w.config.chart.foreColor,\n          cssClass: 'apexcharts-text ' + cssClass ? cssClass : 0\n        });\n        var parent = w.globals.dom.baseEl.querySelector(appendTo);\n\n        if (parent) {\n          parent.appendChild(elText.node);\n        }\n\n        var textRect = elText.bbox();\n\n        if (text) {\n          var elRect = this.graphics.drawRect(textRect.x - paddingLeft, textRect.y - paddingTop, textRect.width + paddingLeft + paddingRight, textRect.height + paddingBottom + paddingTop, borderRadius, backgroundColor ? backgroundColor : 'transparent', 1, borderWidth, borderColor, strokeDashArray);\n          parent.insertBefore(elRect.node, elText.node);\n        }\n      }\n    }, {\n      key: \"addImage\",\n      value: function addImage(params, index) {\n        var w = this.w;\n        var path = params.path,\n            _params$x = params.x,\n            x = _params$x === void 0 ? 0 : _params$x,\n            _params$y = params.y,\n            y = _params$y === void 0 ? 0 : _params$y,\n            _params$width = params.width,\n            width = _params$width === void 0 ? 20 : _params$width,\n            _params$height = params.height,\n            height = _params$height === void 0 ? 20 : _params$height,\n            _params$appendTo2 = params.appendTo,\n            appendTo = _params$appendTo2 === void 0 ? '.apexcharts-annotations' : _params$appendTo2;\n        var img = w.globals.dom.Paper.image(path);\n        img.size(width, height).move(x, y);\n        var parent = w.globals.dom.baseEl.querySelector(appendTo);\n\n        if (parent) {\n          parent.appendChild(img.node);\n        }\n\n        return img;\n      } // The addXaxisAnnotation method requires a parent class, and user calling this method externally on the chart instance may not specify parent, hence a different method\n\n    }, {\n      key: \"addXaxisAnnotationExternal\",\n      value: function addXaxisAnnotationExternal(params, pushToMemory, context) {\n        this.addAnnotationExternal({\n          params: params,\n          pushToMemory: pushToMemory,\n          context: context,\n          type: 'xaxis',\n          contextMethod: context.addXaxisAnnotation\n        });\n        return context;\n      }\n    }, {\n      key: \"addYaxisAnnotationExternal\",\n      value: function addYaxisAnnotationExternal(params, pushToMemory, context) {\n        this.addAnnotationExternal({\n          params: params,\n          pushToMemory: pushToMemory,\n          context: context,\n          type: 'yaxis',\n          contextMethod: context.addYaxisAnnotation\n        });\n        return context;\n      }\n    }, {\n      key: \"addPointAnnotationExternal\",\n      value: function addPointAnnotationExternal(params, pushToMemory, context) {\n        if (typeof this.invertAxis === 'undefined') {\n          this.invertAxis = context.w.globals.isBarHorizontal;\n        }\n\n        this.addAnnotationExternal({\n          params: params,\n          pushToMemory: pushToMemory,\n          context: context,\n          type: 'point',\n          contextMethod: context.addPointAnnotation\n        });\n        return context;\n      }\n    }, {\n      key: \"addAnnotationExternal\",\n      value: function addAnnotationExternal(_ref) {\n        var params = _ref.params,\n            pushToMemory = _ref.pushToMemory,\n            context = _ref.context,\n            type = _ref.type,\n            contextMethod = _ref.contextMethod;\n        var me = context;\n        var w = me.w;\n        var parent = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations\"));\n        var index = parent.childNodes.length + 1;\n        var options = new Options();\n        var axesAnno = Object.assign({}, type === 'xaxis' ? options.xAxisAnnotation : type === 'yaxis' ? options.yAxisAnnotation : options.pointAnnotation);\n        var anno = Utils$1.extend(axesAnno, params);\n\n        switch (type) {\n          case 'xaxis':\n            this.addXaxisAnnotation(anno, parent, index);\n            break;\n\n          case 'yaxis':\n            this.addYaxisAnnotation(anno, parent, index);\n            break;\n\n          case 'point':\n            this.addPointAnnotation(anno, parent, index);\n            break;\n        } // add background\n\n\n        var axesAnnoLabel = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations .apexcharts-\").concat(type, \"-annotation-label[rel='\").concat(index, \"']\"));\n        var elRect = this.helpers.addBackgroundToAnno(axesAnnoLabel, anno);\n\n        if (elRect) {\n          parent.insertBefore(elRect.node, axesAnnoLabel);\n        }\n\n        if (pushToMemory) {\n          w.globals.memory.methodsToExec.push({\n            context: me,\n            id: anno.id ? anno.id : Utils$1.randomId(),\n            method: contextMethod,\n            label: 'addAnnotation',\n            params: params\n          });\n        }\n\n        return context;\n      }\n    }, {\n      key: \"clearAnnotations\",\n      value: function clearAnnotations(ctx) {\n        var w = ctx.w;\n        var annos = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations'); // annotations added externally should be cleared out too\n\n        w.globals.memory.methodsToExec.map(function (m, i) {\n          if (m.label === 'addText' || m.label === 'addAnnotation') {\n            w.globals.memory.methodsToExec.splice(i, 1);\n          }\n        });\n        annos = Utils$1.listToArray(annos); // delete the DOM elements\n\n        Array.prototype.forEach.call(annos, function (a) {\n          while (a.firstChild) {\n            a.removeChild(a.firstChild);\n          }\n        });\n      }\n    }, {\n      key: \"removeAnnotation\",\n      value: function removeAnnotation(ctx, id) {\n        var w = ctx.w;\n        var annos = w.globals.dom.baseEl.querySelectorAll(\".\".concat(id));\n\n        if (annos) {\n          w.globals.memory.methodsToExec.map(function (m, i) {\n            if (m.id === id) {\n              w.globals.memory.methodsToExec.splice(i, 1);\n            }\n          });\n          Array.prototype.forEach.call(annos, function (a) {\n            a.parentElement.removeChild(a);\n          });\n        }\n      }\n    }]);\n\n    return Annotations;\n  }();\n\n  /**\n   * DateTime Class to manipulate datetime values.\n   *\n   * @module DateTime\n   **/\n\n  var DateTime = /*#__PURE__*/function () {\n    function DateTime(ctx) {\n      _classCallCheck(this, DateTime);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.months31 = [1, 3, 5, 7, 8, 10, 12];\n      this.months30 = [2, 4, 6, 9, 11];\n      this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n    }\n\n    _createClass(DateTime, [{\n      key: \"isValidDate\",\n      value: function isValidDate(date) {\n        return !isNaN(this.parseDate(date));\n      }\n    }, {\n      key: \"getTimeStamp\",\n      value: function getTimeStamp(dateStr) {\n        if (!Date.parse(dateStr)) {\n          return dateStr;\n        }\n\n        var utc = this.w.config.xaxis.labels.datetimeUTC;\n        return !utc ? new Date(dateStr).getTime() : new Date(new Date(dateStr).toISOString().substr(0, 25)).getTime();\n      }\n    }, {\n      key: \"getDate\",\n      value: function getDate(timestamp) {\n        var utc = this.w.config.xaxis.labels.datetimeUTC;\n        return utc ? new Date(new Date(timestamp).toUTCString()) : new Date(timestamp);\n      }\n    }, {\n      key: \"parseDate\",\n      value: function parseDate(dateStr) {\n        var parsed = Date.parse(dateStr);\n\n        if (!isNaN(parsed)) {\n          return this.getTimeStamp(dateStr);\n        }\n\n        var output = Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));\n        output = this.getTimeStamp(output);\n        return output;\n      } // This fixes the difference of x-axis labels between chrome/safari\n      // Fixes #1726, #1544, #1485, #1255\n\n    }, {\n      key: \"parseDateWithTimezone\",\n      value: function parseDateWithTimezone(dateStr) {\n        return Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));\n      } // http://stackoverflow.com/questions/14638018/current-time-formatting-with-javascript#answer-14638191\n\n    }, {\n      key: \"formatDate\",\n      value: function formatDate(date, format) {\n        var locale = this.w.globals.locale;\n        var utc = this.w.config.xaxis.labels.datetimeUTC;\n        var MMMM = ['\\x00'].concat(_toConsumableArray(locale.months));\n        var MMM = ['\\x01'].concat(_toConsumableArray(locale.shortMonths));\n        var dddd = ['\\x02'].concat(_toConsumableArray(locale.days));\n        var ddd = ['\\x03'].concat(_toConsumableArray(locale.shortDays));\n\n        function ii(i, len) {\n          var s = i + '';\n          len = len || 2;\n\n          while (s.length < len) {\n            s = '0' + s;\n          }\n\n          return s;\n        }\n\n        var y = utc ? date.getUTCFullYear() : date.getFullYear();\n        format = format.replace(/(^|[^\\\\])yyyy+/g, '$1' + y);\n        format = format.replace(/(^|[^\\\\])yy/g, '$1' + y.toString().substr(2, 2));\n        format = format.replace(/(^|[^\\\\])y/g, '$1' + y);\n        var M = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n        format = format.replace(/(^|[^\\\\])MMMM+/g, '$1' + MMMM[0]);\n        format = format.replace(/(^|[^\\\\])MMM/g, '$1' + MMM[0]);\n        format = format.replace(/(^|[^\\\\])MM/g, '$1' + ii(M));\n        format = format.replace(/(^|[^\\\\])M/g, '$1' + M);\n        var d = utc ? date.getUTCDate() : date.getDate();\n        format = format.replace(/(^|[^\\\\])dddd+/g, '$1' + dddd[0]);\n        format = format.replace(/(^|[^\\\\])ddd/g, '$1' + ddd[0]);\n        format = format.replace(/(^|[^\\\\])dd/g, '$1' + ii(d));\n        format = format.replace(/(^|[^\\\\])d/g, '$1' + d);\n        var H = utc ? date.getUTCHours() : date.getHours();\n        format = format.replace(/(^|[^\\\\])HH+/g, '$1' + ii(H));\n        format = format.replace(/(^|[^\\\\])H/g, '$1' + H);\n        var h = H > 12 ? H - 12 : H === 0 ? 12 : H;\n        format = format.replace(/(^|[^\\\\])hh+/g, '$1' + ii(h));\n        format = format.replace(/(^|[^\\\\])h/g, '$1' + h);\n        var m = utc ? date.getUTCMinutes() : date.getMinutes();\n        format = format.replace(/(^|[^\\\\])mm+/g, '$1' + ii(m));\n        format = format.replace(/(^|[^\\\\])m/g, '$1' + m);\n        var s = utc ? date.getUTCSeconds() : date.getSeconds();\n        format = format.replace(/(^|[^\\\\])ss+/g, '$1' + ii(s));\n        format = format.replace(/(^|[^\\\\])s/g, '$1' + s);\n        var f = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n        format = format.replace(/(^|[^\\\\])fff+/g, '$1' + ii(f, 3));\n        f = Math.round(f / 10);\n        format = format.replace(/(^|[^\\\\])ff/g, '$1' + ii(f));\n        f = Math.round(f / 10);\n        format = format.replace(/(^|[^\\\\])f/g, '$1' + f);\n        var T = H < 12 ? 'AM' : 'PM';\n        format = format.replace(/(^|[^\\\\])TT+/g, '$1' + T);\n        format = format.replace(/(^|[^\\\\])T/g, '$1' + T.charAt(0));\n        var t = T.toLowerCase();\n        format = format.replace(/(^|[^\\\\])tt+/g, '$1' + t);\n        format = format.replace(/(^|[^\\\\])t/g, '$1' + t.charAt(0));\n        var tz = -date.getTimezoneOffset();\n        var K = utc || !tz ? 'Z' : tz > 0 ? '+' : '-';\n\n        if (!utc) {\n          tz = Math.abs(tz);\n          var tzHrs = Math.floor(tz / 60);\n          var tzMin = tz % 60;\n          K += ii(tzHrs) + ':' + ii(tzMin);\n        }\n\n        format = format.replace(/(^|[^\\\\])K/g, '$1' + K);\n        var day = (utc ? date.getUTCDay() : date.getDay()) + 1;\n        format = format.replace(new RegExp(dddd[0], 'g'), dddd[day]);\n        format = format.replace(new RegExp(ddd[0], 'g'), ddd[day]);\n        format = format.replace(new RegExp(MMMM[0], 'g'), MMMM[M]);\n        format = format.replace(new RegExp(MMM[0], 'g'), MMM[M]);\n        format = format.replace(/\\\\(.)/g, '$1');\n        return format;\n      }\n    }, {\n      key: \"getTimeUnitsfromTimestamp\",\n      value: function getTimeUnitsfromTimestamp(minX, maxX, utc) {\n        var w = this.w;\n\n        if (w.config.xaxis.min !== undefined) {\n          minX = w.config.xaxis.min;\n        }\n\n        if (w.config.xaxis.max !== undefined) {\n          maxX = w.config.xaxis.max;\n        }\n\n        var tsMin = this.getDate(minX);\n        var tsMax = this.getDate(maxX);\n        var minD = this.formatDate(tsMin, 'yyyy MM dd HH mm ss fff').split(' ');\n        var maxD = this.formatDate(tsMax, 'yyyy MM dd HH mm ss fff').split(' ');\n        return {\n          minMillisecond: parseInt(minD[6], 10),\n          maxMillisecond: parseInt(maxD[6], 10),\n          minSecond: parseInt(minD[5], 10),\n          maxSecond: parseInt(maxD[5], 10),\n          minMinute: parseInt(minD[4], 10),\n          maxMinute: parseInt(maxD[4], 10),\n          minHour: parseInt(minD[3], 10),\n          maxHour: parseInt(maxD[3], 10),\n          minDate: parseInt(minD[2], 10),\n          maxDate: parseInt(maxD[2], 10),\n          minMonth: parseInt(minD[1], 10) - 1,\n          maxMonth: parseInt(maxD[1], 10) - 1,\n          minYear: parseInt(minD[0], 10),\n          maxYear: parseInt(maxD[0], 10)\n        };\n      }\n    }, {\n      key: \"isLeapYear\",\n      value: function isLeapYear(year) {\n        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n      }\n    }, {\n      key: \"calculcateLastDaysOfMonth\",\n      value: function calculcateLastDaysOfMonth(month, year, subtract) {\n        var days = this.determineDaysOfMonths(month, year); // whatever days we get, subtract the number of days asked\n\n        return days - subtract;\n      }\n    }, {\n      key: \"determineDaysOfYear\",\n      value: function determineDaysOfYear(year) {\n        var days = 365;\n\n        if (this.isLeapYear(year)) {\n          days = 366;\n        }\n\n        return days;\n      }\n    }, {\n      key: \"determineRemainingDaysOfYear\",\n      value: function determineRemainingDaysOfYear(year, month, date) {\n        var dayOfYear = this.daysCntOfYear[month] + date;\n        if (month > 1 && this.isLeapYear()) dayOfYear++;\n        return dayOfYear;\n      }\n    }, {\n      key: \"determineDaysOfMonths\",\n      value: function determineDaysOfMonths(month, year) {\n        var days = 30;\n        month = Utils$1.monthMod(month);\n\n        switch (true) {\n          case this.months30.indexOf(month) > -1:\n            if (month === 2) {\n              if (this.isLeapYear(year)) {\n                days = 29;\n              } else {\n                days = 28;\n              }\n            }\n\n            break;\n\n          case this.months31.indexOf(month) > -1:\n            days = 31;\n            break;\n\n          default:\n            days = 31;\n            break;\n        }\n\n        return days;\n      }\n    }]);\n\n    return DateTime;\n  }();\n\n  /**\n   * ApexCharts Formatter Class for setting value formatters for axes as well as tooltips.\n   *\n   * @module Formatters\n   **/\n\n  var Formatters = /*#__PURE__*/function () {\n    function Formatters(ctx) {\n      _classCallCheck(this, Formatters);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.tooltipKeyFormat = 'dd MMM';\n    }\n\n    _createClass(Formatters, [{\n      key: \"xLabelFormat\",\n      value: function xLabelFormat(fn, val, timestamp, opts) {\n        var w = this.w;\n\n        if (w.config.xaxis.type === 'datetime') {\n          if (w.config.xaxis.labels.formatter === undefined) {\n            // if user has not specified a custom formatter, use the default tooltip.x.format\n            if (w.config.tooltip.x.formatter === undefined) {\n              var datetimeObj = new DateTime(this.ctx);\n              return datetimeObj.formatDate(datetimeObj.getDate(val), w.config.tooltip.x.format);\n            }\n          }\n        }\n\n        return fn(val, timestamp, opts);\n      }\n    }, {\n      key: \"defaultGeneralFormatter\",\n      value: function defaultGeneralFormatter(val) {\n        if (Array.isArray(val)) {\n          return val.map(function (v) {\n            return v;\n          });\n        } else {\n          return val;\n        }\n      }\n    }, {\n      key: \"defaultYFormatter\",\n      value: function defaultYFormatter(v, yaxe, i) {\n        var w = this.w;\n\n        if (Utils$1.isNumber(v)) {\n          if (w.globals.yValueDecimal !== 0) {\n            v = v.toFixed(yaxe.decimalsInFloat !== undefined ? yaxe.decimalsInFloat : w.globals.yValueDecimal);\n          } else if (w.globals.maxYArr[i] - w.globals.minYArr[i] < 5) {\n            v = v.toFixed(1);\n          } else {\n            v = v.toFixed(0);\n          }\n        }\n\n        return v;\n      }\n    }, {\n      key: \"setLabelFormatters\",\n      value: function setLabelFormatters() {\n        var _this = this;\n\n        var w = this.w;\n\n        w.globals.xaxisTooltipFormatter = function (val) {\n          return _this.defaultGeneralFormatter(val);\n        };\n\n        w.globals.ttKeyFormatter = function (val) {\n          return _this.defaultGeneralFormatter(val);\n        };\n\n        w.globals.ttZFormatter = function (val) {\n          return val;\n        };\n\n        w.globals.legendFormatter = function (val) {\n          return _this.defaultGeneralFormatter(val);\n        }; // formatter function will always overwrite format property\n\n\n        if (w.config.xaxis.labels.formatter !== undefined) {\n          w.globals.xLabelFormatter = w.config.xaxis.labels.formatter;\n        } else {\n          w.globals.xLabelFormatter = function (val) {\n            if (Utils$1.isNumber(val)) {\n              if (!w.config.xaxis.convertedCatToNumeric && w.config.xaxis.type === 'numeric') {\n                if (Utils$1.isNumber(w.config.xaxis.decimalsInFloat)) {\n                  return val.toFixed(w.config.xaxis.decimalsInFloat);\n                } else {\n                  var diff = w.globals.maxX - w.globals.minX;\n\n                  if (diff > 0 && diff < 100) {\n                    return val.toFixed(1);\n                  }\n\n                  return val.toFixed(0);\n                }\n              }\n\n              if (w.globals.isBarHorizontal) {\n                var range = w.globals.maxY - w.globals.minYArr;\n\n                if (range < 4) {\n                  return val.toFixed(1);\n                }\n              }\n\n              return val.toFixed(0);\n            }\n\n            return val;\n          };\n        }\n\n        if (typeof w.config.tooltip.x.formatter === 'function') {\n          w.globals.ttKeyFormatter = w.config.tooltip.x.formatter;\n        } else {\n          w.globals.ttKeyFormatter = w.globals.xLabelFormatter;\n        }\n\n        if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n          w.globals.xaxisTooltipFormatter = w.config.xaxis.tooltip.formatter;\n        }\n\n        if (Array.isArray(w.config.tooltip.y)) {\n          w.globals.ttVal = w.config.tooltip.y;\n        } else {\n          if (w.config.tooltip.y.formatter !== undefined) {\n            w.globals.ttVal = w.config.tooltip.y;\n          }\n        }\n\n        if (w.config.tooltip.z.formatter !== undefined) {\n          w.globals.ttZFormatter = w.config.tooltip.z.formatter;\n        } // legend formatter - if user wants to append any global values of series to legend text\n\n\n        if (w.config.legend.formatter !== undefined) {\n          w.globals.legendFormatter = w.config.legend.formatter;\n        } // formatter function will always overwrite format property\n\n\n        w.config.yaxis.forEach(function (yaxe, i) {\n          if (yaxe.labels.formatter !== undefined) {\n            w.globals.yLabelFormatters[i] = yaxe.labels.formatter;\n          } else {\n            w.globals.yLabelFormatters[i] = function (val) {\n              if (!w.globals.xyCharts) return val;\n\n              if (Array.isArray(val)) {\n                return val.map(function (v) {\n                  return _this.defaultYFormatter(v, yaxe, i);\n                });\n              } else {\n                return _this.defaultYFormatter(val, yaxe, i);\n              }\n            };\n          }\n        });\n        return w.globals;\n      }\n    }, {\n      key: \"heatmapLabelFormatters\",\n      value: function heatmapLabelFormatters() {\n        var w = this.w;\n\n        if (w.config.chart.type === 'heatmap') {\n          w.globals.yAxisScale[0].result = w.globals.seriesNames.slice(); //  get the longest string from the labels array and also apply label formatter to it\n\n          var longest = w.globals.seriesNames.reduce(function (a, b) {\n            return a.length > b.length ? a : b;\n          }, 0);\n          w.globals.yAxisScale[0].niceMax = longest;\n          w.globals.yAxisScale[0].niceMin = longest;\n        }\n      }\n    }]);\n\n    return Formatters;\n  }();\n\n  /**\n   * ApexCharts Default Class for setting default options for all chart types.\n   *\n   * @module Defaults\n   **/\n\n  var getRangeValues = function getRangeValues(_ref) {\n    var _w$config$series$seri;\n\n    var isTimeline = _ref.isTimeline,\n        ctx = _ref.ctx,\n        seriesIndex = _ref.seriesIndex,\n        dataPointIndex = _ref.dataPointIndex,\n        y1 = _ref.y1,\n        y2 = _ref.y2,\n        w = _ref.w;\n    var start = w.globals.seriesRangeStart[seriesIndex][dataPointIndex];\n    var end = w.globals.seriesRangeEnd[seriesIndex][dataPointIndex];\n    var ylabel = w.globals.labels[dataPointIndex];\n    var seriesName = w.config.series[seriesIndex].name ? w.config.series[seriesIndex].name : '';\n    var yLbFormatter = w.globals.ttKeyFormatter;\n    var yLbTitleFormatter = w.config.tooltip.y.title.formatter;\n    var opts = {\n      w: w,\n      seriesIndex: seriesIndex,\n      dataPointIndex: dataPointIndex,\n      start: start,\n      end: end\n    };\n\n    if (typeof yLbTitleFormatter === 'function') {\n      seriesName = yLbTitleFormatter(seriesName, opts);\n    }\n\n    if ((_w$config$series$seri = w.config.series[seriesIndex].data[dataPointIndex]) !== null && _w$config$series$seri !== void 0 && _w$config$series$seri.x) {\n      ylabel = w.config.series[seriesIndex].data[dataPointIndex].x;\n    }\n\n    if (!isTimeline) {\n      if (w.config.xaxis.type === 'datetime') {\n        var xFormat = new Formatters(ctx);\n        ylabel = xFormat.xLabelFormat(w.globals.ttKeyFormatter, ylabel, ylabel, {\n          i: undefined,\n          dateFormatter: new DateTime(ctx).formatDate,\n          w: w\n        });\n      }\n    }\n\n    if (typeof yLbFormatter === 'function') {\n      ylabel = yLbFormatter(ylabel, opts);\n    }\n\n    if (Number.isFinite(y1) && Number.isFinite(y2)) {\n      start = y1;\n      end = y2;\n    }\n\n    var startVal = '';\n    var endVal = '';\n    var color = w.globals.colors[seriesIndex];\n\n    if (w.config.tooltip.x.formatter === undefined) {\n      if (w.config.xaxis.type === 'datetime') {\n        var datetimeObj = new DateTime(ctx);\n        startVal = datetimeObj.formatDate(datetimeObj.getDate(start), w.config.tooltip.x.format);\n        endVal = datetimeObj.formatDate(datetimeObj.getDate(end), w.config.tooltip.x.format);\n      } else {\n        startVal = start;\n        endVal = end;\n      }\n    } else {\n      startVal = w.config.tooltip.x.formatter(start);\n      endVal = w.config.tooltip.x.formatter(end);\n    }\n\n    return {\n      start: start,\n      end: end,\n      startVal: startVal,\n      endVal: endVal,\n      ylabel: ylabel,\n      color: color,\n      seriesName: seriesName\n    };\n  };\n\n  var buildRangeTooltipHTML = function buildRangeTooltipHTML(opts) {\n    var color = opts.color,\n        seriesName = opts.seriesName,\n        ylabel = opts.ylabel,\n        start = opts.start,\n        end = opts.end,\n        seriesIndex = opts.seriesIndex,\n        dataPointIndex = opts.dataPointIndex;\n    var formatter = opts.ctx.tooltip.tooltipLabels.getFormatters(seriesIndex);\n    start = formatter.yLbFormatter(start);\n    end = formatter.yLbFormatter(end);\n    var val = formatter.yLbFormatter(opts.w.globals.series[seriesIndex][dataPointIndex]);\n    var valueHTML = '';\n    var rangeValues = \"<span class=\\\"value start-value\\\">\\n  \".concat(start, \"\\n  </span> <span class=\\\"separator\\\">-</span> <span class=\\\"value end-value\\\">\\n  \").concat(end, \"\\n  </span>\");\n\n    if (opts.w.globals.comboCharts) {\n      if (opts.w.config.series[seriesIndex].type === 'rangeArea' || opts.w.config.series[seriesIndex].type === 'rangeBar') {\n        valueHTML = rangeValues;\n      } else {\n        valueHTML = \"<span>\".concat(val, \"</span>\");\n      }\n    } else {\n      valueHTML = rangeValues;\n    }\n\n    return '<div class=\"apexcharts-tooltip-rangebar\">' + '<div> <span class=\"series-name\" style=\"color: ' + color + '\">' + (seriesName ? seriesName : '') + '</span></div>' + '<div> <span class=\"category\">' + ylabel + ': </span> ' + valueHTML + ' </div>' + '</div>';\n  };\n\n  var Defaults = /*#__PURE__*/function () {\n    function Defaults(opts) {\n      _classCallCheck(this, Defaults);\n\n      this.opts = opts;\n    }\n\n    _createClass(Defaults, [{\n      key: \"hideYAxis\",\n      value: function hideYAxis() {\n        this.opts.yaxis[0].show = false;\n        this.opts.yaxis[0].title.text = '';\n        this.opts.yaxis[0].axisBorder.show = false;\n        this.opts.yaxis[0].axisTicks.show = false;\n        this.opts.yaxis[0].floating = true;\n      }\n    }, {\n      key: \"line\",\n      value: function line() {\n        return {\n          chart: {\n            animations: {\n              easing: 'swing'\n            }\n          },\n          dataLabels: {\n            enabled: false\n          },\n          stroke: {\n            width: 5,\n            curve: 'straight'\n          },\n          markers: {\n            size: 0,\n            hover: {\n              sizeOffset: 6\n            }\n          },\n          xaxis: {\n            crosshairs: {\n              width: 1\n            }\n          }\n        };\n      }\n    }, {\n      key: \"sparkline\",\n      value: function sparkline(defaults) {\n        this.hideYAxis();\n        var ret = {\n          grid: {\n            show: false,\n            padding: {\n              left: 0,\n              right: 0,\n              top: 0,\n              bottom: 0\n            }\n          },\n          legend: {\n            show: false\n          },\n          xaxis: {\n            labels: {\n              show: false\n            },\n            tooltip: {\n              enabled: false\n            },\n            axisBorder: {\n              show: false\n            },\n            axisTicks: {\n              show: false\n            }\n          },\n          chart: {\n            toolbar: {\n              show: false\n            },\n            zoom: {\n              enabled: false\n            }\n          },\n          dataLabels: {\n            enabled: false\n          }\n        };\n        return Utils$1.extend(defaults, ret);\n      }\n    }, {\n      key: \"bar\",\n      value: function bar() {\n        return {\n          chart: {\n            stacked: false,\n            animations: {\n              easing: 'swing'\n            }\n          },\n          plotOptions: {\n            bar: {\n              dataLabels: {\n                position: 'center'\n              }\n            }\n          },\n          dataLabels: {\n            style: {\n              colors: ['#fff']\n            },\n            background: {\n              enabled: false\n            }\n          },\n          stroke: {\n            width: 0,\n            lineCap: 'round'\n          },\n          fill: {\n            opacity: 0.85\n          },\n          legend: {\n            markers: {\n              shape: 'square',\n              radius: 2,\n              size: 8\n            }\n          },\n          tooltip: {\n            shared: false,\n            intersect: true\n          },\n          xaxis: {\n            tooltip: {\n              enabled: false\n            },\n            tickPlacement: 'between',\n            crosshairs: {\n              width: 'barWidth',\n              position: 'back',\n              fill: {\n                type: 'gradient'\n              },\n              dropShadow: {\n                enabled: false\n              },\n              stroke: {\n                width: 0\n              }\n            }\n          }\n        };\n      }\n    }, {\n      key: \"funnel\",\n      value: function funnel() {\n        this.hideYAxis();\n        return _objectSpread2(_objectSpread2({}, this.bar()), {}, {\n          chart: {\n            animations: {\n              easing: 'linear',\n              speed: 800,\n              animateGradually: {\n                enabled: false\n              }\n            }\n          },\n          plotOptions: {\n            bar: {\n              horizontal: true,\n              borderRadiusApplication: 'around',\n              borderRadius: 0,\n              dataLabels: {\n                position: 'center'\n              }\n            }\n          },\n          grid: {\n            show: false,\n            padding: {\n              left: 0,\n              right: 0\n            }\n          },\n          xaxis: {\n            labels: {\n              show: false\n            },\n            tooltip: {\n              enabled: false\n            },\n            axisBorder: {\n              show: false\n            },\n            axisTicks: {\n              show: false\n            }\n          }\n        });\n      }\n    }, {\n      key: \"candlestick\",\n      value: function candlestick() {\n        var _this = this;\n\n        return {\n          stroke: {\n            width: 1,\n            colors: ['#333']\n          },\n          fill: {\n            opacity: 1\n          },\n          dataLabels: {\n            enabled: false\n          },\n          tooltip: {\n            shared: true,\n            custom: function custom(_ref2) {\n              var seriesIndex = _ref2.seriesIndex,\n                  dataPointIndex = _ref2.dataPointIndex,\n                  w = _ref2.w;\n              return _this._getBoxTooltip(w, seriesIndex, dataPointIndex, ['Open', 'High', '', 'Low', 'Close'], 'candlestick');\n            }\n          },\n          states: {\n            active: {\n              filter: {\n                type: 'none'\n              }\n            }\n          },\n          xaxis: {\n            crosshairs: {\n              width: 1\n            }\n          }\n        };\n      }\n    }, {\n      key: \"boxPlot\",\n      value: function boxPlot() {\n        var _this2 = this;\n\n        return {\n          chart: {\n            animations: {\n              dynamicAnimation: {\n                enabled: false\n              }\n            }\n          },\n          stroke: {\n            width: 1,\n            colors: ['#24292e']\n          },\n          dataLabels: {\n            enabled: false\n          },\n          tooltip: {\n            shared: true,\n            custom: function custom(_ref3) {\n              var seriesIndex = _ref3.seriesIndex,\n                  dataPointIndex = _ref3.dataPointIndex,\n                  w = _ref3.w;\n              return _this2._getBoxTooltip(w, seriesIndex, dataPointIndex, ['Minimum', 'Q1', 'Median', 'Q3', 'Maximum'], 'boxPlot');\n            }\n          },\n          markers: {\n            size: 5,\n            strokeWidth: 1,\n            strokeColors: '#111'\n          },\n          xaxis: {\n            crosshairs: {\n              width: 1\n            }\n          }\n        };\n      }\n    }, {\n      key: \"rangeBar\",\n      value: function rangeBar() {\n        var handleTimelineTooltip = function handleTimelineTooltip(opts) {\n          var _getRangeValues = getRangeValues(_objectSpread2(_objectSpread2({}, opts), {}, {\n            isTimeline: true\n          })),\n              color = _getRangeValues.color,\n              seriesName = _getRangeValues.seriesName,\n              ylabel = _getRangeValues.ylabel,\n              startVal = _getRangeValues.startVal,\n              endVal = _getRangeValues.endVal;\n\n          return buildRangeTooltipHTML(_objectSpread2(_objectSpread2({}, opts), {}, {\n            color: color,\n            seriesName: seriesName,\n            ylabel: ylabel,\n            start: startVal,\n            end: endVal\n          }));\n        };\n\n        var handleRangeColumnTooltip = function handleRangeColumnTooltip(opts) {\n          var _getRangeValues2 = getRangeValues(opts),\n              color = _getRangeValues2.color,\n              seriesName = _getRangeValues2.seriesName,\n              ylabel = _getRangeValues2.ylabel,\n              start = _getRangeValues2.start,\n              end = _getRangeValues2.end;\n\n          return buildRangeTooltipHTML(_objectSpread2(_objectSpread2({}, opts), {}, {\n            color: color,\n            seriesName: seriesName,\n            ylabel: ylabel,\n            start: start,\n            end: end\n          }));\n        };\n\n        return {\n          chart: {\n            animations: {\n              animateGradually: false\n            }\n          },\n          stroke: {\n            width: 0,\n            lineCap: 'square'\n          },\n          plotOptions: {\n            bar: {\n              borderRadius: 0,\n              dataLabels: {\n                position: 'center'\n              }\n            }\n          },\n          dataLabels: {\n            enabled: false,\n            formatter: function formatter(val, _ref4) {\n              _ref4.ctx;\n                  var seriesIndex = _ref4.seriesIndex,\n                  dataPointIndex = _ref4.dataPointIndex,\n                  w = _ref4.w;\n\n              var getVal = function getVal() {\n                var start = w.globals.seriesRangeStart[seriesIndex][dataPointIndex];\n                var end = w.globals.seriesRangeEnd[seriesIndex][dataPointIndex];\n                return end - start;\n              };\n\n              if (w.globals.comboCharts) {\n                if (w.config.series[seriesIndex].type === 'rangeBar' || w.config.series[seriesIndex].type === 'rangeArea') {\n                  return getVal();\n                } else {\n                  return val;\n                }\n              } else {\n                return getVal();\n              }\n            },\n            background: {\n              enabled: false\n            },\n            style: {\n              colors: ['#fff']\n            }\n          },\n          markers: {\n            size: 10\n          },\n          tooltip: {\n            shared: false,\n            followCursor: true,\n            custom: function custom(opts) {\n              if (opts.w.config.plotOptions && opts.w.config.plotOptions.bar && opts.w.config.plotOptions.bar.horizontal) {\n                return handleTimelineTooltip(opts);\n              } else {\n                return handleRangeColumnTooltip(opts);\n              }\n            }\n          },\n          xaxis: {\n            tickPlacement: 'between',\n            tooltip: {\n              enabled: false\n            },\n            crosshairs: {\n              stroke: {\n                width: 0\n              }\n            }\n          }\n        };\n      }\n    }, {\n      key: \"dumbbell\",\n      value: function dumbbell(opts) {\n        var _opts$plotOptions$bar, _opts$plotOptions$bar2;\n\n        if (!((_opts$plotOptions$bar = opts.plotOptions.bar) !== null && _opts$plotOptions$bar !== void 0 && _opts$plotOptions$bar.barHeight)) {\n          opts.plotOptions.bar.barHeight = 2;\n        }\n\n        if (!((_opts$plotOptions$bar2 = opts.plotOptions.bar) !== null && _opts$plotOptions$bar2 !== void 0 && _opts$plotOptions$bar2.columnWidth)) {\n          opts.plotOptions.bar.columnWidth = 2;\n        }\n\n        return opts;\n      }\n    }, {\n      key: \"area\",\n      value: function area() {\n        return {\n          stroke: {\n            width: 4,\n            fill: {\n              type: 'solid',\n              gradient: {\n                inverseColors: false,\n                shade: 'light',\n                type: 'vertical',\n                opacityFrom: 0.65,\n                opacityTo: 0.5,\n                stops: [0, 100, 100]\n              }\n            }\n          },\n          fill: {\n            type: 'gradient',\n            gradient: {\n              inverseColors: false,\n              shade: 'light',\n              type: 'vertical',\n              opacityFrom: 0.65,\n              opacityTo: 0.5,\n              stops: [0, 100, 100]\n            }\n          },\n          markers: {\n            size: 0,\n            hover: {\n              sizeOffset: 6\n            }\n          },\n          tooltip: {\n            followCursor: false\n          }\n        };\n      }\n    }, {\n      key: \"rangeArea\",\n      value: function rangeArea() {\n        var handleRangeAreaTooltip = function handleRangeAreaTooltip(opts) {\n          var _getRangeValues3 = getRangeValues(opts),\n              color = _getRangeValues3.color,\n              seriesName = _getRangeValues3.seriesName,\n              ylabel = _getRangeValues3.ylabel,\n              start = _getRangeValues3.start,\n              end = _getRangeValues3.end;\n\n          return buildRangeTooltipHTML(_objectSpread2(_objectSpread2({}, opts), {}, {\n            color: color,\n            seriesName: seriesName,\n            ylabel: ylabel,\n            start: start,\n            end: end\n          }));\n        };\n\n        return {\n          stroke: {\n            curve: 'straight',\n            width: 0\n          },\n          fill: {\n            type: 'solid',\n            opacity: 0.6\n          },\n          markers: {\n            size: 0\n          },\n          states: {\n            hover: {\n              filter: {\n                type: 'none'\n              }\n            },\n            active: {\n              filter: {\n                type: 'none'\n              }\n            }\n          },\n          tooltip: {\n            intersect: false,\n            shared: true,\n            followCursor: true,\n            custom: function custom(opts) {\n              return handleRangeAreaTooltip(opts);\n            }\n          }\n        };\n      }\n    }, {\n      key: \"brush\",\n      value: function brush(defaults) {\n        var ret = {\n          chart: {\n            toolbar: {\n              autoSelected: 'selection',\n              show: false\n            },\n            zoom: {\n              enabled: false\n            }\n          },\n          dataLabels: {\n            enabled: false\n          },\n          stroke: {\n            width: 1\n          },\n          tooltip: {\n            enabled: false\n          },\n          xaxis: {\n            tooltip: {\n              enabled: false\n            }\n          }\n        };\n        return Utils$1.extend(defaults, ret);\n      }\n    }, {\n      key: \"stacked100\",\n      value: function stacked100(opts) {\n        opts.dataLabels = opts.dataLabels || {};\n        opts.dataLabels.formatter = opts.dataLabels.formatter || undefined;\n        var existingDataLabelFormatter = opts.dataLabels.formatter;\n        opts.yaxis.forEach(function (yaxe, index) {\n          opts.yaxis[index].min = 0;\n          opts.yaxis[index].max = 100;\n        });\n        var isBar = opts.chart.type === 'bar';\n\n        if (isBar) {\n          opts.dataLabels.formatter = existingDataLabelFormatter || function (val) {\n            if (typeof val === 'number') {\n              return val ? val.toFixed(0) + '%' : val;\n            }\n\n            return val;\n          };\n        }\n\n        return opts;\n      }\n    }, {\n      key: \"stackedBars\",\n      value: function stackedBars() {\n        var barDefaults = this.bar();\n        return _objectSpread2(_objectSpread2({}, barDefaults), {}, {\n          plotOptions: _objectSpread2(_objectSpread2({}, barDefaults.plotOptions), {}, {\n            bar: _objectSpread2(_objectSpread2({}, barDefaults.plotOptions.bar), {}, {\n              borderRadiusApplication: 'end',\n              borderRadiusWhenStacked: 'last'\n            })\n          })\n        });\n      } // This function removes the left and right spacing in chart for line/area/scatter if xaxis type = category for those charts by converting xaxis = numeric. Numeric/Datetime xaxis prevents the unnecessary spacing in the left/right of the chart area\n\n    }, {\n      key: \"convertCatToNumeric\",\n      value: function convertCatToNumeric(opts) {\n        opts.xaxis.convertedCatToNumeric = true;\n        return opts;\n      }\n    }, {\n      key: \"convertCatToNumericXaxis\",\n      value: function convertCatToNumericXaxis(opts, ctx, cats) {\n        opts.xaxis.type = 'numeric';\n        opts.xaxis.labels = opts.xaxis.labels || {};\n\n        opts.xaxis.labels.formatter = opts.xaxis.labels.formatter || function (val) {\n          return Utils$1.isNumber(val) ? Math.floor(val) : val;\n        };\n\n        var defaultFormatter = opts.xaxis.labels.formatter;\n        var labels = opts.xaxis.categories && opts.xaxis.categories.length ? opts.xaxis.categories : opts.labels;\n\n        if (cats && cats.length) {\n          labels = cats.map(function (c) {\n            return Array.isArray(c) ? c : String(c);\n          });\n        }\n\n        if (labels && labels.length) {\n          opts.xaxis.labels.formatter = function (val) {\n            return Utils$1.isNumber(val) ? defaultFormatter(labels[Math.floor(val) - 1]) : defaultFormatter(val);\n          };\n        }\n\n        opts.xaxis.categories = [];\n        opts.labels = [];\n        opts.xaxis.tickAmount = opts.xaxis.tickAmount || 'dataPoints';\n        return opts;\n      }\n    }, {\n      key: \"bubble\",\n      value: function bubble() {\n        return {\n          dataLabels: {\n            style: {\n              colors: ['#fff']\n            }\n          },\n          tooltip: {\n            shared: false,\n            intersect: true\n          },\n          xaxis: {\n            crosshairs: {\n              width: 0\n            }\n          },\n          fill: {\n            type: 'solid',\n            gradient: {\n              shade: 'light',\n              inverse: true,\n              shadeIntensity: 0.55,\n              opacityFrom: 0.4,\n              opacityTo: 0.8\n            }\n          }\n        };\n      }\n    }, {\n      key: \"scatter\",\n      value: function scatter() {\n        return {\n          dataLabels: {\n            enabled: false\n          },\n          tooltip: {\n            shared: false,\n            intersect: true\n          },\n          markers: {\n            size: 6,\n            strokeWidth: 1,\n            hover: {\n              sizeOffset: 2\n            }\n          }\n        };\n      }\n    }, {\n      key: \"heatmap\",\n      value: function heatmap() {\n        return {\n          chart: {\n            stacked: false\n          },\n          fill: {\n            opacity: 1\n          },\n          dataLabels: {\n            style: {\n              colors: ['#fff']\n            }\n          },\n          stroke: {\n            colors: ['#fff']\n          },\n          tooltip: {\n            followCursor: true,\n            marker: {\n              show: false\n            },\n            x: {\n              show: false\n            }\n          },\n          legend: {\n            position: 'top',\n            markers: {\n              shape: 'square',\n              size: 10,\n              offsetY: 2\n            }\n          },\n          grid: {\n            padding: {\n              right: 20\n            }\n          }\n        };\n      }\n    }, {\n      key: \"treemap\",\n      value: function treemap() {\n        return {\n          chart: {\n            zoom: {\n              enabled: false\n            }\n          },\n          dataLabels: {\n            style: {\n              fontSize: 14,\n              fontWeight: 600,\n              colors: ['#fff']\n            }\n          },\n          stroke: {\n            show: true,\n            width: 2,\n            colors: ['#fff']\n          },\n          legend: {\n            show: false\n          },\n          fill: {\n            gradient: {\n              stops: [0, 100]\n            }\n          },\n          tooltip: {\n            followCursor: true,\n            x: {\n              show: false\n            }\n          },\n          grid: {\n            padding: {\n              left: 0,\n              right: 0\n            }\n          },\n          xaxis: {\n            crosshairs: {\n              show: false\n            },\n            tooltip: {\n              enabled: false\n            }\n          }\n        };\n      }\n    }, {\n      key: \"pie\",\n      value: function pie() {\n        return {\n          chart: {\n            toolbar: {\n              show: false\n            }\n          },\n          plotOptions: {\n            pie: {\n              donut: {\n                labels: {\n                  show: false\n                }\n              }\n            }\n          },\n          dataLabels: {\n            formatter: function formatter(val) {\n              return val.toFixed(1) + '%';\n            },\n            style: {\n              colors: ['#fff']\n            },\n            background: {\n              enabled: false\n            },\n            dropShadow: {\n              enabled: true\n            }\n          },\n          stroke: {\n            colors: ['#fff']\n          },\n          fill: {\n            opacity: 1,\n            gradient: {\n              shade: 'light',\n              stops: [0, 100]\n            }\n          },\n          tooltip: {\n            theme: 'dark',\n            fillSeriesColor: true\n          },\n          legend: {\n            position: 'right'\n          }\n        };\n      }\n    }, {\n      key: \"donut\",\n      value: function donut() {\n        return {\n          chart: {\n            toolbar: {\n              show: false\n            }\n          },\n          dataLabels: {\n            formatter: function formatter(val) {\n              return val.toFixed(1) + '%';\n            },\n            style: {\n              colors: ['#fff']\n            },\n            background: {\n              enabled: false\n            },\n            dropShadow: {\n              enabled: true\n            }\n          },\n          stroke: {\n            colors: ['#fff']\n          },\n          fill: {\n            opacity: 1,\n            gradient: {\n              shade: 'light',\n              shadeIntensity: 0.35,\n              stops: [80, 100],\n              opacityFrom: 1,\n              opacityTo: 1\n            }\n          },\n          tooltip: {\n            theme: 'dark',\n            fillSeriesColor: true\n          },\n          legend: {\n            position: 'right'\n          }\n        };\n      }\n    }, {\n      key: \"polarArea\",\n      value: function polarArea() {\n        this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6;\n        return {\n          chart: {\n            toolbar: {\n              show: false\n            }\n          },\n          dataLabels: {\n            formatter: function formatter(val) {\n              return val.toFixed(1) + '%';\n            },\n            enabled: false\n          },\n          stroke: {\n            show: true,\n            width: 2\n          },\n          fill: {\n            opacity: 0.7\n          },\n          tooltip: {\n            theme: 'dark',\n            fillSeriesColor: true\n          },\n          legend: {\n            position: 'right'\n          }\n        };\n      }\n    }, {\n      key: \"radar\",\n      value: function radar() {\n        this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6;\n        return {\n          dataLabels: {\n            enabled: false,\n            style: {\n              fontSize: '11px'\n            }\n          },\n          stroke: {\n            width: 2\n          },\n          markers: {\n            size: 3,\n            strokeWidth: 1,\n            strokeOpacity: 1\n          },\n          fill: {\n            opacity: 0.2\n          },\n          tooltip: {\n            shared: false,\n            intersect: true,\n            followCursor: true\n          },\n          grid: {\n            show: false\n          },\n          xaxis: {\n            labels: {\n              formatter: function formatter(val) {\n                return val;\n              },\n              style: {\n                colors: ['#a8a8a8'],\n                fontSize: '11px'\n              }\n            },\n            tooltip: {\n              enabled: false\n            },\n            crosshairs: {\n              show: false\n            }\n          }\n        };\n      }\n    }, {\n      key: \"radialBar\",\n      value: function radialBar() {\n        return {\n          chart: {\n            animations: {\n              dynamicAnimation: {\n                enabled: true,\n                speed: 800\n              }\n            },\n            toolbar: {\n              show: false\n            }\n          },\n          fill: {\n            gradient: {\n              shade: 'dark',\n              shadeIntensity: 0.4,\n              inverseColors: false,\n              type: 'diagonal2',\n              opacityFrom: 1,\n              opacityTo: 1,\n              stops: [70, 98, 100]\n            }\n          },\n          legend: {\n            show: false,\n            position: 'right'\n          },\n          tooltip: {\n            enabled: false,\n            fillSeriesColor: true\n          }\n        };\n      }\n    }, {\n      key: \"_getBoxTooltip\",\n      value: function _getBoxTooltip(w, seriesIndex, dataPointIndex, labels, chartType) {\n        var o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];\n        var h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];\n        var m = w.globals.seriesCandleM[seriesIndex][dataPointIndex];\n        var l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];\n        var c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];\n\n        if (w.config.series[seriesIndex].type && w.config.series[seriesIndex].type !== chartType) {\n          return \"<div class=\\\"apexcharts-custom-tooltip\\\">\\n          \".concat(w.config.series[seriesIndex].name ? w.config.series[seriesIndex].name : 'series-' + (seriesIndex + 1), \": <strong>\").concat(w.globals.series[seriesIndex][dataPointIndex], \"</strong>\\n        </div>\");\n        } else {\n          return \"<div class=\\\"apexcharts-tooltip-box apexcharts-tooltip-\".concat(w.config.chart.type, \"\\\">\") + \"<div>\".concat(labels[0], \": <span class=\\\"value\\\">\") + o + '</span></div>' + \"<div>\".concat(labels[1], \": <span class=\\\"value\\\">\") + h + '</span></div>' + (m ? \"<div>\".concat(labels[2], \": <span class=\\\"value\\\">\") + m + '</span></div>' : '') + \"<div>\".concat(labels[3], \": <span class=\\\"value\\\">\") + l + '</span></div>' + \"<div>\".concat(labels[4], \": <span class=\\\"value\\\">\") + c + '</span></div>' + '</div>';\n        }\n      }\n    }]);\n\n    return Defaults;\n  }();\n\n  /**\n   * ApexCharts Config Class for extending user options with pre-defined ApexCharts config.\n   *\n   * @module Config\n   **/\n\n  var Config = /*#__PURE__*/function () {\n    function Config(opts) {\n      _classCallCheck(this, Config);\n\n      this.opts = opts;\n    }\n\n    _createClass(Config, [{\n      key: \"init\",\n      value: function init(_ref) {\n        var responsiveOverride = _ref.responsiveOverride;\n        var opts = this.opts;\n        var options = new Options();\n        var defaults = new Defaults(opts);\n        this.chartType = opts.chart.type;\n        opts = this.extendYAxis(opts);\n        opts = this.extendAnnotations(opts);\n        var config = options.init();\n        var newDefaults = {};\n\n        if (opts && _typeof(opts) === 'object') {\n          var _opts$plotOptions, _opts$plotOptions$bar, _opts$chart$brush, _opts$plotOptions2, _opts$plotOptions2$ba, _opts, _opts$stroke, _opts$chart$sparkline, _window$Apex$chart, _window$Apex$chart$sp;\n\n          var chartDefaults = {};\n          var chartTypes = ['line', 'area', 'bar', 'candlestick', 'boxPlot', 'rangeBar', 'rangeArea', 'bubble', 'scatter', 'heatmap', 'treemap', 'pie', 'polarArea', 'donut', 'radar', 'radialBar'];\n\n          if (chartTypes.indexOf(opts.chart.type) !== -1) {\n            chartDefaults = defaults[opts.chart.type]();\n          } else {\n            chartDefaults = defaults.line();\n          }\n\n          if ((_opts$plotOptions = opts.plotOptions) !== null && _opts$plotOptions !== void 0 && (_opts$plotOptions$bar = _opts$plotOptions.bar) !== null && _opts$plotOptions$bar !== void 0 && _opts$plotOptions$bar.isFunnel) {\n            chartDefaults = defaults.funnel();\n          }\n\n          if (opts.chart.stacked && opts.chart.type === 'bar') {\n            chartDefaults = defaults.stackedBars();\n          }\n\n          if ((_opts$chart$brush = opts.chart.brush) !== null && _opts$chart$brush !== void 0 && _opts$chart$brush.enabled) {\n            chartDefaults = defaults.brush(chartDefaults);\n          }\n\n          if (opts.chart.stacked && opts.chart.stackType === '100%') {\n            opts = defaults.stacked100(opts);\n          }\n\n          if ((_opts$plotOptions2 = opts.plotOptions) !== null && _opts$plotOptions2 !== void 0 && (_opts$plotOptions2$ba = _opts$plotOptions2.bar) !== null && _opts$plotOptions2$ba !== void 0 && _opts$plotOptions2$ba.isDumbbell) {\n            opts = defaults.dumbbell(opts);\n          }\n\n          if (((_opts = opts) === null || _opts === void 0 ? void 0 : (_opts$stroke = _opts.stroke) === null || _opts$stroke === void 0 ? void 0 : _opts$stroke.curve) === 'monotoneCubic') {\n            opts.stroke.curve = 'smooth';\n          } // If user has specified a dark theme, make the tooltip dark too\n\n\n          this.checkForDarkTheme(window.Apex); // check global window Apex options\n\n          this.checkForDarkTheme(opts); // check locally passed options\n\n          opts.xaxis = opts.xaxis || window.Apex.xaxis || {}; // an important boolean needs to be set here\n          // otherwise all the charts will have this flag set to true window.Apex.xaxis is set globally\n\n          if (!responsiveOverride) {\n            opts.xaxis.convertedCatToNumeric = false;\n          }\n\n          opts = this.checkForCatToNumericXAxis(this.chartType, chartDefaults, opts);\n\n          if ((_opts$chart$sparkline = opts.chart.sparkline) !== null && _opts$chart$sparkline !== void 0 && _opts$chart$sparkline.enabled || (_window$Apex$chart = window.Apex.chart) !== null && _window$Apex$chart !== void 0 && (_window$Apex$chart$sp = _window$Apex$chart.sparkline) !== null && _window$Apex$chart$sp !== void 0 && _window$Apex$chart$sp.enabled) {\n            chartDefaults = defaults.sparkline(chartDefaults);\n          }\n\n          newDefaults = Utils$1.extend(config, chartDefaults);\n        } // config should cascade in this fashion\n        // default-config < global-apex-variable-config < user-defined-config\n        // get GLOBALLY defined options and merge with the default config\n\n\n        var mergedWithDefaultConfig = Utils$1.extend(newDefaults, window.Apex); // get the merged config and extend with user defined config\n\n        config = Utils$1.extend(mergedWithDefaultConfig, opts); // some features are not supported. those mismatches should be handled\n\n        config = this.handleUserInputErrors(config);\n        return config;\n      }\n    }, {\n      key: \"checkForCatToNumericXAxis\",\n      value: function checkForCatToNumericXAxis(chartType, chartDefaults, opts) {\n        var _opts$plotOptions3, _opts$plotOptions3$ba;\n\n        var defaults = new Defaults(opts);\n        var isBarHorizontal = (chartType === 'bar' || chartType === 'boxPlot') && ((_opts$plotOptions3 = opts.plotOptions) === null || _opts$plotOptions3 === void 0 ? void 0 : (_opts$plotOptions3$ba = _opts$plotOptions3.bar) === null || _opts$plotOptions3$ba === void 0 ? void 0 : _opts$plotOptions3$ba.horizontal);\n        var unsupportedZoom = chartType === 'pie' || chartType === 'polarArea' || chartType === 'donut' || chartType === 'radar' || chartType === 'radialBar' || chartType === 'heatmap';\n        var notNumericXAxis = opts.xaxis.type !== 'datetime' && opts.xaxis.type !== 'numeric';\n        var tickPlacement = opts.xaxis.tickPlacement ? opts.xaxis.tickPlacement : chartDefaults.xaxis && chartDefaults.xaxis.tickPlacement;\n\n        if (!isBarHorizontal && !unsupportedZoom && notNumericXAxis && tickPlacement !== 'between') {\n          opts = defaults.convertCatToNumeric(opts);\n        }\n\n        return opts;\n      }\n    }, {\n      key: \"extendYAxis\",\n      value: function extendYAxis(opts, w) {\n        var options = new Options();\n\n        if (typeof opts.yaxis === 'undefined' || !opts.yaxis || Array.isArray(opts.yaxis) && opts.yaxis.length === 0) {\n          opts.yaxis = {};\n        } // extend global yaxis config (only if object is provided / not an array)\n\n\n        if (opts.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array) {\n          opts.yaxis = Utils$1.extend(opts.yaxis, window.Apex.yaxis);\n        } // as we can't extend nested object's array with extend, we need to do it first\n        // user can provide either an array or object in yaxis config\n\n\n        if (opts.yaxis.constructor !== Array) {\n          // convert the yaxis to array if user supplied object\n          opts.yaxis = [Utils$1.extend(options.yAxis, opts.yaxis)];\n        } else {\n          opts.yaxis = Utils$1.extendArray(opts.yaxis, options.yAxis);\n        }\n\n        var isLogY = false;\n        opts.yaxis.forEach(function (y) {\n          if (y.logarithmic) {\n            isLogY = true;\n          }\n        });\n        var series = opts.series;\n\n        if (w && !series) {\n          series = w.config.series;\n        } // A logarithmic chart works correctly when each series has a corresponding y-axis\n        // If this is not the case, we manually create yaxis for multi-series log chart\n\n\n        if (isLogY && series.length !== opts.yaxis.length && series.length) {\n          opts.yaxis = series.map(function (s, i) {\n            if (!s.name) {\n              series[i].name = \"series-\".concat(i + 1);\n            }\n\n            if (opts.yaxis[i]) {\n              opts.yaxis[i].seriesName = series[i].name;\n              return opts.yaxis[i];\n            } else {\n              var newYaxis = Utils$1.extend(options.yAxis, opts.yaxis[0]);\n              newYaxis.show = false;\n              return newYaxis;\n            }\n          });\n        }\n\n        if (isLogY && series.length > 1 && series.length !== opts.yaxis.length) {\n          console.warn('A multi-series logarithmic chart should have equal number of series and y-axes');\n        }\n\n        return opts;\n      } // annotations also accepts array, so we need to extend them manually\n\n    }, {\n      key: \"extendAnnotations\",\n      value: function extendAnnotations(opts) {\n        if (typeof opts.annotations === 'undefined') {\n          opts.annotations = {};\n          opts.annotations.yaxis = [];\n          opts.annotations.xaxis = [];\n          opts.annotations.points = [];\n        }\n\n        opts = this.extendYAxisAnnotations(opts);\n        opts = this.extendXAxisAnnotations(opts);\n        opts = this.extendPointAnnotations(opts);\n        return opts;\n      }\n    }, {\n      key: \"extendYAxisAnnotations\",\n      value: function extendYAxisAnnotations(opts) {\n        var options = new Options();\n        opts.annotations.yaxis = Utils$1.extendArray(typeof opts.annotations.yaxis !== 'undefined' ? opts.annotations.yaxis : [], options.yAxisAnnotation);\n        return opts;\n      }\n    }, {\n      key: \"extendXAxisAnnotations\",\n      value: function extendXAxisAnnotations(opts) {\n        var options = new Options();\n        opts.annotations.xaxis = Utils$1.extendArray(typeof opts.annotations.xaxis !== 'undefined' ? opts.annotations.xaxis : [], options.xAxisAnnotation);\n        return opts;\n      }\n    }, {\n      key: \"extendPointAnnotations\",\n      value: function extendPointAnnotations(opts) {\n        var options = new Options();\n        opts.annotations.points = Utils$1.extendArray(typeof opts.annotations.points !== 'undefined' ? opts.annotations.points : [], options.pointAnnotation);\n        return opts;\n      }\n    }, {\n      key: \"checkForDarkTheme\",\n      value: function checkForDarkTheme(opts) {\n        if (opts.theme && opts.theme.mode === 'dark') {\n          if (!opts.tooltip) {\n            opts.tooltip = {};\n          }\n\n          if (opts.tooltip.theme !== 'light') {\n            opts.tooltip.theme = 'dark';\n          }\n\n          if (!opts.chart.foreColor) {\n            opts.chart.foreColor = '#f6f7f8';\n          }\n\n          if (!opts.chart.background) {\n            opts.chart.background = '#424242';\n          }\n\n          if (!opts.theme.palette) {\n            opts.theme.palette = 'palette4';\n          }\n        }\n      }\n    }, {\n      key: \"handleUserInputErrors\",\n      value: function handleUserInputErrors(opts) {\n        var config = opts; // conflicting tooltip option. intersect makes sure to focus on 1 point at a time. Shared cannot be used along with it\n\n        if (config.tooltip.shared && config.tooltip.intersect) {\n          throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.');\n        }\n\n        if (config.chart.type === 'bar' && config.plotOptions.bar.horizontal) {\n          // No multiple yaxis for bars\n          if (config.yaxis.length > 1) {\n            throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false');\n          } // if yaxis is reversed in horizontal bar chart, you should draw the y-axis on right side\n\n\n          if (config.yaxis[0].reversed) {\n            config.yaxis[0].opposite = true;\n          }\n\n          config.xaxis.tooltip.enabled = false; // no xaxis tooltip for horizontal bar\n\n          config.yaxis[0].tooltip.enabled = false; // no xaxis tooltip for horizontal bar\n\n          config.chart.zoom.enabled = false; // no zooming for horz bars\n        }\n\n        if (config.chart.type === 'bar' || config.chart.type === 'rangeBar') {\n          if (config.tooltip.shared) {\n            if (config.xaxis.crosshairs.width === 'barWidth' && config.series.length > 1) {\n              config.xaxis.crosshairs.width = 'tickWidth';\n            }\n          }\n        }\n\n        if (config.chart.type === 'candlestick' || config.chart.type === 'boxPlot') {\n          if (config.yaxis[0].reversed) {\n            console.warn(\"Reversed y-axis in \".concat(config.chart.type, \" chart is not supported.\"));\n            config.yaxis[0].reversed = false;\n          }\n        }\n\n        return config;\n      }\n    }]);\n\n    return Config;\n  }();\n\n  var Globals = /*#__PURE__*/function () {\n    function Globals() {\n      _classCallCheck(this, Globals);\n    }\n\n    _createClass(Globals, [{\n      key: \"initGlobalVars\",\n      value: function initGlobalVars(gl) {\n        gl.series = []; // the MAIN series array (y values)\n\n        gl.seriesCandleO = [];\n        gl.seriesCandleH = [];\n        gl.seriesCandleM = [];\n        gl.seriesCandleL = [];\n        gl.seriesCandleC = [];\n        gl.seriesRangeStart = [];\n        gl.seriesRangeEnd = [];\n        gl.seriesRange = [];\n        gl.seriesPercent = [];\n        gl.seriesGoals = [];\n        gl.seriesX = [];\n        gl.seriesZ = [];\n        gl.seriesNames = [];\n        gl.seriesTotals = [];\n        gl.seriesLog = [];\n        gl.seriesColors = [];\n        gl.stackedSeriesTotals = [];\n        gl.seriesXvalues = []; // we will need this in tooltip (it's x position)\n        // when we will have unequal x values, we will need\n        // some way to get x value depending on mouse pointer\n\n        gl.seriesYvalues = []; // we will need this when deciding which series\n        // user hovered on\n\n        gl.labels = [];\n        gl.hasXaxisGroups = false;\n        gl.groups = [];\n        gl.hasSeriesGroups = false;\n        gl.seriesGroups = [];\n        gl.categoryLabels = [];\n        gl.timescaleLabels = [];\n        gl.noLabelsProvided = false;\n        gl.resizeTimer = null;\n        gl.selectionResizeTimer = null;\n        gl.delayedElements = [];\n        gl.pointsArray = [];\n        gl.dataLabelsRects = [];\n        gl.isXNumeric = false;\n        gl.skipLastTimelinelabel = false;\n        gl.skipFirstTimelinelabel = false;\n        gl.isDataXYZ = false;\n        gl.isMultiLineX = false;\n        gl.isMultipleYAxis = false;\n        gl.maxY = -Number.MAX_VALUE;\n        gl.minY = Number.MIN_VALUE;\n        gl.minYArr = [];\n        gl.maxYArr = [];\n        gl.maxX = -Number.MAX_VALUE;\n        gl.minX = Number.MAX_VALUE;\n        gl.initialMaxX = -Number.MAX_VALUE;\n        gl.initialMinX = Number.MAX_VALUE;\n        gl.maxDate = 0;\n        gl.minDate = Number.MAX_VALUE;\n        gl.minZ = Number.MAX_VALUE;\n        gl.maxZ = -Number.MAX_VALUE;\n        gl.minXDiff = Number.MAX_VALUE;\n        gl.yAxisScale = [];\n        gl.xAxisScale = null;\n        gl.xAxisTicksPositions = [];\n        gl.yLabelsCoords = [];\n        gl.yTitleCoords = [];\n        gl.barPadForNumericAxis = 0;\n        gl.padHorizontal = 0;\n        gl.xRange = 0;\n        gl.yRange = [];\n        gl.zRange = 0;\n        gl.dataPoints = 0;\n        gl.xTickAmount = 0;\n      }\n    }, {\n      key: \"globalVars\",\n      value: function globalVars(config) {\n        return {\n          chartID: null,\n          // chart ID - apexcharts-cuid\n          cuid: null,\n          // chart ID - random numbers excluding \"apexcharts\" part\n          events: {\n            beforeMount: [],\n            mounted: [],\n            updated: [],\n            clicked: [],\n            selection: [],\n            dataPointSelection: [],\n            zoomed: [],\n            scrolled: []\n          },\n          colors: [],\n          clientX: null,\n          clientY: null,\n          fill: {\n            colors: []\n          },\n          stroke: {\n            colors: []\n          },\n          dataLabels: {\n            style: {\n              colors: []\n            }\n          },\n          radarPolygons: {\n            fill: {\n              colors: []\n            }\n          },\n          markers: {\n            colors: [],\n            size: config.markers.size,\n            largestSize: 0\n          },\n          animationEnded: false,\n          isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,\n          isDirty: false,\n          // chart has been updated after the initial render. This is different than dataChanged property. isDirty means user manually called some method to update\n          isExecCalled: false,\n          // whether user updated the chart through the exec method\n          initialConfig: null,\n          // we will store the first config user has set to go back when user finishes interactions like zooming and come out of it\n          initialSeries: [],\n          lastXAxis: [],\n          lastYAxis: [],\n          columnSeries: null,\n          labels: [],\n          // store the text to draw on x axis\n          // Don't mutate the labels, many things including tooltips depends on it!\n          timescaleLabels: [],\n          // store the timescaleLabels Labels in another variable\n          noLabelsProvided: false,\n          // if user didn't provide any categories/labels or x values, fallback to 1,2,3,4...\n          allSeriesCollapsed: false,\n          collapsedSeries: [],\n          // when user collapses a series, it goes into this array\n          collapsedSeriesIndices: [],\n          // this stores the index of the collapsedSeries instead of whole object for quick access\n          ancillaryCollapsedSeries: [],\n          // when user collapses an \"alwaysVisible\" series, it goes into this array\n          ancillaryCollapsedSeriesIndices: [],\n          // this stores the index of the ancillaryCollapsedSeries whose y-axis is always visible\n          risingSeries: [],\n          // when user re-opens a collapsed series, it goes here\n          dataFormatXNumeric: false,\n          // boolean value to indicate user has passed numeric x values\n          capturedSeriesIndex: -1,\n          capturedDataPointIndex: -1,\n          selectedDataPoints: [],\n          goldenPadding: 35,\n          // this value is used at a lot of places for spacing purpose\n          invalidLogScale: false,\n          // if a user enabled log scale but the data provided is not valid to generate a log scale, turn on this flag\n          ignoreYAxisIndexes: [],\n          // when series are being collapsed in multiple y axes, ignore certain index\n          yAxisSameScaleIndices: [],\n          maxValsInArrayIndex: 0,\n          radialSize: 0,\n          selection: undefined,\n          zoomEnabled: config.chart.toolbar.autoSelected === 'zoom' && config.chart.toolbar.tools.zoom && config.chart.zoom.enabled,\n          panEnabled: config.chart.toolbar.autoSelected === 'pan' && config.chart.toolbar.tools.pan,\n          selectionEnabled: config.chart.toolbar.autoSelected === 'selection' && config.chart.toolbar.tools.selection,\n          yaxis: null,\n          mousedown: false,\n          lastClientPosition: {},\n          // don't reset this variable this the chart is destroyed. It is used to detect right or left mousemove in panning\n          visibleXRange: undefined,\n          yValueDecimal: 0,\n          // are there floating numbers in the series. If yes, this represent the len of the decimals\n          total: 0,\n          SVGNS: 'http://www.w3.org/2000/svg',\n          // svg namespace\n          svgWidth: 0,\n          // the whole svg width\n          svgHeight: 0,\n          // the whole svg height\n          noData: false,\n          // whether there is any data to display or not\n          locale: {},\n          // the current locale values will be preserved here for global access\n          dom: {},\n          // for storing all dom nodes in this particular property\n          memory: {\n            methodsToExec: []\n          },\n          shouldAnimate: true,\n          skipLastTimelinelabel: false,\n          // when last label is cropped, skip drawing it\n          skipFirstTimelinelabel: false,\n          // when first label is cropped, skip drawing it\n          delayedElements: [],\n          // element which appear after animation has finished\n          axisCharts: true,\n          // chart type = line or area or bar\n          // (refer them also as plot charts in the code)\n          isDataXYZ: false,\n          // bool: data was provided in a {[x,y,z]} pattern\n          resized: false,\n          // bool: user has resized\n          resizeTimer: null,\n          // timeout function to make a small delay before\n          // drawing when user resized\n          comboCharts: false,\n          // bool: whether it's a combination of line/column\n          dataChanged: false,\n          // bool: has data changed dynamically\n          previousPaths: [],\n          // array: when data is changed, it will animate from\n          // previous paths\n          allSeriesHasEqualX: true,\n          pointsArray: [],\n          // store the points positions here to draw later on hover\n          // format is - [[x,y],[x,y]... [x,y]]\n          dataLabelsRects: [],\n          // store the positions of datalabels to prevent collision\n          lastDrawnDataLabelsIndexes: [],\n          hasNullValues: false,\n          // bool: whether series contains null values\n          easing: null,\n          // function: animation effect to apply\n          zoomed: false,\n          // whether user has zoomed or not\n          gridWidth: 0,\n          // drawable width of actual graphs (series paths)\n          gridHeight: 0,\n          // drawable height of actual graphs (series paths)\n          rotateXLabels: false,\n          defaultLabels: false,\n          xLabelFormatter: undefined,\n          // formatter for x axis labels\n          yLabelFormatters: [],\n          xaxisTooltipFormatter: undefined,\n          // formatter for x axis tooltip\n          ttKeyFormatter: undefined,\n          ttVal: undefined,\n          ttZFormatter: undefined,\n          LINE_HEIGHT_RATIO: 1.618,\n          xAxisLabelsHeight: 0,\n          xAxisGroupLabelsHeight: 0,\n          xAxisLabelsWidth: 0,\n          yAxisLabelsWidth: 0,\n          scaleX: 1,\n          scaleY: 1,\n          translateX: 0,\n          translateY: 0,\n          translateYAxisX: [],\n          yAxisWidths: [],\n          translateXAxisY: 0,\n          translateXAxisX: 0,\n          tooltip: null\n        };\n      }\n    }, {\n      key: \"init\",\n      value: function init(config) {\n        var globals = this.globalVars(config);\n        this.initGlobalVars(globals);\n        globals.initialConfig = Utils$1.extend({}, config);\n        globals.initialSeries = Utils$1.clone(config.series);\n        globals.lastXAxis = Utils$1.clone(globals.initialConfig.xaxis);\n        globals.lastYAxis = Utils$1.clone(globals.initialConfig.yaxis);\n        return globals;\n      }\n    }]);\n\n    return Globals;\n  }();\n\n  /**\n   * ApexCharts Base Class for extending user options with pre-defined ApexCharts config.\n   *\n   * @module Base\n   **/\n\n  var Base = /*#__PURE__*/function () {\n    function Base(opts) {\n      _classCallCheck(this, Base);\n\n      this.opts = opts;\n    }\n\n    _createClass(Base, [{\n      key: \"init\",\n      value: function init() {\n        var config = new Config(this.opts).init({\n          responsiveOverride: false\n        });\n        var globals = new Globals().init(config);\n        var w = {\n          config: config,\n          globals: globals\n        };\n        return w;\n      }\n    }]);\n\n    return Base;\n  }();\n\n  /**\n   * ApexCharts Fill Class for setting fill options of the paths.\n   *\n   * @module Fill\n   **/\n\n  var Fill = /*#__PURE__*/function () {\n    function Fill(ctx) {\n      _classCallCheck(this, Fill);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.opts = null;\n      this.seriesIndex = 0;\n    }\n\n    _createClass(Fill, [{\n      key: \"clippedImgArea\",\n      value: function clippedImgArea(params) {\n        var w = this.w;\n        var cnf = w.config;\n        var svgW = parseInt(w.globals.gridWidth, 10);\n        var svgH = parseInt(w.globals.gridHeight, 10);\n        var size = svgW > svgH ? svgW : svgH;\n        var fillImg = params.image;\n        var imgWidth = 0;\n        var imgHeight = 0;\n\n        if (typeof params.width === 'undefined' && typeof params.height === 'undefined') {\n          if (cnf.fill.image.width !== undefined && cnf.fill.image.height !== undefined) {\n            imgWidth = cnf.fill.image.width + 1;\n            imgHeight = cnf.fill.image.height;\n          } else {\n            imgWidth = size + 1;\n            imgHeight = size;\n          }\n        } else {\n          imgWidth = params.width;\n          imgHeight = params.height;\n        }\n\n        var elPattern = document.createElementNS(w.globals.SVGNS, 'pattern');\n        Graphics.setAttrs(elPattern, {\n          id: params.patternID,\n          patternUnits: params.patternUnits ? params.patternUnits : 'userSpaceOnUse',\n          width: imgWidth + 'px',\n          height: imgHeight + 'px'\n        });\n        var elImage = document.createElementNS(w.globals.SVGNS, 'image');\n        elPattern.appendChild(elImage);\n        elImage.setAttributeNS(window.SVG.xlink, 'href', fillImg);\n        Graphics.setAttrs(elImage, {\n          x: 0,\n          y: 0,\n          preserveAspectRatio: 'none',\n          width: imgWidth + 'px',\n          height: imgHeight + 'px'\n        });\n        elImage.style.opacity = params.opacity;\n        w.globals.dom.elDefs.node.appendChild(elPattern);\n      }\n    }, {\n      key: \"getSeriesIndex\",\n      value: function getSeriesIndex(opts) {\n        var w = this.w;\n        var cType = w.config.chart.type;\n\n        if ((cType === 'bar' || cType === 'rangeBar') && w.config.plotOptions.bar.distributed || cType === 'heatmap' || cType === 'treemap') {\n          this.seriesIndex = opts.seriesNumber;\n        } else {\n          this.seriesIndex = opts.seriesNumber % w.globals.series.length;\n        }\n\n        return this.seriesIndex;\n      }\n    }, {\n      key: \"fillPath\",\n      value: function fillPath(opts) {\n        var w = this.w;\n        this.opts = opts;\n        var cnf = this.w.config;\n        var pathFill;\n        var patternFill, gradientFill;\n        this.seriesIndex = this.getSeriesIndex(opts);\n        var fillColors = this.getFillColors();\n        var fillColor = fillColors[this.seriesIndex]; //override fillcolor if user inputted color with data\n\n        if (w.globals.seriesColors[this.seriesIndex] !== undefined) {\n          fillColor = w.globals.seriesColors[this.seriesIndex];\n        }\n\n        if (typeof fillColor === 'function') {\n          fillColor = fillColor({\n            seriesIndex: this.seriesIndex,\n            dataPointIndex: opts.dataPointIndex,\n            value: opts.value,\n            w: w\n          });\n        }\n\n        var fillType = opts.fillType ? opts.fillType : this.getFillType(this.seriesIndex);\n        var fillOpacity = Array.isArray(cnf.fill.opacity) ? cnf.fill.opacity[this.seriesIndex] : cnf.fill.opacity;\n\n        if (opts.color) {\n          fillColor = opts.color;\n        } // in case a color is undefined, fallback to white color to prevent runtime error\n\n\n        if (!fillColor) {\n          fillColor = '#fff';\n          console.warn('undefined color - ApexCharts');\n        }\n\n        var defaultColor = fillColor;\n\n        if (fillColor.indexOf('rgb') === -1) {\n          if (fillColor.length < 9) {\n            // if the hex contains alpha and is of 9 digit, skip the opacity\n            defaultColor = Utils$1.hexToRgba(fillColor, fillOpacity);\n          }\n        } else {\n          if (fillColor.indexOf('rgba') > -1) {\n            fillOpacity = Utils$1.getOpacityFromRGBA(fillColor);\n          }\n        }\n\n        if (opts.opacity) fillOpacity = opts.opacity;\n\n        if (fillType === 'pattern') {\n          patternFill = this.handlePatternFill({\n            fillConfig: opts.fillConfig,\n            patternFill: patternFill,\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n            defaultColor: defaultColor\n          });\n        }\n\n        if (fillType === 'gradient') {\n          gradientFill = this.handleGradientFill({\n            fillConfig: opts.fillConfig,\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n            i: this.seriesIndex\n          });\n        }\n\n        if (fillType === 'image') {\n          var imgSrc = cnf.fill.image.src;\n          var patternID = opts.patternID ? opts.patternID : '';\n          this.clippedImgArea({\n            opacity: fillOpacity,\n            image: Array.isArray(imgSrc) ? opts.seriesNumber < imgSrc.length ? imgSrc[opts.seriesNumber] : imgSrc[0] : imgSrc,\n            width: opts.width ? opts.width : undefined,\n            height: opts.height ? opts.height : undefined,\n            patternUnits: opts.patternUnits,\n            patternID: \"pattern\".concat(w.globals.cuid).concat(opts.seriesNumber + 1).concat(patternID)\n          });\n          pathFill = \"url(#pattern\".concat(w.globals.cuid).concat(opts.seriesNumber + 1).concat(patternID, \")\");\n        } else if (fillType === 'gradient') {\n          pathFill = gradientFill;\n        } else if (fillType === 'pattern') {\n          pathFill = patternFill;\n        } else {\n          pathFill = defaultColor;\n        } // override pattern/gradient if opts.solid is true\n\n\n        if (opts.solid) {\n          pathFill = defaultColor;\n        }\n\n        return pathFill;\n      }\n    }, {\n      key: \"getFillType\",\n      value: function getFillType(seriesIndex) {\n        var w = this.w;\n\n        if (Array.isArray(w.config.fill.type)) {\n          return w.config.fill.type[seriesIndex];\n        } else {\n          return w.config.fill.type;\n        }\n      }\n    }, {\n      key: \"getFillColors\",\n      value: function getFillColors() {\n        var w = this.w;\n        var cnf = w.config;\n        var opts = this.opts;\n        var fillColors = [];\n\n        if (w.globals.comboCharts) {\n          if (w.config.series[this.seriesIndex].type === 'line') {\n            if (Array.isArray(w.globals.stroke.colors)) {\n              fillColors = w.globals.stroke.colors;\n            } else {\n              fillColors.push(w.globals.stroke.colors);\n            }\n          } else {\n            if (Array.isArray(w.globals.fill.colors)) {\n              fillColors = w.globals.fill.colors;\n            } else {\n              fillColors.push(w.globals.fill.colors);\n            }\n          }\n        } else {\n          if (cnf.chart.type === 'line') {\n            if (Array.isArray(w.globals.stroke.colors)) {\n              fillColors = w.globals.stroke.colors;\n            } else {\n              fillColors.push(w.globals.stroke.colors);\n            }\n          } else {\n            if (Array.isArray(w.globals.fill.colors)) {\n              fillColors = w.globals.fill.colors;\n            } else {\n              fillColors.push(w.globals.fill.colors);\n            }\n          }\n        } // colors passed in arguments\n\n\n        if (typeof opts.fillColors !== 'undefined') {\n          fillColors = [];\n\n          if (Array.isArray(opts.fillColors)) {\n            fillColors = opts.fillColors.slice();\n          } else {\n            fillColors.push(opts.fillColors);\n          }\n        }\n\n        return fillColors;\n      }\n    }, {\n      key: \"handlePatternFill\",\n      value: function handlePatternFill(_ref) {\n        var fillConfig = _ref.fillConfig,\n            patternFill = _ref.patternFill,\n            fillColor = _ref.fillColor,\n            fillOpacity = _ref.fillOpacity,\n            defaultColor = _ref.defaultColor;\n        var fillCnf = this.w.config.fill;\n\n        if (fillConfig) {\n          fillCnf = fillConfig;\n        }\n\n        var opts = this.opts;\n        var graphics = new Graphics(this.ctx);\n        var patternStrokeWidth = Array.isArray(fillCnf.pattern.strokeWidth) ? fillCnf.pattern.strokeWidth[this.seriesIndex] : fillCnf.pattern.strokeWidth;\n        var patternLineColor = fillColor;\n\n        if (Array.isArray(fillCnf.pattern.style)) {\n          if (typeof fillCnf.pattern.style[opts.seriesNumber] !== 'undefined') {\n            var pf = graphics.drawPattern(fillCnf.pattern.style[opts.seriesNumber], fillCnf.pattern.width, fillCnf.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);\n            patternFill = pf;\n          } else {\n            patternFill = defaultColor;\n          }\n        } else {\n          patternFill = graphics.drawPattern(fillCnf.pattern.style, fillCnf.pattern.width, fillCnf.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);\n        }\n\n        return patternFill;\n      }\n    }, {\n      key: \"handleGradientFill\",\n      value: function handleGradientFill(_ref2) {\n        var fillColor = _ref2.fillColor,\n            fillOpacity = _ref2.fillOpacity,\n            fillConfig = _ref2.fillConfig,\n            i = _ref2.i;\n        var fillCnf = this.w.config.fill;\n\n        if (fillConfig) {\n          fillCnf = _objectSpread2(_objectSpread2({}, fillCnf), fillConfig);\n        }\n\n        var opts = this.opts;\n        var graphics = new Graphics(this.ctx);\n        var utils = new Utils$1();\n        var type = fillCnf.gradient.type;\n        var gradientFrom = fillColor;\n        var gradientTo;\n        var opacityFrom = fillCnf.gradient.opacityFrom === undefined ? fillOpacity : Array.isArray(fillCnf.gradient.opacityFrom) ? fillCnf.gradient.opacityFrom[i] : fillCnf.gradient.opacityFrom;\n\n        if (gradientFrom.indexOf('rgba') > -1) {\n          opacityFrom = Utils$1.getOpacityFromRGBA(gradientFrom);\n        }\n\n        var opacityTo = fillCnf.gradient.opacityTo === undefined ? fillOpacity : Array.isArray(fillCnf.gradient.opacityTo) ? fillCnf.gradient.opacityTo[i] : fillCnf.gradient.opacityTo;\n\n        if (fillCnf.gradient.gradientToColors === undefined || fillCnf.gradient.gradientToColors.length === 0) {\n          if (fillCnf.gradient.shade === 'dark') {\n            gradientTo = utils.shadeColor(parseFloat(fillCnf.gradient.shadeIntensity) * -1, fillColor.indexOf('rgb') > -1 ? Utils$1.rgb2hex(fillColor) : fillColor);\n          } else {\n            gradientTo = utils.shadeColor(parseFloat(fillCnf.gradient.shadeIntensity), fillColor.indexOf('rgb') > -1 ? Utils$1.rgb2hex(fillColor) : fillColor);\n          }\n        } else {\n          if (fillCnf.gradient.gradientToColors[opts.seriesNumber]) {\n            var gToColor = fillCnf.gradient.gradientToColors[opts.seriesNumber];\n            gradientTo = gToColor;\n\n            if (gToColor.indexOf('rgba') > -1) {\n              opacityTo = Utils$1.getOpacityFromRGBA(gToColor);\n            }\n          } else {\n            gradientTo = fillColor;\n          }\n        }\n\n        if (fillCnf.gradient.gradientFrom) {\n          gradientFrom = fillCnf.gradient.gradientFrom;\n        }\n\n        if (fillCnf.gradient.gradientTo) {\n          gradientTo = fillCnf.gradient.gradientTo;\n        }\n\n        if (fillCnf.gradient.inverseColors) {\n          var t = gradientFrom;\n          gradientFrom = gradientTo;\n          gradientTo = t;\n        }\n\n        if (gradientFrom.indexOf('rgb') > -1) {\n          gradientFrom = Utils$1.rgb2hex(gradientFrom);\n        }\n\n        if (gradientTo.indexOf('rgb') > -1) {\n          gradientTo = Utils$1.rgb2hex(gradientTo);\n        }\n\n        return graphics.drawGradient(type, gradientFrom, gradientTo, opacityFrom, opacityTo, opts.size, fillCnf.gradient.stops, fillCnf.gradient.colorStops, i);\n      }\n    }]);\n\n    return Fill;\n  }();\n\n  /**\n   * ApexCharts Markers Class for drawing points on y values in axes charts.\n   *\n   * @module Markers\n   **/\n\n  var Markers = /*#__PURE__*/function () {\n    function Markers(ctx, opts) {\n      _classCallCheck(this, Markers);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(Markers, [{\n      key: \"setGlobalMarkerSize\",\n      value: function setGlobalMarkerSize() {\n        var w = this.w;\n        w.globals.markers.size = Array.isArray(w.config.markers.size) ? w.config.markers.size : [w.config.markers.size];\n\n        if (w.globals.markers.size.length > 0) {\n          if (w.globals.markers.size.length < w.globals.series.length + 1) {\n            for (var i = 0; i <= w.globals.series.length; i++) {\n              if (typeof w.globals.markers.size[i] === 'undefined') {\n                w.globals.markers.size.push(w.globals.markers.size[0]);\n              }\n            }\n          }\n        } else {\n          w.globals.markers.size = w.config.series.map(function (s) {\n            return w.config.markers.size;\n          });\n        }\n      }\n    }, {\n      key: \"plotChartMarkers\",\n      value: function plotChartMarkers(pointsPos, seriesIndex, j, pSize) {\n        var alwaysDrawMarker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n        var w = this.w;\n        var i = seriesIndex;\n        var p = pointsPos;\n        var elPointsWrap = null;\n        var graphics = new Graphics(this.ctx);\n        var point;\n        var hasDiscreteMarkers = w.config.markers.discrete && w.config.markers.discrete.length;\n\n        if (w.globals.markers.size[seriesIndex] > 0 || alwaysDrawMarker || hasDiscreteMarkers) {\n          elPointsWrap = graphics.group({\n            class: alwaysDrawMarker || hasDiscreteMarkers ? '' : 'apexcharts-series-markers'\n          });\n          elPointsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n        }\n\n        if (Array.isArray(p.x)) {\n          for (var q = 0; q < p.x.length; q++) {\n            var dataPointIndex = j; // a small hack as we have 2 points for the first val to connect it\n\n            if (j === 1 && q === 0) dataPointIndex = 0;\n            if (j === 1 && q === 1) dataPointIndex = 1;\n            var PointClasses = 'apexcharts-marker';\n\n            if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {\n              PointClasses += ' no-pointer-events';\n            }\n\n            var shouldMarkerDraw = Array.isArray(w.config.markers.size) ? w.globals.markers.size[seriesIndex] > 0 : w.config.markers.size > 0;\n\n            if (shouldMarkerDraw || alwaysDrawMarker || hasDiscreteMarkers) {\n              if (Utils$1.isNumber(p.y[q])) {\n                PointClasses += \" w\".concat(Utils$1.randomId());\n              } else {\n                PointClasses = 'apexcharts-nullpoint';\n              }\n\n              var opts = this.getMarkerConfig({\n                cssClass: PointClasses,\n                seriesIndex: seriesIndex,\n                dataPointIndex: dataPointIndex\n              });\n\n              if (w.config.series[i].data[dataPointIndex]) {\n                if (w.config.series[i].data[dataPointIndex].fillColor) {\n                  opts.pointFillColor = w.config.series[i].data[dataPointIndex].fillColor;\n                }\n\n                if (w.config.series[i].data[dataPointIndex].strokeColor) {\n                  opts.pointStrokeColor = w.config.series[i].data[dataPointIndex].strokeColor;\n                }\n              }\n\n              if (pSize) {\n                opts.pSize = pSize;\n              }\n\n              if (p.x[q] < 0 || p.x[q] > w.globals.gridWidth || p.y[q] < 0 || p.y[q] > w.globals.gridHeight) {\n                opts.pSize = 0;\n              }\n\n              point = graphics.drawMarker(p.x[q], p.y[q], opts);\n              point.attr('rel', dataPointIndex);\n              point.attr('j', dataPointIndex);\n              point.attr('index', seriesIndex);\n              point.node.setAttribute('default-marker-size', opts.pSize);\n              var filters = new Filters(this.ctx);\n              filters.setSelectionFilter(point, seriesIndex, dataPointIndex);\n              this.addEvents(point);\n\n              if (elPointsWrap) {\n                elPointsWrap.add(point);\n              }\n            } else {\n              // dynamic array creation - multidimensional\n              if (typeof w.globals.pointsArray[seriesIndex] === 'undefined') w.globals.pointsArray[seriesIndex] = [];\n              w.globals.pointsArray[seriesIndex].push([p.x[q], p.y[q]]);\n            }\n          }\n        }\n\n        return elPointsWrap;\n      }\n    }, {\n      key: \"getMarkerConfig\",\n      value: function getMarkerConfig(_ref) {\n        var cssClass = _ref.cssClass,\n            seriesIndex = _ref.seriesIndex,\n            _ref$dataPointIndex = _ref.dataPointIndex,\n            dataPointIndex = _ref$dataPointIndex === void 0 ? null : _ref$dataPointIndex,\n            _ref$finishRadius = _ref.finishRadius,\n            finishRadius = _ref$finishRadius === void 0 ? null : _ref$finishRadius;\n        var w = this.w;\n        var pStyle = this.getMarkerStyle(seriesIndex);\n        var pSize = w.globals.markers.size[seriesIndex];\n        var m = w.config.markers; // discrete markers is an option where user can specify a particular marker with different shape, size and color\n\n        if (dataPointIndex !== null && m.discrete.length) {\n          m.discrete.map(function (marker) {\n            if (marker.seriesIndex === seriesIndex && marker.dataPointIndex === dataPointIndex) {\n              pStyle.pointStrokeColor = marker.strokeColor;\n              pStyle.pointFillColor = marker.fillColor;\n              pSize = marker.size;\n              pStyle.pointShape = marker.shape;\n            }\n          });\n        }\n\n        return {\n          pSize: finishRadius === null ? pSize : finishRadius,\n          pRadius: m.radius,\n          width: Array.isArray(m.width) ? m.width[seriesIndex] : m.width,\n          height: Array.isArray(m.height) ? m.height[seriesIndex] : m.height,\n          pointStrokeWidth: Array.isArray(m.strokeWidth) ? m.strokeWidth[seriesIndex] : m.strokeWidth,\n          pointStrokeColor: pStyle.pointStrokeColor,\n          pointFillColor: pStyle.pointFillColor,\n          shape: pStyle.pointShape || (Array.isArray(m.shape) ? m.shape[seriesIndex] : m.shape),\n          class: cssClass,\n          pointStrokeOpacity: Array.isArray(m.strokeOpacity) ? m.strokeOpacity[seriesIndex] : m.strokeOpacity,\n          pointStrokeDashArray: Array.isArray(m.strokeDashArray) ? m.strokeDashArray[seriesIndex] : m.strokeDashArray,\n          pointFillOpacity: Array.isArray(m.fillOpacity) ? m.fillOpacity[seriesIndex] : m.fillOpacity,\n          seriesIndex: seriesIndex\n        };\n      }\n    }, {\n      key: \"addEvents\",\n      value: function addEvents(circle) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        circle.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this.ctx, circle));\n        circle.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this.ctx, circle));\n        circle.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this.ctx, circle));\n        circle.node.addEventListener('click', w.config.markers.onClick);\n        circle.node.addEventListener('dblclick', w.config.markers.onDblClick);\n        circle.node.addEventListener('touchstart', graphics.pathMouseDown.bind(this.ctx, circle), {\n          passive: true\n        });\n      }\n    }, {\n      key: \"getMarkerStyle\",\n      value: function getMarkerStyle(seriesIndex) {\n        var w = this.w;\n        var colors = w.globals.markers.colors;\n        var strokeColors = w.config.markers.strokeColor || w.config.markers.strokeColors;\n        var pointStrokeColor = Array.isArray(strokeColors) ? strokeColors[seriesIndex] : strokeColors;\n        var pointFillColor = Array.isArray(colors) ? colors[seriesIndex] : colors;\n        return {\n          pointStrokeColor: pointStrokeColor,\n          pointFillColor: pointFillColor\n        };\n      }\n    }]);\n\n    return Markers;\n  }();\n\n  /**\n   * ApexCharts Scatter Class.\n   * This Class also handles bubbles chart as currently there is no major difference in drawing them,\n   * @module Scatter\n   **/\n\n  var Scatter = /*#__PURE__*/function () {\n    function Scatter(ctx) {\n      _classCallCheck(this, Scatter);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.initialAnim = this.w.config.chart.animations.enabled;\n      this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n    }\n\n    _createClass(Scatter, [{\n      key: \"draw\",\n      value: function draw(elSeries, j, opts) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var realIndex = opts.realIndex;\n        var pointsPos = opts.pointsPos;\n        var zRatio = opts.zRatio;\n        var elPointsMain = opts.elParent;\n        var elPointsWrap = graphics.group({\n          class: \"apexcharts-series-markers apexcharts-series-\".concat(w.config.chart.type)\n        });\n        elPointsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n\n        if (Array.isArray(pointsPos.x)) {\n          for (var q = 0; q < pointsPos.x.length; q++) {\n            var dataPointIndex = j + 1;\n            var shouldDraw = true; // a small hack as we have 2 points for the first val to connect it\n\n            if (j === 0 && q === 0) dataPointIndex = 0;\n            if (j === 0 && q === 1) dataPointIndex = 1;\n            var radius = 0;\n            var finishRadius = w.globals.markers.size[realIndex];\n\n            if (zRatio !== Infinity) {\n              // means we have a bubble\n              var bubble = w.config.plotOptions.bubble;\n              finishRadius = w.globals.seriesZ[realIndex][dataPointIndex];\n\n              if (bubble.zScaling) {\n                finishRadius /= zRatio;\n              }\n\n              if (bubble.minBubbleRadius && finishRadius < bubble.minBubbleRadius) {\n                finishRadius = bubble.minBubbleRadius;\n              }\n\n              if (bubble.maxBubbleRadius && finishRadius > bubble.maxBubbleRadius) {\n                finishRadius = bubble.maxBubbleRadius;\n              }\n            }\n\n            if (!w.config.chart.animations.enabled) {\n              radius = finishRadius;\n            }\n\n            var x = pointsPos.x[q];\n            var y = pointsPos.y[q];\n            radius = radius || 0;\n\n            if (y === null || typeof w.globals.series[realIndex][dataPointIndex] === 'undefined') {\n              shouldDraw = false;\n            }\n\n            if (shouldDraw) {\n              var point = this.drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j);\n              elPointsWrap.add(point);\n            }\n\n            elPointsMain.add(elPointsWrap);\n          }\n        }\n      }\n    }, {\n      key: \"drawPoint\",\n      value: function drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j) {\n        var w = this.w;\n        var i = realIndex;\n        var anim = new Animations(this.ctx);\n        var filters = new Filters(this.ctx);\n        var fill = new Fill(this.ctx);\n        var markers = new Markers(this.ctx);\n        var graphics = new Graphics(this.ctx);\n        var markerConfig = markers.getMarkerConfig({\n          cssClass: 'apexcharts-marker',\n          seriesIndex: i,\n          dataPointIndex: dataPointIndex,\n          finishRadius: w.config.chart.type === 'bubble' || w.globals.comboCharts && w.config.series[realIndex] && w.config.series[realIndex].type === 'bubble' ? finishRadius : null\n        });\n        finishRadius = markerConfig.pSize;\n        var pathFillCircle = fill.fillPath({\n          seriesNumber: realIndex,\n          dataPointIndex: dataPointIndex,\n          color: markerConfig.pointFillColor,\n          patternUnits: 'objectBoundingBox',\n          value: w.globals.series[realIndex][j]\n        });\n        var el;\n\n        if (markerConfig.shape === 'circle') {\n          el = graphics.drawCircle(radius);\n        } else if (markerConfig.shape === 'square' || markerConfig.shape === 'rect') {\n          el = graphics.drawRect(0, 0, markerConfig.width - markerConfig.pointStrokeWidth / 2, markerConfig.height - markerConfig.pointStrokeWidth / 2, markerConfig.pRadius);\n        }\n\n        if (w.config.series[i].data[dataPointIndex]) {\n          if (w.config.series[i].data[dataPointIndex].fillColor) {\n            pathFillCircle = w.config.series[i].data[dataPointIndex].fillColor;\n          }\n        }\n\n        el.attr({\n          x: x - markerConfig.width / 2 - markerConfig.pointStrokeWidth / 2,\n          y: y - markerConfig.height / 2 - markerConfig.pointStrokeWidth / 2,\n          cx: x,\n          cy: y,\n          fill: pathFillCircle,\n          'fill-opacity': markerConfig.pointFillOpacity,\n          stroke: markerConfig.pointStrokeColor,\n          r: finishRadius,\n          'stroke-width': markerConfig.pointStrokeWidth,\n          'stroke-dasharray': markerConfig.pointStrokeDashArray,\n          'stroke-opacity': markerConfig.pointStrokeOpacity\n        });\n\n        if (w.config.chart.dropShadow.enabled) {\n          var dropShadow = w.config.chart.dropShadow;\n          filters.dropShadow(el, dropShadow, realIndex);\n        }\n\n        if (this.initialAnim && !w.globals.dataChanged && !w.globals.resized) {\n          var speed = w.config.chart.animations.speed;\n          anim.animateMarker(el, 0, markerConfig.shape === 'circle' ? finishRadius : {\n            width: markerConfig.width,\n            height: markerConfig.height\n          }, speed, w.globals.easing, function () {\n            window.setTimeout(function () {\n              anim.animationCompleted(el);\n            }, 100);\n          });\n        } else {\n          w.globals.animationEnded = true;\n        }\n\n        if (w.globals.dataChanged && markerConfig.shape === 'circle') {\n          if (this.dynamicAnim) {\n            var _speed = w.config.chart.animations.dynamicAnimation.speed;\n            var prevX, prevY, prevR;\n            var prevPathJ = null;\n            prevPathJ = w.globals.previousPaths[realIndex] && w.globals.previousPaths[realIndex][j];\n\n            if (typeof prevPathJ !== 'undefined' && prevPathJ !== null) {\n              // series containing less elements will ignore these values and revert to 0\n              prevX = prevPathJ.x;\n              prevY = prevPathJ.y;\n              prevR = typeof prevPathJ.r !== 'undefined' ? prevPathJ.r : finishRadius;\n            }\n\n            for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {\n              if (w.globals.collapsedSeries[cs].index === realIndex) {\n                _speed = 1;\n                finishRadius = 0;\n              }\n            }\n\n            if (x === 0 && y === 0) finishRadius = 0;\n            anim.animateCircle(el, {\n              cx: prevX,\n              cy: prevY,\n              r: prevR\n            }, {\n              cx: x,\n              cy: y,\n              r: finishRadius\n            }, _speed, w.globals.easing);\n          } else {\n            el.attr({\n              r: finishRadius\n            });\n          }\n        }\n\n        el.attr({\n          rel: dataPointIndex,\n          j: dataPointIndex,\n          index: realIndex,\n          'default-marker-size': finishRadius\n        });\n        filters.setSelectionFilter(el, realIndex, dataPointIndex);\n        markers.addEvents(el);\n        el.node.classList.add('apexcharts-marker');\n        return el;\n      }\n    }, {\n      key: \"centerTextInBubble\",\n      value: function centerTextInBubble(y) {\n        var w = this.w;\n        y = y + parseInt(w.config.dataLabels.style.fontSize, 10) / 4;\n        return {\n          y: y\n        };\n      }\n    }]);\n\n    return Scatter;\n  }();\n\n  /**\n   * ApexCharts DataLabels Class for drawing dataLabels on Axes based Charts.\n   *\n   * @module DataLabels\n   **/\n\n  var DataLabels = /*#__PURE__*/function () {\n    function DataLabels(ctx) {\n      _classCallCheck(this, DataLabels);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    } // When there are many datalabels to be printed, and some of them overlaps each other in the same series, this method will take care of that\n    // Also, when datalabels exceeds the drawable area and get clipped off, we need to adjust and move some pixels to make them visible again\n\n\n    _createClass(DataLabels, [{\n      key: \"dataLabelsCorrection\",\n      value: function dataLabelsCorrection(x, y, val, i, dataPointIndex, alwaysDrawDataLabel, fontSize) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var drawnextLabel = false; //\n\n        var textRects = graphics.getTextRects(val, fontSize);\n        var width = textRects.width;\n        var height = textRects.height;\n        if (y < 0) y = 0;\n        if (y > w.globals.gridHeight + height) y = w.globals.gridHeight + height / 2; // first value in series, so push an empty array\n\n        if (typeof w.globals.dataLabelsRects[i] === 'undefined') w.globals.dataLabelsRects[i] = []; // then start pushing actual rects in that sub-array\n\n        w.globals.dataLabelsRects[i].push({\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        });\n        var len = w.globals.dataLabelsRects[i].length - 2;\n        var lastDrawnIndex = typeof w.globals.lastDrawnDataLabelsIndexes[i] !== 'undefined' ? w.globals.lastDrawnDataLabelsIndexes[i][w.globals.lastDrawnDataLabelsIndexes[i].length - 1] : 0;\n\n        if (typeof w.globals.dataLabelsRects[i][len] !== 'undefined') {\n          var lastDataLabelRect = w.globals.dataLabelsRects[i][lastDrawnIndex];\n\n          if ( // next label forward and x not intersecting\n          x > lastDataLabelRect.x + lastDataLabelRect.width || y > lastDataLabelRect.y + lastDataLabelRect.height || y + height < lastDataLabelRect.y || x + width < lastDataLabelRect.x // next label is going to be drawn backwards\n          ) {\n            // the 2 indexes don't override, so OK to draw next label\n            drawnextLabel = true;\n          }\n        }\n\n        if (dataPointIndex === 0 || alwaysDrawDataLabel) {\n          drawnextLabel = true;\n        }\n\n        return {\n          x: x,\n          y: y,\n          textRects: textRects,\n          drawnextLabel: drawnextLabel\n        };\n      }\n    }, {\n      key: \"drawDataLabel\",\n      value: function drawDataLabel(_ref) {\n        var _this = this;\n\n        var type = _ref.type,\n            pos = _ref.pos,\n            i = _ref.i,\n            j = _ref.j,\n            isRangeStart = _ref.isRangeStart,\n            _ref$strokeWidth = _ref.strokeWidth,\n            strokeWidth = _ref$strokeWidth === void 0 ? 2 : _ref$strokeWidth;\n        // this method handles line, area, bubble, scatter charts as those charts contains markers/points which have pre-defined x/y positions\n        // all other charts like radar / bars / heatmaps will define their own drawDataLabel routine\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var dataLabelsConfig = w.config.dataLabels;\n        var x = 0;\n        var y = 0;\n        var dataPointIndex = j;\n        var elDataLabelsWrap = null;\n\n        if (!dataLabelsConfig.enabled || !Array.isArray(pos.x)) {\n          return elDataLabelsWrap;\n        }\n\n        elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-data-labels'\n        });\n\n        for (var q = 0; q < pos.x.length; q++) {\n          x = pos.x[q] + dataLabelsConfig.offsetX;\n          y = pos.y[q] + dataLabelsConfig.offsetY + strokeWidth;\n\n          if (!isNaN(x)) {\n            // a small hack as we have 2 points for the first val to connect it\n            if (j === 1 && q === 0) dataPointIndex = 0;\n            if (j === 1 && q === 1) dataPointIndex = 1;\n            var val = w.globals.series[i][dataPointIndex];\n\n            if (type === 'rangeArea') {\n              if (isRangeStart) {\n                val = w.globals.seriesRangeStart[i][dataPointIndex];\n              } else {\n                val = w.globals.seriesRangeEnd[i][dataPointIndex];\n              }\n            }\n\n            var text = '';\n\n            var getText = function getText(v) {\n              return w.config.dataLabels.formatter(v, {\n                ctx: _this.ctx,\n                seriesIndex: i,\n                dataPointIndex: dataPointIndex,\n                w: w\n              });\n            };\n\n            if (w.config.chart.type === 'bubble') {\n              val = w.globals.seriesZ[i][dataPointIndex];\n              text = getText(val);\n              y = pos.y[q];\n              var scatter = new Scatter(this.ctx);\n              var centerTextInBubbleCoords = scatter.centerTextInBubble(y, i, dataPointIndex);\n              y = centerTextInBubbleCoords.y;\n            } else {\n              if (typeof val !== 'undefined') {\n                text = getText(val);\n              }\n            }\n\n            this.plotDataLabelsText({\n              x: x,\n              y: y,\n              text: text,\n              i: i,\n              j: dataPointIndex,\n              parent: elDataLabelsWrap,\n              offsetCorrection: true,\n              dataLabelsConfig: w.config.dataLabels\n            });\n          }\n        }\n\n        return elDataLabelsWrap;\n      }\n    }, {\n      key: \"plotDataLabelsText\",\n      value: function plotDataLabelsText(opts) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var x = opts.x,\n            y = opts.y,\n            i = opts.i,\n            j = opts.j,\n            text = opts.text,\n            textAnchor = opts.textAnchor,\n            fontSize = opts.fontSize,\n            parent = opts.parent,\n            dataLabelsConfig = opts.dataLabelsConfig,\n            color = opts.color,\n            alwaysDrawDataLabel = opts.alwaysDrawDataLabel,\n            offsetCorrection = opts.offsetCorrection;\n\n        if (Array.isArray(w.config.dataLabels.enabledOnSeries)) {\n          if (w.config.dataLabels.enabledOnSeries.indexOf(i) < 0) {\n            return;\n          }\n        }\n\n        var correctedLabels = {\n          x: x,\n          y: y,\n          drawnextLabel: true,\n          textRects: null\n        };\n\n        if (offsetCorrection) {\n          correctedLabels = this.dataLabelsCorrection(x, y, text, i, j, alwaysDrawDataLabel, parseInt(dataLabelsConfig.style.fontSize, 10));\n        } // when zoomed, we don't need to correct labels offsets,\n        // but if normally, labels get cropped, correct them\n\n\n        if (!w.globals.zoomed) {\n          x = correctedLabels.x;\n          y = correctedLabels.y;\n        }\n\n        if (correctedLabels.textRects) {\n          // fixes #2264\n          if (x < -10 - correctedLabels.textRects.width || x > w.globals.gridWidth + correctedLabels.textRects.width + 10) {\n            // datalabels fall outside drawing area, so draw a blank label\n            text = '';\n          }\n        }\n\n        var dataLabelColor = w.globals.dataLabels.style.colors[i];\n\n        if ((w.config.chart.type === 'bar' || w.config.chart.type === 'rangeBar') && w.config.plotOptions.bar.distributed || w.config.dataLabels.distributed) {\n          dataLabelColor = w.globals.dataLabels.style.colors[j];\n        }\n\n        if (typeof dataLabelColor === 'function') {\n          dataLabelColor = dataLabelColor({\n            series: w.globals.series,\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        }\n\n        if (color) {\n          dataLabelColor = color;\n        }\n\n        var offX = dataLabelsConfig.offsetX;\n        var offY = dataLabelsConfig.offsetY;\n\n        if (w.config.chart.type === 'bar' || w.config.chart.type === 'rangeBar') {\n          // for certain chart types, we handle offsets while calculating datalabels pos\n          // why? because bars/column may have negative values and based on that\n          // offsets becomes reversed\n          offX = 0;\n          offY = 0;\n        }\n\n        if (correctedLabels.drawnextLabel) {\n          var dataLabelText = graphics.drawText({\n            width: 100,\n            height: parseInt(dataLabelsConfig.style.fontSize, 10),\n            x: x + offX,\n            y: y + offY,\n            foreColor: dataLabelColor,\n            textAnchor: textAnchor || dataLabelsConfig.textAnchor,\n            text: text,\n            fontSize: fontSize || dataLabelsConfig.style.fontSize,\n            fontFamily: dataLabelsConfig.style.fontFamily,\n            fontWeight: dataLabelsConfig.style.fontWeight || 'normal'\n          });\n          dataLabelText.attr({\n            class: 'apexcharts-datalabel',\n            cx: x,\n            cy: y\n          });\n\n          if (dataLabelsConfig.dropShadow.enabled) {\n            var textShadow = dataLabelsConfig.dropShadow;\n            var filters = new Filters(this.ctx);\n            filters.dropShadow(dataLabelText, textShadow);\n          }\n\n          parent.add(dataLabelText);\n\n          if (typeof w.globals.lastDrawnDataLabelsIndexes[i] === 'undefined') {\n            w.globals.lastDrawnDataLabelsIndexes[i] = [];\n          }\n\n          w.globals.lastDrawnDataLabelsIndexes[i].push(j);\n        }\n      }\n    }, {\n      key: \"addBackgroundToDataLabel\",\n      value: function addBackgroundToDataLabel(el, coords) {\n        var w = this.w;\n        var bCnf = w.config.dataLabels.background;\n        var paddingH = bCnf.padding;\n        var paddingV = bCnf.padding / 2;\n        var width = coords.width;\n        var height = coords.height;\n        var graphics = new Graphics(this.ctx);\n        var elRect = graphics.drawRect(coords.x - paddingH, coords.y - paddingV / 2, width + paddingH * 2, height + paddingV, bCnf.borderRadius, w.config.chart.background === 'transparent' ? '#fff' : w.config.chart.background, bCnf.opacity, bCnf.borderWidth, bCnf.borderColor);\n\n        if (bCnf.dropShadow.enabled) {\n          var filters = new Filters(this.ctx);\n          filters.dropShadow(elRect, bCnf.dropShadow);\n        }\n\n        return elRect;\n      }\n    }, {\n      key: \"dataLabelsBackground\",\n      value: function dataLabelsBackground() {\n        var w = this.w;\n        if (w.config.chart.type === 'bubble') return;\n        var elDataLabels = w.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels text');\n\n        for (var i = 0; i < elDataLabels.length; i++) {\n          var el = elDataLabels[i];\n          var coords = el.getBBox();\n          var elRect = null;\n\n          if (coords.width && coords.height) {\n            elRect = this.addBackgroundToDataLabel(el, coords);\n          }\n\n          if (elRect) {\n            el.parentNode.insertBefore(elRect.node, el);\n            var background = el.getAttribute('fill');\n            var shouldAnim = w.config.chart.animations.enabled && !w.globals.resized && !w.globals.dataChanged;\n\n            if (shouldAnim) {\n              elRect.animate().attr({\n                fill: background\n              });\n            } else {\n              elRect.attr({\n                fill: background\n              });\n            }\n\n            el.setAttribute('fill', w.config.dataLabels.background.foreColor);\n          }\n        }\n      }\n    }, {\n      key: \"bringForward\",\n      value: function bringForward() {\n        var w = this.w;\n        var elDataLabelsNodes = w.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels');\n        var elSeries = w.globals.dom.baseEl.querySelector('.apexcharts-plot-series:last-child');\n\n        for (var i = 0; i < elDataLabelsNodes.length; i++) {\n          if (elSeries) {\n            elSeries.insertBefore(elDataLabelsNodes[i], elSeries.nextSibling);\n          }\n        }\n      }\n    }]);\n\n    return DataLabels;\n  }();\n\n  /**\n   * ApexCharts Series Class for interaction with the Series of the chart.\n   *\n   * @module Series\n   **/\n\n  var Series = /*#__PURE__*/function () {\n    function Series(ctx) {\n      _classCallCheck(this, Series);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.legendInactiveClass = 'legend-mouseover-inactive';\n    }\n\n    _createClass(Series, [{\n      key: \"getAllSeriesEls\",\n      value: function getAllSeriesEls() {\n        return this.w.globals.dom.baseEl.getElementsByClassName(\"apexcharts-series\");\n      }\n    }, {\n      key: \"getSeriesByName\",\n      value: function getSeriesByName(seriesName) {\n        return this.w.globals.dom.baseEl.querySelector(\".apexcharts-inner .apexcharts-series[seriesName='\".concat(Utils$1.escapeString(seriesName), \"']\"));\n      }\n    }, {\n      key: \"isSeriesHidden\",\n      value: function isSeriesHidden(seriesName) {\n        var targetElement = this.getSeriesByName(seriesName);\n        var realIndex = parseInt(targetElement.getAttribute('data:realIndex'), 10);\n        var isHidden = targetElement.classList.contains('apexcharts-series-collapsed');\n        return {\n          isHidden: isHidden,\n          realIndex: realIndex\n        };\n      }\n    }, {\n      key: \"addCollapsedClassToSeries\",\n      value: function addCollapsedClassToSeries(elSeries, index) {\n        var w = this.w;\n\n        function iterateOnAllCollapsedSeries(series) {\n          for (var cs = 0; cs < series.length; cs++) {\n            if (series[cs].index === index) {\n              elSeries.node.classList.add('apexcharts-series-collapsed');\n            }\n          }\n        }\n\n        iterateOnAllCollapsedSeries(w.globals.collapsedSeries);\n        iterateOnAllCollapsedSeries(w.globals.ancillaryCollapsedSeries);\n      }\n    }, {\n      key: \"toggleSeries\",\n      value: function toggleSeries(seriesName) {\n        var isSeriesHidden = this.isSeriesHidden(seriesName);\n        this.ctx.legend.legendHelpers.toggleDataSeries(isSeriesHidden.realIndex, isSeriesHidden.isHidden);\n        return isSeriesHidden.isHidden;\n      }\n    }, {\n      key: \"showSeries\",\n      value: function showSeries(seriesName) {\n        var isSeriesHidden = this.isSeriesHidden(seriesName);\n\n        if (isSeriesHidden.isHidden) {\n          this.ctx.legend.legendHelpers.toggleDataSeries(isSeriesHidden.realIndex, true);\n        }\n      }\n    }, {\n      key: \"hideSeries\",\n      value: function hideSeries(seriesName) {\n        var isSeriesHidden = this.isSeriesHidden(seriesName);\n\n        if (!isSeriesHidden.isHidden) {\n          this.ctx.legend.legendHelpers.toggleDataSeries(isSeriesHidden.realIndex, false);\n        }\n      }\n    }, {\n      key: \"resetSeries\",\n      value: function resetSeries() {\n        var shouldUpdateChart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var shouldResetZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var shouldResetCollapsed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var w = this.w;\n        var series = Utils$1.clone(w.globals.initialSeries);\n        w.globals.previousPaths = [];\n\n        if (shouldResetCollapsed) {\n          w.globals.collapsedSeries = [];\n          w.globals.ancillaryCollapsedSeries = [];\n          w.globals.collapsedSeriesIndices = [];\n          w.globals.ancillaryCollapsedSeriesIndices = [];\n        } else {\n          series = this.emptyCollapsedSeries(series);\n        }\n\n        w.config.series = series;\n\n        if (shouldUpdateChart) {\n          if (shouldResetZoom) {\n            w.globals.zoomed = false;\n            this.ctx.updateHelpers.revertDefaultAxisMinMax();\n          }\n\n          this.ctx.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);\n        }\n      }\n    }, {\n      key: \"emptyCollapsedSeries\",\n      value: function emptyCollapsedSeries(series) {\n        var w = this.w;\n\n        for (var i = 0; i < series.length; i++) {\n          if (w.globals.collapsedSeriesIndices.indexOf(i) > -1) {\n            series[i].data = [];\n          }\n        }\n\n        return series;\n      }\n    }, {\n      key: \"toggleSeriesOnHover\",\n      value: function toggleSeriesOnHover(e, targetElement) {\n        var w = this.w;\n        if (!targetElement) targetElement = e.target;\n        var allSeriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series, .apexcharts-datalabels\");\n\n        if (e.type === 'mousemove') {\n          var seriesCnt = parseInt(targetElement.getAttribute('rel'), 10) - 1;\n          var seriesEl = null;\n          var dataLabelEl = null;\n\n          if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {\n            if (w.globals.axisCharts) {\n              seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesCnt, \"']\"));\n              dataLabelEl = w.globals.dom.baseEl.querySelector(\".apexcharts-datalabels[data\\\\:realIndex='\".concat(seriesCnt, \"']\"));\n            } else {\n              seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"']\"));\n            }\n          } else {\n            seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"'] path\"));\n          }\n\n          for (var se = 0; se < allSeriesEls.length; se++) {\n            allSeriesEls[se].classList.add(this.legendInactiveClass);\n          }\n\n          if (seriesEl !== null) {\n            if (!w.globals.axisCharts) {\n              seriesEl.parentNode.classList.remove(this.legendInactiveClass);\n            }\n\n            seriesEl.classList.remove(this.legendInactiveClass);\n\n            if (dataLabelEl !== null) {\n              dataLabelEl.classList.remove(this.legendInactiveClass);\n            }\n          }\n        } else if (e.type === 'mouseout') {\n          for (var _se = 0; _se < allSeriesEls.length; _se++) {\n            allSeriesEls[_se].classList.remove(this.legendInactiveClass);\n          }\n        }\n      }\n    }, {\n      key: \"highlightRangeInSeries\",\n      value: function highlightRangeInSeries(e, targetElement) {\n        var _this = this;\n\n        var w = this.w;\n        var allHeatMapElements = w.globals.dom.baseEl.getElementsByClassName('apexcharts-heatmap-rect');\n\n        var activeInactive = function activeInactive(action) {\n          for (var i = 0; i < allHeatMapElements.length; i++) {\n            allHeatMapElements[i].classList[action](_this.legendInactiveClass);\n          }\n        };\n\n        var removeInactiveClassFromHoveredRange = function removeInactiveClassFromHoveredRange(range) {\n          for (var i = 0; i < allHeatMapElements.length; i++) {\n            var val = parseInt(allHeatMapElements[i].getAttribute('val'), 10);\n\n            if (val >= range.from && val <= range.to) {\n              allHeatMapElements[i].classList.remove(_this.legendInactiveClass);\n            }\n          }\n        };\n\n        if (e.type === 'mousemove') {\n          var seriesCnt = parseInt(targetElement.getAttribute('rel'), 10) - 1;\n          activeInactive('add');\n          var range = w.config.plotOptions.heatmap.colorScale.ranges[seriesCnt];\n          removeInactiveClassFromHoveredRange(range);\n        } else if (e.type === 'mouseout') {\n          activeInactive('remove');\n        }\n      }\n    }, {\n      key: \"getActiveConfigSeriesIndex\",\n      value: function getActiveConfigSeriesIndex() {\n        var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'asc';\n        var chartTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var w = this.w;\n        var activeIndex = 0;\n\n        if (w.config.series.length > 1) {\n          // active series flag is required to know if user has not deactivated via legend click\n          var activeSeriesIndex = w.config.series.map(function (s, index) {\n            var checkChartType = function checkChartType() {\n              if (w.globals.comboCharts) {\n                return chartTypes.length === 0 || chartTypes.length && chartTypes.indexOf(w.config.series[index].type) > -1;\n              }\n\n              return true;\n            };\n\n            var hasData = s.data && s.data.length > 0 && w.globals.collapsedSeriesIndices.indexOf(index) === -1;\n            return hasData && checkChartType() ? index : -1;\n          });\n\n          for (var a = order === 'asc' ? 0 : activeSeriesIndex.length - 1; order === 'asc' ? a < activeSeriesIndex.length : a >= 0; order === 'asc' ? a++ : a--) {\n            if (activeSeriesIndex[a] !== -1) {\n              activeIndex = activeSeriesIndex[a];\n              break;\n            }\n          }\n        }\n\n        return activeIndex;\n      }\n    }, {\n      key: \"getBarSeriesIndices\",\n      value: function getBarSeriesIndices() {\n        var w = this.w;\n\n        if (w.globals.comboCharts) {\n          return this.w.config.series.map(function (s, i) {\n            return s.type === 'bar' || s.type === 'column' ? i : -1;\n          }).filter(function (i) {\n            return i !== -1;\n          });\n        }\n\n        return this.w.config.series.map(function (s, i) {\n          return i;\n        });\n      }\n    }, {\n      key: \"getPreviousPaths\",\n      value: function getPreviousPaths() {\n        var w = this.w;\n        w.globals.previousPaths = [];\n\n        function pushPaths(seriesEls, i, type) {\n          var paths = seriesEls[i].childNodes;\n          var dArr = {\n            type: type,\n            paths: [],\n            realIndex: seriesEls[i].getAttribute('data:realIndex')\n          };\n\n          for (var j = 0; j < paths.length; j++) {\n            if (paths[j].hasAttribute('pathTo')) {\n              var d = paths[j].getAttribute('pathTo');\n              dArr.paths.push({\n                d: d\n              });\n            }\n          }\n\n          w.globals.previousPaths.push(dArr);\n        }\n\n        var getPaths = function getPaths(chartType) {\n          return w.globals.dom.baseEl.querySelectorAll(\".apexcharts-\".concat(chartType, \"-series .apexcharts-series\"));\n        };\n\n        var chartTypes = ['line', 'area', 'bar', 'rangebar', 'rangeArea', 'candlestick', 'radar'];\n        chartTypes.forEach(function (type) {\n          var paths = getPaths(type);\n\n          for (var p = 0; p < paths.length; p++) {\n            pushPaths(paths, p, type);\n          }\n        });\n        this.handlePrevBubbleScatterPaths('bubble');\n        this.handlePrevBubbleScatterPaths('scatter');\n        var heatTreeSeries = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-\".concat(w.config.chart.type, \" .apexcharts-series\"));\n\n        if (heatTreeSeries.length > 0) {\n          var _loop = function _loop(h) {\n            var seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-\".concat(w.config.chart.type, \" .apexcharts-series[data\\\\:realIndex='\").concat(h, \"'] rect\"));\n            var dArr = [];\n\n            var _loop2 = function _loop2(i) {\n              var getAttr = function getAttr(x) {\n                return seriesEls[i].getAttribute(x);\n              };\n\n              var rect = {\n                x: parseFloat(getAttr('x')),\n                y: parseFloat(getAttr('y')),\n                width: parseFloat(getAttr('width')),\n                height: parseFloat(getAttr('height'))\n              };\n              dArr.push({\n                rect: rect,\n                color: seriesEls[i].getAttribute('color')\n              });\n            };\n\n            for (var i = 0; i < seriesEls.length; i++) {\n              _loop2(i);\n            }\n\n            w.globals.previousPaths.push(dArr);\n          };\n\n          for (var h = 0; h < heatTreeSeries.length; h++) {\n            _loop(h);\n          }\n        }\n\n        if (!w.globals.axisCharts) {\n          // for non-axis charts (i.e., circular charts, pathFrom is not usable. We need whole series)\n          w.globals.previousPaths = w.globals.series;\n        }\n      }\n    }, {\n      key: \"handlePrevBubbleScatterPaths\",\n      value: function handlePrevBubbleScatterPaths(type) {\n        var w = this.w;\n        var paths = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-\".concat(type, \"-series .apexcharts-series\"));\n\n        if (paths.length > 0) {\n          for (var s = 0; s < paths.length; s++) {\n            var seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-\".concat(type, \"-series .apexcharts-series[data\\\\:realIndex='\").concat(s, \"'] circle\"));\n            var dArr = [];\n\n            for (var i = 0; i < seriesEls.length; i++) {\n              dArr.push({\n                x: seriesEls[i].getAttribute('cx'),\n                y: seriesEls[i].getAttribute('cy'),\n                r: seriesEls[i].getAttribute('r')\n              });\n            }\n\n            w.globals.previousPaths.push(dArr);\n          }\n        }\n      }\n    }, {\n      key: \"clearPreviousPaths\",\n      value: function clearPreviousPaths() {\n        var w = this.w;\n        w.globals.previousPaths = [];\n        w.globals.allSeriesCollapsed = false;\n      }\n    }, {\n      key: \"handleNoData\",\n      value: function handleNoData() {\n        var w = this.w;\n        var me = this;\n        var noDataOpts = w.config.noData;\n        var graphics = new Graphics(me.ctx);\n        var x = w.globals.svgWidth / 2;\n        var y = w.globals.svgHeight / 2;\n        var textAnchor = 'middle';\n        w.globals.noData = true;\n        w.globals.animationEnded = true;\n\n        if (noDataOpts.align === 'left') {\n          x = 10;\n          textAnchor = 'start';\n        } else if (noDataOpts.align === 'right') {\n          x = w.globals.svgWidth - 10;\n          textAnchor = 'end';\n        }\n\n        if (noDataOpts.verticalAlign === 'top') {\n          y = 50;\n        } else if (noDataOpts.verticalAlign === 'bottom') {\n          y = w.globals.svgHeight - 50;\n        }\n\n        x = x + noDataOpts.offsetX;\n        y = y + parseInt(noDataOpts.style.fontSize, 10) + 2 + noDataOpts.offsetY;\n\n        if (noDataOpts.text !== undefined && noDataOpts.text !== '') {\n          var titleText = graphics.drawText({\n            x: x,\n            y: y,\n            text: noDataOpts.text,\n            textAnchor: textAnchor,\n            fontSize: noDataOpts.style.fontSize,\n            fontFamily: noDataOpts.style.fontFamily,\n            foreColor: noDataOpts.style.color,\n            opacity: 1,\n            class: 'apexcharts-text-nodata'\n          });\n          w.globals.dom.Paper.add(titleText);\n        }\n      } // When user clicks on legends, the collapsed series is filled with [0,0,0,...,0]\n      // This is because we don't want to alter the series' length as it is used at many places\n\n    }, {\n      key: \"setNullSeriesToZeroValues\",\n      value: function setNullSeriesToZeroValues(series) {\n        var w = this.w;\n\n        for (var sl = 0; sl < series.length; sl++) {\n          if (series[sl].length === 0) {\n            for (var j = 0; j < series[w.globals.maxValsInArrayIndex].length; j++) {\n              series[sl].push(0);\n            }\n          }\n        }\n\n        return series;\n      }\n    }, {\n      key: \"hasAllSeriesEqualX\",\n      value: function hasAllSeriesEqualX() {\n        var equalLen = true;\n        var w = this.w;\n        var filteredSerX = this.filteredSeriesX();\n\n        for (var i = 0; i < filteredSerX.length - 1; i++) {\n          if (filteredSerX[i][0] !== filteredSerX[i + 1][0]) {\n            equalLen = false;\n            break;\n          }\n        }\n\n        w.globals.allSeriesHasEqualX = equalLen;\n        return equalLen;\n      }\n    }, {\n      key: \"filteredSeriesX\",\n      value: function filteredSeriesX() {\n        var w = this.w;\n        var filteredSeriesX = w.globals.seriesX.map(function (ser) {\n          return ser.length > 0 ? ser : [];\n        });\n        return filteredSeriesX;\n      }\n    }]);\n\n    return Series;\n  }();\n\n  var Data = /*#__PURE__*/function () {\n    function Data(ctx) {\n      _classCallCheck(this, Data);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.twoDSeries = [];\n      this.threeDSeries = [];\n      this.twoDSeriesX = [];\n      this.seriesGoals = [];\n      this.coreUtils = new CoreUtils(this.ctx);\n    }\n\n    _createClass(Data, [{\n      key: \"isMultiFormat\",\n      value: function isMultiFormat() {\n        return this.isFormatXY() || this.isFormat2DArray();\n      } // given format is [{x, y}, {x, y}]\n\n    }, {\n      key: \"isFormatXY\",\n      value: function isFormatXY() {\n        var series = this.w.config.series.slice();\n        var sr = new Series(this.ctx);\n        this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();\n\n        if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && series[this.activeSeriesIndex].data[0] !== null && typeof series[this.activeSeriesIndex].data[0].x !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null) {\n          return true;\n        }\n      } // given format is [[x, y], [x, y]]\n\n    }, {\n      key: \"isFormat2DArray\",\n      value: function isFormat2DArray() {\n        var series = this.w.config.series.slice();\n        var sr = new Series(this.ctx);\n        this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();\n\n        if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && typeof series[this.activeSeriesIndex].data[0] !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null && series[this.activeSeriesIndex].data[0].constructor === Array) {\n          return true;\n        }\n      }\n    }, {\n      key: \"handleFormat2DArray\",\n      value: function handleFormat2DArray(ser, i) {\n        var cnf = this.w.config;\n        var gl = this.w.globals;\n        var isBoxPlot = cnf.chart.type === 'boxPlot' || cnf.series[i].type === 'boxPlot';\n\n        for (var j = 0; j < ser[i].data.length; j++) {\n          if (typeof ser[i].data[j][1] !== 'undefined') {\n            if (Array.isArray(ser[i].data[j][1]) && ser[i].data[j][1].length === 4 && !isBoxPlot) {\n              // candlestick nested ohlc format\n              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j][1][3]));\n            } else if (ser[i].data[j].length >= 5) {\n              // candlestick non-nested ohlc format\n              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j][4]));\n            } else {\n              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j][1]));\n            }\n\n            gl.dataFormatXNumeric = true;\n          }\n\n          if (cnf.xaxis.type === 'datetime') {\n            // if timestamps are provided and xaxis type is datetime,\n            var ts = new Date(ser[i].data[j][0]);\n            ts = new Date(ts).getTime();\n            this.twoDSeriesX.push(ts);\n          } else {\n            this.twoDSeriesX.push(ser[i].data[j][0]);\n          }\n        }\n\n        for (var _j = 0; _j < ser[i].data.length; _j++) {\n          if (typeof ser[i].data[_j][2] !== 'undefined') {\n            this.threeDSeries.push(ser[i].data[_j][2]);\n            gl.isDataXYZ = true;\n          }\n        }\n      }\n    }, {\n      key: \"handleFormatXY\",\n      value: function handleFormatXY(ser, i) {\n        var cnf = this.w.config;\n        var gl = this.w.globals;\n        var dt = new DateTime(this.ctx);\n        var activeI = i;\n\n        if (gl.collapsedSeriesIndices.indexOf(i) > -1) {\n          // fix #368\n          activeI = this.activeSeriesIndex;\n        } // get series\n\n\n        for (var j = 0; j < ser[i].data.length; j++) {\n          if (typeof ser[i].data[j].y !== 'undefined') {\n            if (Array.isArray(ser[i].data[j].y)) {\n              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j].y[ser[i].data[j].y.length - 1]));\n            } else {\n              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j].y));\n            }\n          }\n\n          if (typeof ser[i].data[j].goals !== 'undefined' && Array.isArray(ser[i].data[j].goals)) {\n            if (typeof this.seriesGoals[i] === 'undefined') {\n              this.seriesGoals[i] = [];\n            }\n\n            this.seriesGoals[i].push(ser[i].data[j].goals);\n          } else {\n            if (typeof this.seriesGoals[i] === 'undefined') {\n              this.seriesGoals[i] = [];\n            }\n\n            this.seriesGoals[i].push(null);\n          }\n        } // get seriesX\n\n\n        for (var _j2 = 0; _j2 < ser[activeI].data.length; _j2++) {\n          var isXString = typeof ser[activeI].data[_j2].x === 'string';\n          var isXArr = Array.isArray(ser[activeI].data[_j2].x);\n          var isXDate = !isXArr && !!dt.isValidDate(ser[activeI].data[_j2].x.toString());\n\n          if (isXString || isXDate) {\n            // user supplied '01/01/2017' or a date string (a JS date object is not supported)\n            if (isXString || cnf.xaxis.convertedCatToNumeric) {\n              var isRangeColumn = gl.isBarHorizontal && gl.isRangeData;\n\n              if (cnf.xaxis.type === 'datetime' && !isRangeColumn) {\n                this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x));\n              } else {\n                // a category and not a numeric x value\n                this.fallbackToCategory = true;\n                this.twoDSeriesX.push(ser[activeI].data[_j2].x);\n\n                if (!isNaN(ser[activeI].data[_j2].x) && this.w.config.xaxis.type !== 'category' && typeof ser[activeI].data[_j2].x !== 'string') {\n                  gl.isXNumeric = true;\n                }\n              }\n            } else {\n              if (cnf.xaxis.type === 'datetime') {\n                this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x.toString()));\n              } else {\n                gl.dataFormatXNumeric = true;\n                gl.isXNumeric = true;\n                this.twoDSeriesX.push(parseFloat(ser[activeI].data[_j2].x));\n              }\n            }\n          } else if (isXArr) {\n            // a multiline label described in array format\n            this.fallbackToCategory = true;\n            this.twoDSeriesX.push(ser[activeI].data[_j2].x);\n          } else {\n            // a numeric value in x property\n            gl.isXNumeric = true;\n            gl.dataFormatXNumeric = true;\n            this.twoDSeriesX.push(ser[activeI].data[_j2].x);\n          }\n        }\n\n        if (ser[i].data[0] && typeof ser[i].data[0].z !== 'undefined') {\n          for (var t = 0; t < ser[i].data.length; t++) {\n            this.threeDSeries.push(ser[i].data[t].z);\n          }\n\n          gl.isDataXYZ = true;\n        }\n      }\n    }, {\n      key: \"handleRangeData\",\n      value: function handleRangeData(ser, i) {\n        var gl = this.w.globals;\n        var range = {};\n\n        if (this.isFormat2DArray()) {\n          range = this.handleRangeDataFormat('array', ser, i);\n        } else if (this.isFormatXY()) {\n          range = this.handleRangeDataFormat('xy', ser, i);\n        }\n\n        gl.seriesRangeStart.push(range.start);\n        gl.seriesRangeEnd.push(range.end);\n        gl.seriesRange.push(range.rangeUniques); // check for overlaps to avoid clashes in a timeline chart\n\n        gl.seriesRange.forEach(function (sr, si) {\n          if (sr) {\n            sr.forEach(function (sarr, sarri) {\n              sarr.y.forEach(function (arr, arri) {\n                for (var sri = 0; sri < sarr.y.length; sri++) {\n                  if (arri !== sri) {\n                    var range1y1 = arr.y1;\n                    var range1y2 = arr.y2;\n                    var range2y1 = sarr.y[sri].y1;\n                    var range2y2 = sarr.y[sri].y2;\n\n                    if (range1y1 <= range2y2 && range2y1 <= range1y2) {\n                      if (sarr.overlaps.indexOf(arr.rangeName) < 0) {\n                        sarr.overlaps.push(arr.rangeName);\n                      }\n\n                      if (sarr.overlaps.indexOf(sarr.y[sri].rangeName) < 0) {\n                        sarr.overlaps.push(sarr.y[sri].rangeName);\n                      }\n                    }\n                  }\n                }\n              });\n            });\n          }\n        });\n        return range;\n      }\n    }, {\n      key: \"handleCandleStickBoxData\",\n      value: function handleCandleStickBoxData(ser, i) {\n        var gl = this.w.globals;\n        var ohlc = {};\n\n        if (this.isFormat2DArray()) {\n          ohlc = this.handleCandleStickBoxDataFormat('array', ser, i);\n        } else if (this.isFormatXY()) {\n          ohlc = this.handleCandleStickBoxDataFormat('xy', ser, i);\n        }\n\n        gl.seriesCandleO[i] = ohlc.o;\n        gl.seriesCandleH[i] = ohlc.h;\n        gl.seriesCandleM[i] = ohlc.m;\n        gl.seriesCandleL[i] = ohlc.l;\n        gl.seriesCandleC[i] = ohlc.c;\n        return ohlc;\n      }\n    }, {\n      key: \"handleRangeDataFormat\",\n      value: function handleRangeDataFormat(format, ser, i) {\n        var rangeStart = [];\n        var rangeEnd = [];\n        var uniqueKeys = ser[i].data.filter(function (thing, index, self) {\n          return index === self.findIndex(function (t) {\n            return t.x === thing.x;\n          });\n        }).map(function (r, index) {\n          return {\n            x: r.x,\n            overlaps: [],\n            y: []\n          };\n        });\n\n        if (format === 'array') {\n          for (var j = 0; j < ser[i].data.length; j++) {\n            if (Array.isArray(ser[i].data[j])) {\n              rangeStart.push(ser[i].data[j][1][0]);\n              rangeEnd.push(ser[i].data[j][1][1]);\n            } else {\n              rangeStart.push(ser[i].data[j]);\n              rangeEnd.push(ser[i].data[j]);\n            }\n          }\n        } else if (format === 'xy') {\n          var _loop = function _loop(_j3) {\n            var isDataPoint2D = Array.isArray(ser[i].data[_j3].y);\n            var id = Utils$1.randomId();\n            var x = ser[i].data[_j3].x;\n            var y = {\n              y1: isDataPoint2D ? ser[i].data[_j3].y[0] : ser[i].data[_j3].y,\n              y2: isDataPoint2D ? ser[i].data[_j3].y[1] : ser[i].data[_j3].y,\n              rangeName: id\n            }; // CAUTION: mutating config object by adding a new property\n            // TODO: As this is specifically for timeline rangebar charts, update the docs mentioning the series only supports xy format\n\n            ser[i].data[_j3].rangeName = id;\n            var uI = uniqueKeys.findIndex(function (t) {\n              return t.x === x;\n            });\n            uniqueKeys[uI].y.push(y);\n            rangeStart.push(y.y1);\n            rangeEnd.push(y.y2);\n          };\n\n          for (var _j3 = 0; _j3 < ser[i].data.length; _j3++) {\n            _loop(_j3);\n          }\n        }\n\n        return {\n          start: rangeStart,\n          end: rangeEnd,\n          rangeUniques: uniqueKeys\n        };\n      }\n    }, {\n      key: \"handleCandleStickBoxDataFormat\",\n      value: function handleCandleStickBoxDataFormat(format, ser, i) {\n        var w = this.w;\n        var isBoxPlot = w.config.chart.type === 'boxPlot' || w.config.series[i].type === 'boxPlot';\n        var serO = [];\n        var serH = [];\n        var serM = [];\n        var serL = [];\n        var serC = [];\n\n        if (format === 'array') {\n          if (isBoxPlot && ser[i].data[0].length === 6 || !isBoxPlot && ser[i].data[0].length === 5) {\n            for (var j = 0; j < ser[i].data.length; j++) {\n              serO.push(ser[i].data[j][1]);\n              serH.push(ser[i].data[j][2]);\n\n              if (isBoxPlot) {\n                serM.push(ser[i].data[j][3]);\n                serL.push(ser[i].data[j][4]);\n                serC.push(ser[i].data[j][5]);\n              } else {\n                serL.push(ser[i].data[j][3]);\n                serC.push(ser[i].data[j][4]);\n              }\n            }\n          } else {\n            for (var _j4 = 0; _j4 < ser[i].data.length; _j4++) {\n              if (Array.isArray(ser[i].data[_j4][1])) {\n                serO.push(ser[i].data[_j4][1][0]);\n                serH.push(ser[i].data[_j4][1][1]);\n\n                if (isBoxPlot) {\n                  serM.push(ser[i].data[_j4][1][2]);\n                  serL.push(ser[i].data[_j4][1][3]);\n                  serC.push(ser[i].data[_j4][1][4]);\n                } else {\n                  serL.push(ser[i].data[_j4][1][2]);\n                  serC.push(ser[i].data[_j4][1][3]);\n                }\n              }\n            }\n          }\n        } else if (format === 'xy') {\n          for (var _j5 = 0; _j5 < ser[i].data.length; _j5++) {\n            if (Array.isArray(ser[i].data[_j5].y)) {\n              serO.push(ser[i].data[_j5].y[0]);\n              serH.push(ser[i].data[_j5].y[1]);\n\n              if (isBoxPlot) {\n                serM.push(ser[i].data[_j5].y[2]);\n                serL.push(ser[i].data[_j5].y[3]);\n                serC.push(ser[i].data[_j5].y[4]);\n              } else {\n                serL.push(ser[i].data[_j5].y[2]);\n                serC.push(ser[i].data[_j5].y[3]);\n              }\n            }\n          }\n        }\n\n        return {\n          o: serO,\n          h: serH,\n          m: serM,\n          l: serL,\n          c: serC\n        };\n      }\n    }, {\n      key: \"parseDataAxisCharts\",\n      value: function parseDataAxisCharts(ser) {\n        var _ser$,\n            _this = this;\n\n        var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.ctx;\n        var cnf = this.w.config;\n        var gl = this.w.globals;\n        var dt = new DateTime(ctx);\n        var xlabels = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();\n        gl.isRangeBar = cnf.chart.type === 'rangeBar' && gl.isBarHorizontal;\n        gl.hasXaxisGroups = cnf.xaxis.type === 'category' && cnf.xaxis.group.groups.length > 0;\n\n        if (gl.hasXaxisGroups) {\n          gl.groups = cnf.xaxis.group.groups;\n        }\n\n        gl.hasSeriesGroups = (_ser$ = ser[0]) === null || _ser$ === void 0 ? void 0 : _ser$.group;\n\n        if (gl.hasSeriesGroups) {\n          var buckets = [];\n\n          var groups = _toConsumableArray(new Set(ser.map(function (s) {\n            return s.group;\n          })));\n\n          ser.forEach(function (s, i) {\n            var index = groups.indexOf(s.group);\n            if (!buckets[index]) buckets[index] = [];\n            buckets[index].push(s.name);\n          });\n          gl.seriesGroups = buckets;\n        }\n\n        var handleDates = function handleDates() {\n          for (var j = 0; j < xlabels.length; j++) {\n            if (typeof xlabels[j] === 'string') {\n              // user provided date strings\n              var isDate = dt.isValidDate(xlabels[j]);\n\n              if (isDate) {\n                _this.twoDSeriesX.push(dt.parseDate(xlabels[j]));\n              } else {\n                throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date');\n              }\n            } else {\n              // user provided timestamps\n              _this.twoDSeriesX.push(xlabels[j]);\n            }\n          }\n        };\n\n        for (var i = 0; i < ser.length; i++) {\n          this.twoDSeries = [];\n          this.twoDSeriesX = [];\n          this.threeDSeries = [];\n\n          if (typeof ser[i].data === 'undefined') {\n            console.error(\"It is a possibility that you may have not included 'data' property in series.\");\n            return;\n          }\n\n          if (cnf.chart.type === 'rangeBar' || cnf.chart.type === 'rangeArea' || ser[i].type === 'rangeBar' || ser[i].type === 'rangeArea') {\n            gl.isRangeData = true;\n\n            if (gl.isComboCharts) {\n              if (ser[i].type === 'rangeBar' || ser[i].type === 'rangeArea') {\n                this.handleRangeData(ser, i);\n              }\n            } else if (cnf.chart.type === 'rangeBar' || cnf.chart.type === 'rangeArea') {\n              this.handleRangeData(ser, i);\n            }\n          }\n\n          if (this.isMultiFormat()) {\n            if (this.isFormat2DArray()) {\n              this.handleFormat2DArray(ser, i);\n            } else if (this.isFormatXY()) {\n              this.handleFormatXY(ser, i);\n            }\n\n            if (cnf.chart.type === 'candlestick' || ser[i].type === 'candlestick' || cnf.chart.type === 'boxPlot' || ser[i].type === 'boxPlot') {\n              this.handleCandleStickBoxData(ser, i);\n            }\n\n            gl.series.push(this.twoDSeries);\n            gl.labels.push(this.twoDSeriesX);\n            gl.seriesX.push(this.twoDSeriesX);\n            gl.seriesGoals = this.seriesGoals;\n\n            if (i === this.activeSeriesIndex && !this.fallbackToCategory) {\n              gl.isXNumeric = true;\n            }\n          } else {\n            if (cnf.xaxis.type === 'datetime') {\n              // user didn't supplied [{x,y}] or [[x,y]], but single array in data.\n              // Also labels/categories were supplied differently\n              gl.isXNumeric = true;\n              handleDates();\n              gl.seriesX.push(this.twoDSeriesX);\n            } else if (cnf.xaxis.type === 'numeric') {\n              gl.isXNumeric = true;\n\n              if (xlabels.length > 0) {\n                this.twoDSeriesX = xlabels;\n                gl.seriesX.push(this.twoDSeriesX);\n              }\n            }\n\n            gl.labels.push(this.twoDSeriesX);\n            var singleArray = ser[i].data.map(function (d) {\n              return Utils$1.parseNumber(d);\n            });\n            gl.series.push(singleArray);\n          }\n\n          gl.seriesZ.push(this.threeDSeries);\n\n          if (ser[i].name !== undefined) {\n            gl.seriesNames.push(ser[i].name);\n          } else {\n            gl.seriesNames.push('series-' + parseInt(i + 1, 10));\n          } // overrided default color if user inputs color with series data\n\n\n          if (ser[i].color !== undefined) {\n            gl.seriesColors.push(ser[i].color);\n          } else {\n            gl.seriesColors.push(undefined);\n          }\n        }\n\n        return this.w;\n      }\n    }, {\n      key: \"parseDataNonAxisCharts\",\n      value: function parseDataNonAxisCharts(ser) {\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n        gl.series = ser.slice();\n        gl.seriesNames = cnf.labels.slice();\n\n        for (var i = 0; i < gl.series.length; i++) {\n          if (gl.seriesNames[i] === undefined) {\n            gl.seriesNames.push('series-' + (i + 1));\n          }\n        }\n\n        return this.w;\n      }\n      /** User possibly set string categories in xaxis.categories or labels prop\n       * Or didn't set xaxis labels at all - in which case we manually do it.\n       * If user passed series data as [[3, 2], [4, 5]] or [{ x: 3, y: 55 }],\n       * this shouldn't be called\n       * @param {array} ser - the series which user passed to the config\n       */\n\n    }, {\n      key: \"handleExternalLabelsData\",\n      value: function handleExternalLabelsData(ser) {\n        var cnf = this.w.config;\n        var gl = this.w.globals;\n\n        if (cnf.xaxis.categories.length > 0) {\n          // user provided labels in xaxis.category prop\n          gl.labels = cnf.xaxis.categories;\n        } else if (cnf.labels.length > 0) {\n          // user provided labels in labels props\n          gl.labels = cnf.labels.slice();\n        } else if (this.fallbackToCategory) {\n          // user provided labels in x prop in [{ x: 3, y: 55 }] data, and those labels are already stored in gl.labels[0], so just re-arrange the gl.labels array\n          gl.labels = gl.labels[0];\n\n          if (gl.seriesRange.length) {\n            gl.seriesRange.map(function (srt) {\n              srt.forEach(function (sr) {\n                if (gl.labels.indexOf(sr.x) < 0 && sr.x) {\n                  gl.labels.push(sr.x);\n                }\n              });\n            }); // remove duplicate x-axis labels\n\n            gl.labels = Array.from(new Set(gl.labels.map(JSON.stringify)), JSON.parse);\n          }\n\n          if (cnf.xaxis.convertedCatToNumeric) {\n            var defaults = new Defaults(cnf);\n            defaults.convertCatToNumericXaxis(cnf, this.ctx, gl.seriesX[0]);\n\n            this._generateExternalLabels(ser);\n          }\n        } else {\n          this._generateExternalLabels(ser);\n        }\n      }\n    }, {\n      key: \"_generateExternalLabels\",\n      value: function _generateExternalLabels(ser) {\n        var gl = this.w.globals;\n        var cnf = this.w.config; // user didn't provided any labels, fallback to 1-2-3-4-5\n\n        var labelArr = [];\n\n        if (gl.axisCharts) {\n          if (gl.series.length > 0) {\n            if (this.isFormatXY()) {\n              // in case there is a combo chart (boxplot/scatter)\n              // and there are duplicated x values, we need to eliminate duplicates\n              var seriesDataFiltered = cnf.series.map(function (serie, s) {\n                return serie.data.filter(function (v, i, a) {\n                  return a.findIndex(function (t) {\n                    return t.x === v.x;\n                  }) === i;\n                });\n              });\n              var len = seriesDataFiltered.reduce(function (p, c, i, a) {\n                return a[p].length > c.length ? p : i;\n              }, 0);\n\n              for (var i = 0; i < seriesDataFiltered[len].length; i++) {\n                labelArr.push(i + 1);\n              }\n            } else {\n              for (var _i = 0; _i < gl.series[gl.maxValsInArrayIndex].length; _i++) {\n                labelArr.push(_i + 1);\n              }\n            }\n          }\n\n          gl.seriesX = []; // create gl.seriesX as it will be used in calculations of x positions\n\n          for (var _i2 = 0; _i2 < ser.length; _i2++) {\n            gl.seriesX.push(labelArr);\n          } // turn on the isXNumeric flag to allow minX and maxX to function properly\n\n\n          if (!this.w.globals.isBarHorizontal) {\n            gl.isXNumeric = true;\n          }\n        } // no series to pull labels from, put a 0-10 series\n        // possibly, user collapsed all series. Hence we can't work with above calc\n\n\n        if (labelArr.length === 0) {\n          labelArr = gl.axisCharts ? [] : gl.series.map(function (gls, glsi) {\n            return glsi + 1;\n          });\n\n          for (var _i3 = 0; _i3 < ser.length; _i3++) {\n            gl.seriesX.push(labelArr);\n          }\n        } // Finally, pass the labelArr in gl.labels which will be printed on x-axis\n\n\n        gl.labels = labelArr;\n\n        if (cnf.xaxis.convertedCatToNumeric) {\n          gl.categoryLabels = labelArr.map(function (l) {\n            return cnf.xaxis.labels.formatter(l);\n          });\n        } // Turn on this global flag to indicate no labels were provided by user\n\n\n        gl.noLabelsProvided = true;\n      } // Segregate user provided data into appropriate vars\n\n    }, {\n      key: \"parseData\",\n      value: function parseData(ser) {\n        var w = this.w;\n        var cnf = w.config;\n        var gl = w.globals;\n        this.excludeCollapsedSeriesInYAxis(); // If we detected string in X prop of series, we fallback to category x-axis\n\n        this.fallbackToCategory = false;\n        this.ctx.core.resetGlobals();\n        this.ctx.core.isMultipleY();\n\n        if (gl.axisCharts) {\n          // axisCharts includes line / area / column / scatter\n          this.parseDataAxisCharts(ser);\n          this.coreUtils.getLargestSeries();\n        } else {\n          // non-axis charts are pie / donut\n          this.parseDataNonAxisCharts(ser);\n        } // set Null values to 0 in all series when user hides/shows some series\n\n\n        if (cnf.chart.stacked) {\n          var series = new Series(this.ctx);\n          gl.series = series.setNullSeriesToZeroValues(gl.series);\n        }\n\n        this.coreUtils.getSeriesTotals();\n\n        if (gl.axisCharts) {\n          gl.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals();\n        }\n\n        this.coreUtils.getPercentSeries();\n\n        if (!gl.dataFormatXNumeric && (!gl.isXNumeric || cnf.xaxis.type === 'numeric' && cnf.labels.length === 0 && cnf.xaxis.categories.length === 0)) {\n          // x-axis labels couldn't be detected; hence try searching every option in config\n          this.handleExternalLabelsData(ser);\n        } // check for multiline xaxis\n\n\n        var catLabels = this.coreUtils.getCategoryLabels(gl.labels);\n\n        for (var l = 0; l < catLabels.length; l++) {\n          if (Array.isArray(catLabels[l])) {\n            gl.isMultiLineX = true;\n            break;\n          }\n        }\n      }\n    }, {\n      key: \"excludeCollapsedSeriesInYAxis\",\n      value: function excludeCollapsedSeriesInYAxis() {\n        var _this2 = this;\n\n        var w = this.w;\n        w.globals.ignoreYAxisIndexes = w.globals.collapsedSeries.map(function (collapsed, i) {\n          // fix issue #1215\n          // if stacked, not returning collapsed.index to preserve yaxis\n          if (_this2.w.globals.isMultipleYAxis && !w.config.chart.stacked) {\n            return collapsed.index;\n          }\n        });\n      }\n    }]);\n\n    return Data;\n  }();\n\n  var AxesUtils = /*#__PURE__*/function () {\n    function AxesUtils(ctx) {\n      _classCallCheck(this, AxesUtils);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    } // Based on the formatter function, get the label text and position\n\n\n    _createClass(AxesUtils, [{\n      key: \"getLabel\",\n      value: function getLabel(labels, timescaleLabels, x, i) {\n        var drawnLabels = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n        var fontSize = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '12px';\n        var isLeafGroup = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n        var w = this.w;\n        var rawLabel = typeof labels[i] === 'undefined' ? '' : labels[i];\n        var label = rawLabel;\n        var xlbFormatter = w.globals.xLabelFormatter;\n        var customFormatter = w.config.xaxis.labels.formatter;\n        var isBold = false;\n        var xFormat = new Formatters(this.ctx);\n        var timestamp = rawLabel;\n\n        if (isLeafGroup) {\n          label = xFormat.xLabelFormat(xlbFormatter, rawLabel, timestamp, {\n            i: i,\n            dateFormatter: new DateTime(this.ctx).formatDate,\n            w: w\n          });\n\n          if (customFormatter !== undefined) {\n            label = customFormatter(rawLabel, labels[i], {\n              i: i,\n              dateFormatter: new DateTime(this.ctx).formatDate,\n              w: w\n            });\n          }\n        }\n\n        var determineHighestUnit = function determineHighestUnit(unit) {\n          var highestUnit = null;\n          timescaleLabels.forEach(function (t) {\n            if (t.unit === 'month') {\n              highestUnit = 'year';\n            } else if (t.unit === 'day') {\n              highestUnit = 'month';\n            } else if (t.unit === 'hour') {\n              highestUnit = 'day';\n            } else if (t.unit === 'minute') {\n              highestUnit = 'hour';\n            }\n          });\n          return highestUnit === unit;\n        };\n\n        if (timescaleLabels.length > 0) {\n          isBold = determineHighestUnit(timescaleLabels[i].unit);\n          x = timescaleLabels[i].position;\n          label = timescaleLabels[i].value;\n        } else {\n          if (w.config.xaxis.type === 'datetime' && customFormatter === undefined) {\n            label = '';\n          }\n        }\n\n        if (typeof label === 'undefined') label = '';\n        label = Array.isArray(label) ? label : label.toString();\n        var graphics = new Graphics(this.ctx);\n        var textRect = {};\n\n        if (w.globals.rotateXLabels && isLeafGroup) {\n          textRect = graphics.getTextRects(label, parseInt(fontSize, 10), null, \"rotate(\".concat(w.config.xaxis.labels.rotate, \" 0 0)\"), false);\n        } else {\n          textRect = graphics.getTextRects(label, parseInt(fontSize, 10));\n        }\n\n        var allowDuplicatesInTimeScale = !w.config.xaxis.labels.showDuplicates && this.ctx.timeScale;\n\n        if (!Array.isArray(label) && (label.indexOf('NaN') === 0 || label.toLowerCase().indexOf('invalid') === 0 || label.toLowerCase().indexOf('infinity') >= 0 || drawnLabels.indexOf(label) >= 0 && allowDuplicatesInTimeScale)) {\n          label = '';\n        }\n\n        return {\n          x: x,\n          text: label,\n          textRect: textRect,\n          isBold: isBold\n        };\n      }\n    }, {\n      key: \"checkLabelBasedOnTickamount\",\n      value: function checkLabelBasedOnTickamount(i, label, labelsLen) {\n        var w = this.w;\n        var ticks = w.config.xaxis.tickAmount;\n        if (ticks === 'dataPoints') ticks = Math.round(w.globals.gridWidth / 120);\n        if (ticks > labelsLen) return label;\n        var tickMultiple = Math.round(labelsLen / (ticks + 1));\n\n        if (i % tickMultiple === 0) {\n          return label;\n        } else {\n          label.text = '';\n        }\n\n        return label;\n      }\n    }, {\n      key: \"checkForOverflowingLabels\",\n      value: function checkForOverflowingLabels(i, label, labelsLen, drawnLabels, drawnLabelsRects) {\n        var w = this.w;\n\n        if (i === 0) {\n          // check if first label is being truncated\n          if (w.globals.skipFirstTimelinelabel) {\n            label.text = '';\n          }\n        }\n\n        if (i === labelsLen - 1) {\n          // check if last label is being truncated\n          if (w.globals.skipLastTimelinelabel) {\n            label.text = '';\n          }\n        }\n\n        if (w.config.xaxis.labels.hideOverlappingLabels && drawnLabels.length > 0) {\n          var prev = drawnLabelsRects[drawnLabelsRects.length - 1];\n\n          if (label.x < prev.textRect.width / (w.globals.rotateXLabels ? Math.abs(w.config.xaxis.labels.rotate) / 12 : 1.01) + prev.x) {\n            label.text = '';\n          }\n        }\n\n        return label;\n      }\n    }, {\n      key: \"checkForReversedLabels\",\n      value: function checkForReversedLabels(i, labels) {\n        var w = this.w;\n\n        if (w.config.yaxis[i] && w.config.yaxis[i].reversed) {\n          labels.reverse();\n        }\n\n        return labels;\n      }\n    }, {\n      key: \"isYAxisHidden\",\n      value: function isYAxisHidden(index) {\n        var w = this.w;\n        var coreUtils = new CoreUtils(this.ctx);\n        return !w.config.yaxis[index].show || !w.config.yaxis[index].showForNullSeries && coreUtils.isSeriesNull(index) && w.globals.collapsedSeriesIndices.indexOf(index) === -1;\n      } // get the label color for y-axis\n      // realIndex is the actual series index, while i is the tick Index\n\n    }, {\n      key: \"getYAxisForeColor\",\n      value: function getYAxisForeColor(yColors, realIndex) {\n        var w = this.w;\n\n        if (Array.isArray(yColors) && w.globals.yAxisScale[realIndex]) {\n          this.ctx.theme.pushExtraColors(yColors, w.globals.yAxisScale[realIndex].result.length, false);\n        }\n\n        return yColors;\n      }\n    }, {\n      key: \"drawYAxisTicks\",\n      value: function drawYAxisTicks(x, tickAmount, axisBorder, axisTicks, realIndex, labelsDivider, elYaxis) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx); // initial label position = 0;\n\n        var t = w.globals.translateY;\n\n        if (axisTicks.show && tickAmount > 0) {\n          if (w.config.yaxis[realIndex].opposite === true) x = x + axisTicks.width;\n\n          for (var i = tickAmount; i >= 0; i--) {\n            var tY = t + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY - 1;\n\n            if (w.globals.isBarHorizontal) {\n              tY = labelsDivider * i;\n            }\n\n            if (w.config.chart.type === 'heatmap') {\n              tY = tY + labelsDivider / 2;\n            }\n\n            var elTick = graphics.drawLine(x + axisBorder.offsetX - axisTicks.width + axisTicks.offsetX, tY + axisTicks.offsetY, x + axisBorder.offsetX + axisTicks.offsetX, tY + axisTicks.offsetY, axisTicks.color);\n            elYaxis.add(elTick);\n            t = t + labelsDivider;\n          }\n        }\n      }\n    }]);\n\n    return AxesUtils;\n  }();\n\n  var Exports = /*#__PURE__*/function () {\n    function Exports(ctx) {\n      _classCallCheck(this, Exports);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(Exports, [{\n      key: \"scaleSvgNode\",\n      value: function scaleSvgNode(svg, scale) {\n        // get current both width and height of the svg\n        var svgWidth = parseFloat(svg.getAttributeNS(null, 'width'));\n        var svgHeight = parseFloat(svg.getAttributeNS(null, 'height')); // set new width and height based on the scale\n\n        svg.setAttributeNS(null, 'width', svgWidth * scale);\n        svg.setAttributeNS(null, 'height', svgHeight * scale);\n        svg.setAttributeNS(null, 'viewBox', '0 0 ' + svgWidth + ' ' + svgHeight);\n      }\n    }, {\n      key: \"fixSvgStringForIe11\",\n      value: function fixSvgStringForIe11(svgData) {\n        // IE11 generates broken SVG that we have to fix by using regex\n        if (!Utils$1.isIE11()) {\n          // not IE11 - noop\n          return svgData.replace(/&nbsp;/g, '&#160;');\n        } // replace second occurrence of \"xmlns\" attribute with \"xmlns:xlink\" with correct url + add xmlns:svgjs\n\n\n        var nXmlnsSeen = 0;\n        var result = svgData.replace(/xmlns=\"http:\\/\\/www.w3.org\\/2000\\/svg\"/g, function (match) {\n          nXmlnsSeen++;\n          return nXmlnsSeen === 2 ? 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.dev\"' : match;\n        }); // remove the invalid empty namespace declarations\n\n        result = result.replace(/xmlns:NS\\d+=\"\"/g, ''); // remove these broken namespaces from attributes\n\n        result = result.replace(/NS\\d+:(\\w+:\\w+=\")/g, '$1');\n        return result;\n      }\n    }, {\n      key: \"getSvgString\",\n      value: function getSvgString(scale) {\n        if (scale == undefined) {\n          scale = 1; // if no scale is specified, don't scale...\n        }\n\n        var svgString = this.w.globals.dom.Paper.svg(); // in case the scale is different than 1, the svg needs to be rescaled\n\n        if (scale !== 1) {\n          // clone the svg node so it remains intact in the UI\n          var svgNode = this.w.globals.dom.Paper.node.cloneNode(true); // scale the image\n\n          this.scaleSvgNode(svgNode, scale); // get the string representation of the svgNode\n\n          svgString = new XMLSerializer().serializeToString(svgNode);\n        }\n\n        return this.fixSvgStringForIe11(svgString);\n      }\n    }, {\n      key: \"cleanup\",\n      value: function cleanup() {\n        var w = this.w; // hide some elements to avoid printing them on exported svg\n\n        var xcrosshairs = w.globals.dom.baseEl.getElementsByClassName('apexcharts-xcrosshairs');\n        var ycrosshairs = w.globals.dom.baseEl.getElementsByClassName('apexcharts-ycrosshairs');\n        var zoomSelectionRects = w.globals.dom.baseEl.querySelectorAll('.apexcharts-zoom-rect, .apexcharts-selection-rect');\n        Array.prototype.forEach.call(zoomSelectionRects, function (z) {\n          z.setAttribute('width', 0);\n        });\n\n        if (xcrosshairs && xcrosshairs[0]) {\n          xcrosshairs[0].setAttribute('x', -500);\n          xcrosshairs[0].setAttribute('x1', -500);\n          xcrosshairs[0].setAttribute('x2', -500);\n        }\n\n        if (ycrosshairs && ycrosshairs[0]) {\n          ycrosshairs[0].setAttribute('y', -100);\n          ycrosshairs[0].setAttribute('y1', -100);\n          ycrosshairs[0].setAttribute('y2', -100);\n        }\n      }\n    }, {\n      key: \"svgUrl\",\n      value: function svgUrl() {\n        this.cleanup();\n        var svgData = this.getSvgString();\n        var svgBlob = new Blob([svgData], {\n          type: 'image/svg+xml;charset=utf-8'\n        });\n        return URL.createObjectURL(svgBlob);\n      }\n    }, {\n      key: \"dataURI\",\n      value: function dataURI(options) {\n        var _this = this;\n\n        return new Promise(function (resolve) {\n          var w = _this.w;\n          var scale = options ? options.scale || options.width / w.globals.svgWidth : 1;\n\n          _this.cleanup();\n\n          var canvas = document.createElement('canvas');\n          canvas.width = w.globals.svgWidth * scale;\n          canvas.height = parseInt(w.globals.dom.elWrap.style.height, 10) * scale; // because of resizeNonAxisCharts\n\n          var canvasBg = w.config.chart.background === 'transparent' ? '#fff' : w.config.chart.background;\n          var ctx = canvas.getContext('2d');\n          ctx.fillStyle = canvasBg;\n          ctx.fillRect(0, 0, canvas.width * scale, canvas.height * scale);\n\n          var svgData = _this.getSvgString(scale);\n\n          if (window.canvg && Utils$1.isIE11()) {\n            // use canvg as a polyfill to workaround ie11 considering a canvas with loaded svg 'unsafe'\n            // without ignoreClear we lose our background color; without ignoreDimensions some grid lines become invisible\n            var v = window.canvg.Canvg.fromString(ctx, svgData, {\n              ignoreClear: true,\n              ignoreDimensions: true\n            }); // render the svg to canvas\n\n            v.start();\n            var blob = canvas.msToBlob(); // dispose - missing this will cause a memory leak\n\n            v.stop();\n            resolve({\n              blob: blob\n            });\n          } else {\n            var svgUrl = 'data:image/svg+xml,' + encodeURIComponent(svgData);\n            var img = new Image();\n            img.crossOrigin = 'anonymous';\n\n            img.onload = function () {\n              ctx.drawImage(img, 0, 0);\n\n              if (canvas.msToBlob) {\n                // IE and Edge can't navigate to data urls, so we return the blob instead\n                var _blob = canvas.msToBlob();\n\n                resolve({\n                  blob: _blob\n                });\n              } else {\n                var imgURI = canvas.toDataURL('image/png');\n                resolve({\n                  imgURI: imgURI\n                });\n              }\n            };\n\n            img.src = svgUrl;\n          }\n        });\n      }\n    }, {\n      key: \"exportToSVG\",\n      value: function exportToSVG() {\n        this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, '.svg');\n      }\n    }, {\n      key: \"exportToPng\",\n      value: function exportToPng() {\n        var _this2 = this;\n\n        this.dataURI().then(function (_ref) {\n          var imgURI = _ref.imgURI,\n              blob = _ref.blob;\n\n          if (blob) {\n            navigator.msSaveOrOpenBlob(blob, _this2.w.globals.chartID + '.png');\n          } else {\n            _this2.triggerDownload(imgURI, _this2.w.config.chart.toolbar.export.png.filename, '.png');\n          }\n        });\n      }\n    }, {\n      key: \"exportToCSV\",\n      value: function exportToCSV(_ref2) {\n        var _this3 = this;\n\n        var series = _ref2.series,\n            fileName = _ref2.fileName,\n            _ref2$columnDelimiter = _ref2.columnDelimiter,\n            columnDelimiter = _ref2$columnDelimiter === void 0 ? ',' : _ref2$columnDelimiter,\n            _ref2$lineDelimiter = _ref2.lineDelimiter,\n            lineDelimiter = _ref2$lineDelimiter === void 0 ? '\\n' : _ref2$lineDelimiter;\n        var w = this.w;\n        if (!series) series = w.config.series;\n        var columns = [];\n        var rows = [];\n        var result = '';\n        var universalBOM = \"\\uFEFF\";\n        var gSeries = w.globals.series.map(function (s, i) {\n          return w.globals.collapsedSeriesIndices.indexOf(i) === -1 ? s : [];\n        });\n\n        var isTimeStamp = function isTimeStamp(num) {\n          return w.config.xaxis.type === 'datetime' && String(num).length >= 10;\n        };\n\n        var seriesMaxDataLength = Math.max.apply(Math, _toConsumableArray(series.map(function (s) {\n          return s.data ? s.data.length : 0;\n        })));\n        var dataFormat = new Data(this.ctx);\n        var axesUtils = new AxesUtils(this.ctx);\n\n        var getCat = function getCat(i) {\n          var cat = ''; // pie / donut/ radial\n\n          if (!w.globals.axisCharts) {\n            cat = w.config.labels[i];\n          } else {\n            // xy charts\n            // non datetime\n            if (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) {\n              if (w.globals.isBarHorizontal) {\n                var lbFormatter = w.globals.yLabelFormatters[0];\n                var sr = new Series(_this3.ctx);\n                var activeSeries = sr.getActiveConfigSeriesIndex();\n                cat = lbFormatter(w.globals.labels[i], {\n                  seriesIndex: activeSeries,\n                  dataPointIndex: i,\n                  w: w\n                });\n              } else {\n                cat = axesUtils.getLabel(w.globals.labels, w.globals.timescaleLabels, 0, i).text;\n              }\n            } // datetime, but labels specified in categories or labels\n\n\n            if (w.config.xaxis.type === 'datetime') {\n              if (w.config.xaxis.categories.length) {\n                cat = w.config.xaxis.categories[i];\n              } else if (w.config.labels.length) {\n                cat = w.config.labels[i];\n              }\n            }\n          }\n\n          if (Array.isArray(cat)) {\n            cat = cat.join(' ');\n          }\n\n          return Utils$1.isNumber(cat) ? cat : cat.split(columnDelimiter).join('');\n        }; // Fix https://github.com/apexcharts/apexcharts.js/issues/3365\n\n\n        var getEmptyDataForCsvColumn = function getEmptyDataForCsvColumn() {\n          return _toConsumableArray(Array(seriesMaxDataLength)).map(function () {\n            return '';\n          });\n        };\n\n        var handleAxisRowsColumns = function handleAxisRowsColumns(s, sI) {\n          if (columns.length && sI === 0) {\n            // It's the first series.  Go ahead and create the first row with header information.\n            rows.push(columns.join(columnDelimiter));\n          }\n\n          if (s.data) {\n            // Use the data we have, or generate a properly sized empty array with empty data if some data is missing.\n            s.data = s.data.length && s.data || getEmptyDataForCsvColumn();\n\n            for (var i = 0; i < s.data.length; i++) {\n              // Reset the columns array so that we can start building columns for this row.\n              columns = [];\n              var cat = getCat(i);\n\n              if (!cat) {\n                if (dataFormat.isFormatXY()) {\n                  cat = series[sI].data[i].x;\n                } else if (dataFormat.isFormat2DArray()) {\n                  cat = series[sI].data[i] ? series[sI].data[i][0] : '';\n                }\n              }\n\n              if (sI === 0) {\n                // It's the first series.  Also handle the category.\n                columns.push(isTimeStamp(cat) ? w.config.chart.toolbar.export.csv.dateFormatter(cat) : Utils$1.isNumber(cat) ? cat : cat.split(columnDelimiter).join(''));\n\n                for (var ci = 0; ci < w.globals.series.length; ci++) {\n                  if (dataFormat.isFormatXY()) {\n                    var _series$ci$data$i;\n\n                    columns.push((_series$ci$data$i = series[ci].data[i]) === null || _series$ci$data$i === void 0 ? void 0 : _series$ci$data$i.y);\n                  } else {\n                    columns.push(gSeries[ci][i]);\n                  }\n                }\n              }\n\n              if (w.config.chart.type === 'candlestick' || s.type && s.type === 'candlestick') {\n                columns.pop();\n                columns.push(w.globals.seriesCandleO[sI][i]);\n                columns.push(w.globals.seriesCandleH[sI][i]);\n                columns.push(w.globals.seriesCandleL[sI][i]);\n                columns.push(w.globals.seriesCandleC[sI][i]);\n              }\n\n              if (w.config.chart.type === 'boxPlot' || s.type && s.type === 'boxPlot') {\n                columns.pop();\n                columns.push(w.globals.seriesCandleO[sI][i]);\n                columns.push(w.globals.seriesCandleH[sI][i]);\n                columns.push(w.globals.seriesCandleM[sI][i]);\n                columns.push(w.globals.seriesCandleL[sI][i]);\n                columns.push(w.globals.seriesCandleC[sI][i]);\n              }\n\n              if (w.config.chart.type === 'rangeBar') {\n                columns.pop();\n                columns.push(w.globals.seriesRangeStart[sI][i]);\n                columns.push(w.globals.seriesRangeEnd[sI][i]);\n              }\n\n              if (columns.length) {\n                rows.push(columns.join(columnDelimiter));\n              }\n            }\n          }\n        };\n\n        columns.push(w.config.chart.toolbar.export.csv.headerCategory);\n\n        if (w.config.chart.type === 'boxPlot') {\n          columns.push('minimum');\n          columns.push('q1');\n          columns.push('median');\n          columns.push('q3');\n          columns.push('maximum');\n        } else if (w.config.chart.type === 'candlestick') {\n          columns.push('open');\n          columns.push('high');\n          columns.push('low');\n          columns.push('close');\n        } else if (w.config.chart.type === 'rangeBar') {\n          columns.push('minimum');\n          columns.push('maximum');\n        } else {\n          series.map(function (s, sI) {\n            var sname = (s.name ? s.name : \"series-\".concat(sI)) + '';\n\n            if (w.globals.axisCharts) {\n              columns.push(sname.split(columnDelimiter).join('') ? sname.split(columnDelimiter).join('') : \"series-\".concat(sI));\n            }\n          });\n        }\n\n        if (!w.globals.axisCharts) {\n          columns.push(w.config.chart.toolbar.export.csv.headerValue);\n          rows.push(columns.join(columnDelimiter));\n        }\n\n        series.map(function (s, sI) {\n          if (w.globals.axisCharts) {\n            handleAxisRowsColumns(s, sI);\n          } else {\n            columns = [];\n            columns.push(w.globals.labels[sI].split(columnDelimiter).join(''));\n            columns.push(gSeries[sI]);\n            rows.push(columns.join(columnDelimiter));\n          }\n        });\n        result += rows.join(lineDelimiter);\n        this.triggerDownload('data:text/csv; charset=utf-8,' + encodeURIComponent(universalBOM + result), fileName ? fileName : w.config.chart.toolbar.export.csv.filename, '.csv');\n      }\n    }, {\n      key: \"triggerDownload\",\n      value: function triggerDownload(href, filename, ext) {\n        var downloadLink = document.createElement('a');\n        downloadLink.href = href;\n        downloadLink.download = (filename ? filename : this.w.globals.chartID) + ext;\n        document.body.appendChild(downloadLink);\n        downloadLink.click();\n        document.body.removeChild(downloadLink);\n      }\n    }]);\n\n    return Exports;\n  }();\n\n  /**\n   * ApexCharts XAxis Class for drawing X-Axis.\n   *\n   * @module XAxis\n   **/\n\n  var XAxis = /*#__PURE__*/function () {\n    function XAxis(ctx, elgrid) {\n      _classCallCheck(this, XAxis);\n\n      this.ctx = ctx;\n      this.elgrid = elgrid;\n      this.w = ctx.w;\n      var w = this.w;\n      this.axesUtils = new AxesUtils(ctx);\n      this.xaxisLabels = w.globals.labels.slice();\n\n      if (w.globals.timescaleLabels.length > 0 && !w.globals.isBarHorizontal) {\n        //  timeline labels are there and chart is not rangeabr timeline\n        this.xaxisLabels = w.globals.timescaleLabels.slice();\n      }\n\n      if (w.config.xaxis.overwriteCategories) {\n        this.xaxisLabels = w.config.xaxis.overwriteCategories;\n      }\n\n      this.drawnLabels = [];\n      this.drawnLabelsRects = [];\n\n      if (w.config.xaxis.position === 'top') {\n        this.offY = 0;\n      } else {\n        this.offY = w.globals.gridHeight + 1;\n      }\n\n      this.offY = this.offY + w.config.xaxis.axisBorder.offsetY;\n      this.isCategoryBarHorizontal = w.config.chart.type === 'bar' && w.config.plotOptions.bar.horizontal;\n      this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;\n      this.xaxisFontFamily = w.config.xaxis.labels.style.fontFamily;\n      this.xaxisForeColors = w.config.xaxis.labels.style.colors;\n      this.xaxisBorderWidth = w.config.xaxis.axisBorder.width;\n\n      if (this.isCategoryBarHorizontal) {\n        this.xaxisBorderWidth = w.config.yaxis[0].axisBorder.width.toString();\n      }\n\n      if (this.xaxisBorderWidth.indexOf('%') > -1) {\n        this.xaxisBorderWidth = w.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100;\n      } else {\n        this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10);\n      }\n\n      this.xaxisBorderHeight = w.config.xaxis.axisBorder.height; // For bars, we will only consider single y xais,\n      // as we are not providing multiple yaxis for bar charts\n\n      this.yaxis = w.config.yaxis[0];\n    }\n\n    _createClass(XAxis, [{\n      key: \"drawXaxis\",\n      value: function drawXaxis() {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var elXaxis = graphics.group({\n          class: 'apexcharts-xaxis',\n          transform: \"translate(\".concat(w.config.xaxis.offsetX, \", \").concat(w.config.xaxis.offsetY, \")\")\n        });\n        var elXaxisTexts = graphics.group({\n          class: 'apexcharts-xaxis-texts-g',\n          transform: \"translate(\".concat(w.globals.translateXAxisX, \", \").concat(w.globals.translateXAxisY, \")\")\n        });\n        elXaxis.add(elXaxisTexts);\n        var labels = [];\n\n        for (var i = 0; i < this.xaxisLabels.length; i++) {\n          labels.push(this.xaxisLabels[i]);\n        }\n\n        this.drawXAxisLabelAndGroup(true, graphics, elXaxisTexts, labels, w.globals.isXNumeric, function (i, colWidth) {\n          return colWidth;\n        });\n\n        if (w.globals.hasXaxisGroups) {\n          var labelsGroup = w.globals.groups;\n          labels = [];\n\n          for (var _i = 0; _i < labelsGroup.length; _i++) {\n            labels.push(labelsGroup[_i].title);\n          }\n\n          var overwriteStyles = {};\n\n          if (w.config.xaxis.group.style) {\n            overwriteStyles.xaxisFontSize = w.config.xaxis.group.style.fontSize;\n            overwriteStyles.xaxisFontFamily = w.config.xaxis.group.style.fontFamily;\n            overwriteStyles.xaxisForeColors = w.config.xaxis.group.style.colors;\n            overwriteStyles.fontWeight = w.config.xaxis.group.style.fontWeight;\n            overwriteStyles.cssClass = w.config.xaxis.group.style.cssClass;\n          }\n\n          this.drawXAxisLabelAndGroup(false, graphics, elXaxisTexts, labels, false, function (i, colWidth) {\n            return labelsGroup[i].cols * colWidth;\n          }, overwriteStyles);\n        }\n\n        if (w.config.xaxis.title.text !== undefined) {\n          var elXaxisTitle = graphics.group({\n            class: 'apexcharts-xaxis-title'\n          });\n          var elXAxisTitleText = graphics.drawText({\n            x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,\n            y: this.offY + parseFloat(this.xaxisFontSize) + (w.config.xaxis.position === 'bottom' ? w.globals.xAxisLabelsHeight : -w.globals.xAxisLabelsHeight - 10) + w.config.xaxis.title.offsetY,\n            text: w.config.xaxis.title.text,\n            textAnchor: 'middle',\n            fontSize: w.config.xaxis.title.style.fontSize,\n            fontFamily: w.config.xaxis.title.style.fontFamily,\n            fontWeight: w.config.xaxis.title.style.fontWeight,\n            foreColor: w.config.xaxis.title.style.color,\n            cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass\n          });\n          elXaxisTitle.add(elXAxisTitleText);\n          elXaxis.add(elXaxisTitle);\n        }\n\n        if (w.config.xaxis.axisBorder.show) {\n          var offX = w.globals.barPadForNumericAxis;\n          var elHorzLine = graphics.drawLine(w.globals.padHorizontal + w.config.xaxis.axisBorder.offsetX - offX, this.offY, this.xaxisBorderWidth + offX, this.offY, w.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);\n\n          if (this.elgrid && this.elgrid.elGridBorders && w.config.grid.show) {\n            this.elgrid.elGridBorders.add(elHorzLine);\n          } else {\n            elXaxis.add(elHorzLine);\n          }\n        }\n\n        return elXaxis;\n      }\n    }, {\n      key: \"drawXAxisLabelAndGroup\",\n      value: function drawXAxisLabelAndGroup(isLeafGroup, graphics, elXaxisTexts, labels, isXNumeric, colWidthCb) {\n        var _this = this;\n\n        var overwriteStyles = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n        var drawnLabels = [];\n        var drawnLabelsRects = [];\n        var w = this.w;\n        var xaxisFontSize = overwriteStyles.xaxisFontSize || this.xaxisFontSize;\n        var xaxisFontFamily = overwriteStyles.xaxisFontFamily || this.xaxisFontFamily;\n        var xaxisForeColors = overwriteStyles.xaxisForeColors || this.xaxisForeColors;\n        var fontWeight = overwriteStyles.fontWeight || w.config.xaxis.labels.style.fontWeight;\n        var cssClass = overwriteStyles.cssClass || w.config.xaxis.labels.style.cssClass;\n        var colWidth; // initial x Position (keep adding column width in the loop)\n\n        var xPos = w.globals.padHorizontal;\n        var labelsLen = labels.length;\n        /**\n         * labelsLen can be different (whether you are drawing x-axis labels or x-axis group labels)\n         * hence, we introduce dataPoints to be consistent.\n         * Also, in datetime/numeric xaxis, dataPoints can be misleading, so we resort to labelsLen for such xaxis type\n         */\n\n        var dataPoints = w.config.xaxis.type === 'category' ? w.globals.dataPoints : labelsLen; // when all series are collapsed, fixes #3381\n\n        if (dataPoints === 0 && labelsLen > dataPoints) dataPoints = labelsLen;\n\n        if (isXNumeric) {\n          var len = dataPoints > 1 ? dataPoints - 1 : dataPoints;\n          colWidth = w.globals.gridWidth / Math.min(len, labelsLen - 1);\n          xPos = xPos + colWidthCb(0, colWidth) / 2 + w.config.xaxis.labels.offsetX;\n        } else {\n          colWidth = w.globals.gridWidth / dataPoints;\n          xPos = xPos + colWidthCb(0, colWidth) + w.config.xaxis.labels.offsetX;\n        }\n\n        var _loop = function _loop(i) {\n          var x = xPos - colWidthCb(i, colWidth) / 2 + w.config.xaxis.labels.offsetX;\n\n          if (i === 0 && labelsLen === 1 && colWidth / 2 === xPos && dataPoints === 1) {\n            // single datapoint\n            x = w.globals.gridWidth / 2;\n          }\n\n          var label = _this.axesUtils.getLabel(labels, w.globals.timescaleLabels, x, i, drawnLabels, xaxisFontSize, isLeafGroup);\n\n          var offsetYCorrection = 28;\n\n          if (w.globals.rotateXLabels && isLeafGroup) {\n            offsetYCorrection = 22;\n          }\n\n          if (w.config.xaxis.title.text && w.config.xaxis.position === 'top') {\n            offsetYCorrection += parseFloat(w.config.xaxis.title.style.fontSize) + 2;\n          }\n\n          if (!isLeafGroup) {\n            offsetYCorrection = offsetYCorrection + parseFloat(xaxisFontSize) + (w.globals.xAxisLabelsHeight - w.globals.xAxisGroupLabelsHeight) + (w.globals.rotateXLabels ? 10 : 0);\n          }\n\n          var isCategoryTickAmounts = typeof w.config.xaxis.tickAmount !== 'undefined' && w.config.xaxis.tickAmount !== 'dataPoints' && w.config.xaxis.type !== 'datetime';\n\n          if (isCategoryTickAmounts) {\n            label = _this.axesUtils.checkLabelBasedOnTickamount(i, label, labelsLen);\n          } else {\n            label = _this.axesUtils.checkForOverflowingLabels(i, label, labelsLen, drawnLabels, drawnLabelsRects);\n          }\n\n          var getCatForeColor = function getCatForeColor() {\n            return isLeafGroup && w.config.xaxis.convertedCatToNumeric ? xaxisForeColors[w.globals.minX + i - 1] : xaxisForeColors[i];\n          };\n\n          if (w.config.xaxis.labels.show) {\n            var elText = graphics.drawText({\n              x: label.x,\n              y: _this.offY + w.config.xaxis.labels.offsetY + offsetYCorrection - (w.config.xaxis.position === 'top' ? w.globals.xAxisHeight + w.config.xaxis.axisTicks.height - 2 : 0),\n              text: label.text,\n              textAnchor: 'middle',\n              fontWeight: label.isBold ? 600 : fontWeight,\n              fontSize: xaxisFontSize,\n              fontFamily: xaxisFontFamily,\n              foreColor: Array.isArray(xaxisForeColors) ? getCatForeColor() : xaxisForeColors,\n              isPlainText: false,\n              cssClass: (isLeafGroup ? 'apexcharts-xaxis-label ' : 'apexcharts-xaxis-group-label ') + cssClass\n            });\n            elXaxisTexts.add(elText);\n            elText.on('click', function (e) {\n              if (typeof w.config.chart.events.xAxisLabelClick === 'function') {\n                var opts = Object.assign({}, w, {\n                  labelIndex: i\n                });\n                w.config.chart.events.xAxisLabelClick(e, _this.ctx, opts);\n              }\n            });\n\n            if (isLeafGroup) {\n              var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n              elTooltipTitle.textContent = Array.isArray(label.text) ? label.text.join(' ') : label.text;\n              elText.node.appendChild(elTooltipTitle);\n\n              if (label.text !== '') {\n                drawnLabels.push(label.text);\n                drawnLabelsRects.push(label);\n              }\n            }\n          }\n\n          if (i < labelsLen - 1) {\n            xPos = xPos + colWidthCb(i + 1, colWidth);\n          }\n        };\n\n        for (var i = 0; i <= labelsLen - 1; i++) {\n          _loop(i);\n        }\n      } // this actually becomes the vertical axis (for bar charts)\n\n    }, {\n      key: \"drawXaxisInversed\",\n      value: function drawXaxisInversed(realIndex) {\n        var _this2 = this;\n\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var translateYAxisX = w.config.yaxis[0].opposite ? w.globals.translateYAxisX[realIndex] : 0;\n        var elYaxis = graphics.group({\n          class: 'apexcharts-yaxis apexcharts-xaxis-inversed',\n          rel: realIndex\n        });\n        var elYaxisTexts = graphics.group({\n          class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g',\n          transform: 'translate(' + translateYAxisX + ', 0)'\n        });\n        elYaxis.add(elYaxisTexts);\n        var colHeight; // initial x Position (keep adding column width in the loop)\n\n        var yPos;\n        var labels = [];\n\n        if (w.config.yaxis[realIndex].show) {\n          for (var i = 0; i < this.xaxisLabels.length; i++) {\n            labels.push(this.xaxisLabels[i]);\n          }\n        }\n\n        colHeight = w.globals.gridHeight / labels.length;\n        yPos = -(colHeight / 2.2);\n        var lbFormatter = w.globals.yLabelFormatters[0];\n        var ylabels = w.config.yaxis[0].labels;\n\n        if (ylabels.show) {\n          var _loop2 = function _loop2(_i2) {\n            var label = typeof labels[_i2] === 'undefined' ? '' : labels[_i2];\n            label = lbFormatter(label, {\n              seriesIndex: realIndex,\n              dataPointIndex: _i2,\n              w: w\n            });\n\n            var yColors = _this2.axesUtils.getYAxisForeColor(ylabels.style.colors, realIndex);\n\n            var getForeColor = function getForeColor() {\n              return Array.isArray(yColors) ? yColors[_i2] : yColors;\n            };\n\n            var multiY = 0;\n\n            if (Array.isArray(label)) {\n              multiY = label.length / 2 * parseInt(ylabels.style.fontSize, 10);\n            }\n\n            var offsetX = ylabels.offsetX - 15;\n            var textAnchor = 'end';\n\n            if (_this2.yaxis.opposite) {\n              textAnchor = 'start';\n            }\n\n            if (w.config.yaxis[0].labels.align === 'left') {\n              offsetX = ylabels.offsetX;\n              textAnchor = 'start';\n            } else if (w.config.yaxis[0].labels.align === 'center') {\n              offsetX = ylabels.offsetX;\n              textAnchor = 'middle';\n            } else if (w.config.yaxis[0].labels.align === 'right') {\n              textAnchor = 'end';\n            }\n\n            var elLabel = graphics.drawText({\n              x: offsetX,\n              y: yPos + colHeight + ylabels.offsetY - multiY,\n              text: label,\n              textAnchor: textAnchor,\n              foreColor: getForeColor(),\n              fontSize: ylabels.style.fontSize,\n              fontFamily: ylabels.style.fontFamily,\n              fontWeight: ylabels.style.fontWeight,\n              isPlainText: false,\n              cssClass: 'apexcharts-yaxis-label ' + ylabels.style.cssClass,\n              maxWidth: ylabels.maxWidth\n            });\n            elYaxisTexts.add(elLabel);\n            elLabel.on('click', function (e) {\n              if (typeof w.config.chart.events.xAxisLabelClick === 'function') {\n                var opts = Object.assign({}, w, {\n                  labelIndex: _i2\n                });\n                w.config.chart.events.xAxisLabelClick(e, _this2.ctx, opts);\n              }\n            });\n            var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n            elTooltipTitle.textContent = Array.isArray(label) ? label.join(' ') : label;\n            elLabel.node.appendChild(elTooltipTitle);\n\n            if (w.config.yaxis[realIndex].labels.rotate !== 0) {\n              var labelRotatingCenter = graphics.rotateAroundCenter(elLabel.node);\n              elLabel.node.setAttribute('transform', \"rotate(\".concat(w.config.yaxis[realIndex].labels.rotate, \" 0 \").concat(labelRotatingCenter.y, \")\"));\n            }\n\n            yPos = yPos + colHeight;\n          };\n\n          for (var _i2 = 0; _i2 <= labels.length - 1; _i2++) {\n            _loop2(_i2);\n          }\n        }\n\n        if (w.config.yaxis[0].title.text !== undefined) {\n          var elXaxisTitle = graphics.group({\n            class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed',\n            transform: 'translate(' + translateYAxisX + ', 0)'\n          });\n          var elXAxisTitleText = graphics.drawText({\n            x: w.config.yaxis[0].title.offsetX,\n            y: w.globals.gridHeight / 2 + w.config.yaxis[0].title.offsetY,\n            text: w.config.yaxis[0].title.text,\n            textAnchor: 'middle',\n            foreColor: w.config.yaxis[0].title.style.color,\n            fontSize: w.config.yaxis[0].title.style.fontSize,\n            fontWeight: w.config.yaxis[0].title.style.fontWeight,\n            fontFamily: w.config.yaxis[0].title.style.fontFamily,\n            cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[0].title.style.cssClass\n          });\n          elXaxisTitle.add(elXAxisTitleText);\n          elYaxis.add(elXaxisTitle);\n        }\n\n        var offX = 0;\n\n        if (this.isCategoryBarHorizontal && w.config.yaxis[0].opposite) {\n          offX = w.globals.gridWidth;\n        }\n\n        var axisBorder = w.config.xaxis.axisBorder;\n\n        if (axisBorder.show) {\n          var elVerticalLine = graphics.drawLine(w.globals.padHorizontal + axisBorder.offsetX + offX, 1 + axisBorder.offsetY, w.globals.padHorizontal + axisBorder.offsetX + offX, w.globals.gridHeight + axisBorder.offsetY, axisBorder.color, 0);\n\n          if (this.elgrid && this.elgrid.elGridBorders && w.config.grid.show) {\n            this.elgrid.elGridBorders.add(elVerticalLine);\n          } else {\n            elYaxis.add(elVerticalLine);\n          }\n        }\n\n        if (w.config.yaxis[0].axisTicks.show) {\n          this.axesUtils.drawYAxisTicks(offX, labels.length, w.config.yaxis[0].axisBorder, w.config.yaxis[0].axisTicks, 0, colHeight, elYaxis);\n        }\n\n        return elYaxis;\n      }\n    }, {\n      key: \"drawXaxisTicks\",\n      value: function drawXaxisTicks(x1, y2, appendToElement) {\n        var w = this.w;\n        var x2 = x1;\n        if (x1 < 0 || x1 - 2 > w.globals.gridWidth) return;\n        var y1 = this.offY + w.config.xaxis.axisTicks.offsetY;\n        y2 = y2 + y1 + w.config.xaxis.axisTicks.height;\n\n        if (w.config.xaxis.position === 'top') {\n          y2 = y1 - w.config.xaxis.axisTicks.height;\n        }\n\n        if (w.config.xaxis.axisTicks.show) {\n          var graphics = new Graphics(this.ctx);\n          var line = graphics.drawLine(x1 + w.config.xaxis.axisTicks.offsetX, y1 + w.config.xaxis.offsetY, x2 + w.config.xaxis.axisTicks.offsetX, y2 + w.config.xaxis.offsetY, w.config.xaxis.axisTicks.color); // we are not returning anything, but appending directly to the element passed in param\n\n          appendToElement.add(line);\n          line.node.classList.add('apexcharts-xaxis-tick');\n        }\n      }\n    }, {\n      key: \"getXAxisTicksPositions\",\n      value: function getXAxisTicksPositions() {\n        var w = this.w;\n        var xAxisTicksPositions = [];\n        var xCount = this.xaxisLabels.length;\n        var x1 = w.globals.padHorizontal;\n\n        if (w.globals.timescaleLabels.length > 0) {\n          for (var i = 0; i < xCount; i++) {\n            x1 = this.xaxisLabels[i].position;\n            xAxisTicksPositions.push(x1);\n          }\n        } else {\n          var xCountForCategoryCharts = xCount;\n\n          for (var _i3 = 0; _i3 < xCountForCategoryCharts; _i3++) {\n            var x1Count = xCountForCategoryCharts;\n\n            if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {\n              x1Count -= 1;\n            }\n\n            x1 = x1 + w.globals.gridWidth / x1Count;\n            xAxisTicksPositions.push(x1);\n          }\n        }\n\n        return xAxisTicksPositions;\n      } // to rotate x-axis labels or to put ... for longer text in xaxis\n\n    }, {\n      key: \"xAxisLabelCorrections\",\n      value: function xAxisLabelCorrections() {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var xAxis = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g');\n        var xAxisTexts = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)');\n        var yAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text');\n        var xAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text tspan');\n\n        if (w.globals.rotateXLabels || w.config.xaxis.labels.rotateAlways) {\n          for (var xat = 0; xat < xAxisTexts.length; xat++) {\n            var textRotatingCenter = graphics.rotateAroundCenter(xAxisTexts[xat]);\n            textRotatingCenter.y = textRotatingCenter.y - 1; // + tickWidth/4;\n\n            textRotatingCenter.x = textRotatingCenter.x + 1;\n            xAxisTexts[xat].setAttribute('transform', \"rotate(\".concat(w.config.xaxis.labels.rotate, \" \").concat(textRotatingCenter.x, \" \").concat(textRotatingCenter.y, \")\"));\n            xAxisTexts[xat].setAttribute('text-anchor', \"end\");\n            var offsetHeight = 10;\n            xAxis.setAttribute('transform', \"translate(0, \".concat(-offsetHeight, \")\"));\n            var tSpan = xAxisTexts[xat].childNodes;\n\n            if (w.config.xaxis.labels.trim) {\n              Array.prototype.forEach.call(tSpan, function (ts) {\n                graphics.placeTextWithEllipsis(ts, ts.textContent, w.globals.xAxisLabelsHeight - (w.config.legend.position === 'bottom' ? 20 : 10));\n              });\n            }\n          }\n        } else {\n          (function () {\n            var width = w.globals.gridWidth / (w.globals.labels.length + 1);\n\n            for (var _xat = 0; _xat < xAxisTexts.length; _xat++) {\n              var _tSpan = xAxisTexts[_xat].childNodes;\n\n              if (w.config.xaxis.labels.trim && w.config.xaxis.type !== 'datetime') {\n                Array.prototype.forEach.call(_tSpan, function (ts) {\n                  graphics.placeTextWithEllipsis(ts, ts.textContent, width);\n                });\n              }\n            }\n          })();\n        }\n\n        if (yAxisTextsInversed.length > 0) {\n          // truncate rotated y axis in bar chart (x axis)\n          var firstLabelPosX = yAxisTextsInversed[yAxisTextsInversed.length - 1].getBBox();\n          var lastLabelPosX = yAxisTextsInversed[0].getBBox();\n\n          if (firstLabelPosX.x < -20) {\n            yAxisTextsInversed[yAxisTextsInversed.length - 1].parentNode.removeChild(yAxisTextsInversed[yAxisTextsInversed.length - 1]);\n          }\n\n          if (lastLabelPosX.x + lastLabelPosX.width > w.globals.gridWidth && !w.globals.isBarHorizontal) {\n            yAxisTextsInversed[0].parentNode.removeChild(yAxisTextsInversed[0]);\n          } // truncate rotated x axis in bar chart (y axis)\n\n\n          for (var _xat2 = 0; _xat2 < xAxisTextsInversed.length; _xat2++) {\n            graphics.placeTextWithEllipsis(xAxisTextsInversed[_xat2], xAxisTextsInversed[_xat2].textContent, w.config.yaxis[0].labels.maxWidth - (w.config.yaxis[0].title.text ? parseFloat(w.config.yaxis[0].title.style.fontSize) * 2 : 0) - 15);\n          }\n        }\n      } // renderXAxisBands() {\n      //   let w = this.w;\n      //   let plotBand = document.createElementNS(w.globals.SVGNS, 'rect')\n      //   w.globals.dom.elGraphical.add(plotBand)\n      // }\n\n    }]);\n\n    return XAxis;\n  }();\n\n  /**\n   * ApexCharts Grid Class for drawing Cartesian Grid.\n   *\n   * @module Grid\n   **/\n\n  var Grid = /*#__PURE__*/function () {\n    function Grid(ctx) {\n      _classCallCheck(this, Grid);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      var w = this.w;\n      this.xaxisLabels = w.globals.labels.slice();\n      this.axesUtils = new AxesUtils(ctx);\n      this.isRangeBar = w.globals.seriesRange.length && w.globals.isBarHorizontal;\n\n      if (w.globals.timescaleLabels.length > 0) {\n        //  timescaleLabels labels are there\n        this.xaxisLabels = w.globals.timescaleLabels.slice();\n      }\n    } // when using sparklines or when showing no grid, we need to have a grid area which is reused at many places for other calculations as well\n\n\n    _createClass(Grid, [{\n      key: \"drawGridArea\",\n      value: function drawGridArea() {\n        var elGrid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n\n        if (elGrid === null) {\n          elGrid = graphics.group({\n            class: 'apexcharts-grid'\n          });\n        }\n\n        var elVerticalLine = graphics.drawLine(w.globals.padHorizontal, 1, w.globals.padHorizontal, w.globals.gridHeight, 'transparent');\n        var elHorzLine = graphics.drawLine(w.globals.padHorizontal, w.globals.gridHeight, w.globals.gridWidth, w.globals.gridHeight, 'transparent');\n        elGrid.add(elHorzLine);\n        elGrid.add(elVerticalLine);\n        return elGrid;\n      }\n    }, {\n      key: \"drawGrid\",\n      value: function drawGrid() {\n        var gl = this.w.globals;\n        var elgrid = null;\n\n        if (gl.axisCharts) {\n          // grid is drawn after xaxis and yaxis are drawn\n          elgrid = this.renderGrid();\n          this.drawGridArea(elgrid.el);\n        }\n\n        return elgrid;\n      } // This mask will clip off overflowing graphics from the drawable area\n\n    }, {\n      key: \"createGridMask\",\n      value: function createGridMask() {\n        var w = this.w;\n        var gl = w.globals;\n        var graphics = new Graphics(this.ctx);\n        var strokeSize = Array.isArray(w.config.stroke.width) ? 0 : w.config.stroke.width;\n\n        if (Array.isArray(w.config.stroke.width)) {\n          var strokeMaxSize = 0;\n          w.config.stroke.width.forEach(function (m) {\n            strokeMaxSize = Math.max(strokeMaxSize, m);\n          });\n          strokeSize = strokeMaxSize;\n        }\n\n        gl.dom.elGridRectMask = document.createElementNS(gl.SVGNS, 'clipPath');\n        gl.dom.elGridRectMask.setAttribute('id', \"gridRectMask\".concat(gl.cuid));\n        gl.dom.elGridRectMarkerMask = document.createElementNS(gl.SVGNS, 'clipPath');\n        gl.dom.elGridRectMarkerMask.setAttribute('id', \"gridRectMarkerMask\".concat(gl.cuid));\n        gl.dom.elForecastMask = document.createElementNS(gl.SVGNS, 'clipPath');\n        gl.dom.elForecastMask.setAttribute('id', \"forecastMask\".concat(gl.cuid));\n        gl.dom.elNonForecastMask = document.createElementNS(gl.SVGNS, 'clipPath');\n        gl.dom.elNonForecastMask.setAttribute('id', \"nonForecastMask\".concat(gl.cuid)); // let barHalfWidth = 0\n\n        var type = w.config.chart.type;\n        var hasBar = type === 'bar' || type === 'rangeBar' || type === 'candlestick' || type === 'boxPlot' || w.globals.comboBarCount > 0;\n        var barWidthLeft = 0;\n        var barWidthRight = 0;\n\n        if (hasBar && w.globals.isXNumeric && !w.globals.isBarHorizontal) {\n          barWidthLeft = w.config.grid.padding.left;\n          barWidthRight = w.config.grid.padding.right;\n\n          if (gl.barPadForNumericAxis > barWidthLeft) {\n            barWidthLeft = gl.barPadForNumericAxis;\n            barWidthRight = gl.barPadForNumericAxis;\n          }\n        }\n\n        gl.dom.elGridRect = graphics.drawRect(-strokeSize / 2 - barWidthLeft - 2, -strokeSize / 2, gl.gridWidth + strokeSize + barWidthRight + barWidthLeft + 4, gl.gridHeight + strokeSize, 0, '#fff');\n        var markerSize = w.globals.markers.largestSize + 1;\n        gl.dom.elGridRectMarker = graphics.drawRect(-markerSize * 2, -markerSize * 2, gl.gridWidth + markerSize * 4, gl.gridHeight + markerSize * 4, 0, '#fff');\n        gl.dom.elGridRectMask.appendChild(gl.dom.elGridRect.node);\n        gl.dom.elGridRectMarkerMask.appendChild(gl.dom.elGridRectMarker.node);\n        var defs = gl.dom.baseEl.querySelector('defs');\n        defs.appendChild(gl.dom.elGridRectMask);\n        defs.appendChild(gl.dom.elForecastMask);\n        defs.appendChild(gl.dom.elNonForecastMask);\n        defs.appendChild(gl.dom.elGridRectMarkerMask);\n      }\n    }, {\n      key: \"_drawGridLines\",\n      value: function _drawGridLines(_ref) {\n        var i = _ref.i,\n            x1 = _ref.x1,\n            y1 = _ref.y1,\n            x2 = _ref.x2,\n            y2 = _ref.y2,\n            xCount = _ref.xCount,\n            parent = _ref.parent;\n        var w = this.w;\n\n        var shouldDraw = function shouldDraw() {\n          if (i === 0 && w.globals.skipFirstTimelinelabel) {\n            return false;\n          }\n\n          if (i === xCount - 1 && w.globals.skipLastTimelinelabel && !w.config.xaxis.labels.formatter) {\n            return false;\n          }\n\n          if (w.config.chart.type === 'radar') {\n            return false;\n          }\n\n          return true;\n        };\n\n        if (shouldDraw()) {\n          if (w.config.grid.xaxis.lines.show) {\n            this._drawGridLine({\n              i: i,\n              x1: x1,\n              y1: y1,\n              x2: x2,\n              y2: y2,\n              xCount: xCount,\n              parent: parent\n            });\n          }\n\n          var y_2 = 0;\n\n          if (w.globals.hasXaxisGroups && w.config.xaxis.tickPlacement === 'between') {\n            var groups = w.globals.groups;\n\n            if (groups) {\n              var gacc = 0;\n\n              for (var gi = 0; gacc < i && gi < groups.length; gi++) {\n                gacc += groups[gi].cols;\n              }\n\n              if (gacc === i) {\n                y_2 = w.globals.xAxisLabelsHeight * 0.6;\n              }\n            }\n          }\n\n          var xAxis = new XAxis(this.ctx);\n          xAxis.drawXaxisTicks(x1, y_2, w.globals.dom.elGraphical);\n        }\n      }\n    }, {\n      key: \"_drawGridLine\",\n      value: function _drawGridLine(_ref2) {\n        var i = _ref2.i,\n            x1 = _ref2.x1,\n            y1 = _ref2.y1,\n            x2 = _ref2.x2,\n            y2 = _ref2.y2,\n            xCount = _ref2.xCount,\n            parent = _ref2.parent;\n        var w = this.w;\n        var excludeBorders = false;\n        var isHorzLine = parent.node.classList.contains('apexcharts-gridlines-horizontal');\n        var strokeDashArray = w.config.grid.strokeDashArray;\n        var offX = w.globals.barPadForNumericAxis;\n\n        if (y1 === 0 && y2 === 0 || x1 === 0 && x2 === 0) {\n          excludeBorders = true;\n        }\n\n        if (y1 === w.globals.gridHeight && y2 === w.globals.gridHeight) {\n          excludeBorders = true;\n        }\n\n        if (w.globals.isBarHorizontal && (i === 0 || i === xCount - 1)) {\n          excludeBorders = true;\n        }\n\n        var graphics = new Graphics(this);\n        var line = graphics.drawLine(x1 - (isHorzLine ? offX : 0), y1, x2 + (isHorzLine ? offX : 0), y2, w.config.grid.borderColor, strokeDashArray);\n        line.node.classList.add('apexcharts-gridline');\n\n        if (excludeBorders && w.config.grid.show) {\n          this.elGridBorders.add(line);\n        } else {\n          parent.add(line);\n        }\n      }\n    }, {\n      key: \"_drawGridBandRect\",\n      value: function _drawGridBandRect(_ref3) {\n        var c = _ref3.c,\n            x1 = _ref3.x1,\n            y1 = _ref3.y1,\n            x2 = _ref3.x2,\n            y2 = _ref3.y2,\n            type = _ref3.type;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var offX = w.globals.barPadForNumericAxis;\n        if (type === 'column' && w.config.xaxis.type === 'datetime') return;\n        var color = w.config.grid[type].colors[c];\n        var rect = graphics.drawRect(x1 - (type === 'row' ? offX : 0), y1, x2 + (type === 'row' ? offX * 2 : 0), y2, 0, color, w.config.grid[type].opacity);\n        this.elg.add(rect);\n        rect.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n        rect.node.classList.add(\"apexcharts-grid-\".concat(type));\n      }\n    }, {\n      key: \"_drawXYLines\",\n      value: function _drawXYLines(_ref4) {\n        var _this = this;\n\n        var xCount = _ref4.xCount,\n            tickAmount = _ref4.tickAmount;\n        var w = this.w;\n\n        var datetimeLines = function datetimeLines(_ref5) {\n          var xC = _ref5.xC,\n              x1 = _ref5.x1,\n              y1 = _ref5.y1,\n              x2 = _ref5.x2,\n              y2 = _ref5.y2;\n\n          for (var i = 0; i < xC; i++) {\n            x1 = _this.xaxisLabels[i].position;\n            x2 = _this.xaxisLabels[i].position;\n\n            _this._drawGridLines({\n              i: i,\n              x1: x1,\n              y1: y1,\n              x2: x2,\n              y2: y2,\n              xCount: xCount,\n              parent: _this.elgridLinesV\n            });\n          }\n        };\n\n        var categoryLines = function categoryLines(_ref6) {\n          var xC = _ref6.xC,\n              x1 = _ref6.x1,\n              y1 = _ref6.y1,\n              x2 = _ref6.x2,\n              y2 = _ref6.y2;\n\n          for (var i = 0; i < xC + (w.globals.isXNumeric ? 0 : 1); i++) {\n            if (i === 0 && xC === 1 && w.globals.dataPoints === 1) {\n              // single datapoint\n              x1 = w.globals.gridWidth / 2;\n              x2 = x1;\n            }\n\n            _this._drawGridLines({\n              i: i,\n              x1: x1,\n              y1: y1,\n              x2: x2,\n              y2: y2,\n              xCount: xCount,\n              parent: _this.elgridLinesV\n            });\n\n            x1 = x1 + w.globals.gridWidth / (w.globals.isXNumeric ? xC - 1 : xC);\n            x2 = x1;\n          }\n        }; // draw vertical lines\n\n\n        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {\n          var x1 = w.globals.padHorizontal;\n          var y1 = 0;\n          var x2;\n          var y2 = w.globals.gridHeight;\n\n          if (w.globals.timescaleLabels.length) {\n            datetimeLines({\n              xC: xCount,\n              x1: x1,\n              y1: y1,\n              x2: x2,\n              y2: y2\n            });\n          } else {\n            if (w.globals.isXNumeric) {\n              xCount = w.globals.xAxisScale.result.length;\n            }\n\n            categoryLines({\n              xC: xCount,\n              x1: x1,\n              y1: y1,\n              x2: x2,\n              y2: y2\n            });\n          }\n        } // draw horizontal lines\n\n\n        if (w.config.grid.yaxis.lines.show) {\n          var _x = 0;\n          var _y = 0;\n          var _y2 = 0;\n          var _x2 = w.globals.gridWidth;\n          var tA = tickAmount + 1;\n\n          if (this.isRangeBar) {\n            tA = w.globals.labels.length;\n          }\n\n          for (var i = 0; i < tA + (this.isRangeBar ? 1 : 0); i++) {\n            this._drawGridLine({\n              i: i,\n              xCount: tA + (this.isRangeBar ? 1 : 0),\n              x1: _x,\n              y1: _y,\n              x2: _x2,\n              y2: _y2,\n              parent: this.elgridLinesH\n            });\n\n            _y = _y + w.globals.gridHeight / (this.isRangeBar ? tA : tickAmount);\n            _y2 = _y;\n          }\n        }\n      }\n    }, {\n      key: \"_drawInvertedXYLines\",\n      value: function _drawInvertedXYLines(_ref7) {\n        var xCount = _ref7.xCount;\n        var w = this.w; // draw vertical lines\n\n        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {\n          var x1 = w.globals.padHorizontal;\n          var y1 = 0;\n          var x2;\n          var y2 = w.globals.gridHeight;\n\n          for (var i = 0; i < xCount + 1; i++) {\n            if (w.config.grid.xaxis.lines.show) {\n              this._drawGridLine({\n                i: i,\n                xCount: xCount + 1,\n                x1: x1,\n                y1: y1,\n                x2: x2,\n                y2: y2,\n                parent: this.elgridLinesV\n              });\n            }\n\n            var xAxis = new XAxis(this.ctx);\n            xAxis.drawXaxisTicks(x1, 0, w.globals.dom.elGraphical);\n            x1 = x1 + w.globals.gridWidth / xCount + 0.3;\n            x2 = x1;\n          }\n        } // draw horizontal lines\n\n\n        if (w.config.grid.yaxis.lines.show) {\n          var _x3 = 0;\n          var _y3 = 0;\n          var _y4 = 0;\n          var _x4 = w.globals.gridWidth;\n\n          for (var _i = 0; _i < w.globals.dataPoints + 1; _i++) {\n            this._drawGridLine({\n              i: _i,\n              xCount: w.globals.dataPoints + 1,\n              x1: _x3,\n              y1: _y3,\n              x2: _x4,\n              y2: _y4,\n              parent: this.elgridLinesH\n            });\n\n            _y3 = _y3 + w.globals.gridHeight / w.globals.dataPoints;\n            _y4 = _y3;\n          }\n        }\n      } // actual grid rendering\n\n    }, {\n      key: \"renderGrid\",\n      value: function renderGrid() {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        this.elg = graphics.group({\n          class: 'apexcharts-grid'\n        });\n        this.elgridLinesH = graphics.group({\n          class: 'apexcharts-gridlines-horizontal'\n        });\n        this.elgridLinesV = graphics.group({\n          class: 'apexcharts-gridlines-vertical'\n        });\n        this.elGridBorders = graphics.group({\n          class: 'apexcharts-grid-borders'\n        });\n        this.elg.add(this.elgridLinesH);\n        this.elg.add(this.elgridLinesV);\n\n        if (!w.config.grid.show) {\n          this.elgridLinesV.hide();\n          this.elgridLinesH.hide();\n          this.elGridBorders.hide();\n        }\n\n        var yTickAmount = w.globals.yAxisScale.length ? w.globals.yAxisScale[0].result.length - 1 : 5;\n\n        for (var i = 0; i < w.globals.series.length; i++) {\n          if (typeof w.globals.yAxisScale[i] !== 'undefined') {\n            yTickAmount = w.globals.yAxisScale[i].result.length - 1;\n          }\n\n          if (yTickAmount > 2) break;\n        }\n\n        var xCount;\n\n        if (!w.globals.isBarHorizontal || this.isRangeBar) {\n          xCount = this.xaxisLabels.length;\n\n          if (this.isRangeBar) {\n            xCount--;\n            yTickAmount = w.globals.labels.length;\n\n            if (w.config.xaxis.tickAmount && w.config.xaxis.labels.formatter) {\n              xCount = w.config.xaxis.tickAmount;\n            }\n          }\n\n          this._drawXYLines({\n            xCount: xCount,\n            tickAmount: yTickAmount\n          });\n        } else {\n          xCount = yTickAmount; // for horizontal bar chart, get the xaxis tickamount\n\n          yTickAmount = w.globals.xTickAmount;\n\n          this._drawInvertedXYLines({\n            xCount: xCount,\n            tickAmount: yTickAmount\n          });\n        }\n\n        this.drawGridBands(xCount, yTickAmount);\n        return {\n          el: this.elg,\n          elGridBorders: this.elGridBorders,\n          xAxisTickWidth: w.globals.gridWidth / xCount\n        };\n      }\n    }, {\n      key: \"drawGridBands\",\n      value: function drawGridBands(xCount, tickAmount) {\n        var w = this.w; // rows background bands\n\n        if (w.config.grid.row.colors !== undefined && w.config.grid.row.colors.length > 0) {\n          var x1 = 0;\n          var y1 = 0;\n          var y2 = w.globals.gridHeight / tickAmount;\n          var x2 = w.globals.gridWidth;\n\n          for (var i = 0, c = 0; i < tickAmount; i++, c++) {\n            if (c >= w.config.grid.row.colors.length) {\n              c = 0;\n            }\n\n            this._drawGridBandRect({\n              c: c,\n              x1: x1,\n              y1: y1,\n              x2: x2,\n              y2: y2,\n              type: 'row'\n            });\n\n            y1 = y1 + w.globals.gridHeight / tickAmount;\n          }\n        } // columns background bands\n\n\n        if (w.config.grid.column.colors !== undefined && w.config.grid.column.colors.length > 0) {\n          var xc = !w.globals.isBarHorizontal && w.config.xaxis.tickPlacement === 'on' && (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) ? xCount - 1 : xCount;\n          var _x5 = w.globals.padHorizontal;\n          var _y5 = 0;\n\n          var _x6 = w.globals.padHorizontal + w.globals.gridWidth / xc;\n\n          var _y6 = w.globals.gridHeight;\n\n          for (var _i2 = 0, _c = 0; _i2 < xCount; _i2++, _c++) {\n            if (_c >= w.config.grid.column.colors.length) {\n              _c = 0;\n            }\n\n            this._drawGridBandRect({\n              c: _c,\n              x1: _x5,\n              y1: _y5,\n              x2: _x6,\n              y2: _y6,\n              type: 'column'\n            });\n\n            _x5 = _x5 + w.globals.gridWidth / xc;\n          }\n        }\n      }\n    }]);\n\n    return Grid;\n  }();\n\n  var Range$1 = /*#__PURE__*/function () {\n    function Range(ctx) {\n      _classCallCheck(this, Range);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    } // http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axiss\n    // This routine creates the Y axis values for a graph.\n\n\n    _createClass(Range, [{\n      key: \"niceScale\",\n      value: function niceScale(yMin, yMax) {\n        var ticks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n        var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var NO_MIN_MAX_PROVIDED = arguments.length > 4 ? arguments[4] : undefined;\n        var w = this.w; // Determine Range\n\n        var range = Math.abs(yMax - yMin);\n        ticks = this._adjustTicksForSmallRange(ticks, index, range);\n\n        if (ticks === 'dataPoints') {\n          ticks = w.globals.dataPoints - 1;\n        }\n\n        if (yMin === Number.MIN_VALUE && yMax === 0 || !Utils$1.isNumber(yMin) && !Utils$1.isNumber(yMax) || yMin === Number.MIN_VALUE && yMax === -Number.MAX_VALUE) {\n          // when all values are 0\n          yMin = 0;\n          yMax = ticks;\n          var linearScale = this.linearScale(yMin, yMax, ticks);\n          return linearScale;\n        }\n\n        if (yMin > yMax) {\n          // if somehow due to some wrong config, user sent max less than min,\n          // adjust the min/max again\n          console.warn('axis.min cannot be greater than axis.max');\n          yMax = yMin + 0.1;\n        } else if (yMin === yMax) {\n          // If yMin and yMax are identical, then\n          // adjust the yMin and yMax values to actually\n          // make a graph. Also avoids division by zero errors.\n          yMin = yMin === 0 ? 0 : yMin - 0.5; // some small value\n\n          yMax = yMax === 0 ? 2 : yMax + 0.5; // some small value\n        } // Calculate Min amd Max graphical labels and graph\n        // increments.  The number of ticks defaults to\n        // 10 which is the SUGGESTED value.  Any tick value\n        // entered is used as a suggested value which is\n        // adjusted to be a 'pretty' value.\n        //\n        // Output will be an array of the Y axis values that\n        // encompass the Y values.\n\n\n        var result = [];\n\n        if (range < 1 && NO_MIN_MAX_PROVIDED && (w.config.chart.type === 'candlestick' || w.config.series[index].type === 'candlestick' || w.config.chart.type === 'boxPlot' || w.config.series[index].type === 'boxPlot' || w.globals.isRangeData)) {\n          /* fix https://github.com/apexcharts/apexcharts.js/issues/430 */\n          yMax = yMax * 1.01;\n        }\n\n        var tiks = ticks + 1; // Adjust ticks if needed\n\n        if (tiks < 2) {\n          tiks = 2;\n        } else if (tiks > 2) {\n          tiks -= 2;\n        } // Get raw step value\n\n\n        var tempStep = range / tiks; // Calculate pretty step value\n\n        var mag = Math.floor(Utils$1.log10(tempStep));\n        var magPow = Math.pow(10, mag);\n        var magMsd = Math.round(tempStep / magPow);\n\n        if (magMsd < 1) {\n          magMsd = 1;\n        }\n\n        var stepSize = magMsd * magPow; // build Y label array.\n        // Lower and upper bounds calculations\n\n        var lb = stepSize * Math.floor(yMin / stepSize);\n        var ub = stepSize * Math.ceil(yMax / stepSize); // Build array\n\n        var val = lb;\n\n        if (NO_MIN_MAX_PROVIDED && range > 2) {\n          while (1) {\n            result.push(Utils$1.stripNumber(val, 7));\n            val += stepSize;\n\n            if (val > ub) {\n              break;\n            }\n          }\n\n          return {\n            result: result,\n            niceMin: result[0],\n            niceMax: result[result.length - 1]\n          };\n        } else {\n          result = [];\n          var v = yMin;\n          result.push(Utils$1.stripNumber(v, 7));\n          var valuesDivider = Math.abs(yMax - yMin) / ticks;\n\n          for (var i = 0; i <= ticks; i++) {\n            v = v + valuesDivider;\n            result.push(v);\n          }\n\n          if (result[result.length - 2] >= yMax) {\n            result.pop();\n          }\n\n          return {\n            result: result,\n            niceMin: result[0],\n            niceMax: result[result.length - 1]\n          };\n        }\n      }\n    }, {\n      key: \"linearScale\",\n      value: function linearScale(yMin, yMax) {\n        var ticks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n        var index = arguments.length > 3 ? arguments[3] : undefined;\n        var range = Math.abs(yMax - yMin);\n        ticks = this._adjustTicksForSmallRange(ticks, index, range);\n\n        if (ticks === 'dataPoints') {\n          ticks = this.w.globals.dataPoints - 1;\n        }\n\n        var step = range / ticks;\n\n        if (ticks === Number.MAX_VALUE) {\n          ticks = 10;\n          step = 1;\n        }\n\n        var result = [];\n        var v = yMin;\n\n        while (ticks >= 0) {\n          result.push(v);\n          v = v + step;\n          ticks -= 1;\n        }\n\n        return {\n          result: result,\n          niceMin: result[0],\n          niceMax: result[result.length - 1]\n        };\n      }\n    }, {\n      key: \"logarithmicScaleNice\",\n      value: function logarithmicScaleNice(yMin, yMax, base) {\n        // Basic validation to avoid for loop starting at -inf.\n        if (yMax <= 0) yMax = Math.max(yMin, base);\n        if (yMin <= 0) yMin = Math.min(yMax, base);\n        var logs = [];\n        var logMax = Math.ceil(Math.log(yMax) / Math.log(base) + 1); // Get powers of base for our max and min\n\n        var logMin = Math.floor(Math.log(yMin) / Math.log(base));\n\n        for (var i = logMin; i < logMax; i++) {\n          logs.push(Math.pow(base, i));\n        }\n\n        return {\n          result: logs,\n          niceMin: logs[0],\n          niceMax: logs[logs.length - 1]\n        };\n      }\n    }, {\n      key: \"logarithmicScale\",\n      value: function logarithmicScale(yMin, yMax, base) {\n        // Basic validation to avoid for loop starting at -inf.\n        if (yMax <= 0) yMax = Math.max(yMin, base);\n        if (yMin <= 0) yMin = Math.min(yMax, base);\n        var logs = []; // Get the logarithmic range.\n\n        var logMax = Math.log(yMax) / Math.log(base);\n        var logMin = Math.log(yMin) / Math.log(base); // Get the exact logarithmic range.\n        // (This is the exact number of multiples of the base there are between yMin and yMax).\n\n        var logRange = logMax - logMin; // Round the logarithmic range to get the number of ticks we will create.\n        // If the chosen min/max values are multiples of each other WRT the base, this will be neat.\n        // If the chosen min/max aren't, we will at least still provide USEFUL ticks.\n\n        var ticks = Math.round(logRange); // Get the logarithmic spacing between ticks.\n\n        var logTickSpacing = logRange / ticks; // Create as many ticks as there is range in the logs.\n\n        for (var i = 0, logTick = logMin; i < ticks; i++, logTick += logTickSpacing) {\n          logs.push(Math.pow(base, logTick));\n        } // Add a final tick at the yMax.\n\n\n        logs.push(Math.pow(base, logMax));\n        return {\n          result: logs,\n          niceMin: yMin,\n          niceMax: yMax\n        };\n      }\n    }, {\n      key: \"_adjustTicksForSmallRange\",\n      value: function _adjustTicksForSmallRange(ticks, index, range) {\n        var newTicks = ticks;\n\n        if (typeof index !== 'undefined' && this.w.config.yaxis[index].labels.formatter && this.w.config.yaxis[index].tickAmount === undefined) {\n          var formattedVal = Number(this.w.config.yaxis[index].labels.formatter(1));\n\n          if (Utils$1.isNumber(formattedVal) && this.w.globals.yValueDecimal === 0) {\n            newTicks = Math.ceil(range);\n          }\n        }\n\n        return newTicks < ticks ? newTicks : ticks;\n      }\n    }, {\n      key: \"setYScaleForIndex\",\n      value: function setYScaleForIndex(index, minY, maxY) {\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n        var y = gl.isBarHorizontal ? cnf.xaxis : cnf.yaxis[index];\n\n        if (typeof gl.yAxisScale[index] === 'undefined') {\n          gl.yAxisScale[index] = [];\n        }\n\n        var diff = Math.abs(maxY - minY);\n\n        if (y.logarithmic && diff <= 5) {\n          gl.invalidLogScale = true;\n        }\n\n        if (y.logarithmic && diff > 5) {\n          gl.allSeriesCollapsed = false;\n          gl.yAxisScale[index] = this.logarithmicScale(minY, maxY, y.logBase);\n          gl.yAxisScale[index] = y.forceNiceScale ? this.logarithmicScaleNice(minY, maxY, y.logBase) : this.logarithmicScale(minY, maxY, y.logBase);\n        } else {\n          if (maxY === -Number.MAX_VALUE || !Utils$1.isNumber(maxY)) {\n            // no data in the chart. Either all series collapsed or user passed a blank array\n            gl.yAxisScale[index] = this.linearScale(0, 5, 5);\n          } else {\n            // there is some data. Turn off the allSeriesCollapsed flag\n            gl.allSeriesCollapsed = false;\n\n            if ((y.min !== undefined || y.max !== undefined) && !y.forceNiceScale) {\n              // fix https://github.com/apexcharts/apexcharts.js/issues/492\n              gl.yAxisScale[index] = this.linearScale(minY, maxY, y.tickAmount, index);\n            } else {\n              var noMinMaxProvided = cnf.yaxis[index].max === undefined && cnf.yaxis[index].min === undefined || cnf.yaxis[index].forceNiceScale;\n              gl.yAxisScale[index] = this.niceScale(minY, maxY, y.tickAmount ? y.tickAmount : diff < 5 && diff > 1 ? diff + 1 : 5, index, // fix https://github.com/apexcharts/apexcharts.js/issues/397\n              noMinMaxProvided);\n            }\n          }\n        }\n      }\n    }, {\n      key: \"setXScale\",\n      value: function setXScale(minX, maxX) {\n        var w = this.w;\n        var gl = w.globals;\n        var x = w.config.xaxis;\n        var diff = Math.abs(maxX - minX);\n\n        if (maxX === -Number.MAX_VALUE || !Utils$1.isNumber(maxX)) {\n          // no data in the chart. Either all series collapsed or user passed a blank array\n          gl.xAxisScale = this.linearScale(0, 5, 5);\n        } else {\n          gl.xAxisScale = this.linearScale(minX, maxX, x.tickAmount ? x.tickAmount : diff < 5 && diff > 1 ? diff + 1 : 5, 0);\n        }\n\n        return gl.xAxisScale;\n      }\n    }, {\n      key: \"setMultipleYScales\",\n      value: function setMultipleYScales() {\n        var _this = this;\n\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n        var minYArr = gl.minYArr.concat([]);\n        var maxYArr = gl.maxYArr.concat([]);\n        var scalesIndices = []; // here, we loop through the yaxis array and find the item which has \"seriesName\" property\n\n        cnf.yaxis.forEach(function (yaxe, i) {\n          var index = i;\n          cnf.series.forEach(function (s, si) {\n            // if seriesName matches and that series is not collapsed, we use that scale\n            // fix issue #1215\n            // proceed even if si is in gl.collapsedSeriesIndices\n            if (s.name === yaxe.seriesName) {\n              index = si;\n\n              if (i !== si) {\n                scalesIndices.push({\n                  index: si,\n                  similarIndex: i,\n                  alreadyExists: true\n                });\n              } else {\n                scalesIndices.push({\n                  index: si\n                });\n              }\n            }\n          });\n          var minY = minYArr[index];\n          var maxY = maxYArr[index];\n\n          _this.setYScaleForIndex(i, minY, maxY);\n        });\n        this.sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices);\n      }\n    }, {\n      key: \"sameScaleInMultipleAxes\",\n      value: function sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices) {\n        var _this2 = this;\n\n        var cnf = this.w.config;\n        var gl = this.w.globals; // we got the scalesIndices array in the above code, but we need to filter out the items which doesn't have same scales\n\n        var similarIndices = [];\n        scalesIndices.forEach(function (scale) {\n          if (scale.alreadyExists) {\n            if (typeof similarIndices[scale.index] === 'undefined') {\n              similarIndices[scale.index] = [];\n            }\n\n            similarIndices[scale.index].push(scale.index);\n            similarIndices[scale.index].push(scale.similarIndex);\n          }\n        });\n\n        function intersect(a, b) {\n          return a.filter(function (value) {\n            return b.indexOf(value) !== -1;\n          });\n        }\n\n        gl.yAxisSameScaleIndices = similarIndices;\n        similarIndices.forEach(function (si, i) {\n          similarIndices.forEach(function (sj, j) {\n            if (i !== j) {\n              if (intersect(si, sj).length > 0) {\n                similarIndices[i] = similarIndices[i].concat(similarIndices[j]);\n              }\n            }\n          });\n        }); // then, we remove duplicates from the similarScale array\n\n        var uniqueSimilarIndices = similarIndices.map(function (item) {\n          return item.filter(function (i, pos) {\n            return item.indexOf(i) === pos;\n          });\n        }); // sort further to remove whole duplicate arrays later\n\n        var sortedIndices = uniqueSimilarIndices.map(function (s) {\n          return s.sort();\n        }); // remove undefined items\n\n        similarIndices = similarIndices.filter(function (s) {\n          return !!s;\n        });\n        var indices = sortedIndices.slice();\n        var stringIndices = indices.map(function (ind) {\n          return JSON.stringify(ind);\n        });\n        indices = indices.filter(function (ind, p) {\n          return stringIndices.indexOf(JSON.stringify(ind)) === p;\n        });\n        var sameScaleMinYArr = [];\n        var sameScaleMaxYArr = [];\n        minYArr.forEach(function (minYValue, yi) {\n          indices.forEach(function (scale, i) {\n            // we compare only the yIndex which exists in the indices array\n            if (scale.indexOf(yi) > -1) {\n              if (typeof sameScaleMinYArr[i] === 'undefined') {\n                sameScaleMinYArr[i] = [];\n                sameScaleMaxYArr[i] = [];\n              }\n\n              sameScaleMinYArr[i].push({\n                key: yi,\n                value: minYValue\n              });\n              sameScaleMaxYArr[i].push({\n                key: yi,\n                value: maxYArr[yi]\n              });\n            }\n          });\n        });\n        var sameScaleMin = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, Number.MIN_VALUE);\n        var sameScaleMax = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);\n        sameScaleMinYArr.forEach(function (s, i) {\n          s.forEach(function (sc, j) {\n            sameScaleMin[i] = Math.min(sc.value, sameScaleMin[i]);\n          });\n        });\n        sameScaleMaxYArr.forEach(function (s, i) {\n          s.forEach(function (sc, j) {\n            sameScaleMax[i] = Math.max(sc.value, sameScaleMax[i]);\n          });\n        });\n        minYArr.forEach(function (min, i) {\n          sameScaleMaxYArr.forEach(function (s, si) {\n            var minY = sameScaleMin[si];\n            var maxY = sameScaleMax[si];\n\n            if (cnf.chart.stacked) {\n              // for stacked charts, we need to add the values\n              maxY = 0;\n              s.forEach(function (ind, k) {\n                // fix incorrectly adjust y scale issue #1215\n                if (ind.value !== -Number.MAX_VALUE) {\n                  maxY += ind.value;\n                }\n\n                if (minY !== Number.MIN_VALUE) {\n                  minY += sameScaleMinYArr[si][k].value;\n                }\n              });\n            }\n\n            s.forEach(function (ind, k) {\n              if (s[k].key === i) {\n                if (cnf.yaxis[i].min !== undefined) {\n                  if (typeof cnf.yaxis[i].min === 'function') {\n                    minY = cnf.yaxis[i].min(gl.minY);\n                  } else {\n                    minY = cnf.yaxis[i].min;\n                  }\n                }\n\n                if (cnf.yaxis[i].max !== undefined) {\n                  if (typeof cnf.yaxis[i].max === 'function') {\n                    maxY = cnf.yaxis[i].max(gl.maxY);\n                  } else {\n                    maxY = cnf.yaxis[i].max;\n                  }\n                }\n\n                _this2.setYScaleForIndex(i, minY, maxY);\n              }\n            });\n          });\n        });\n      } // experimental feature which scales the y-axis to a min/max based on x-axis range\n\n    }, {\n      key: \"autoScaleY\",\n      value: function autoScaleY(ctx, yaxis, e) {\n        if (!ctx) {\n          ctx = this;\n        }\n\n        var w = ctx.w;\n\n        if (w.globals.isMultipleYAxis || w.globals.collapsedSeries.length) {\n          // The autoScale option for multiple y-axis is turned off as it leads to buggy behavior.\n          // Also, when a series is collapsed, it results in incorrect behavior. Hence turned it off for that too - fixes apexcharts.js#795\n          console.warn('autoScaleYaxis not supported in a multi-yaxis chart.');\n          return yaxis;\n        }\n\n        var seriesX = w.globals.seriesX[0];\n        var isStacked = w.config.chart.stacked;\n        yaxis.forEach(function (yaxe, yi) {\n          var firstXIndex = 0;\n\n          for (var xi = 0; xi < seriesX.length; xi++) {\n            if (seriesX[xi] >= e.xaxis.min) {\n              firstXIndex = xi;\n              break;\n            }\n          }\n\n          var initialMin = w.globals.minYArr[yi];\n          var initialMax = w.globals.maxYArr[yi];\n          var min, max;\n          var stackedSer = w.globals.stackedSeriesTotals;\n          w.globals.series.forEach(function (serie, sI) {\n            var firstValue = serie[firstXIndex];\n\n            if (isStacked) {\n              firstValue = stackedSer[firstXIndex];\n              min = max = firstValue;\n              stackedSer.forEach(function (y, yI) {\n                if (seriesX[yI] <= e.xaxis.max && seriesX[yI] >= e.xaxis.min) {\n                  if (y > max && y !== null) max = y;\n                  if (serie[yI] < min && serie[yI] !== null) min = serie[yI];\n                }\n              });\n            } else {\n              min = max = firstValue;\n              serie.forEach(function (y, yI) {\n                if (seriesX[yI] <= e.xaxis.max && seriesX[yI] >= e.xaxis.min) {\n                  var valMin = y;\n                  var valMax = y;\n                  w.globals.series.forEach(function (wS, wSI) {\n                    if (y !== null) {\n                      valMin = Math.min(wS[yI], valMin);\n                      valMax = Math.max(wS[yI], valMax);\n                    }\n                  });\n                  if (valMax > max && valMax !== null) max = valMax;\n                  if (valMin < min && valMin !== null) min = valMin;\n                }\n              });\n            }\n\n            if (min === undefined && max === undefined) {\n              min = initialMin;\n              max = initialMax;\n            }\n\n            min *= min < 0 ? 1.1 : 0.9;\n            max *= max < 0 ? 0.9 : 1.1;\n\n            if (min === 0 && max === 0) {\n              min = -1;\n              max = 1;\n            }\n\n            if (max < 0 && max < initialMax) {\n              max = initialMax;\n            }\n\n            if (min < 0 && min > initialMin) {\n              min = initialMin;\n            }\n\n            if (yaxis.length > 1) {\n              yaxis[sI].min = yaxe.min === undefined ? min : yaxe.min;\n              yaxis[sI].max = yaxe.max === undefined ? max : yaxe.max;\n            } else {\n              yaxis[0].min = yaxe.min === undefined ? min : yaxe.min;\n              yaxis[0].max = yaxe.max === undefined ? max : yaxe.max;\n            }\n          });\n        });\n        return yaxis;\n      }\n    }]);\n\n    return Range;\n  }();\n\n  /**\n   * Range is used to generates values between min and max.\n   *\n   * @module Range\n   **/\n\n  var Range = /*#__PURE__*/function () {\n    function Range(ctx) {\n      _classCallCheck(this, Range);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.scales = new Range$1(ctx);\n    }\n\n    _createClass(Range, [{\n      key: \"init\",\n      value: function init() {\n        this.setYRange();\n        this.setXRange();\n        this.setZRange();\n      }\n    }, {\n      key: \"getMinYMaxY\",\n      value: function getMinYMaxY(startingIndex) {\n        var lowestY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n        var highestY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Number.MAX_VALUE;\n        var len = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var cnf = this.w.config;\n        var gl = this.w.globals;\n        var maxY = -Number.MAX_VALUE;\n        var minY = Number.MIN_VALUE;\n\n        if (len === null) {\n          len = startingIndex + 1;\n        }\n\n        var series = gl.series;\n        var seriesMin = series;\n        var seriesMax = series;\n\n        if (cnf.chart.type === 'candlestick') {\n          seriesMin = gl.seriesCandleL;\n          seriesMax = gl.seriesCandleH;\n        } else if (cnf.chart.type === 'boxPlot') {\n          seriesMin = gl.seriesCandleO;\n          seriesMax = gl.seriesCandleC;\n        } else if (gl.isRangeData) {\n          seriesMin = gl.seriesRangeStart;\n          seriesMax = gl.seriesRangeEnd;\n        }\n\n        for (var i = startingIndex; i < len; i++) {\n          gl.dataPoints = Math.max(gl.dataPoints, series[i].length);\n\n          if (gl.categoryLabels.length) {\n            gl.dataPoints = gl.categoryLabels.filter(function (label) {\n              return typeof label !== 'undefined';\n            }).length;\n          }\n\n          if (gl.labels.length && cnf.xaxis.type !== 'datetime' && gl.series.reduce(function (a, c) {\n            return a + c.length;\n          }, 0) !== 0) {\n            // the condition cnf.xaxis.type !== 'datetime' fixes #3897 and #3905\n            gl.dataPoints = Math.max(gl.dataPoints, gl.labels.length);\n          }\n\n          for (var j = 0; j < gl.series[i].length; j++) {\n            var val = series[i][j];\n\n            if (val !== null && Utils$1.isNumber(val)) {\n              if (typeof seriesMax[i][j] !== 'undefined') {\n                maxY = Math.max(maxY, seriesMax[i][j]);\n                lowestY = Math.min(lowestY, seriesMax[i][j]);\n              }\n\n              if (typeof seriesMin[i][j] !== 'undefined') {\n                lowestY = Math.min(lowestY, seriesMin[i][j]);\n                highestY = Math.max(highestY, seriesMin[i][j]);\n              }\n\n              if (this.w.config.chart.type === 'candlestick' || this.w.config.chart.type === 'boxPlot' || this.w.config.chart.type !== 'rangeArea' || this.w.config.chart.type !== 'rangeBar') {\n                if (this.w.config.chart.type === 'candlestick' || this.w.config.chart.type === 'boxPlot') {\n                  if (typeof gl.seriesCandleC[i][j] !== 'undefined') {\n                    maxY = Math.max(maxY, gl.seriesCandleO[i][j]);\n                    maxY = Math.max(maxY, gl.seriesCandleH[i][j]);\n                    maxY = Math.max(maxY, gl.seriesCandleL[i][j]);\n                    maxY = Math.max(maxY, gl.seriesCandleC[i][j]);\n\n                    if (this.w.config.chart.type === 'boxPlot') {\n                      maxY = Math.max(maxY, gl.seriesCandleM[i][j]);\n                    }\n                  }\n                } // there is a combo chart and the specified series in not either candlestick, boxplot, or rangeArea/rangeBar; find the max there\n\n\n                if (cnf.series[i].type && (cnf.series[i].type !== 'candlestick' || cnf.series[i].type !== 'boxPlot' || cnf.series[i].type !== 'rangeArea' || cnf.series[i].type !== 'rangeBar')) {\n                  maxY = Math.max(maxY, gl.series[i][j]);\n                  lowestY = Math.min(lowestY, gl.series[i][j]);\n                }\n\n                highestY = maxY;\n              }\n\n              if (gl.seriesGoals[i] && gl.seriesGoals[i][j] && Array.isArray(gl.seriesGoals[i][j])) {\n                gl.seriesGoals[i][j].forEach(function (g) {\n                  if (minY !== Number.MIN_VALUE) {\n                    minY = Math.min(minY, g.value);\n                    lowestY = minY;\n                  }\n\n                  maxY = Math.max(maxY, g.value);\n                  highestY = maxY;\n                });\n              }\n\n              if (Utils$1.isFloat(val)) {\n                val = Utils$1.noExponents(val);\n                gl.yValueDecimal = Math.max(gl.yValueDecimal, val.toString().split('.')[1].length);\n              }\n\n              if (minY > seriesMin[i][j] && seriesMin[i][j] < 0) {\n                minY = seriesMin[i][j];\n              }\n            } else {\n              gl.hasNullValues = true;\n            }\n          }\n        }\n\n        if (cnf.chart.type === 'rangeBar' && gl.seriesRangeStart.length && gl.isBarHorizontal) {\n          minY = lowestY;\n        }\n\n        if (cnf.chart.type === 'bar') {\n          if (minY < 0 && maxY < 0) {\n            // all negative values in a bar chart, hence make the max to 0\n            maxY = 0;\n          }\n\n          if (minY === Number.MIN_VALUE) {\n            minY = 0;\n          }\n        }\n\n        return {\n          minY: minY,\n          maxY: maxY,\n          lowestY: lowestY,\n          highestY: highestY\n        };\n      }\n    }, {\n      key: \"setYRange\",\n      value: function setYRange() {\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n        gl.maxY = -Number.MAX_VALUE;\n        gl.minY = Number.MIN_VALUE;\n        var lowestYInAllSeries = Number.MAX_VALUE;\n\n        if (gl.isMultipleYAxis) {\n          // we need to get minY and maxY for multiple y axis\n          for (var i = 0; i < gl.series.length; i++) {\n            var minYMaxYArr = this.getMinYMaxY(i, lowestYInAllSeries, null, i + 1);\n            gl.minYArr.push(minYMaxYArr.minY);\n            gl.maxYArr.push(minYMaxYArr.maxY);\n            lowestYInAllSeries = minYMaxYArr.lowestY;\n          }\n        } // and then, get the minY and maxY from all series\n\n\n        var minYMaxY = this.getMinYMaxY(0, lowestYInAllSeries, null, gl.series.length);\n        gl.minY = minYMaxY.minY;\n        gl.maxY = minYMaxY.maxY;\n        lowestYInAllSeries = minYMaxY.lowestY;\n\n        if (cnf.chart.stacked) {\n          this._setStackedMinMax();\n        } // if the numbers are too big, reduce the range\n        // for eg, if number is between 100000-110000, putting 0 as the lowest value is not so good idea. So change the gl.minY for line/area/candlesticks/boxPlot\n\n\n        if (cnf.chart.type === 'line' || cnf.chart.type === 'area' || cnf.chart.type === 'candlestick' || cnf.chart.type === 'boxPlot' || cnf.chart.type === 'rangeBar' && !gl.isBarHorizontal) {\n          if (gl.minY === Number.MIN_VALUE && lowestYInAllSeries !== -Number.MAX_VALUE && lowestYInAllSeries !== gl.maxY // single value possibility\n          ) {\n            var diff = gl.maxY - lowestYInAllSeries;\n\n            if (lowestYInAllSeries >= 0 && lowestYInAllSeries <= 10 || cnf.yaxis[0].min !== undefined || cnf.yaxis[0].max !== undefined) {\n              // if minY is already 0/low value, we don't want to go negatives here - so this check is essential.\n              diff = 0;\n            }\n\n            gl.minY = lowestYInAllSeries - diff * 5 / 100;\n            /* fix https://github.com/apexcharts/apexcharts.js/issues/614 */\n\n            /* fix https://github.com/apexcharts/apexcharts.js/issues/968 */\n\n            if (lowestYInAllSeries > 0 && gl.minY < 0) {\n              gl.minY = 0;\n            }\n            /* fix https://github.com/apexcharts/apexcharts.js/issues/426 */\n\n\n            gl.maxY = gl.maxY + diff * 5 / 100;\n          }\n        }\n\n        cnf.yaxis.forEach(function (yaxe, index) {\n          // override all min/max values by user defined values (y axis)\n          if (yaxe.max !== undefined) {\n            if (typeof yaxe.max === 'number') {\n              gl.maxYArr[index] = yaxe.max;\n            } else if (typeof yaxe.max === 'function') {\n              // fixes apexcharts.js/issues/2098\n              gl.maxYArr[index] = yaxe.max(gl.isMultipleYAxis ? gl.maxYArr[index] : gl.maxY);\n            } // gl.maxY is for single y-axis chart, it will be ignored in multi-yaxis\n\n\n            gl.maxY = gl.maxYArr[index];\n          }\n\n          if (yaxe.min !== undefined) {\n            if (typeof yaxe.min === 'number') {\n              gl.minYArr[index] = yaxe.min;\n            } else if (typeof yaxe.min === 'function') {\n              // fixes apexcharts.js/issues/2098\n              gl.minYArr[index] = yaxe.min(gl.isMultipleYAxis ? gl.minYArr[index] === Number.MIN_VALUE ? 0 : gl.minYArr[index] : gl.minY);\n            } // gl.minY is for single y-axis chart, it will be ignored in multi-yaxis\n\n\n            gl.minY = gl.minYArr[index];\n          }\n        }); // for horizontal bar charts, we need to check xaxis min/max as user may have specified there\n\n        if (gl.isBarHorizontal) {\n          var minmax = ['min', 'max'];\n          minmax.forEach(function (m) {\n            if (cnf.xaxis[m] !== undefined && typeof cnf.xaxis[m] === 'number') {\n              m === 'min' ? gl.minY = cnf.xaxis[m] : gl.maxY = cnf.xaxis[m];\n            }\n          });\n        } // for multi y-axis we need different scales for each\n\n\n        if (gl.isMultipleYAxis) {\n          this.scales.setMultipleYScales();\n          gl.minY = lowestYInAllSeries;\n          gl.yAxisScale.forEach(function (scale, i) {\n            gl.minYArr[i] = scale.niceMin;\n            gl.maxYArr[i] = scale.niceMax;\n          });\n        } else {\n          this.scales.setYScaleForIndex(0, gl.minY, gl.maxY);\n          gl.minY = gl.yAxisScale[0].niceMin;\n          gl.maxY = gl.yAxisScale[0].niceMax;\n          gl.minYArr[0] = gl.yAxisScale[0].niceMin;\n          gl.maxYArr[0] = gl.yAxisScale[0].niceMax;\n        }\n\n        return {\n          minY: gl.minY,\n          maxY: gl.maxY,\n          minYArr: gl.minYArr,\n          maxYArr: gl.maxYArr,\n          yAxisScale: gl.yAxisScale\n        };\n      }\n    }, {\n      key: \"setXRange\",\n      value: function setXRange() {\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n        var isXNumeric = cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'datetime' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided || gl.noLabelsProvided || gl.isXNumeric;\n\n        var getInitialMinXMaxX = function getInitialMinXMaxX() {\n          for (var i = 0; i < gl.series.length; i++) {\n            if (gl.labels[i]) {\n              for (var j = 0; j < gl.labels[i].length; j++) {\n                if (gl.labels[i][j] !== null && Utils$1.isNumber(gl.labels[i][j])) {\n                  gl.maxX = Math.max(gl.maxX, gl.labels[i][j]);\n                  gl.initialMaxX = Math.max(gl.maxX, gl.labels[i][j]);\n                  gl.minX = Math.min(gl.minX, gl.labels[i][j]);\n                  gl.initialMinX = Math.min(gl.minX, gl.labels[i][j]);\n                }\n              }\n            }\n          }\n        }; // minX maxX starts here\n\n\n        if (gl.isXNumeric) {\n          getInitialMinXMaxX();\n        }\n\n        if (gl.noLabelsProvided) {\n          if (cnf.xaxis.categories.length === 0) {\n            gl.maxX = gl.labels[gl.labels.length - 1];\n            gl.initialMaxX = gl.labels[gl.labels.length - 1];\n            gl.minX = 1;\n            gl.initialMinX = 1;\n          }\n        }\n\n        if (gl.isXNumeric || gl.noLabelsProvided || gl.dataFormatXNumeric) {\n          var ticks;\n\n          if (cnf.xaxis.tickAmount === undefined) {\n            ticks = Math.round(gl.svgWidth / 150); // no labels provided and total number of dataPoints is less than 30\n\n            if (cnf.xaxis.type === 'numeric' && gl.dataPoints < 30) {\n              ticks = gl.dataPoints - 1;\n            } // this check is for when ticks exceeds total datapoints and that would result in duplicate labels\n\n\n            if (ticks > gl.dataPoints && gl.dataPoints !== 0) {\n              ticks = gl.dataPoints - 1;\n            }\n          } else if (cnf.xaxis.tickAmount === 'dataPoints') {\n            if (gl.series.length > 1) {\n              ticks = gl.series[gl.maxValsInArrayIndex].length - 1;\n            }\n\n            if (gl.isXNumeric) {\n              ticks = gl.maxX - gl.minX - 1;\n            }\n          } else {\n            ticks = cnf.xaxis.tickAmount;\n          }\n\n          gl.xTickAmount = ticks; // override all min/max values by user defined values (x axis)\n\n          if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {\n            gl.maxX = cnf.xaxis.max;\n          }\n\n          if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {\n            gl.minX = cnf.xaxis.min;\n          } // if range is provided, adjust the new minX\n\n\n          if (cnf.xaxis.range !== undefined) {\n            gl.minX = gl.maxX - cnf.xaxis.range;\n          }\n\n          if (gl.minX !== Number.MAX_VALUE && gl.maxX !== -Number.MAX_VALUE) {\n            if (cnf.xaxis.convertedCatToNumeric && !gl.dataFormatXNumeric) {\n              var catScale = [];\n\n              for (var i = gl.minX - 1; i < gl.maxX; i++) {\n                catScale.push(i + 1);\n              }\n\n              gl.xAxisScale = {\n                result: catScale,\n                niceMin: catScale[0],\n                niceMax: catScale[catScale.length - 1]\n              };\n            } else {\n              gl.xAxisScale = this.scales.setXScale(gl.minX, gl.maxX);\n            }\n          } else {\n            gl.xAxisScale = this.scales.linearScale(0, ticks, ticks);\n\n            if (gl.noLabelsProvided && gl.labels.length > 0) {\n              gl.xAxisScale = this.scales.linearScale(1, gl.labels.length, ticks - 1); // this is the only place seriesX is again mutated\n\n              gl.seriesX = gl.labels.slice();\n            }\n          } // we will still store these labels as the count for this will be different (to draw grid and labels placement)\n\n\n          if (isXNumeric) {\n            gl.labels = gl.xAxisScale.result.slice();\n          }\n        }\n\n        if (gl.isBarHorizontal && gl.labels.length) {\n          gl.xTickAmount = gl.labels.length;\n        } // single dataPoint\n\n\n        this._handleSingleDataPoint(); // minimum x difference to calculate bar width in numeric bars\n\n\n        this._getMinXDiff();\n\n        return {\n          minX: gl.minX,\n          maxX: gl.maxX\n        };\n      }\n    }, {\n      key: \"setZRange\",\n      value: function setZRange() {\n        // minZ, maxZ starts here\n        var gl = this.w.globals;\n        if (!gl.isDataXYZ) return;\n\n        for (var i = 0; i < gl.series.length; i++) {\n          if (typeof gl.seriesZ[i] !== 'undefined') {\n            for (var j = 0; j < gl.seriesZ[i].length; j++) {\n              if (gl.seriesZ[i][j] !== null && Utils$1.isNumber(gl.seriesZ[i][j])) {\n                gl.maxZ = Math.max(gl.maxZ, gl.seriesZ[i][j]);\n                gl.minZ = Math.min(gl.minZ, gl.seriesZ[i][j]);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_handleSingleDataPoint\",\n      value: function _handleSingleDataPoint() {\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n\n        if (gl.minX === gl.maxX) {\n          var datetimeObj = new DateTime(this.ctx);\n\n          if (cnf.xaxis.type === 'datetime') {\n            var newMinX = datetimeObj.getDate(gl.minX);\n\n            if (cnf.xaxis.labels.datetimeUTC) {\n              newMinX.setUTCDate(newMinX.getUTCDate() - 2);\n            } else {\n              newMinX.setDate(newMinX.getDate() - 2);\n            }\n\n            gl.minX = new Date(newMinX).getTime();\n            var newMaxX = datetimeObj.getDate(gl.maxX);\n\n            if (cnf.xaxis.labels.datetimeUTC) {\n              newMaxX.setUTCDate(newMaxX.getUTCDate() + 2);\n            } else {\n              newMaxX.setDate(newMaxX.getDate() + 2);\n            }\n\n            gl.maxX = new Date(newMaxX).getTime();\n          } else if (cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided) {\n            gl.minX = gl.minX - 2;\n            gl.initialMinX = gl.minX;\n            gl.maxX = gl.maxX + 2;\n            gl.initialMaxX = gl.maxX;\n          }\n        }\n      }\n    }, {\n      key: \"_getMinXDiff\",\n      value: function _getMinXDiff() {\n        var gl = this.w.globals;\n\n        if (gl.isXNumeric) {\n          // get the least x diff if numeric x axis is present\n          gl.seriesX.forEach(function (sX, i) {\n            if (sX.length === 1) {\n              // a small hack to prevent overlapping multiple bars when there is just 1 datapoint in bar series.\n              // fix #811\n              sX.push(gl.seriesX[gl.maxValsInArrayIndex][gl.seriesX[gl.maxValsInArrayIndex].length - 1]);\n            } // fix #983 (clone the array to avoid side effects)\n\n\n            var seriesX = sX.slice();\n            seriesX.sort(function (a, b) {\n              return a - b;\n            });\n            seriesX.forEach(function (s, j) {\n              if (j > 0) {\n                var xDiff = s - seriesX[j - 1];\n\n                if (xDiff > 0) {\n                  gl.minXDiff = Math.min(xDiff, gl.minXDiff);\n                }\n              }\n            });\n\n            if (gl.dataPoints === 1 || gl.minXDiff === Number.MAX_VALUE) {\n              // fixes apexcharts.js #1221\n              gl.minXDiff = 0.5;\n            }\n          });\n        }\n      }\n    }, {\n      key: \"_setStackedMinMax\",\n      value: function _setStackedMinMax() {\n        var _this = this;\n\n        var gl = this.w.globals; // for stacked charts, we calculate each series's parallel values. i.e, series[0][j] + series[1][j] .... [series[i.length][j]] and get the max out of it\n\n        if (!gl.series.length) return;\n        var seriesGroups = gl.seriesGroups;\n\n        if (!seriesGroups.length) {\n          seriesGroups = [this.w.config.series.map(function (serie) {\n            return serie.name;\n          })];\n        }\n\n        var stackedPoss = {};\n        var stackedNegs = {};\n        seriesGroups.forEach(function (group) {\n          stackedPoss[group] = [];\n          stackedNegs[group] = [];\n\n          var indicesOfSeriesInGroup = _this.w.config.series.map(function (serie, si) {\n            return group.indexOf(serie.name) > -1 ? si : null;\n          }).filter(function (f) {\n            return f !== null;\n          });\n\n          indicesOfSeriesInGroup.forEach(function (i) {\n            for (var j = 0; j < gl.series[gl.maxValsInArrayIndex].length; j++) {\n              if (typeof stackedPoss[group][j] === 'undefined') {\n                stackedPoss[group][j] = 0;\n                stackedNegs[group][j] = 0;\n              }\n\n              if (gl.series[i][j] !== null && Utils$1.isNumber(gl.series[i][j])) {\n                gl.series[i][j] > 0 ? stackedPoss[group][j] += parseFloat(gl.series[i][j]) + 0.0001 : stackedNegs[group][j] += parseFloat(gl.series[i][j]);\n              }\n            }\n          });\n        });\n        Object.entries(stackedPoss).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 1),\n              key = _ref2[0];\n\n          stackedPoss[key].forEach(function (_, stgi) {\n            gl.maxY = Math.max(gl.maxY, stackedPoss[key][stgi]);\n            gl.minY = Math.min(gl.minY, stackedNegs[key][stgi]);\n          });\n        });\n      }\n    }]);\n\n    return Range;\n  }();\n\n  /**\n   * ApexCharts YAxis Class for drawing Y-Axis.\n   *\n   * @module YAxis\n   **/\n\n  var YAxis = /*#__PURE__*/function () {\n    function YAxis(ctx, elgrid) {\n      _classCallCheck(this, YAxis);\n\n      this.ctx = ctx;\n      this.elgrid = elgrid;\n      this.w = ctx.w;\n      var w = this.w;\n      this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;\n      this.axisFontFamily = w.config.xaxis.labels.style.fontFamily;\n      this.xaxisForeColors = w.config.xaxis.labels.style.colors;\n      this.isCategoryBarHorizontal = w.config.chart.type === 'bar' && w.config.plotOptions.bar.horizontal;\n      this.xAxisoffX = 0;\n\n      if (w.config.xaxis.position === 'bottom') {\n        this.xAxisoffX = w.globals.gridHeight;\n      }\n\n      this.drawnLabels = [];\n      this.axesUtils = new AxesUtils(ctx);\n    }\n\n    _createClass(YAxis, [{\n      key: \"drawYaxis\",\n      value: function drawYaxis(realIndex) {\n        var _this = this;\n\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var yaxisStyle = w.config.yaxis[realIndex].labels.style;\n        var yaxisFontSize = yaxisStyle.fontSize;\n        var yaxisFontFamily = yaxisStyle.fontFamily;\n        var yaxisFontWeight = yaxisStyle.fontWeight;\n        var elYaxis = graphics.group({\n          class: 'apexcharts-yaxis',\n          rel: realIndex,\n          transform: 'translate(' + w.globals.translateYAxisX[realIndex] + ', 0)'\n        });\n\n        if (this.axesUtils.isYAxisHidden(realIndex)) {\n          return elYaxis;\n        }\n\n        var elYaxisTexts = graphics.group({\n          class: 'apexcharts-yaxis-texts-g'\n        });\n        elYaxis.add(elYaxisTexts);\n        var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg height/number of ticks\n\n        var labelsDivider = w.globals.gridHeight / tickAmount; // initial label position = 0;\n\n        var l = w.globals.translateY;\n        var lbFormatter = w.globals.yLabelFormatters[realIndex];\n        var labels = w.globals.yAxisScale[realIndex].result.slice();\n        labels = this.axesUtils.checkForReversedLabels(realIndex, labels);\n        var firstLabel = '';\n\n        if (w.config.yaxis[realIndex].labels.show) {\n          var _loop = function _loop(i) {\n            var val = labels[i];\n            val = lbFormatter(val, i, w);\n            var xPad = w.config.yaxis[realIndex].labels.padding;\n\n            if (w.config.yaxis[realIndex].opposite && w.config.yaxis.length !== 0) {\n              xPad = xPad * -1;\n            }\n\n            var textAnchor = 'end';\n\n            if (w.config.yaxis[realIndex].opposite) {\n              textAnchor = 'start';\n            }\n\n            if (w.config.yaxis[realIndex].labels.align === 'left') {\n              textAnchor = 'start';\n            } else if (w.config.yaxis[realIndex].labels.align === 'center') {\n              textAnchor = 'middle';\n            } else if (w.config.yaxis[realIndex].labels.align === 'right') {\n              textAnchor = 'end';\n            }\n\n            var yColors = _this.axesUtils.getYAxisForeColor(yaxisStyle.colors, realIndex);\n\n            var getForeColor = function getForeColor() {\n              return Array.isArray(yColors) ? yColors[i] : yColors;\n            };\n\n            var offsetY = w.config.yaxis[realIndex].labels.offsetY;\n\n            if (w.config.chart.type === 'heatmap') {\n              var divisor = w.globals.gridHeight / w.globals.series.length - 1;\n              offsetY = offsetY - divisor / 2;\n            }\n\n            var label = graphics.drawText({\n              x: xPad,\n              y: l + tickAmount / 10 + offsetY + 1,\n              text: val,\n              textAnchor: textAnchor,\n              fontSize: yaxisFontSize,\n              fontFamily: yaxisFontFamily,\n              fontWeight: yaxisFontWeight,\n              maxWidth: w.config.yaxis[realIndex].labels.maxWidth,\n              foreColor: getForeColor(),\n              isPlainText: false,\n              cssClass: 'apexcharts-yaxis-label ' + yaxisStyle.cssClass\n            });\n\n            if (i === tickAmount) {\n              firstLabel = label;\n            }\n\n            elYaxisTexts.add(label);\n            var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n            elTooltipTitle.textContent = Array.isArray(val) ? val.join(' ') : val;\n            label.node.appendChild(elTooltipTitle);\n\n            if (w.config.yaxis[realIndex].labels.rotate !== 0) {\n              var firstabelRotatingCenter = graphics.rotateAroundCenter(firstLabel.node);\n              var labelRotatingCenter = graphics.rotateAroundCenter(label.node);\n              label.node.setAttribute('transform', \"rotate(\".concat(w.config.yaxis[realIndex].labels.rotate, \" \").concat(firstabelRotatingCenter.x, \" \").concat(labelRotatingCenter.y, \")\"));\n            }\n\n            l = l + labelsDivider;\n          };\n\n          for (var i = tickAmount; i >= 0; i--) {\n            _loop(i);\n          }\n        }\n\n        if (w.config.yaxis[realIndex].title.text !== undefined) {\n          var elYaxisTitle = graphics.group({\n            class: 'apexcharts-yaxis-title'\n          });\n          var _x = 0;\n\n          if (w.config.yaxis[realIndex].opposite) {\n            _x = w.globals.translateYAxisX[realIndex];\n          }\n\n          var elYAxisTitleText = graphics.drawText({\n            x: _x,\n            y: w.globals.gridHeight / 2 + w.globals.translateY + w.config.yaxis[realIndex].title.offsetY,\n            text: w.config.yaxis[realIndex].title.text,\n            textAnchor: 'end',\n            foreColor: w.config.yaxis[realIndex].title.style.color,\n            fontSize: w.config.yaxis[realIndex].title.style.fontSize,\n            fontWeight: w.config.yaxis[realIndex].title.style.fontWeight,\n            fontFamily: w.config.yaxis[realIndex].title.style.fontFamily,\n            cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[realIndex].title.style.cssClass\n          });\n          elYaxisTitle.add(elYAxisTitleText);\n          elYaxis.add(elYaxisTitle);\n        }\n\n        var axisBorder = w.config.yaxis[realIndex].axisBorder;\n        var x = 31 + axisBorder.offsetX;\n\n        if (w.config.yaxis[realIndex].opposite) {\n          x = -31 - axisBorder.offsetX;\n        }\n\n        if (axisBorder.show) {\n          var elVerticalLine = graphics.drawLine(x, w.globals.translateY + axisBorder.offsetY - 2, x, w.globals.gridHeight + w.globals.translateY + axisBorder.offsetY + 2, axisBorder.color, 0, axisBorder.width);\n          elYaxis.add(elVerticalLine);\n        }\n\n        if (w.config.yaxis[realIndex].axisTicks.show) {\n          this.axesUtils.drawYAxisTicks(x, tickAmount, axisBorder, w.config.yaxis[realIndex].axisTicks, realIndex, labelsDivider, elYaxis);\n        }\n\n        return elYaxis;\n      } // This actually becomes horizontal axis (for bar charts)\n\n    }, {\n      key: \"drawYaxisInversed\",\n      value: function drawYaxisInversed(realIndex) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var elXaxis = graphics.group({\n          class: 'apexcharts-xaxis apexcharts-yaxis-inversed'\n        });\n        var elXaxisTexts = graphics.group({\n          class: 'apexcharts-xaxis-texts-g',\n          transform: \"translate(\".concat(w.globals.translateXAxisX, \", \").concat(w.globals.translateXAxisY, \")\")\n        });\n        elXaxis.add(elXaxisTexts);\n        var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg width/number of ticks\n\n        var labelsDivider = w.globals.gridWidth / tickAmount + 0.1; // initial label position;\n\n        var l = labelsDivider + w.config.xaxis.labels.offsetX;\n        var lbFormatter = w.globals.xLabelFormatter;\n        var labels = w.globals.yAxisScale[realIndex].result.slice();\n        var timescaleLabels = w.globals.timescaleLabels;\n\n        if (timescaleLabels.length > 0) {\n          this.xaxisLabels = timescaleLabels.slice();\n          labels = timescaleLabels.slice();\n          tickAmount = labels.length;\n        }\n\n        labels = this.axesUtils.checkForReversedLabels(realIndex, labels);\n        var tl = timescaleLabels.length;\n\n        if (w.config.xaxis.labels.show) {\n          for (var i = tl ? 0 : tickAmount; tl ? i < tl : i >= 0; tl ? i++ : i--) {\n            var val = labels[i];\n            val = lbFormatter(val, i, w);\n            var x = w.globals.gridWidth + w.globals.padHorizontal - (l - labelsDivider + w.config.xaxis.labels.offsetX);\n\n            if (timescaleLabels.length) {\n              var label = this.axesUtils.getLabel(labels, timescaleLabels, x, i, this.drawnLabels, this.xaxisFontSize);\n              x = label.x;\n              val = label.text;\n              this.drawnLabels.push(label.text);\n\n              if (i === 0 && w.globals.skipFirstTimelinelabel) {\n                val = '';\n              }\n\n              if (i === labels.length - 1 && w.globals.skipLastTimelinelabel) {\n                val = '';\n              }\n            }\n\n            var elTick = graphics.drawText({\n              x: x,\n              y: this.xAxisoffX + w.config.xaxis.labels.offsetY + 30 - (w.config.xaxis.position === 'top' ? w.globals.xAxisHeight + w.config.xaxis.axisTicks.height - 2 : 0),\n              text: val,\n              textAnchor: 'middle',\n              foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[realIndex] : this.xaxisForeColors,\n              fontSize: this.xaxisFontSize,\n              fontFamily: this.xaxisFontFamily,\n              fontWeight: w.config.xaxis.labels.style.fontWeight,\n              isPlainText: false,\n              cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass\n            });\n            elXaxisTexts.add(elTick);\n            elTick.tspan(val);\n            var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n            elTooltipTitle.textContent = val;\n            elTick.node.appendChild(elTooltipTitle);\n            l = l + labelsDivider;\n          }\n        }\n\n        this.inversedYAxisTitleText(elXaxis);\n        this.inversedYAxisBorder(elXaxis);\n        return elXaxis;\n      }\n    }, {\n      key: \"inversedYAxisBorder\",\n      value: function inversedYAxisBorder(parent) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var axisBorder = w.config.xaxis.axisBorder;\n\n        if (axisBorder.show) {\n          var lineCorrection = 0;\n\n          if (w.config.chart.type === 'bar' && w.globals.isXNumeric) {\n            lineCorrection = lineCorrection - 15;\n          }\n\n          var elHorzLine = graphics.drawLine(w.globals.padHorizontal + lineCorrection + axisBorder.offsetX, this.xAxisoffX, w.globals.gridWidth, this.xAxisoffX, axisBorder.color, 0, axisBorder.height); // in horizontal bars, we append axisBorder to elGridBorders element to avoid z-index issues\n\n          if (this.elgrid && this.elgrid.elGridBorders && w.config.grid.show) {\n            this.elgrid.elGridBorders.add(elHorzLine);\n          } else {\n            parent.add(elHorzLine);\n          }\n        }\n      }\n    }, {\n      key: \"inversedYAxisTitleText\",\n      value: function inversedYAxisTitleText(parent) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n\n        if (w.config.xaxis.title.text !== undefined) {\n          var elYaxisTitle = graphics.group({\n            class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed'\n          });\n          var elYAxisTitleText = graphics.drawText({\n            x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,\n            y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(w.config.xaxis.title.style.fontSize) + w.config.xaxis.title.offsetY + 20,\n            text: w.config.xaxis.title.text,\n            textAnchor: 'middle',\n            fontSize: w.config.xaxis.title.style.fontSize,\n            fontFamily: w.config.xaxis.title.style.fontFamily,\n            fontWeight: w.config.xaxis.title.style.fontWeight,\n            foreColor: w.config.xaxis.title.style.color,\n            cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass\n          });\n          elYaxisTitle.add(elYAxisTitleText);\n          parent.add(elYaxisTitle);\n        }\n      }\n    }, {\n      key: \"yAxisTitleRotate\",\n      value: function yAxisTitleRotate(realIndex, yAxisOpposite) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var yAxisLabelsCoord = {\n          width: 0,\n          height: 0\n        };\n        var yAxisTitleCoord = {\n          width: 0,\n          height: 0\n        };\n        var elYAxisLabelsWrap = w.globals.dom.baseEl.querySelector(\" .apexcharts-yaxis[rel='\".concat(realIndex, \"'] .apexcharts-yaxis-texts-g\"));\n\n        if (elYAxisLabelsWrap !== null) {\n          yAxisLabelsCoord = elYAxisLabelsWrap.getBoundingClientRect();\n        }\n\n        var yAxisTitle = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxis[rel='\".concat(realIndex, \"'] .apexcharts-yaxis-title text\"));\n\n        if (yAxisTitle !== null) {\n          yAxisTitleCoord = yAxisTitle.getBoundingClientRect();\n        }\n\n        if (yAxisTitle !== null) {\n          var x = this.xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite);\n          yAxisTitle.setAttribute('x', x.xPos - (yAxisOpposite ? 10 : 0));\n        }\n\n        if (yAxisTitle !== null) {\n          var titleRotatingCenter = graphics.rotateAroundCenter(yAxisTitle);\n          yAxisTitle.setAttribute('transform', \"rotate(\".concat(yAxisOpposite ? w.config.yaxis[realIndex].title.rotate * -1 : w.config.yaxis[realIndex].title.rotate, \" \").concat(titleRotatingCenter.x, \" \").concat(titleRotatingCenter.y, \")\"));\n        }\n      }\n    }, {\n      key: \"xPaddingForYAxisTitle\",\n      value: function xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite) {\n        var w = this.w;\n        var oppositeAxisCount = 0;\n        var x = 0;\n        var padd = 10;\n\n        if (w.config.yaxis[realIndex].title.text === undefined || realIndex < 0) {\n          return {\n            xPos: x,\n            padd: 0\n          };\n        }\n\n        if (yAxisOpposite) {\n          x = yAxisLabelsCoord.width + w.config.yaxis[realIndex].title.offsetX + yAxisTitleCoord.width / 2 + padd / 2;\n          oppositeAxisCount += 1;\n\n          if (oppositeAxisCount === 0) {\n            x = x - padd / 2;\n          }\n        } else {\n          x = yAxisLabelsCoord.width * -1 + w.config.yaxis[realIndex].title.offsetX + padd / 2 + yAxisTitleCoord.width / 2;\n\n          if (w.globals.isBarHorizontal) {\n            padd = 25;\n            x = yAxisLabelsCoord.width * -1 - w.config.yaxis[realIndex].title.offsetX - padd;\n          }\n        }\n\n        return {\n          xPos: x,\n          padd: padd\n        };\n      } // sets the x position of the y-axis by counting the labels width, title width and any offset\n\n    }, {\n      key: \"setYAxisXPosition\",\n      value: function setYAxisXPosition(yaxisLabelCoords, yTitleCoords) {\n        var w = this.w;\n        var xLeft = 0;\n        var xRight = 0;\n        var leftOffsetX = 18;\n        var rightOffsetX = 1;\n\n        if (w.config.yaxis.length > 1) {\n          this.multipleYs = true;\n        }\n\n        w.config.yaxis.map(function (yaxe, index) {\n          var shouldNotDrawAxis = w.globals.ignoreYAxisIndexes.indexOf(index) > -1 || !yaxe.show || yaxe.floating || yaxisLabelCoords[index].width === 0;\n          var axisWidth = yaxisLabelCoords[index].width + yTitleCoords[index].width;\n\n          if (!yaxe.opposite) {\n            xLeft = w.globals.translateX - leftOffsetX;\n\n            if (!shouldNotDrawAxis) {\n              leftOffsetX = leftOffsetX + axisWidth + 20;\n            }\n\n            w.globals.translateYAxisX[index] = xLeft + yaxe.labels.offsetX;\n          } else {\n            if (w.globals.isBarHorizontal) {\n              xRight = w.globals.gridWidth + w.globals.translateX - 1;\n              w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX;\n            } else {\n              xRight = w.globals.gridWidth + w.globals.translateX + rightOffsetX;\n\n              if (!shouldNotDrawAxis) {\n                rightOffsetX = rightOffsetX + axisWidth + 20;\n              }\n\n              w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX + 20;\n            }\n          }\n        });\n      }\n    }, {\n      key: \"setYAxisTextAlignments\",\n      value: function setYAxisTextAlignments() {\n        var w = this.w;\n        var yaxis = w.globals.dom.baseEl.getElementsByClassName(\"apexcharts-yaxis\");\n        yaxis = Utils$1.listToArray(yaxis);\n        yaxis.forEach(function (y, index) {\n          var yaxe = w.config.yaxis[index]; // proceed only if user has specified alignment\n\n          if (yaxe && !yaxe.floating && yaxe.labels.align !== undefined) {\n            var yAxisInner = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxis[rel='\".concat(index, \"'] .apexcharts-yaxis-texts-g\"));\n            var yAxisTexts = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-yaxis[rel='\".concat(index, \"'] .apexcharts-yaxis-label\"));\n            yAxisTexts = Utils$1.listToArray(yAxisTexts);\n            var rect = yAxisInner.getBoundingClientRect();\n\n            if (yaxe.labels.align === 'left') {\n              yAxisTexts.forEach(function (label, lI) {\n                label.setAttribute('text-anchor', 'start');\n              });\n\n              if (!yaxe.opposite) {\n                yAxisInner.setAttribute('transform', \"translate(-\".concat(rect.width, \", 0)\"));\n              }\n            } else if (yaxe.labels.align === 'center') {\n              yAxisTexts.forEach(function (label, lI) {\n                label.setAttribute('text-anchor', 'middle');\n              });\n              yAxisInner.setAttribute('transform', \"translate(\".concat(rect.width / 2 * (!yaxe.opposite ? -1 : 1), \", 0)\"));\n            } else if (yaxe.labels.align === 'right') {\n              yAxisTexts.forEach(function (label, lI) {\n                label.setAttribute('text-anchor', 'end');\n              });\n\n              if (yaxe.opposite) {\n                yAxisInner.setAttribute('transform', \"translate(\".concat(rect.width, \", 0)\"));\n              }\n            }\n          }\n        });\n      }\n    }]);\n\n    return YAxis;\n  }();\n\n  var Events = /*#__PURE__*/function () {\n    function Events(ctx) {\n      _classCallCheck(this, Events);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.documentEvent = Utils$1.bind(this.documentEvent, this);\n    }\n\n    _createClass(Events, [{\n      key: \"addEventListener\",\n      value: function addEventListener(name, handler) {\n        var w = this.w;\n\n        if (w.globals.events.hasOwnProperty(name)) {\n          w.globals.events[name].push(handler);\n        } else {\n          w.globals.events[name] = [handler];\n        }\n      }\n    }, {\n      key: \"removeEventListener\",\n      value: function removeEventListener(name, handler) {\n        var w = this.w;\n\n        if (!w.globals.events.hasOwnProperty(name)) {\n          return;\n        }\n\n        var index = w.globals.events[name].indexOf(handler);\n\n        if (index !== -1) {\n          w.globals.events[name].splice(index, 1);\n        }\n      }\n    }, {\n      key: \"fireEvent\",\n      value: function fireEvent(name, args) {\n        var w = this.w;\n\n        if (!w.globals.events.hasOwnProperty(name)) {\n          return;\n        }\n\n        if (!args || !args.length) {\n          args = [];\n        }\n\n        var evs = w.globals.events[name];\n        var l = evs.length;\n\n        for (var i = 0; i < l; i++) {\n          evs[i].apply(null, args);\n        }\n      }\n    }, {\n      key: \"setupEventHandlers\",\n      value: function setupEventHandlers() {\n        var _this = this;\n\n        var w = this.w;\n        var me = this.ctx;\n        var clickableArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);\n        this.ctx.eventList.forEach(function (event) {\n          clickableArea.addEventListener(event, function (e) {\n            var opts = Object.assign({}, w, {\n              seriesIndex: w.globals.capturedSeriesIndex,\n              dataPointIndex: w.globals.capturedDataPointIndex\n            });\n\n            if (e.type === 'mousemove' || e.type === 'touchmove') {\n              if (typeof w.config.chart.events.mouseMove === 'function') {\n                w.config.chart.events.mouseMove(e, me, opts);\n              }\n            } else if (e.type === 'mouseleave' || e.type === 'touchleave') {\n              if (typeof w.config.chart.events.mouseLeave === 'function') {\n                w.config.chart.events.mouseLeave(e, me, opts);\n              }\n            } else if (e.type === 'mouseup' && e.which === 1 || e.type === 'touchend') {\n              if (typeof w.config.chart.events.click === 'function') {\n                w.config.chart.events.click(e, me, opts);\n              }\n\n              me.ctx.events.fireEvent('click', [e, me, opts]);\n            }\n          }, {\n            capture: false,\n            passive: true\n          });\n        });\n        this.ctx.eventList.forEach(function (event) {\n          w.globals.dom.baseEl.addEventListener(event, _this.documentEvent, {\n            passive: true\n          });\n        });\n        this.ctx.core.setupBrushHandler();\n      }\n    }, {\n      key: \"documentEvent\",\n      value: function documentEvent(e) {\n        var w = this.w;\n        var target = e.target.className;\n\n        if (e.type === 'click') {\n          var elMenu = w.globals.dom.baseEl.querySelector('.apexcharts-menu');\n\n          if (elMenu && elMenu.classList.contains('apexcharts-menu-open') && target !== 'apexcharts-menu-icon') {\n            elMenu.classList.remove('apexcharts-menu-open');\n          }\n        }\n\n        w.globals.clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n        w.globals.clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;\n      }\n    }]);\n\n    return Events;\n  }();\n\n  var Localization = /*#__PURE__*/function () {\n    function Localization(ctx) {\n      _classCallCheck(this, Localization);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(Localization, [{\n      key: \"setCurrentLocaleValues\",\n      value: function setCurrentLocaleValues(localeName) {\n        var locales = this.w.config.chart.locales; // check if user has specified locales in global Apex variable\n        // if yes - then extend those with local chart's locale\n\n        if (window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0) {\n          locales = this.w.config.chart.locales.concat(window.Apex.chart.locales);\n        } // find the locale from the array of locales which user has set (either by chart.defaultLocale or by calling setLocale() method.)\n\n\n        var selectedLocale = locales.filter(function (c) {\n          return c.name === localeName;\n        })[0];\n\n        if (selectedLocale) {\n          // create a complete locale object by extending defaults so you don't get undefined errors.\n          var ret = Utils$1.extend(en, selectedLocale); // store these locale options in global var for ease access\n\n          this.w.globals.locale = ret.options;\n        } else {\n          throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options');\n        }\n      }\n    }]);\n\n    return Localization;\n  }();\n\n  var Axes = /*#__PURE__*/function () {\n    function Axes(ctx) {\n      _classCallCheck(this, Axes);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(Axes, [{\n      key: \"drawAxis\",\n      value: function drawAxis(type, elgrid) {\n        var _this = this;\n\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n        var xAxis = new XAxis(this.ctx, elgrid);\n        var yAxis = new YAxis(this.ctx, elgrid);\n\n        if (gl.axisCharts && type !== 'radar') {\n          var elXaxis, elYaxis;\n\n          if (gl.isBarHorizontal) {\n            elYaxis = yAxis.drawYaxisInversed(0);\n            elXaxis = xAxis.drawXaxisInversed(0);\n            gl.dom.elGraphical.add(elXaxis);\n            gl.dom.elGraphical.add(elYaxis);\n          } else {\n            elXaxis = xAxis.drawXaxis();\n            gl.dom.elGraphical.add(elXaxis);\n            cnf.yaxis.map(function (yaxe, index) {\n              if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {\n                elYaxis = yAxis.drawYaxis(index);\n                gl.dom.Paper.add(elYaxis);\n\n                if (_this.w.config.grid.position === 'back') {\n                  var inner = gl.dom.Paper.children()[1];\n                  inner.remove();\n                  gl.dom.Paper.add(inner);\n                }\n              }\n            });\n          }\n        }\n      }\n    }]);\n\n    return Axes;\n  }();\n\n  var Crosshairs = /*#__PURE__*/function () {\n    function Crosshairs(ctx) {\n      _classCallCheck(this, Crosshairs);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(Crosshairs, [{\n      key: \"drawXCrosshairs\",\n      value: function drawXCrosshairs() {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var filters = new Filters(this.ctx);\n        var crosshairGradient = w.config.xaxis.crosshairs.fill.gradient;\n        var crosshairShadow = w.config.xaxis.crosshairs.dropShadow;\n        var fillType = w.config.xaxis.crosshairs.fill.type;\n        var gradientFrom = crosshairGradient.colorFrom;\n        var gradientTo = crosshairGradient.colorTo;\n        var opacityFrom = crosshairGradient.opacityFrom;\n        var opacityTo = crosshairGradient.opacityTo;\n        var stops = crosshairGradient.stops;\n        var shadow = 'none';\n        var dropShadow = crosshairShadow.enabled;\n        var shadowLeft = crosshairShadow.left;\n        var shadowTop = crosshairShadow.top;\n        var shadowBlur = crosshairShadow.blur;\n        var shadowColor = crosshairShadow.color;\n        var shadowOpacity = crosshairShadow.opacity;\n        var xcrosshairsFill = w.config.xaxis.crosshairs.fill.color;\n\n        if (w.config.xaxis.crosshairs.show) {\n          if (fillType === 'gradient') {\n            xcrosshairsFill = graphics.drawGradient('vertical', gradientFrom, gradientTo, opacityFrom, opacityTo, null, stops, null);\n          }\n\n          var xcrosshairs = graphics.drawRect();\n\n          if (w.config.xaxis.crosshairs.width === 1) {\n            // to prevent drawing 2 lines, convert rect to line\n            xcrosshairs = graphics.drawLine();\n          }\n\n          var gridHeight = w.globals.gridHeight;\n\n          if (!Utils$1.isNumber(gridHeight) || gridHeight < 0) {\n            gridHeight = 0;\n          }\n\n          var crosshairsWidth = w.config.xaxis.crosshairs.width;\n\n          if (!Utils$1.isNumber(crosshairsWidth) || crosshairsWidth < 0) {\n            crosshairsWidth = 0;\n          }\n\n          xcrosshairs.attr({\n            class: 'apexcharts-xcrosshairs',\n            x: 0,\n            y: 0,\n            y2: gridHeight,\n            width: crosshairsWidth,\n            height: gridHeight,\n            fill: xcrosshairsFill,\n            filter: shadow,\n            'fill-opacity': w.config.xaxis.crosshairs.opacity,\n            stroke: w.config.xaxis.crosshairs.stroke.color,\n            'stroke-width': w.config.xaxis.crosshairs.stroke.width,\n            'stroke-dasharray': w.config.xaxis.crosshairs.stroke.dashArray\n          });\n\n          if (dropShadow) {\n            xcrosshairs = filters.dropShadow(xcrosshairs, {\n              left: shadowLeft,\n              top: shadowTop,\n              blur: shadowBlur,\n              color: shadowColor,\n              opacity: shadowOpacity\n            });\n          }\n\n          w.globals.dom.elGraphical.add(xcrosshairs);\n        }\n      }\n    }, {\n      key: \"drawYCrosshairs\",\n      value: function drawYCrosshairs() {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var crosshair = w.config.yaxis[0].crosshairs;\n        var offX = w.globals.barPadForNumericAxis;\n\n        if (w.config.yaxis[0].crosshairs.show) {\n          var ycrosshairs = graphics.drawLine(-offX, 0, w.globals.gridWidth + offX, 0, crosshair.stroke.color, crosshair.stroke.dashArray, crosshair.stroke.width);\n          ycrosshairs.attr({\n            class: 'apexcharts-ycrosshairs'\n          });\n          w.globals.dom.elGraphical.add(ycrosshairs);\n        } // draw an invisible crosshair to help in positioning the yaxis tooltip\n\n\n        var ycrosshairsHidden = graphics.drawLine(-offX, 0, w.globals.gridWidth + offX, 0, crosshair.stroke.color, 0, 0);\n        ycrosshairsHidden.attr({\n          class: 'apexcharts-ycrosshairs-hidden'\n        });\n        w.globals.dom.elGraphical.add(ycrosshairsHidden);\n      }\n    }]);\n\n    return Crosshairs;\n  }();\n\n  /**\n   * ApexCharts Responsive Class to override options for different screen sizes.\n   *\n   * @module Responsive\n   **/\n\n  var Responsive = /*#__PURE__*/function () {\n    function Responsive(ctx) {\n      _classCallCheck(this, Responsive);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    } // the opts parameter if not null has to be set overriding everything\n    // as the opts is set by user externally\n\n\n    _createClass(Responsive, [{\n      key: \"checkResponsiveConfig\",\n      value: function checkResponsiveConfig(opts) {\n        var _this = this;\n\n        var w = this.w;\n        var cnf = w.config; // check if responsive config exists\n\n        if (cnf.responsive.length === 0) return;\n        var res = cnf.responsive.slice();\n        res.sort(function (a, b) {\n          return a.breakpoint > b.breakpoint ? 1 : b.breakpoint > a.breakpoint ? -1 : 0;\n        }).reverse();\n        var config = new Config({});\n\n        var iterateResponsiveOptions = function iterateResponsiveOptions() {\n          var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var largestBreakpoint = res[0].breakpoint;\n          var width = window.innerWidth > 0 ? window.innerWidth : screen.width;\n\n          if (width > largestBreakpoint) {\n            var options = CoreUtils.extendArrayProps(config, w.globals.initialConfig, w);\n            newOptions = Utils$1.extend(options, newOptions);\n            newOptions = Utils$1.extend(w.config, newOptions);\n\n            _this.overrideResponsiveOptions(newOptions);\n          } else {\n            for (var i = 0; i < res.length; i++) {\n              if (width < res[i].breakpoint) {\n                newOptions = CoreUtils.extendArrayProps(config, res[i].options, w);\n                newOptions = Utils$1.extend(w.config, newOptions);\n\n                _this.overrideResponsiveOptions(newOptions);\n              }\n            }\n          }\n        };\n\n        if (opts) {\n          var options = CoreUtils.extendArrayProps(config, opts, w);\n          options = Utils$1.extend(w.config, options);\n          options = Utils$1.extend(options, opts);\n          iterateResponsiveOptions(options);\n        } else {\n          iterateResponsiveOptions({});\n        }\n      }\n    }, {\n      key: \"overrideResponsiveOptions\",\n      value: function overrideResponsiveOptions(newOptions) {\n        var newConfig = new Config(newOptions).init({\n          responsiveOverride: true\n        });\n        this.w.config = newConfig;\n      }\n    }]);\n\n    return Responsive;\n  }();\n\n  /**\n   * ApexCharts Theme Class for setting the colors and palettes.\n   *\n   * @module Theme\n   **/\n\n  var Theme = /*#__PURE__*/function () {\n    function Theme(ctx) {\n      _classCallCheck(this, Theme);\n\n      this.ctx = ctx;\n      this.colors = [];\n      this.w = ctx.w;\n      var w = this.w;\n      this.isColorFn = false;\n      this.isHeatmapDistributed = w.config.chart.type === 'treemap' && w.config.plotOptions.treemap.distributed || w.config.chart.type === 'heatmap' && w.config.plotOptions.heatmap.distributed;\n      this.isBarDistributed = w.config.plotOptions.bar.distributed && (w.config.chart.type === 'bar' || w.config.chart.type === 'rangeBar');\n    }\n\n    _createClass(Theme, [{\n      key: \"init\",\n      value: function init() {\n        this.setDefaultColors();\n      }\n    }, {\n      key: \"setDefaultColors\",\n      value: function setDefaultColors() {\n        var _w$config$colors,\n            _this = this;\n\n        var w = this.w;\n        var utils = new Utils$1();\n        w.globals.dom.elWrap.classList.add(\"apexcharts-theme-\".concat(w.config.theme.mode));\n\n        if (w.config.colors === undefined || ((_w$config$colors = w.config.colors) === null || _w$config$colors === void 0 ? void 0 : _w$config$colors.length) === 0) {\n          w.globals.colors = this.predefined();\n        } else {\n          w.globals.colors = w.config.colors; // if user provided a function in colors, we need to eval here\n\n          if (Array.isArray(w.config.colors) && w.config.colors.length > 0 && typeof w.config.colors[0] === 'function') {\n            w.globals.colors = w.config.series.map(function (s, i) {\n              var c = w.config.colors[i];\n              if (!c) c = w.config.colors[0];\n\n              if (typeof c === 'function') {\n                _this.isColorFn = true;\n                return c({\n                  value: w.globals.axisCharts ? w.globals.series[i][0] ? w.globals.series[i][0] : 0 : w.globals.series[i],\n                  seriesIndex: i,\n                  dataPointIndex: i,\n                  w: w\n                });\n              }\n\n              return c;\n            });\n          }\n        } // user defined colors in series array\n\n\n        w.globals.seriesColors.map(function (c, i) {\n          if (c) {\n            w.globals.colors[i] = c;\n          }\n        });\n\n        if (w.config.theme.monochrome.enabled) {\n          var monoArr = [];\n          var glsCnt = w.globals.series.length;\n\n          if (this.isBarDistributed || this.isHeatmapDistributed) {\n            glsCnt = w.globals.series[0].length * w.globals.series.length;\n          }\n\n          var mainColor = w.config.theme.monochrome.color;\n          var part = 1 / (glsCnt / w.config.theme.monochrome.shadeIntensity);\n          var shade = w.config.theme.monochrome.shadeTo;\n          var percent = 0;\n\n          for (var gsl = 0; gsl < glsCnt; gsl++) {\n            var newColor = void 0;\n\n            if (shade === 'dark') {\n              newColor = utils.shadeColor(percent * -1, mainColor);\n              percent = percent + part;\n            } else {\n              newColor = utils.shadeColor(percent, mainColor);\n              percent = percent + part;\n            }\n\n            monoArr.push(newColor);\n          }\n\n          w.globals.colors = monoArr.slice();\n        }\n\n        var defaultColors = w.globals.colors.slice(); // if user specified fewer colors than no. of series, push the same colors again\n\n        this.pushExtraColors(w.globals.colors);\n        var colorTypes = ['fill', 'stroke'];\n        colorTypes.forEach(function (c) {\n          if (w.config[c].colors === undefined) {\n            w.globals[c].colors = _this.isColorFn ? w.config.colors : defaultColors;\n          } else {\n            w.globals[c].colors = w.config[c].colors.slice();\n          }\n\n          _this.pushExtraColors(w.globals[c].colors);\n        });\n\n        if (w.config.dataLabels.style.colors === undefined) {\n          w.globals.dataLabels.style.colors = defaultColors;\n        } else {\n          w.globals.dataLabels.style.colors = w.config.dataLabels.style.colors.slice();\n        }\n\n        this.pushExtraColors(w.globals.dataLabels.style.colors, 50);\n\n        if (w.config.plotOptions.radar.polygons.fill.colors === undefined) {\n          w.globals.radarPolygons.fill.colors = [w.config.theme.mode === 'dark' ? '#424242' : 'none'];\n        } else {\n          w.globals.radarPolygons.fill.colors = w.config.plotOptions.radar.polygons.fill.colors.slice();\n        }\n\n        this.pushExtraColors(w.globals.radarPolygons.fill.colors, 20); // The point colors\n\n        if (w.config.markers.colors === undefined) {\n          w.globals.markers.colors = defaultColors;\n        } else {\n          w.globals.markers.colors = w.config.markers.colors.slice();\n        }\n\n        this.pushExtraColors(w.globals.markers.colors);\n      } // When the number of colors provided is less than the number of series, this method\n      // will push same colors to the list\n      // params:\n      // distributed is only valid for distributed column/bar charts\n\n    }, {\n      key: \"pushExtraColors\",\n      value: function pushExtraColors(colorSeries, length) {\n        var distributed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var w = this.w;\n        var len = length || w.globals.series.length;\n\n        if (distributed === null) {\n          distributed = this.isBarDistributed || this.isHeatmapDistributed || w.config.chart.type === 'heatmap' && w.config.plotOptions.heatmap.colorScale.inverse;\n        }\n\n        if (distributed && w.globals.series.length) {\n          len = w.globals.series[w.globals.maxValsInArrayIndex].length * w.globals.series.length;\n        }\n\n        if (colorSeries.length < len) {\n          var diff = len - colorSeries.length;\n\n          for (var i = 0; i < diff; i++) {\n            colorSeries.push(colorSeries[i]);\n          }\n        }\n      }\n    }, {\n      key: \"updateThemeOptions\",\n      value: function updateThemeOptions(options) {\n        options.chart = options.chart || {};\n        options.tooltip = options.tooltip || {};\n        var mode = options.theme.mode || 'light';\n        var palette = options.theme.palette ? options.theme.palette : mode === 'dark' ? 'palette4' : 'palette1';\n        var foreColor = options.chart.foreColor ? options.chart.foreColor : mode === 'dark' ? '#f6f7f8' : '#373d3f';\n        options.tooltip.theme = mode;\n        options.chart.foreColor = foreColor;\n        options.theme.palette = palette;\n        return options;\n      }\n    }, {\n      key: \"predefined\",\n      value: function predefined() {\n        var palette = this.w.config.theme.palette; // D6E3F8, FCEFEF, DCE0D9, A5978B, EDDDD4, D6E3F8, FEF5EF\n\n        switch (palette) {\n          case 'palette1':\n            this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];\n            break;\n\n          case 'palette2':\n            this.colors = ['#3f51b5', '#03a9f4', '#4caf50', '#f9ce1d', '#FF9800'];\n            break;\n\n          case 'palette3':\n            this.colors = ['#33b2df', '#546E7A', '#d4526e', '#13d8aa', '#A5978B'];\n            break;\n\n          case 'palette4':\n            this.colors = ['#4ecdc4', '#c7f464', '#81D4FA', '#fd6a6a', '#546E7A'];\n            break;\n\n          case 'palette5':\n            this.colors = ['#2b908f', '#f9a3a4', '#90ee7e', '#fa4443', '#69d2e7'];\n            break;\n\n          case 'palette6':\n            this.colors = ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D'];\n            break;\n\n          case 'palette7':\n            this.colors = ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044'];\n            break;\n\n          case 'palette8':\n            this.colors = ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD'];\n            break;\n\n          case 'palette9':\n            this.colors = ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF'];\n            break;\n\n          case 'palette10':\n            this.colors = ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2'];\n            break;\n\n          default:\n            this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];\n            break;\n        }\n\n        return this.colors;\n      }\n    }]);\n\n    return Theme;\n  }();\n\n  var TitleSubtitle = /*#__PURE__*/function () {\n    function TitleSubtitle(ctx) {\n      _classCallCheck(this, TitleSubtitle);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(TitleSubtitle, [{\n      key: \"draw\",\n      value: function draw() {\n        this.drawTitleSubtitle('title');\n        this.drawTitleSubtitle('subtitle');\n      }\n    }, {\n      key: \"drawTitleSubtitle\",\n      value: function drawTitleSubtitle(type) {\n        var w = this.w;\n        var tsConfig = type === 'title' ? w.config.title : w.config.subtitle;\n        var x = w.globals.svgWidth / 2;\n        var y = tsConfig.offsetY;\n        var textAnchor = 'middle';\n\n        if (tsConfig.align === 'left') {\n          x = 10;\n          textAnchor = 'start';\n        } else if (tsConfig.align === 'right') {\n          x = w.globals.svgWidth - 10;\n          textAnchor = 'end';\n        }\n\n        x = x + tsConfig.offsetX;\n        y = y + parseInt(tsConfig.style.fontSize, 10) + tsConfig.margin / 2;\n\n        if (tsConfig.text !== undefined) {\n          var graphics = new Graphics(this.ctx);\n          var titleText = graphics.drawText({\n            x: x,\n            y: y,\n            text: tsConfig.text,\n            textAnchor: textAnchor,\n            fontSize: tsConfig.style.fontSize,\n            fontFamily: tsConfig.style.fontFamily,\n            fontWeight: tsConfig.style.fontWeight,\n            foreColor: tsConfig.style.color,\n            opacity: 1\n          });\n          titleText.node.setAttribute('class', \"apexcharts-\".concat(type, \"-text\"));\n          w.globals.dom.Paper.add(titleText);\n        }\n      }\n    }]);\n\n    return TitleSubtitle;\n  }();\n\n  var Helpers$3 = /*#__PURE__*/function () {\n    function Helpers(dCtx) {\n      _classCallCheck(this, Helpers);\n\n      this.w = dCtx.w;\n      this.dCtx = dCtx;\n    }\n    /**\n     * Get Chart Title/Subtitle Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n\n    _createClass(Helpers, [{\n      key: \"getTitleSubtitleCoords\",\n      value: function getTitleSubtitleCoords(type) {\n        var w = this.w;\n        var width = 0;\n        var height = 0;\n        var floating = type === 'title' ? w.config.title.floating : w.config.subtitle.floating;\n        var el = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-text\"));\n\n        if (el !== null && !floating) {\n          var coord = el.getBoundingClientRect();\n          width = coord.width;\n          height = w.globals.axisCharts ? coord.height + 5 : coord.height;\n        }\n\n        return {\n          width: width,\n          height: height\n        };\n      }\n    }, {\n      key: \"getLegendsRect\",\n      value: function getLegendsRect() {\n        var w = this.w;\n        var elLegendWrap = w.globals.dom.elLegendWrap;\n\n        if (!w.config.legend.height && (w.config.legend.position === 'top' || w.config.legend.position === 'bottom')) {\n          // avoid legend to take up all the space\n          elLegendWrap.style.maxHeight = w.globals.svgHeight / 2 + 'px';\n        }\n\n        var lgRect = Object.assign({}, Utils$1.getBoundingClientRect(elLegendWrap));\n\n        if (elLegendWrap !== null && !w.config.legend.floating && w.config.legend.show) {\n          this.dCtx.lgRect = {\n            x: lgRect.x,\n            y: lgRect.y,\n            height: lgRect.height,\n            width: lgRect.height === 0 ? 0 : lgRect.width\n          };\n        } else {\n          this.dCtx.lgRect = {\n            x: 0,\n            y: 0,\n            height: 0,\n            width: 0\n          };\n        } // if legend takes up all of the chart space, we need to restrict it.\n\n\n        if (w.config.legend.position === 'left' || w.config.legend.position === 'right') {\n          if (this.dCtx.lgRect.width * 1.5 > w.globals.svgWidth) {\n            this.dCtx.lgRect.width = w.globals.svgWidth / 1.5;\n          }\n        }\n\n        return this.dCtx.lgRect;\n      }\n    }, {\n      key: \"getLargestStringFromMultiArr\",\n      value: function getLargestStringFromMultiArr(val, arr) {\n        var w = this.w;\n        var valArr = val;\n\n        if (w.globals.isMultiLineX) {\n          // if the xaxis labels has multiline texts (array)\n          var maxArrs = arr.map(function (xl, idx) {\n            return Array.isArray(xl) ? xl.length : 1;\n          });\n          var maxArrLen = Math.max.apply(Math, _toConsumableArray(maxArrs));\n          var maxArrIndex = maxArrs.indexOf(maxArrLen);\n          valArr = arr[maxArrIndex];\n        }\n\n        return valArr;\n      }\n    }]);\n\n    return Helpers;\n  }();\n\n  var DimXAxis = /*#__PURE__*/function () {\n    function DimXAxis(dCtx) {\n      _classCallCheck(this, DimXAxis);\n\n      this.w = dCtx.w;\n      this.dCtx = dCtx;\n    }\n    /**\n     * Get X Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n\n    _createClass(DimXAxis, [{\n      key: \"getxAxisLabelsCoords\",\n      value: function getxAxisLabelsCoords() {\n        var w = this.w;\n        var xaxisLabels = w.globals.labels.slice();\n\n        if (w.config.xaxis.convertedCatToNumeric && xaxisLabels.length === 0) {\n          xaxisLabels = w.globals.categoryLabels;\n        }\n\n        var rect;\n\n        if (w.globals.timescaleLabels.length > 0) {\n          var coords = this.getxAxisTimeScaleLabelsCoords();\n          rect = {\n            width: coords.width,\n            height: coords.height\n          };\n          w.globals.rotateXLabels = false;\n        } else {\n          this.dCtx.lgWidthForSideLegends = (w.config.legend.position === 'left' || w.config.legend.position === 'right') && !w.config.legend.floating ? this.dCtx.lgRect.width : 0; // get the longest string from the labels array and also apply label formatter\n\n          var xlbFormatter = w.globals.xLabelFormatter; // prevent changing xaxisLabels to avoid issues in multi-yaxes - fix #522\n\n          var val = Utils$1.getLargestStringFromArr(xaxisLabels);\n          var valArr = this.dCtx.dimHelpers.getLargestStringFromMultiArr(val, xaxisLabels); // the labels gets changed for bar charts\n\n          if (w.globals.isBarHorizontal) {\n            val = w.globals.yAxisScale[0].result.reduce(function (a, b) {\n              return a.length > b.length ? a : b;\n            }, 0);\n            valArr = val;\n          }\n\n          var xFormat = new Formatters(this.dCtx.ctx);\n          var timestamp = val;\n          val = xFormat.xLabelFormat(xlbFormatter, val, timestamp, {\n            i: undefined,\n            dateFormatter: new DateTime(this.dCtx.ctx).formatDate,\n            w: w\n          });\n          valArr = xFormat.xLabelFormat(xlbFormatter, valArr, timestamp, {\n            i: undefined,\n            dateFormatter: new DateTime(this.dCtx.ctx).formatDate,\n            w: w\n          });\n\n          if (w.config.xaxis.convertedCatToNumeric && typeof val === 'undefined' || String(val).trim() === '') {\n            val = '1';\n            valArr = val;\n          }\n\n          var graphics = new Graphics(this.dCtx.ctx);\n          var xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);\n          var xArrLabelrect = xLabelrect;\n\n          if (val !== valArr) {\n            xArrLabelrect = graphics.getTextRects(valArr, w.config.xaxis.labels.style.fontSize);\n          }\n\n          rect = {\n            width: xLabelrect.width >= xArrLabelrect.width ? xLabelrect.width : xArrLabelrect.width,\n            height: xLabelrect.height >= xArrLabelrect.height ? xLabelrect.height : xArrLabelrect.height\n          };\n\n          if (rect.width * xaxisLabels.length > w.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && w.config.xaxis.labels.rotate !== 0 || w.config.xaxis.labels.rotateAlways) {\n            if (!w.globals.isBarHorizontal) {\n              w.globals.rotateXLabels = true;\n\n              var getRotatedTextRects = function getRotatedTextRects(text) {\n                return graphics.getTextRects(text, w.config.xaxis.labels.style.fontSize, w.config.xaxis.labels.style.fontFamily, \"rotate(\".concat(w.config.xaxis.labels.rotate, \" 0 0)\"), false);\n              };\n\n              xLabelrect = getRotatedTextRects(val);\n\n              if (val !== valArr) {\n                xArrLabelrect = getRotatedTextRects(valArr);\n              }\n\n              rect.height = (xLabelrect.height > xArrLabelrect.height ? xLabelrect.height : xArrLabelrect.height) / 1.5;\n              rect.width = xLabelrect.width > xArrLabelrect.width ? xLabelrect.width : xArrLabelrect.width;\n            }\n          } else {\n            w.globals.rotateXLabels = false;\n          }\n        }\n\n        if (!w.config.xaxis.labels.show) {\n          rect = {\n            width: 0,\n            height: 0\n          };\n        }\n\n        return {\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      /**\n       * Get X Axis Label Group height\n       * @memberof Dimensions\n       * @return {{width, height}}\n       */\n\n    }, {\n      key: \"getxAxisGroupLabelsCoords\",\n      value: function getxAxisGroupLabelsCoords() {\n        var _w$config$xaxis$group;\n\n        var w = this.w;\n\n        if (!w.globals.hasXaxisGroups) {\n          return {\n            width: 0,\n            height: 0\n          };\n        }\n\n        var fontSize = ((_w$config$xaxis$group = w.config.xaxis.group.style) === null || _w$config$xaxis$group === void 0 ? void 0 : _w$config$xaxis$group.fontSize) || w.config.xaxis.labels.style.fontSize;\n        var xaxisLabels = w.globals.groups.map(function (g) {\n          return g.title;\n        });\n        var rect; // prevent changing xaxisLabels to avoid issues in multi-yaxes - fix #522\n\n        var val = Utils$1.getLargestStringFromArr(xaxisLabels);\n        var valArr = this.dCtx.dimHelpers.getLargestStringFromMultiArr(val, xaxisLabels);\n        var graphics = new Graphics(this.dCtx.ctx);\n        var xLabelrect = graphics.getTextRects(val, fontSize);\n        var xArrLabelrect = xLabelrect;\n\n        if (val !== valArr) {\n          xArrLabelrect = graphics.getTextRects(valArr, fontSize);\n        }\n\n        rect = {\n          width: xLabelrect.width >= xArrLabelrect.width ? xLabelrect.width : xArrLabelrect.width,\n          height: xLabelrect.height >= xArrLabelrect.height ? xLabelrect.height : xArrLabelrect.height\n        };\n\n        if (!w.config.xaxis.labels.show) {\n          rect = {\n            width: 0,\n            height: 0\n          };\n        }\n\n        return {\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      /**\n       * Get X Axis Title Dimensions\n       * @memberof Dimensions\n       * @return {{width, height}}\n       **/\n\n    }, {\n      key: \"getxAxisTitleCoords\",\n      value: function getxAxisTitleCoords() {\n        var w = this.w;\n        var width = 0;\n        var height = 0;\n\n        if (w.config.xaxis.title.text !== undefined) {\n          var graphics = new Graphics(this.dCtx.ctx);\n          var rect = graphics.getTextRects(w.config.xaxis.title.text, w.config.xaxis.title.style.fontSize);\n          width = rect.width;\n          height = rect.height;\n        }\n\n        return {\n          width: width,\n          height: height\n        };\n      }\n    }, {\n      key: \"getxAxisTimeScaleLabelsCoords\",\n      value: function getxAxisTimeScaleLabelsCoords() {\n        var w = this.w;\n        var rect;\n        this.dCtx.timescaleLabels = w.globals.timescaleLabels.slice();\n        var labels = this.dCtx.timescaleLabels.map(function (label) {\n          return label.value;\n        }); //  get the longest string from the labels array and also apply label formatter to it\n\n        var val = labels.reduce(function (a, b) {\n          // if undefined, maybe user didn't pass the datetime(x) values\n          if (typeof a === 'undefined') {\n            console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date');\n            return 0;\n          } else {\n            return a.length > b.length ? a : b;\n          }\n        }, 0);\n        var graphics = new Graphics(this.dCtx.ctx);\n        rect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);\n        var totalWidthRotated = rect.width * 1.05 * labels.length;\n\n        if (totalWidthRotated > w.globals.gridWidth && w.config.xaxis.labels.rotate !== 0) {\n          w.globals.overlappingXLabels = true;\n        }\n\n        return rect;\n      } // In certain cases, the last labels gets cropped in xaxis.\n      // Hence, we add some additional padding based on the label length to avoid the last label being cropped or we don't draw it at all\n\n    }, {\n      key: \"additionalPaddingXLabels\",\n      value: function additionalPaddingXLabels(xaxisLabelCoords) {\n        var _this = this;\n\n        var w = this.w;\n        var gl = w.globals;\n        var cnf = w.config;\n        var xtype = cnf.xaxis.type;\n        var lbWidth = xaxisLabelCoords.width;\n        gl.skipLastTimelinelabel = false;\n        gl.skipFirstTimelinelabel = false;\n        var isBarOpposite = w.config.yaxis[0].opposite && w.globals.isBarHorizontal;\n\n        var isCollapsed = function isCollapsed(i) {\n          return gl.collapsedSeriesIndices.indexOf(i) !== -1;\n        };\n\n        var rightPad = function rightPad(yaxe) {\n          if (_this.dCtx.timescaleLabels && _this.dCtx.timescaleLabels.length) {\n            // for timeline labels, we take the last label and check if it exceeds gridWidth\n            var firstimescaleLabel = _this.dCtx.timescaleLabels[0];\n            var lastTimescaleLabel = _this.dCtx.timescaleLabels[_this.dCtx.timescaleLabels.length - 1];\n            var lastLabelPosition = lastTimescaleLabel.position + lbWidth / 1.75 - _this.dCtx.yAxisWidthRight;\n            var firstLabelPosition = firstimescaleLabel.position - lbWidth / 1.75 + _this.dCtx.yAxisWidthLeft;\n            var lgRightRectWidth = w.config.legend.position === 'right' && _this.dCtx.lgRect.width > 0 ? _this.dCtx.lgRect.width : 0;\n\n            if (lastLabelPosition > gl.svgWidth - gl.translateX - lgRightRectWidth) {\n              gl.skipLastTimelinelabel = true;\n            }\n\n            if (firstLabelPosition < -((!yaxe.show || yaxe.floating) && (cnf.chart.type === 'bar' || cnf.chart.type === 'candlestick' || cnf.chart.type === 'rangeBar' || cnf.chart.type === 'boxPlot') ? lbWidth / 1.75 : 10)) {\n              gl.skipFirstTimelinelabel = true;\n            }\n          } else if (xtype === 'datetime') {\n            // If user has enabled DateTime, but uses own's formatter\n            if (_this.dCtx.gridPad.right < lbWidth && !gl.rotateXLabels) {\n              gl.skipLastTimelinelabel = true;\n            }\n          } else if (xtype !== 'datetime') {\n            if (_this.dCtx.gridPad.right < lbWidth / 2 - _this.dCtx.yAxisWidthRight && !gl.rotateXLabels && !w.config.xaxis.labels.trim && (w.config.xaxis.tickPlacement !== 'between' || w.globals.isBarHorizontal)) {\n              _this.dCtx.xPadRight = lbWidth / 2 + 1;\n            }\n          }\n        };\n\n        var padYAxe = function padYAxe(yaxe, i) {\n          if (cnf.yaxis.length > 1 && isCollapsed(i)) return;\n          rightPad(yaxe);\n        };\n\n        cnf.yaxis.forEach(function (yaxe, i) {\n          if (isBarOpposite) {\n            if (_this.dCtx.gridPad.left < lbWidth) {\n              _this.dCtx.xPadLeft = lbWidth / 2 + 1;\n            }\n\n            _this.dCtx.xPadRight = lbWidth / 2 + 1;\n          } else {\n            padYAxe(yaxe, i);\n          }\n        });\n      }\n    }]);\n\n    return DimXAxis;\n  }();\n\n  var DimYAxis = /*#__PURE__*/function () {\n    function DimYAxis(dCtx) {\n      _classCallCheck(this, DimYAxis);\n\n      this.w = dCtx.w;\n      this.dCtx = dCtx;\n    }\n    /**\n     * Get Y Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n\n    _createClass(DimYAxis, [{\n      key: \"getyAxisLabelsCoords\",\n      value: function getyAxisLabelsCoords() {\n        var _this = this;\n\n        var w = this.w;\n        var width = 0;\n        var height = 0;\n        var ret = [];\n        var labelPad = 10;\n        var axesUtils = new AxesUtils(this.dCtx.ctx);\n        w.config.yaxis.map(function (yaxe, index) {\n          var formatterArgs = {\n            seriesIndex: index,\n            dataPointIndex: -1,\n            w: w\n          };\n          var yS = w.globals.yAxisScale[index];\n          var yAxisMinWidth = 0;\n          if (!axesUtils.isYAxisHidden(index) && yaxe.labels.show && yaxe.labels.minWidth !== undefined) yAxisMinWidth = yaxe.labels.minWidth;\n\n          if (!axesUtils.isYAxisHidden(index) && yaxe.labels.show && yS.result.length) {\n            var lbFormatter = w.globals.yLabelFormatters[index];\n            var minV = yS.niceMin === Number.MIN_VALUE ? 0 : yS.niceMin;\n            var val = yS.result.reduce(function (acc, curr) {\n              var _String, _String2;\n\n              return ((_String = String(lbFormatter(acc, formatterArgs))) === null || _String === void 0 ? void 0 : _String.length) > ((_String2 = String(lbFormatter(curr, formatterArgs))) === null || _String2 === void 0 ? void 0 : _String2.length) ? acc : curr;\n            }, minV);\n            val = lbFormatter(val, formatterArgs); // the second parameter -1 is the index of tick which user can use in the formatter\n\n            var valArr = val; // if user has specified a custom formatter, and the result is null or empty, we need to discard the formatter and take the value as it is.\n\n            if (typeof val === 'undefined' || val.length === 0) {\n              val = yS.niceMax;\n            }\n\n            if (w.globals.isBarHorizontal) {\n              labelPad = 0;\n              var barYaxisLabels = w.globals.labels.slice(); //  get the longest string from the labels array and also apply label formatter to it\n\n              val = Utils$1.getLargestStringFromArr(barYaxisLabels);\n              val = lbFormatter(val, {\n                seriesIndex: index,\n                dataPointIndex: -1,\n                w: w\n              });\n              valArr = _this.dCtx.dimHelpers.getLargestStringFromMultiArr(val, barYaxisLabels);\n            }\n\n            var graphics = new Graphics(_this.dCtx.ctx);\n            var rotateStr = 'rotate('.concat(yaxe.labels.rotate, ' 0 0)');\n            var rect = graphics.getTextRects(val, yaxe.labels.style.fontSize, yaxe.labels.style.fontFamily, rotateStr, false);\n            var arrLabelrect = rect;\n\n            if (val !== valArr) {\n              arrLabelrect = graphics.getTextRects(valArr, yaxe.labels.style.fontSize, yaxe.labels.style.fontFamily, rotateStr, false);\n            }\n\n            ret.push({\n              width: (yAxisMinWidth > arrLabelrect.width || yAxisMinWidth > rect.width ? yAxisMinWidth : arrLabelrect.width > rect.width ? arrLabelrect.width : rect.width) + labelPad,\n              height: arrLabelrect.height > rect.height ? arrLabelrect.height : rect.height\n            });\n          } else {\n            ret.push({\n              width: width,\n              height: height\n            });\n          }\n        });\n        return ret;\n      }\n      /**\n       * Get Y Axis Dimensions\n       * @memberof Dimensions\n       * @return {{width, height}}\n       **/\n\n    }, {\n      key: \"getyAxisTitleCoords\",\n      value: function getyAxisTitleCoords() {\n        var _this2 = this;\n\n        var w = this.w;\n        var ret = [];\n        w.config.yaxis.map(function (yaxe, index) {\n          if (yaxe.show && yaxe.title.text !== undefined) {\n            var graphics = new Graphics(_this2.dCtx.ctx);\n            var rotateStr = 'rotate('.concat(yaxe.title.rotate, ' 0 0)');\n            var rect = graphics.getTextRects(yaxe.title.text, yaxe.title.style.fontSize, yaxe.title.style.fontFamily, rotateStr, false);\n            ret.push({\n              width: rect.width,\n              height: rect.height\n            });\n          } else {\n            ret.push({\n              width: 0,\n              height: 0\n            });\n          }\n        });\n        return ret;\n      }\n    }, {\n      key: \"getTotalYAxisWidth\",\n      value: function getTotalYAxisWidth() {\n        var w = this.w;\n        var yAxisWidth = 0;\n        var yAxisWidthLeft = 0;\n        var yAxisWidthRight = 0;\n        var padding = w.globals.yAxisScale.length > 1 ? 10 : 0;\n        var axesUtils = new AxesUtils(this.dCtx.ctx);\n\n        var isHiddenYAxis = function isHiddenYAxis(index) {\n          return w.globals.ignoreYAxisIndexes.indexOf(index) > -1;\n        };\n\n        var padForLabelTitle = function padForLabelTitle(coord, index) {\n          var floating = w.config.yaxis[index].floating;\n          var width = 0;\n\n          if (coord.width > 0 && !floating) {\n            width = coord.width + padding;\n\n            if (isHiddenYAxis(index)) {\n              width = width - coord.width - padding;\n            }\n          } else {\n            width = floating || axesUtils.isYAxisHidden(index) ? 0 : 5;\n          }\n\n          w.config.yaxis[index].opposite ? yAxisWidthRight = yAxisWidthRight + width : yAxisWidthLeft = yAxisWidthLeft + width;\n          yAxisWidth = yAxisWidth + width;\n        };\n\n        w.globals.yLabelsCoords.map(function (yLabelCoord, index) {\n          padForLabelTitle(yLabelCoord, index);\n        });\n        w.globals.yTitleCoords.map(function (yTitleCoord, index) {\n          padForLabelTitle(yTitleCoord, index);\n        });\n\n        if (w.globals.isBarHorizontal && !w.config.yaxis[0].floating) {\n          yAxisWidth = w.globals.yLabelsCoords[0].width + w.globals.yTitleCoords[0].width + 15;\n        }\n\n        this.dCtx.yAxisWidthLeft = yAxisWidthLeft;\n        this.dCtx.yAxisWidthRight = yAxisWidthRight;\n        return yAxisWidth;\n      }\n    }]);\n\n    return DimYAxis;\n  }();\n\n  var DimGrid = /*#__PURE__*/function () {\n    function DimGrid(dCtx) {\n      _classCallCheck(this, DimGrid);\n\n      this.w = dCtx.w;\n      this.dCtx = dCtx;\n    }\n\n    _createClass(DimGrid, [{\n      key: \"gridPadForColumnsInNumericAxis\",\n      value: function gridPadForColumnsInNumericAxis(gridWidth) {\n        var w = this.w;\n\n        if (w.globals.noData || w.globals.allSeriesCollapsed) {\n          return 0;\n        }\n\n        var hasBar = function hasBar(type) {\n          return type === 'bar' || type === 'rangeBar' || type === 'candlestick' || type === 'boxPlot';\n        };\n\n        var type = w.config.chart.type;\n        var barWidth = 0;\n        var seriesLen = hasBar(type) ? w.config.series.length : 1;\n\n        if (w.globals.comboBarCount > 0) {\n          seriesLen = w.globals.comboBarCount;\n        }\n\n        w.globals.collapsedSeries.forEach(function (c) {\n          if (hasBar(c.type)) {\n            seriesLen = seriesLen - 1;\n          }\n        });\n\n        if (w.config.chart.stacked) {\n          seriesLen = 1;\n        }\n\n        var barsPresent = hasBar(type) || w.globals.comboBarCount > 0;\n\n        if (barsPresent && w.globals.isXNumeric && !w.globals.isBarHorizontal && seriesLen > 0) {\n          var xRatio = 0;\n          var xRange = Math.abs(w.globals.initialMaxX - w.globals.initialMinX);\n\n          if (xRange <= 3) {\n            xRange = w.globals.dataPoints;\n          }\n\n          xRatio = xRange / gridWidth;\n          var xDivision; // max barwidth should be equal to minXDiff to avoid overlap\n\n          if (w.globals.minXDiff && w.globals.minXDiff / xRatio > 0) {\n            xDivision = w.globals.minXDiff / xRatio;\n          }\n\n          if (xDivision > gridWidth / 2) {\n            xDivision = xDivision / 2;\n          }\n\n          barWidth = xDivision / seriesLen * parseInt(w.config.plotOptions.bar.columnWidth, 10) / 100;\n\n          if (barWidth < 1) {\n            barWidth = 1;\n          }\n\n          barWidth = barWidth / (seriesLen > 1 ? 1 : 1.5) + 5;\n          w.globals.barPadForNumericAxis = barWidth;\n        }\n\n        return barWidth;\n      }\n    }, {\n      key: \"gridPadFortitleSubtitle\",\n      value: function gridPadFortitleSubtitle() {\n        var _this = this;\n\n        var w = this.w;\n        var gl = w.globals;\n        var gridShrinkOffset = this.dCtx.isSparkline || !w.globals.axisCharts ? 0 : 10;\n        var titleSubtitle = ['title', 'subtitle'];\n        titleSubtitle.forEach(function (t) {\n          if (w.config[t].text !== undefined) {\n            gridShrinkOffset += w.config[t].margin;\n          } else {\n            gridShrinkOffset += _this.dCtx.isSparkline || !w.globals.axisCharts ? 0 : 5;\n          }\n        });\n\n        if (w.config.legend.show && w.config.legend.position === 'bottom' && !w.config.legend.floating && !w.globals.axisCharts) {\n          gridShrinkOffset += 10;\n        }\n\n        var titleCoords = this.dCtx.dimHelpers.getTitleSubtitleCoords('title');\n        var subtitleCoords = this.dCtx.dimHelpers.getTitleSubtitleCoords('subtitle');\n        gl.gridHeight = gl.gridHeight - titleCoords.height - subtitleCoords.height - gridShrinkOffset;\n        gl.translateY = gl.translateY + titleCoords.height + subtitleCoords.height + gridShrinkOffset;\n      }\n    }, {\n      key: \"setGridXPosForDualYAxis\",\n      value: function setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords) {\n        var w = this.w;\n        var axesUtils = new AxesUtils(this.dCtx.ctx);\n        w.config.yaxis.map(function (yaxe, index) {\n          if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1 && !yaxe.floating && !axesUtils.isYAxisHidden(index)) {\n            if (yaxe.opposite) {\n              w.globals.translateX = w.globals.translateX - (yaxisLabelCoords[index].width + yTitleCoords[index].width) - parseInt(w.config.yaxis[index].labels.style.fontSize, 10) / 1.2 - 12;\n            } // fixes apexcharts.js#1599\n\n\n            if (w.globals.translateX < 2) {\n              w.globals.translateX = 2;\n            }\n          }\n        });\n      }\n    }]);\n\n    return DimGrid;\n  }();\n\n  /**\n   * ApexCharts Dimensions Class for calculating rects of all elements that are drawn and will be drawn.\n   *\n   * @module Dimensions\n   **/\n\n  var Dimensions = /*#__PURE__*/function () {\n    function Dimensions(ctx) {\n      _classCallCheck(this, Dimensions);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.lgRect = {};\n      this.yAxisWidth = 0;\n      this.yAxisWidthLeft = 0;\n      this.yAxisWidthRight = 0;\n      this.xAxisHeight = 0;\n      this.isSparkline = this.w.config.chart.sparkline.enabled;\n      this.dimHelpers = new Helpers$3(this);\n      this.dimYAxis = new DimYAxis(this);\n      this.dimXAxis = new DimXAxis(this);\n      this.dimGrid = new DimGrid(this);\n      this.lgWidthForSideLegends = 0;\n      this.gridPad = this.w.config.grid.padding;\n      this.xPadRight = 0;\n      this.xPadLeft = 0;\n    }\n    /**\n     * @memberof Dimensions\n     * @param {object} w - chart context\n     **/\n\n\n    _createClass(Dimensions, [{\n      key: \"plotCoords\",\n      value: function plotCoords() {\n        var _this = this;\n\n        var w = this.w;\n        var gl = w.globals;\n        this.lgRect = this.dimHelpers.getLegendsRect();\n\n        if (this.isSparkline && (w.config.markers.discrete.length > 0 || w.config.markers.size > 0)) {\n          Object.entries(this.gridPad).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                k = _ref2[0],\n                v = _ref2[1];\n\n            _this.gridPad[k] = Math.max(v, _this.w.globals.markers.largestSize / 1.5);\n          });\n        }\n\n        if (gl.axisCharts) {\n          // for line / area / scatter / column\n          this.setDimensionsForAxisCharts();\n        } else {\n          // for pie / donuts / circle\n          this.setDimensionsForNonAxisCharts();\n        }\n\n        this.dimGrid.gridPadFortitleSubtitle(); // after calculating everything, apply padding set by user\n\n        gl.gridHeight = gl.gridHeight - this.gridPad.top - this.gridPad.bottom;\n        gl.gridWidth = gl.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;\n        var barWidth = this.dimGrid.gridPadForColumnsInNumericAxis(gl.gridWidth);\n        gl.gridWidth = gl.gridWidth - barWidth * 2;\n        gl.translateX = gl.translateX + this.gridPad.left + this.xPadLeft + (barWidth > 0 ? barWidth + 4 : 0);\n        gl.translateY = gl.translateY + this.gridPad.top;\n      }\n    }, {\n      key: \"setDimensionsForAxisCharts\",\n      value: function setDimensionsForAxisCharts() {\n        var _this2 = this;\n\n        var w = this.w;\n        var gl = w.globals;\n        var yaxisLabelCoords = this.dimYAxis.getyAxisLabelsCoords();\n        var yTitleCoords = this.dimYAxis.getyAxisTitleCoords();\n        w.globals.yLabelsCoords = [];\n        w.globals.yTitleCoords = [];\n        w.config.yaxis.map(function (yaxe, index) {\n          // store the labels and titles coords in global vars\n          w.globals.yLabelsCoords.push({\n            width: yaxisLabelCoords[index].width,\n            index: index\n          });\n          w.globals.yTitleCoords.push({\n            width: yTitleCoords[index].width,\n            index: index\n          });\n        });\n        this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();\n        var xaxisLabelCoords = this.dimXAxis.getxAxisLabelsCoords();\n        var xaxisGroupLabelCoords = this.dimXAxis.getxAxisGroupLabelsCoords();\n        var xtitleCoords = this.dimXAxis.getxAxisTitleCoords();\n        this.conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords, xaxisGroupLabelCoords);\n        gl.translateXAxisY = w.globals.rotateXLabels ? this.xAxisHeight / 8 : -4;\n        gl.translateXAxisX = w.globals.rotateXLabels && w.globals.isXNumeric && w.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0;\n\n        if (w.globals.isBarHorizontal) {\n          gl.rotateXLabels = false;\n          gl.translateXAxisY = -1 * (parseInt(w.config.xaxis.labels.style.fontSize, 10) / 1.5);\n        }\n\n        gl.translateXAxisY = gl.translateXAxisY + w.config.xaxis.labels.offsetY;\n        gl.translateXAxisX = gl.translateXAxisX + w.config.xaxis.labels.offsetX;\n        var yAxisWidth = this.yAxisWidth;\n        var xAxisHeight = this.xAxisHeight;\n        gl.xAxisLabelsHeight = this.xAxisHeight - xtitleCoords.height;\n        gl.xAxisGroupLabelsHeight = gl.xAxisLabelsHeight - xaxisLabelCoords.height;\n        gl.xAxisLabelsWidth = this.xAxisWidth;\n        gl.xAxisHeight = this.xAxisHeight;\n        var translateY = 10;\n\n        if (w.config.chart.type === 'radar' || this.isSparkline) {\n          yAxisWidth = 0;\n          xAxisHeight = gl.goldenPadding;\n        }\n\n        if (this.isSparkline) {\n          this.lgRect = {\n            height: 0,\n            width: 0\n          };\n        }\n\n        if (this.isSparkline || w.config.chart.type === 'treemap') {\n          yAxisWidth = 0;\n          xAxisHeight = 0;\n          translateY = 0;\n        }\n\n        if (!this.isSparkline) {\n          this.dimXAxis.additionalPaddingXLabels(xaxisLabelCoords);\n        }\n\n        var legendTopBottom = function legendTopBottom() {\n          gl.translateX = yAxisWidth;\n          gl.gridHeight = gl.svgHeight - _this2.lgRect.height - xAxisHeight - (!_this2.isSparkline && w.config.chart.type !== 'treemap' ? w.globals.rotateXLabels ? 10 : 15 : 0);\n          gl.gridWidth = gl.svgWidth - yAxisWidth;\n        };\n\n        if (w.config.xaxis.position === 'top') translateY = gl.xAxisHeight - w.config.xaxis.axisTicks.height - 5;\n\n        switch (w.config.legend.position) {\n          case 'bottom':\n            gl.translateY = translateY;\n            legendTopBottom();\n            break;\n\n          case 'top':\n            gl.translateY = this.lgRect.height + translateY;\n            legendTopBottom();\n            break;\n\n          case 'left':\n            gl.translateY = translateY;\n            gl.translateX = this.lgRect.width + yAxisWidth;\n            gl.gridHeight = gl.svgHeight - xAxisHeight - 12;\n            gl.gridWidth = gl.svgWidth - this.lgRect.width - yAxisWidth;\n            break;\n\n          case 'right':\n            gl.translateY = translateY;\n            gl.translateX = yAxisWidth;\n            gl.gridHeight = gl.svgHeight - xAxisHeight - 12;\n            gl.gridWidth = gl.svgWidth - this.lgRect.width - yAxisWidth - 5;\n            break;\n\n          default:\n            throw new Error('Legend position not supported');\n        }\n\n        this.dimGrid.setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords); // after drawing everything, set the Y axis positions\n\n        var objyAxis = new YAxis(this.ctx);\n        objyAxis.setYAxisXPosition(yaxisLabelCoords, yTitleCoords);\n      }\n    }, {\n      key: \"setDimensionsForNonAxisCharts\",\n      value: function setDimensionsForNonAxisCharts() {\n        var w = this.w;\n        var gl = w.globals;\n        var cnf = w.config;\n        var xPad = 0;\n\n        if (w.config.legend.show && !w.config.legend.floating) {\n          xPad = 20;\n        }\n\n        var type = cnf.chart.type === 'pie' || cnf.chart.type === 'polarArea' || cnf.chart.type === 'donut' ? 'pie' : 'radialBar';\n        var offY = cnf.plotOptions[type].offsetY;\n        var offX = cnf.plotOptions[type].offsetX;\n\n        if (!cnf.legend.show || cnf.legend.floating) {\n          gl.gridHeight = gl.svgHeight - cnf.grid.padding.left + cnf.grid.padding.right;\n          gl.gridWidth = gl.gridHeight;\n          gl.translateY = offY;\n          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n          return;\n        }\n\n        switch (cnf.legend.position) {\n          case 'bottom':\n            gl.gridHeight = gl.svgHeight - this.lgRect.height - gl.goldenPadding;\n            gl.gridWidth = gl.svgWidth;\n            gl.translateY = offY - 10;\n            gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n            break;\n\n          case 'top':\n            gl.gridHeight = gl.svgHeight - this.lgRect.height - gl.goldenPadding;\n            gl.gridWidth = gl.svgWidth;\n            gl.translateY = this.lgRect.height + offY + 10;\n            gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n            break;\n\n          case 'left':\n            gl.gridWidth = gl.svgWidth - this.lgRect.width - xPad;\n            gl.gridHeight = cnf.chart.height !== 'auto' ? gl.svgHeight : gl.gridWidth;\n            gl.translateY = offY;\n            gl.translateX = offX + this.lgRect.width + xPad;\n            break;\n\n          case 'right':\n            gl.gridWidth = gl.svgWidth - this.lgRect.width - xPad - 5;\n            gl.gridHeight = cnf.chart.height !== 'auto' ? gl.svgHeight : gl.gridWidth;\n            gl.translateY = offY;\n            gl.translateX = offX + 10;\n            break;\n\n          default:\n            throw new Error('Legend position not supported');\n        }\n      }\n    }, {\n      key: \"conditionalChecksForAxisCoords\",\n      value: function conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords, xaxisGroupLabelCoords) {\n        var w = this.w;\n        var xAxisNum = w.globals.hasXaxisGroups ? 2 : 1;\n        var baseXAxisHeight = xaxisGroupLabelCoords.height + xaxisLabelCoords.height + xtitleCoords.height;\n        var xAxisHeightMultiplicate = w.globals.isMultiLineX ? 1.2 : w.globals.LINE_HEIGHT_RATIO;\n        var rotatedXAxisOffset = w.globals.rotateXLabels ? 22 : 10;\n        var rotatedXAxisLegendOffset = w.globals.rotateXLabels && w.config.legend.position === 'bottom';\n        var additionalOffset = rotatedXAxisLegendOffset ? 10 : 0;\n        this.xAxisHeight = baseXAxisHeight * xAxisHeightMultiplicate + xAxisNum * rotatedXAxisOffset + additionalOffset;\n        this.xAxisWidth = xaxisLabelCoords.width;\n\n        if (this.xAxisHeight - xtitleCoords.height > w.config.xaxis.labels.maxHeight) {\n          this.xAxisHeight = w.config.xaxis.labels.maxHeight;\n        }\n\n        if (w.config.xaxis.labels.minHeight && this.xAxisHeight < w.config.xaxis.labels.minHeight) {\n          this.xAxisHeight = w.config.xaxis.labels.minHeight;\n        }\n\n        if (w.config.xaxis.floating) {\n          this.xAxisHeight = 0;\n        }\n\n        var minYAxisWidth = 0;\n        var maxYAxisWidth = 0;\n        w.config.yaxis.forEach(function (y) {\n          minYAxisWidth += y.labels.minWidth;\n          maxYAxisWidth += y.labels.maxWidth;\n        });\n\n        if (this.yAxisWidth < minYAxisWidth) {\n          this.yAxisWidth = minYAxisWidth;\n        }\n\n        if (this.yAxisWidth > maxYAxisWidth) {\n          this.yAxisWidth = maxYAxisWidth;\n        }\n      }\n    }]);\n\n    return Dimensions;\n  }();\n\n  var Helpers$2 = /*#__PURE__*/function () {\n    function Helpers(lgCtx) {\n      _classCallCheck(this, Helpers);\n\n      this.w = lgCtx.w;\n      this.lgCtx = lgCtx;\n    }\n\n    _createClass(Helpers, [{\n      key: \"getLegendStyles\",\n      value: function getLegendStyles() {\n        var stylesheet = document.createElement('style');\n        stylesheet.setAttribute('type', 'text/css');\n        var text = \"\\t\\n    \\t\\n      .apexcharts-legend {\\t\\n        display: flex;\\t\\n        overflow: auto;\\t\\n        padding: 0 10px;\\t\\n      }\\t\\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\\t\\n        flex-wrap: wrap\\t\\n      }\\t\\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\\t\\n        flex-direction: column;\\t\\n        bottom: 0;\\t\\n      }\\t\\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\\t\\n        justify-content: flex-start;\\t\\n      }\\t\\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\\t\\n        justify-content: center;  \\t\\n      }\\t\\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\\t\\n        justify-content: flex-end;\\t\\n      }\\t\\n      .apexcharts-legend-series {\\t\\n        cursor: pointer;\\t\\n        line-height: normal;\\t\\n      }\\t\\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\\t\\n        display: flex;\\t\\n        align-items: center;\\t\\n      }\\t\\n      .apexcharts-legend-text {\\t\\n        position: relative;\\t\\n        font-size: 14px;\\t\\n      }\\t\\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\\t\\n        pointer-events: none;\\t\\n      }\\t\\n      .apexcharts-legend-marker {\\t\\n        position: relative;\\t\\n        display: inline-block;\\t\\n        cursor: pointer;\\t\\n        margin-right: 3px;\\t\\n        border-style: solid;\\n      }\\t\\n      \\t\\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\\t\\n        display: inline-block;\\t\\n      }\\t\\n      .apexcharts-legend-series.apexcharts-no-click {\\t\\n        cursor: auto;\\t\\n      }\\t\\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\\t\\n        display: none !important;\\t\\n      }\\t\\n      .apexcharts-inactive-legend {\\t\\n        opacity: 0.45;\\t\\n      }\";\n        var rules = document.createTextNode(text);\n        stylesheet.appendChild(rules);\n        return stylesheet;\n      }\n    }, {\n      key: \"getLegendBBox\",\n      value: function getLegendBBox() {\n        var w = this.w;\n        var currLegendsWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n        var currLegendsWrapRect = currLegendsWrap.getBoundingClientRect();\n        var currLegendsWrapWidth = currLegendsWrapRect.width;\n        var currLegendsWrapHeight = currLegendsWrapRect.height;\n        return {\n          clwh: currLegendsWrapHeight,\n          clww: currLegendsWrapWidth\n        };\n      }\n    }, {\n      key: \"appendToForeignObject\",\n      value: function appendToForeignObject() {\n        var gl = this.w.globals;\n        gl.dom.elLegendForeign.appendChild(this.getLegendStyles());\n      }\n    }, {\n      key: \"toggleDataSeries\",\n      value: function toggleDataSeries(seriesCnt, isHidden) {\n        var _this = this;\n\n        var w = this.w;\n\n        if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {\n          w.globals.resized = true; // we don't want initial animations again\n\n          var seriesEl = null;\n          var realIndex = null; // yes, make it null. 1 series will rise at a time\n\n          w.globals.risingSeries = [];\n\n          if (w.globals.axisCharts) {\n            seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesCnt, \"']\"));\n            realIndex = parseInt(seriesEl.getAttribute('data:realIndex'), 10);\n          } else {\n            seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"']\"));\n            realIndex = parseInt(seriesEl.getAttribute('rel'), 10) - 1;\n          }\n\n          if (isHidden) {\n            var seriesToMakeVisible = [{\n              cs: w.globals.collapsedSeries,\n              csi: w.globals.collapsedSeriesIndices\n            }, {\n              cs: w.globals.ancillaryCollapsedSeries,\n              csi: w.globals.ancillaryCollapsedSeriesIndices\n            }];\n            seriesToMakeVisible.forEach(function (r) {\n              _this.riseCollapsedSeries(r.cs, r.csi, realIndex);\n            });\n          } else {\n            this.hideSeries({\n              seriesEl: seriesEl,\n              realIndex: realIndex\n            });\n          }\n        } else {\n          // for non-axis charts i.e pie / donuts\n          var _seriesEl = w.globals.dom.Paper.select(\" .apexcharts-series[rel='\".concat(seriesCnt + 1, \"'] path\"));\n\n          var type = w.config.chart.type;\n\n          if (type === 'pie' || type === 'polarArea' || type === 'donut') {\n            var dataLabels = w.config.plotOptions.pie.donut.labels;\n            var graphics = new Graphics(this.lgCtx.ctx);\n            graphics.pathMouseDown(_seriesEl.members[0], null);\n            this.lgCtx.ctx.pie.printDataLabelsInner(_seriesEl.members[0].node, dataLabels);\n          }\n\n          _seriesEl.fire('click');\n        }\n      }\n    }, {\n      key: \"hideSeries\",\n      value: function hideSeries(_ref) {\n        var seriesEl = _ref.seriesEl,\n            realIndex = _ref.realIndex;\n        var w = this.w;\n        var series = Utils$1.clone(w.config.series);\n\n        if (w.globals.axisCharts) {\n          var shouldNotHideYAxis = false;\n\n          if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].show && w.config.yaxis[realIndex].showAlways) {\n            shouldNotHideYAxis = true;\n\n            if (w.globals.ancillaryCollapsedSeriesIndices.indexOf(realIndex) < 0) {\n              w.globals.ancillaryCollapsedSeries.push({\n                index: realIndex,\n                data: series[realIndex].data.slice(),\n                type: seriesEl.parentNode.className.baseVal.split('-')[1]\n              });\n              w.globals.ancillaryCollapsedSeriesIndices.push(realIndex);\n            }\n          }\n\n          if (!shouldNotHideYAxis) {\n            w.globals.collapsedSeries.push({\n              index: realIndex,\n              data: series[realIndex].data.slice(),\n              type: seriesEl.parentNode.className.baseVal.split('-')[1]\n            });\n            w.globals.collapsedSeriesIndices.push(realIndex);\n            var removeIndexOfRising = w.globals.risingSeries.indexOf(realIndex);\n            w.globals.risingSeries.splice(removeIndexOfRising, 1);\n          }\n        } else {\n          w.globals.collapsedSeries.push({\n            index: realIndex,\n            data: series[realIndex]\n          });\n          w.globals.collapsedSeriesIndices.push(realIndex);\n        }\n\n        var seriesChildren = seriesEl.childNodes;\n\n        for (var sc = 0; sc < seriesChildren.length; sc++) {\n          if (seriesChildren[sc].classList.contains('apexcharts-series-markers-wrap')) {\n            if (seriesChildren[sc].classList.contains('apexcharts-hide')) {\n              seriesChildren[sc].classList.remove('apexcharts-hide');\n            } else {\n              seriesChildren[sc].classList.add('apexcharts-hide');\n            }\n          }\n        }\n\n        w.globals.allSeriesCollapsed = w.globals.collapsedSeries.length === w.config.series.length;\n        series = this._getSeriesBasedOnCollapsedState(series);\n\n        this.lgCtx.ctx.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);\n      }\n    }, {\n      key: \"riseCollapsedSeries\",\n      value: function riseCollapsedSeries(collapsedSeries, seriesIndices, realIndex) {\n        var w = this.w;\n        var series = Utils$1.clone(w.config.series);\n\n        if (collapsedSeries.length > 0) {\n          for (var c = 0; c < collapsedSeries.length; c++) {\n            if (collapsedSeries[c].index === realIndex) {\n              if (w.globals.axisCharts) {\n                series[realIndex].data = collapsedSeries[c].data.slice();\n                collapsedSeries.splice(c, 1);\n                seriesIndices.splice(c, 1);\n                w.globals.risingSeries.push(realIndex);\n              } else {\n                series[realIndex] = collapsedSeries[c].data;\n                collapsedSeries.splice(c, 1);\n                seriesIndices.splice(c, 1);\n                w.globals.risingSeries.push(realIndex);\n              }\n            }\n          }\n\n          series = this._getSeriesBasedOnCollapsedState(series);\n\n          this.lgCtx.ctx.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);\n        }\n      }\n    }, {\n      key: \"_getSeriesBasedOnCollapsedState\",\n      value: function _getSeriesBasedOnCollapsedState(series) {\n        var w = this.w;\n\n        if (w.globals.axisCharts) {\n          series.forEach(function (s, sI) {\n            if (w.globals.collapsedSeriesIndices.indexOf(sI) > -1) {\n              series[sI].data = [];\n            }\n          });\n        } else {\n          series.forEach(function (s, sI) {\n            if (w.globals.collapsedSeriesIndices.indexOf(sI) > -1) {\n              series[sI] = 0;\n            }\n          });\n        }\n\n        return series;\n      }\n    }]);\n\n    return Helpers;\n  }();\n\n  /**\n   * ApexCharts Legend Class to draw legend.\n   *\n   * @module Legend\n   **/\n\n  var Legend = /*#__PURE__*/function () {\n    function Legend(ctx) {\n      _classCallCheck(this, Legend);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.onLegendClick = this.onLegendClick.bind(this);\n      this.onLegendHovered = this.onLegendHovered.bind(this);\n      this.isBarsDistributed = this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1;\n      this.legendHelpers = new Helpers$2(this);\n    }\n\n    _createClass(Legend, [{\n      key: \"init\",\n      value: function init() {\n        var w = this.w;\n        var gl = w.globals;\n        var cnf = w.config;\n        var showLegendAlways = cnf.legend.showForSingleSeries && gl.series.length === 1 || this.isBarsDistributed || gl.series.length > 1;\n\n        if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {\n          while (gl.dom.elLegendWrap.firstChild) {\n            gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild);\n          }\n\n          this.drawLegends();\n\n          if (!Utils$1.isIE11()) {\n            this.legendHelpers.appendToForeignObject();\n          } else {\n            // IE11 doesn't supports foreignObject, hence append it to <head>\n            document.getElementsByTagName('head')[0].appendChild(this.legendHelpers.getLegendStyles());\n          }\n\n          if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {\n            this.legendAlignHorizontal();\n          } else if (cnf.legend.position === 'right' || cnf.legend.position === 'left') {\n            this.legendAlignVertical();\n          }\n        }\n      }\n    }, {\n      key: \"drawLegends\",\n      value: function drawLegends() {\n        var me = this;\n        var w = this.w;\n        var fontFamily = w.config.legend.fontFamily;\n        var legendNames = w.globals.seriesNames;\n        var fillcolor = w.globals.colors.slice();\n\n        if (w.config.chart.type === 'heatmap') {\n          var ranges = w.config.plotOptions.heatmap.colorScale.ranges;\n          legendNames = ranges.map(function (colorScale) {\n            return colorScale.name ? colorScale.name : colorScale.from + ' - ' + colorScale.to;\n          });\n          fillcolor = ranges.map(function (color) {\n            return color.color;\n          });\n        } else if (this.isBarsDistributed) {\n          legendNames = w.globals.labels.slice();\n        }\n\n        if (w.config.legend.customLegendItems.length) {\n          legendNames = w.config.legend.customLegendItems;\n        }\n\n        var legendFormatter = w.globals.legendFormatter;\n        var isLegendInversed = w.config.legend.inverseOrder;\n\n        for (var i = isLegendInversed ? legendNames.length - 1 : 0; isLegendInversed ? i >= 0 : i <= legendNames.length - 1; isLegendInversed ? i-- : i++) {\n          var _w$config$legend$labe;\n\n          var text = legendFormatter(legendNames[i], {\n            seriesIndex: i,\n            w: w\n          });\n          var collapsedSeries = false;\n          var ancillaryCollapsedSeries = false;\n\n          if (w.globals.collapsedSeries.length > 0) {\n            for (var c = 0; c < w.globals.collapsedSeries.length; c++) {\n              if (w.globals.collapsedSeries[c].index === i) {\n                collapsedSeries = true;\n              }\n            }\n          }\n\n          if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {\n            for (var _c = 0; _c < w.globals.ancillaryCollapsedSeriesIndices.length; _c++) {\n              if (w.globals.ancillaryCollapsedSeriesIndices[_c] === i) {\n                ancillaryCollapsedSeries = true;\n              }\n            }\n          }\n\n          var elMarker = document.createElement('span');\n          elMarker.classList.add('apexcharts-legend-marker');\n          var mOffsetX = w.config.legend.markers.offsetX;\n          var mOffsetY = w.config.legend.markers.offsetY;\n          var mHeight = w.config.legend.markers.height;\n          var mWidth = w.config.legend.markers.width;\n          var mBorderWidth = w.config.legend.markers.strokeWidth;\n          var mBorderColor = w.config.legend.markers.strokeColor;\n          var mBorderRadius = w.config.legend.markers.radius;\n          var mStyle = elMarker.style;\n          mStyle.background = fillcolor[i];\n          mStyle.color = fillcolor[i];\n          mStyle.setProperty('background', fillcolor[i], 'important'); // override fill color with custom legend.markers.fillColors\n\n          if (w.config.legend.markers.fillColors && w.config.legend.markers.fillColors[i]) {\n            mStyle.background = w.config.legend.markers.fillColors[i];\n          } // override with data color\n\n\n          if (w.globals.seriesColors[i] !== undefined) {\n            mStyle.background = w.globals.seriesColors[i];\n            mStyle.color = w.globals.seriesColors[i];\n          }\n\n          mStyle.height = Array.isArray(mHeight) ? parseFloat(mHeight[i]) + 'px' : parseFloat(mHeight) + 'px';\n          mStyle.width = Array.isArray(mWidth) ? parseFloat(mWidth[i]) + 'px' : parseFloat(mWidth) + 'px';\n          mStyle.left = (Array.isArray(mOffsetX) ? parseFloat(mOffsetX[i]) : parseFloat(mOffsetX)) + 'px';\n          mStyle.top = (Array.isArray(mOffsetY) ? parseFloat(mOffsetY[i]) : parseFloat(mOffsetY)) + 'px';\n          mStyle.borderWidth = Array.isArray(mBorderWidth) ? mBorderWidth[i] : mBorderWidth;\n          mStyle.borderColor = Array.isArray(mBorderColor) ? mBorderColor[i] : mBorderColor;\n          mStyle.borderRadius = Array.isArray(mBorderRadius) ? parseFloat(mBorderRadius[i]) + 'px' : parseFloat(mBorderRadius) + 'px';\n\n          if (w.config.legend.markers.customHTML) {\n            if (Array.isArray(w.config.legend.markers.customHTML)) {\n              if (w.config.legend.markers.customHTML[i]) {\n                elMarker.innerHTML = w.config.legend.markers.customHTML[i]();\n              }\n            } else {\n              elMarker.innerHTML = w.config.legend.markers.customHTML();\n            }\n          }\n\n          Graphics.setAttrs(elMarker, {\n            rel: i + 1,\n            'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n          });\n\n          if (collapsedSeries || ancillaryCollapsedSeries) {\n            elMarker.classList.add('apexcharts-inactive-legend');\n          }\n\n          var elLegend = document.createElement('div');\n          var elLegendText = document.createElement('span');\n          elLegendText.classList.add('apexcharts-legend-text');\n          elLegendText.innerHTML = Array.isArray(text) ? text.join(' ') : text;\n          var textColor = w.config.legend.labels.useSeriesColors ? w.globals.colors[i] : Array.isArray(w.config.legend.labels.colors) ? (_w$config$legend$labe = w.config.legend.labels.colors) === null || _w$config$legend$labe === void 0 ? void 0 : _w$config$legend$labe[i] : w.config.legend.labels.colors;\n\n          if (!textColor) {\n            textColor = w.config.chart.foreColor;\n          }\n\n          elLegendText.style.color = textColor;\n          elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px';\n          elLegendText.style.fontWeight = w.config.legend.fontWeight;\n          elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily;\n          Graphics.setAttrs(elLegendText, {\n            rel: i + 1,\n            i: i,\n            'data:default-text': encodeURIComponent(text),\n            'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n          });\n          elLegend.appendChild(elMarker);\n          elLegend.appendChild(elLegendText);\n          var coreUtils = new CoreUtils(this.ctx);\n\n          if (!w.config.legend.showForZeroSeries) {\n            var total = coreUtils.getSeriesTotalByIndex(i);\n\n            if (total === 0 && coreUtils.seriesHaveSameValues(i) && !coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {\n              elLegend.classList.add('apexcharts-hidden-zero-series');\n            }\n          }\n\n          if (!w.config.legend.showForNullSeries) {\n            if (coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {\n              elLegend.classList.add('apexcharts-hidden-null-series');\n            }\n          }\n\n          w.globals.dom.elLegendWrap.appendChild(elLegend);\n          w.globals.dom.elLegendWrap.classList.add(\"apexcharts-align-\".concat(w.config.legend.horizontalAlign));\n          w.globals.dom.elLegendWrap.classList.add('apx-legend-position-' + w.config.legend.position);\n          elLegend.classList.add('apexcharts-legend-series');\n          elLegend.style.margin = \"\".concat(w.config.legend.itemMargin.vertical, \"px \").concat(w.config.legend.itemMargin.horizontal, \"px\");\n          w.globals.dom.elLegendWrap.style.width = w.config.legend.width ? w.config.legend.width + 'px' : '';\n          w.globals.dom.elLegendWrap.style.height = w.config.legend.height ? w.config.legend.height + 'px' : '';\n          Graphics.setAttrs(elLegend, {\n            rel: i + 1,\n            seriesName: Utils$1.escapeString(legendNames[i]),\n            'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n          });\n\n          if (collapsedSeries || ancillaryCollapsedSeries) {\n            elLegend.classList.add('apexcharts-inactive-legend');\n          }\n\n          if (!w.config.legend.onItemClick.toggleDataSeries) {\n            elLegend.classList.add('apexcharts-no-click');\n          }\n        }\n\n        w.globals.dom.elWrap.addEventListener('click', me.onLegendClick, true);\n\n        if (w.config.legend.onItemHover.highlightDataSeries && w.config.legend.customLegendItems.length === 0) {\n          w.globals.dom.elWrap.addEventListener('mousemove', me.onLegendHovered, true);\n          w.globals.dom.elWrap.addEventListener('mouseout', me.onLegendHovered, true);\n        }\n      }\n    }, {\n      key: \"setLegendWrapXY\",\n      value: function setLegendWrapXY(offsetX, offsetY) {\n        var w = this.w;\n        var elLegendWrap = w.globals.dom.elLegendWrap;\n        var legendRect = elLegendWrap.getBoundingClientRect();\n        var x = 0;\n        var y = 0;\n\n        if (w.config.legend.position === 'bottom') {\n          y = y + (w.globals.svgHeight - legendRect.height / 2);\n        } else if (w.config.legend.position === 'top') {\n          var dim = new Dimensions(this.ctx);\n          var titleH = dim.dimHelpers.getTitleSubtitleCoords('title').height;\n          var subtitleH = dim.dimHelpers.getTitleSubtitleCoords('subtitle').height;\n          y = y + (titleH > 0 ? titleH - 10 : 0) + (subtitleH > 0 ? subtitleH - 10 : 0);\n        }\n\n        elLegendWrap.style.position = 'absolute';\n        x = x + offsetX + w.config.legend.offsetX;\n        y = y + offsetY + w.config.legend.offsetY;\n        elLegendWrap.style.left = x + 'px';\n        elLegendWrap.style.top = y + 'px';\n\n        if (w.config.legend.position === 'bottom') {\n          elLegendWrap.style.top = 'auto';\n          elLegendWrap.style.bottom = 5 - w.config.legend.offsetY + 'px';\n        } else if (w.config.legend.position === 'right') {\n          elLegendWrap.style.left = 'auto';\n          elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px';\n        }\n\n        var fixedHeigthWidth = ['width', 'height'];\n        fixedHeigthWidth.forEach(function (hw) {\n          if (elLegendWrap.style[hw]) {\n            elLegendWrap.style[hw] = parseInt(w.config.legend[hw], 10) + 'px';\n          }\n        });\n      }\n    }, {\n      key: \"legendAlignHorizontal\",\n      value: function legendAlignHorizontal() {\n        var w = this.w;\n        var elLegendWrap = w.globals.dom.elLegendWrap;\n        elLegendWrap.style.right = 0;\n        var lRect = this.legendHelpers.getLegendBBox();\n        var dimensions = new Dimensions(this.ctx);\n        var titleRect = dimensions.dimHelpers.getTitleSubtitleCoords('title');\n        var subtitleRect = dimensions.dimHelpers.getTitleSubtitleCoords('subtitle');\n        var offsetX = 20;\n        var offsetY = 0; // the whole legend box is set to bottom\n\n        if (w.config.legend.position === 'bottom') {\n          offsetY = -lRect.clwh / 1.8;\n        } else if (w.config.legend.position === 'top') {\n          offsetY = titleRect.height + subtitleRect.height + w.config.title.margin + w.config.subtitle.margin - 10;\n        }\n\n        this.setLegendWrapXY(offsetX, offsetY);\n      }\n    }, {\n      key: \"legendAlignVertical\",\n      value: function legendAlignVertical() {\n        var w = this.w;\n        var lRect = this.legendHelpers.getLegendBBox();\n        var offsetY = 20;\n        var offsetX = 0;\n\n        if (w.config.legend.position === 'left') {\n          offsetX = 20;\n        }\n\n        if (w.config.legend.position === 'right') {\n          offsetX = w.globals.svgWidth - lRect.clww - 10;\n        }\n\n        this.setLegendWrapXY(offsetX, offsetY);\n      }\n    }, {\n      key: \"onLegendHovered\",\n      value: function onLegendHovered(e) {\n        var w = this.w;\n        var hoverOverLegend = e.target.classList.contains('apexcharts-legend-series') || e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker');\n\n        if (w.config.chart.type !== 'heatmap' && !this.isBarsDistributed) {\n          if (!e.target.classList.contains('apexcharts-inactive-legend') && hoverOverLegend) {\n            var series = new Series(this.ctx);\n            series.toggleSeriesOnHover(e, e.target);\n          }\n        } else {\n          // for heatmap handling\n          if (hoverOverLegend) {\n            var seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1;\n            this.ctx.events.fireEvent('legendHover', [this.ctx, seriesCnt, this.w]);\n\n            var _series = new Series(this.ctx);\n\n            _series.highlightRangeInSeries(e, e.target);\n          }\n        }\n      }\n    }, {\n      key: \"onLegendClick\",\n      value: function onLegendClick(e) {\n        var w = this.w;\n        if (w.config.legend.customLegendItems.length) return;\n\n        if (e.target.classList.contains('apexcharts-legend-series') || e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker')) {\n          var seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1;\n          var isHidden = e.target.getAttribute('data:collapsed') === 'true';\n          var legendClick = this.w.config.chart.events.legendClick;\n\n          if (typeof legendClick === 'function') {\n            legendClick(this.ctx, seriesCnt, this.w);\n          }\n\n          this.ctx.events.fireEvent('legendClick', [this.ctx, seriesCnt, this.w]);\n          var markerClick = this.w.config.legend.markers.onClick;\n\n          if (typeof markerClick === 'function' && e.target.classList.contains('apexcharts-legend-marker')) {\n            markerClick(this.ctx, seriesCnt, this.w);\n            this.ctx.events.fireEvent('legendMarkerClick', [this.ctx, seriesCnt, this.w]);\n          } // for now - just prevent click on heatmap legend - and allow hover only\n\n\n          var clickAllowed = w.config.chart.type !== 'treemap' && w.config.chart.type !== 'heatmap' && !this.isBarsDistributed;\n\n          if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {\n            this.legendHelpers.toggleDataSeries(seriesCnt, isHidden);\n          }\n        }\n      }\n    }]);\n\n    return Legend;\n  }();\n\n  var icoPan = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\">\\n    <defs>\\n        <path d=\\\"M0 0h24v24H0z\\\" id=\\\"a\\\"/>\\n    </defs>\\n    <clipPath id=\\\"b\\\">\\n        <use overflow=\\\"visible\\\" xlink:href=\\\"#a\\\"/>\\n    </clipPath>\\n    <path clip-path=\\\"url(#b)\\\" d=\\\"M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z\\\"/>\\n</svg>\";\n\n  var icoZoom = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\">\\n    <path d=\\\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\\\"/>\\n    <path d=\\\"M0 0h24v24H0V0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\\\"/>\\n</svg>\";\n\n  var icoReset = \"<svg fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\\\"/>\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n</svg>\";\n\n  var icoZoomIn = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\\\"/>\\n</svg>\\n\";\n\n  var icoZoomOut = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\\\"/>\\n</svg>\\n\";\n\n  var icoSelect = \"<svg fill=\\\"#6E8192\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z\\\"/>\\n</svg>\";\n\n  var icoMenu = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path fill=\\\"none\\\" d=\\\"M0 0h24v24H0V0z\\\"/><path d=\\\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\\\"/></svg>\";\n\n  /**\n   * ApexCharts Toolbar Class for creating toolbar in axis based charts.\n   *\n   * @module Toolbar\n   **/\n\n  var Toolbar = /*#__PURE__*/function () {\n    function Toolbar(ctx) {\n      _classCallCheck(this, Toolbar);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      var w = this.w;\n      this.ev = this.w.config.chart.events;\n      this.selectedClass = 'apexcharts-selected';\n      this.localeValues = this.w.globals.locale.toolbar;\n      this.minX = w.globals.minX;\n      this.maxX = w.globals.maxX;\n    }\n\n    _createClass(Toolbar, [{\n      key: \"createToolbar\",\n      value: function createToolbar() {\n        var _this = this;\n\n        var w = this.w;\n\n        var createDiv = function createDiv() {\n          return document.createElement('div');\n        };\n\n        var elToolbarWrap = createDiv();\n        elToolbarWrap.setAttribute('class', 'apexcharts-toolbar');\n        elToolbarWrap.style.top = w.config.chart.toolbar.offsetY + 'px';\n        elToolbarWrap.style.right = -w.config.chart.toolbar.offsetX + 3 + 'px';\n        w.globals.dom.elWrap.appendChild(elToolbarWrap);\n        this.elZoom = createDiv();\n        this.elZoomIn = createDiv();\n        this.elZoomOut = createDiv();\n        this.elPan = createDiv();\n        this.elSelection = createDiv();\n        this.elZoomReset = createDiv();\n        this.elMenuIcon = createDiv();\n        this.elMenu = createDiv();\n        this.elCustomIcons = [];\n        this.t = w.config.chart.toolbar.tools;\n\n        if (Array.isArray(this.t.customIcons)) {\n          for (var i = 0; i < this.t.customIcons.length; i++) {\n            this.elCustomIcons.push(createDiv());\n          }\n        }\n\n        var toolbarControls = [];\n\n        var appendZoomControl = function appendZoomControl(type, el, ico) {\n          var tool = type.toLowerCase();\n\n          if (_this.t[tool] && w.config.chart.zoom.enabled) {\n            toolbarControls.push({\n              el: el,\n              icon: typeof _this.t[tool] === 'string' ? _this.t[tool] : ico,\n              title: _this.localeValues[type],\n              class: \"apexcharts-\".concat(tool, \"-icon\")\n            });\n          }\n        };\n\n        appendZoomControl('zoomIn', this.elZoomIn, icoZoomIn);\n        appendZoomControl('zoomOut', this.elZoomOut, icoZoomOut);\n\n        var zoomSelectionCtrls = function zoomSelectionCtrls(z) {\n          if (_this.t[z] && w.config.chart[z].enabled) {\n            toolbarControls.push({\n              el: z === 'zoom' ? _this.elZoom : _this.elSelection,\n              icon: typeof _this.t[z] === 'string' ? _this.t[z] : z === 'zoom' ? icoZoom : icoSelect,\n              title: _this.localeValues[z === 'zoom' ? 'selectionZoom' : 'selection'],\n              class: w.globals.isTouchDevice ? 'apexcharts-element-hidden' : \"apexcharts-\".concat(z, \"-icon\")\n            });\n          }\n        };\n\n        zoomSelectionCtrls('zoom');\n        zoomSelectionCtrls('selection');\n\n        if (this.t.pan && w.config.chart.zoom.enabled) {\n          toolbarControls.push({\n            el: this.elPan,\n            icon: typeof this.t.pan === 'string' ? this.t.pan : icoPan,\n            title: this.localeValues.pan,\n            class: w.globals.isTouchDevice ? 'apexcharts-element-hidden' : 'apexcharts-pan-icon'\n          });\n        }\n\n        appendZoomControl('reset', this.elZoomReset, icoReset);\n\n        if (this.t.download) {\n          toolbarControls.push({\n            el: this.elMenuIcon,\n            icon: typeof this.t.download === 'string' ? this.t.download : icoMenu,\n            title: this.localeValues.menu,\n            class: 'apexcharts-menu-icon'\n          });\n        }\n\n        for (var _i = 0; _i < this.elCustomIcons.length; _i++) {\n          toolbarControls.push({\n            el: this.elCustomIcons[_i],\n            icon: this.t.customIcons[_i].icon,\n            title: this.t.customIcons[_i].title,\n            index: this.t.customIcons[_i].index,\n            class: 'apexcharts-toolbar-custom-icon ' + this.t.customIcons[_i].class\n          });\n        }\n\n        toolbarControls.forEach(function (t, index) {\n          if (t.index) {\n            Utils$1.moveIndexInArray(toolbarControls, index, t.index);\n          }\n        });\n\n        for (var _i2 = 0; _i2 < toolbarControls.length; _i2++) {\n          Graphics.setAttrs(toolbarControls[_i2].el, {\n            class: toolbarControls[_i2].class,\n            title: toolbarControls[_i2].title\n          });\n          toolbarControls[_i2].el.innerHTML = toolbarControls[_i2].icon;\n          elToolbarWrap.appendChild(toolbarControls[_i2].el);\n        }\n\n        this._createHamburgerMenu(elToolbarWrap);\n\n        if (w.globals.zoomEnabled) {\n          this.elZoom.classList.add(this.selectedClass);\n        } else if (w.globals.panEnabled) {\n          this.elPan.classList.add(this.selectedClass);\n        } else if (w.globals.selectionEnabled) {\n          this.elSelection.classList.add(this.selectedClass);\n        }\n\n        this.addToolbarEventListeners();\n      }\n    }, {\n      key: \"_createHamburgerMenu\",\n      value: function _createHamburgerMenu(parent) {\n        this.elMenuItems = [];\n        parent.appendChild(this.elMenu);\n        Graphics.setAttrs(this.elMenu, {\n          class: 'apexcharts-menu'\n        });\n        var menuItems = [{\n          name: 'exportSVG',\n          title: this.localeValues.exportToSVG\n        }, {\n          name: 'exportPNG',\n          title: this.localeValues.exportToPNG\n        }, {\n          name: 'exportCSV',\n          title: this.localeValues.exportToCSV\n        }];\n\n        if (!this.w.globals.allSeriesHasEqualX) {\n          // if it is a multi series, and all series have variable x values, export CSV won't work\n          menuItems.splice(2, 1);\n        }\n\n        for (var i = 0; i < menuItems.length; i++) {\n          this.elMenuItems.push(document.createElement('div'));\n          this.elMenuItems[i].innerHTML = menuItems[i].title;\n          Graphics.setAttrs(this.elMenuItems[i], {\n            class: \"apexcharts-menu-item \".concat(menuItems[i].name),\n            title: menuItems[i].title\n          });\n          this.elMenu.appendChild(this.elMenuItems[i]);\n        }\n      }\n    }, {\n      key: \"addToolbarEventListeners\",\n      value: function addToolbarEventListeners() {\n        var _this2 = this;\n\n        this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this));\n        this.elSelection.addEventListener('click', this.toggleZoomSelection.bind(this, 'selection'));\n        this.elZoom.addEventListener('click', this.toggleZoomSelection.bind(this, 'zoom'));\n        this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this));\n        this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this));\n        this.elPan.addEventListener('click', this.togglePanning.bind(this));\n        this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this));\n        this.elMenuItems.forEach(function (m) {\n          if (m.classList.contains('exportSVG')) {\n            m.addEventListener('click', _this2.handleDownload.bind(_this2, 'svg'));\n          } else if (m.classList.contains('exportPNG')) {\n            m.addEventListener('click', _this2.handleDownload.bind(_this2, 'png'));\n          } else if (m.classList.contains('exportCSV')) {\n            m.addEventListener('click', _this2.handleDownload.bind(_this2, 'csv'));\n          }\n        });\n\n        for (var i = 0; i < this.t.customIcons.length; i++) {\n          this.elCustomIcons[i].addEventListener('click', this.t.customIcons[i].click.bind(this, this.ctx, this.ctx.w));\n        }\n      }\n    }, {\n      key: \"toggleZoomSelection\",\n      value: function toggleZoomSelection(type) {\n        var charts = this.ctx.getSyncedCharts();\n        charts.forEach(function (ch) {\n          ch.ctx.toolbar.toggleOtherControls();\n          var el = type === 'selection' ? ch.ctx.toolbar.elSelection : ch.ctx.toolbar.elZoom;\n          var enabledType = type === 'selection' ? 'selectionEnabled' : 'zoomEnabled';\n          ch.w.globals[enabledType] = !ch.w.globals[enabledType];\n\n          if (!el.classList.contains(ch.ctx.toolbar.selectedClass)) {\n            el.classList.add(ch.ctx.toolbar.selectedClass);\n          } else {\n            el.classList.remove(ch.ctx.toolbar.selectedClass);\n          }\n        });\n      }\n    }, {\n      key: \"getToolbarIconsReference\",\n      value: function getToolbarIconsReference() {\n        var w = this.w;\n\n        if (!this.elZoom) {\n          this.elZoom = w.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon');\n        }\n\n        if (!this.elPan) {\n          this.elPan = w.globals.dom.baseEl.querySelector('.apexcharts-pan-icon');\n        }\n\n        if (!this.elSelection) {\n          this.elSelection = w.globals.dom.baseEl.querySelector('.apexcharts-selection-icon');\n        }\n      }\n    }, {\n      key: \"enableZoomPanFromToolbar\",\n      value: function enableZoomPanFromToolbar(type) {\n        this.toggleOtherControls();\n        type === 'pan' ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;\n        var el = type === 'pan' ? this.elPan : this.elZoom;\n        var el2 = type === 'pan' ? this.elZoom : this.elPan;\n\n        if (el) {\n          el.classList.add(this.selectedClass);\n        }\n\n        if (el2) {\n          el2.classList.remove(this.selectedClass);\n        }\n      }\n    }, {\n      key: \"togglePanning\",\n      value: function togglePanning() {\n        var charts = this.ctx.getSyncedCharts();\n        charts.forEach(function (ch) {\n          ch.ctx.toolbar.toggleOtherControls();\n          ch.w.globals.panEnabled = !ch.w.globals.panEnabled;\n\n          if (!ch.ctx.toolbar.elPan.classList.contains(ch.ctx.toolbar.selectedClass)) {\n            ch.ctx.toolbar.elPan.classList.add(ch.ctx.toolbar.selectedClass);\n          } else {\n            ch.ctx.toolbar.elPan.classList.remove(ch.ctx.toolbar.selectedClass);\n          }\n        });\n      }\n    }, {\n      key: \"toggleOtherControls\",\n      value: function toggleOtherControls() {\n        var _this3 = this;\n\n        var w = this.w;\n        w.globals.panEnabled = false;\n        w.globals.zoomEnabled = false;\n        w.globals.selectionEnabled = false;\n        this.getToolbarIconsReference();\n        var toggleEls = [this.elPan, this.elSelection, this.elZoom];\n        toggleEls.forEach(function (el) {\n          if (el) {\n            el.classList.remove(_this3.selectedClass);\n          }\n        });\n      }\n    }, {\n      key: \"handleZoomIn\",\n      value: function handleZoomIn() {\n        var w = this.w;\n\n        if (w.globals.isRangeBar) {\n          this.minX = w.globals.minY;\n          this.maxX = w.globals.maxY;\n        }\n\n        var centerX = (this.minX + this.maxX) / 2;\n        var newMinX = (this.minX + centerX) / 2;\n        var newMaxX = (this.maxX + centerX) / 2;\n\n        var newMinXMaxX = this._getNewMinXMaxX(newMinX, newMaxX);\n\n        if (!w.globals.disableZoomIn) {\n          this.zoomUpdateOptions(newMinXMaxX.minX, newMinXMaxX.maxX);\n        }\n      }\n    }, {\n      key: \"handleZoomOut\",\n      value: function handleZoomOut() {\n        var w = this.w;\n\n        if (w.globals.isRangeBar) {\n          this.minX = w.globals.minY;\n          this.maxX = w.globals.maxY;\n        } // avoid zooming out beyond 1000 which may result in NaN values being printed on x-axis\n\n\n        if (w.config.xaxis.type === 'datetime' && new Date(this.minX).getUTCFullYear() < 1000) {\n          return;\n        }\n\n        var centerX = (this.minX + this.maxX) / 2;\n        var newMinX = this.minX - (centerX - this.minX);\n        var newMaxX = this.maxX - (centerX - this.maxX);\n\n        var newMinXMaxX = this._getNewMinXMaxX(newMinX, newMaxX);\n\n        if (!w.globals.disableZoomOut) {\n          this.zoomUpdateOptions(newMinXMaxX.minX, newMinXMaxX.maxX);\n        }\n      }\n    }, {\n      key: \"_getNewMinXMaxX\",\n      value: function _getNewMinXMaxX(newMinX, newMaxX) {\n        var shouldFloor = this.w.config.xaxis.convertedCatToNumeric;\n        return {\n          minX: shouldFloor ? Math.floor(newMinX) : newMinX,\n          maxX: shouldFloor ? Math.floor(newMaxX) : newMaxX\n        };\n      }\n    }, {\n      key: \"zoomUpdateOptions\",\n      value: function zoomUpdateOptions(newMinX, newMaxX) {\n        var w = this.w;\n\n        if (newMinX === undefined && newMaxX === undefined) {\n          this.handleZoomReset();\n          return;\n        }\n\n        if (w.config.xaxis.convertedCatToNumeric) {\n          // in category charts, avoid zooming out beyond min and max\n          if (newMinX < 1) {\n            newMinX = 1;\n            newMaxX = w.globals.dataPoints;\n          }\n\n          if (newMaxX - newMinX < 2) {\n            return;\n          }\n        }\n\n        var xaxis = {\n          min: newMinX,\n          max: newMaxX\n        };\n        var beforeZoomRange = this.getBeforeZoomRange(xaxis);\n\n        if (beforeZoomRange) {\n          xaxis = beforeZoomRange.xaxis;\n        }\n\n        var options = {\n          xaxis: xaxis\n        };\n        var yaxis = Utils$1.clone(w.globals.initialConfig.yaxis);\n\n        if (w.config.chart.zoom.autoScaleYaxis) {\n          var scale = new Range$1(this.ctx);\n          yaxis = scale.autoScaleY(this.ctx, yaxis, {\n            xaxis: xaxis\n          });\n        }\n\n        if (!w.config.chart.group) {\n          // if chart in a group, prevent yaxis update here\n          // fix issue #650\n          options.yaxis = yaxis;\n        }\n\n        this.w.globals.zoomed = true;\n\n        this.ctx.updateHelpers._updateOptions(options, false, this.w.config.chart.animations.dynamicAnimation.enabled);\n\n        this.zoomCallback(xaxis, yaxis);\n      }\n    }, {\n      key: \"zoomCallback\",\n      value: function zoomCallback(xaxis, yaxis) {\n        if (typeof this.ev.zoomed === 'function') {\n          this.ev.zoomed(this.ctx, {\n            xaxis: xaxis,\n            yaxis: yaxis\n          });\n        }\n      }\n    }, {\n      key: \"getBeforeZoomRange\",\n      value: function getBeforeZoomRange(xaxis, yaxis) {\n        var newRange = null;\n\n        if (typeof this.ev.beforeZoom === 'function') {\n          newRange = this.ev.beforeZoom(this, {\n            xaxis: xaxis,\n            yaxis: yaxis\n          });\n        }\n\n        return newRange;\n      }\n    }, {\n      key: \"toggleMenu\",\n      value: function toggleMenu() {\n        var _this4 = this;\n\n        window.setTimeout(function () {\n          if (_this4.elMenu.classList.contains('apexcharts-menu-open')) {\n            _this4.elMenu.classList.remove('apexcharts-menu-open');\n          } else {\n            _this4.elMenu.classList.add('apexcharts-menu-open');\n          }\n        }, 0);\n      }\n    }, {\n      key: \"handleDownload\",\n      value: function handleDownload(type) {\n        var w = this.w;\n        var exprt = new Exports(this.ctx);\n\n        switch (type) {\n          case 'svg':\n            exprt.exportToSVG(this.ctx);\n            break;\n\n          case 'png':\n            exprt.exportToPng(this.ctx);\n            break;\n\n          case 'csv':\n            exprt.exportToCSV({\n              series: w.config.series,\n              columnDelimiter: w.config.chart.toolbar.export.csv.columnDelimiter\n            });\n            break;\n        }\n      }\n    }, {\n      key: \"handleZoomReset\",\n      value: function handleZoomReset(e) {\n        var charts = this.ctx.getSyncedCharts();\n        charts.forEach(function (ch) {\n          var w = ch.w; // forget lastXAxis min/max as reset button isn't resetting the x-axis completely if zoomX is called before\n\n          w.globals.lastXAxis.min = w.globals.initialConfig.xaxis.min;\n          w.globals.lastXAxis.max = w.globals.initialConfig.xaxis.max;\n          ch.updateHelpers.revertDefaultAxisMinMax();\n\n          if (typeof w.config.chart.events.beforeResetZoom === 'function') {\n            // here, user get an option to control xaxis and yaxis when resetZoom is called\n            // at this point, whatever is returned from w.config.chart.events.beforeResetZoom\n            // is set as the new xaxis/yaxis min/max\n            var resetZoomRange = w.config.chart.events.beforeResetZoom(ch, w);\n\n            if (resetZoomRange) {\n              ch.updateHelpers.revertDefaultAxisMinMax(resetZoomRange);\n            }\n          }\n\n          if (typeof w.config.chart.events.zoomed === 'function') {\n            ch.ctx.toolbar.zoomCallback({\n              min: w.config.xaxis.min,\n              max: w.config.xaxis.max\n            });\n          }\n\n          w.globals.zoomed = false; // if user has some series collapsed before hitting zoom reset button,\n          // those series should stay collapsed\n\n          var series = ch.ctx.series.emptyCollapsedSeries(Utils$1.clone(w.globals.initialSeries));\n\n          ch.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);\n        });\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.elZoom = null;\n        this.elZoomIn = null;\n        this.elZoomOut = null;\n        this.elPan = null;\n        this.elSelection = null;\n        this.elZoomReset = null;\n        this.elMenuIcon = null;\n      }\n    }]);\n\n    return Toolbar;\n  }();\n\n  /**\n   * ApexCharts Zoom Class for handling zooming and panning on axes based charts.\n   *\n   * @module ZoomPanSelection\n   **/\n\n  var ZoomPanSelection = /*#__PURE__*/function (_Toolbar) {\n    _inherits(ZoomPanSelection, _Toolbar);\n\n    var _super = _createSuper(ZoomPanSelection);\n\n    function ZoomPanSelection(ctx) {\n      var _this;\n\n      _classCallCheck(this, ZoomPanSelection);\n\n      _this = _super.call(this, ctx);\n      _this.ctx = ctx;\n      _this.w = ctx.w;\n      _this.dragged = false;\n      _this.graphics = new Graphics(_this.ctx);\n      _this.eventList = ['mousedown', 'mouseleave', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];\n      _this.clientX = 0;\n      _this.clientY = 0;\n      _this.startX = 0;\n      _this.endX = 0;\n      _this.dragX = 0;\n      _this.startY = 0;\n      _this.endY = 0;\n      _this.dragY = 0;\n      _this.moveDirection = 'none';\n      return _this;\n    }\n\n    _createClass(ZoomPanSelection, [{\n      key: \"init\",\n      value: function init(_ref) {\n        var _this2 = this;\n\n        var xyRatios = _ref.xyRatios;\n        var w = this.w;\n        var me = this;\n        this.xyRatios = xyRatios;\n        this.zoomRect = this.graphics.drawRect(0, 0, 0, 0);\n        this.selectionRect = this.graphics.drawRect(0, 0, 0, 0);\n        this.gridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid');\n        this.zoomRect.node.classList.add('apexcharts-zoom-rect');\n        this.selectionRect.node.classList.add('apexcharts-selection-rect');\n        w.globals.dom.elGraphical.add(this.zoomRect);\n        w.globals.dom.elGraphical.add(this.selectionRect);\n\n        if (w.config.chart.selection.type === 'x') {\n          this.slDraggableRect = this.selectionRect.draggable({\n            minX: 0,\n            minY: 0,\n            maxX: w.globals.gridWidth,\n            maxY: w.globals.gridHeight\n          }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n        } else if (w.config.chart.selection.type === 'y') {\n          this.slDraggableRect = this.selectionRect.draggable({\n            minX: 0,\n            maxX: w.globals.gridWidth\n          }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n        } else {\n          this.slDraggableRect = this.selectionRect.draggable().on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n        }\n\n        this.preselectedSelection();\n        this.hoverArea = w.globals.dom.baseEl.querySelector(\"\".concat(w.globals.chartClass, \" .apexcharts-svg\"));\n        this.hoverArea.classList.add('apexcharts-zoomable');\n        this.eventList.forEach(function (event) {\n          _this2.hoverArea.addEventListener(event, me.svgMouseEvents.bind(me, xyRatios), {\n            capture: false,\n            passive: true\n          });\n        });\n      } // remove the event listeners which were previously added on hover area\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.slDraggableRect) {\n          this.slDraggableRect.draggable(false);\n          this.slDraggableRect.off();\n          this.selectionRect.off();\n        }\n\n        this.selectionRect = null;\n        this.zoomRect = null;\n        this.gridRect = null;\n      }\n    }, {\n      key: \"svgMouseEvents\",\n      value: function svgMouseEvents(xyRatios, e) {\n        var w = this.w;\n        var me = this;\n        var toolbar = this.ctx.toolbar;\n        var zoomtype = w.globals.zoomEnabled ? w.config.chart.zoom.type : w.config.chart.selection.type;\n        var autoSelected = w.config.chart.toolbar.autoSelected;\n\n        if (e.shiftKey) {\n          this.shiftWasPressed = true;\n          toolbar.enableZoomPanFromToolbar(autoSelected === 'pan' ? 'zoom' : 'pan');\n        } else {\n          if (this.shiftWasPressed) {\n            toolbar.enableZoomPanFromToolbar(autoSelected);\n            this.shiftWasPressed = false;\n          }\n        }\n\n        if (!e.target) return;\n        var tc = e.target.classList;\n        var pc;\n\n        if (e.target.parentNode && e.target.parentNode !== null) {\n          pc = e.target.parentNode.classList;\n        }\n\n        var falsePositives = tc.contains('apexcharts-selection-rect') || tc.contains('apexcharts-legend-marker') || tc.contains('apexcharts-legend-text') || pc && pc.contains('apexcharts-toolbar');\n        if (falsePositives) return;\n        me.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;\n        me.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;\n\n        if (e.type === 'mousedown' && e.which === 1) {\n          var gridRectDim = me.gridRect.getBoundingClientRect();\n          me.startX = me.clientX - gridRectDim.left;\n          me.startY = me.clientY - gridRectDim.top;\n          me.dragged = false;\n          me.w.globals.mousedown = true;\n        }\n\n        if (e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') {\n          me.dragged = true;\n\n          if (w.globals.panEnabled) {\n            w.globals.selection = null;\n\n            if (me.w.globals.mousedown) {\n              me.panDragging({\n                context: me,\n                zoomtype: zoomtype,\n                xyRatios: xyRatios\n              });\n            }\n          } else {\n            if (me.w.globals.mousedown && w.globals.zoomEnabled || me.w.globals.mousedown && w.globals.selectionEnabled) {\n              me.selection = me.selectionDrawing({\n                context: me,\n                zoomtype: zoomtype\n              });\n            }\n          }\n        }\n\n        if (e.type === 'mouseup' || e.type === 'touchend' || e.type === 'mouseleave') {\n          // we will be calling getBoundingClientRect on each mousedown/mousemove/mouseup\n          var _gridRectDim = me.gridRect.getBoundingClientRect();\n\n          if (me.w.globals.mousedown) {\n            // user released the drag, now do all the calculations\n            me.endX = me.clientX - _gridRectDim.left;\n            me.endY = me.clientY - _gridRectDim.top;\n            me.dragX = Math.abs(me.endX - me.startX);\n            me.dragY = Math.abs(me.endY - me.startY);\n\n            if (w.globals.zoomEnabled || w.globals.selectionEnabled) {\n              me.selectionDrawn({\n                context: me,\n                zoomtype: zoomtype\n              });\n            }\n\n            if (w.globals.panEnabled && w.config.xaxis.convertedCatToNumeric) {\n              me.delayedPanScrolled();\n            }\n          }\n\n          if (w.globals.zoomEnabled) {\n            me.hideSelectionRect(this.selectionRect);\n          }\n\n          me.dragged = false;\n          me.w.globals.mousedown = false;\n        }\n\n        this.makeSelectionRectDraggable();\n      }\n    }, {\n      key: \"makeSelectionRectDraggable\",\n      value: function makeSelectionRectDraggable() {\n        var w = this.w;\n        if (!this.selectionRect) return;\n        var rectDim = this.selectionRect.node.getBoundingClientRect();\n\n        if (rectDim.width > 0 && rectDim.height > 0) {\n          this.slDraggableRect.selectize({\n            points: 'l, r',\n            pointSize: 8,\n            pointType: 'rect'\n          }).resize({\n            constraint: {\n              minX: 0,\n              minY: 0,\n              maxX: w.globals.gridWidth,\n              maxY: w.globals.gridHeight\n            }\n          }).on('resizing', this.selectionDragging.bind(this, 'resizing'));\n        }\n      }\n    }, {\n      key: \"preselectedSelection\",\n      value: function preselectedSelection() {\n        var w = this.w;\n        var xyRatios = this.xyRatios;\n\n        if (!w.globals.zoomEnabled) {\n          if (typeof w.globals.selection !== 'undefined' && w.globals.selection !== null) {\n            this.drawSelectionRect(w.globals.selection);\n          } else {\n            if (w.config.chart.selection.xaxis.min !== undefined && w.config.chart.selection.xaxis.max !== undefined) {\n              var x = (w.config.chart.selection.xaxis.min - w.globals.minX) / xyRatios.xRatio;\n              var width = w.globals.gridWidth - (w.globals.maxX - w.config.chart.selection.xaxis.max) / xyRatios.xRatio - x;\n              var selectionRect = {\n                x: x,\n                y: 0,\n                width: width,\n                height: w.globals.gridHeight,\n                translateX: 0,\n                translateY: 0,\n                selectionEnabled: true\n              };\n              this.drawSelectionRect(selectionRect);\n              this.makeSelectionRectDraggable();\n\n              if (typeof w.config.chart.events.selection === 'function') {\n                w.config.chart.events.selection(this.ctx, {\n                  xaxis: {\n                    min: w.config.chart.selection.xaxis.min,\n                    max: w.config.chart.selection.xaxis.max\n                  },\n                  yaxis: {}\n                });\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"drawSelectionRect\",\n      value: function drawSelectionRect(_ref2) {\n        var x = _ref2.x,\n            y = _ref2.y,\n            width = _ref2.width,\n            height = _ref2.height,\n            _ref2$translateX = _ref2.translateX,\n            translateX = _ref2$translateX === void 0 ? 0 : _ref2$translateX,\n            _ref2$translateY = _ref2.translateY,\n            translateY = _ref2$translateY === void 0 ? 0 : _ref2$translateY;\n        var w = this.w;\n        var zoomRect = this.zoomRect;\n        var selectionRect = this.selectionRect;\n\n        if (this.dragged || w.globals.selection !== null) {\n          var scalingAttrs = {\n            transform: 'translate(' + translateX + ', ' + translateY + ')'\n          }; // change styles based on zoom or selection\n          // zoom is Enabled and user has dragged, so draw blue rect\n\n          if (w.globals.zoomEnabled && this.dragged) {\n            if (width < 0) width = 1; // fixes apexcharts.js#1168\n\n            zoomRect.attr({\n              x: x,\n              y: y,\n              width: width,\n              height: height,\n              fill: w.config.chart.zoom.zoomedArea.fill.color,\n              'fill-opacity': w.config.chart.zoom.zoomedArea.fill.opacity,\n              stroke: w.config.chart.zoom.zoomedArea.stroke.color,\n              'stroke-width': w.config.chart.zoom.zoomedArea.stroke.width,\n              'stroke-opacity': w.config.chart.zoom.zoomedArea.stroke.opacity\n            });\n            Graphics.setAttrs(zoomRect.node, scalingAttrs);\n          } // selection is enabled\n\n\n          if (w.globals.selectionEnabled) {\n            selectionRect.attr({\n              x: x,\n              y: y,\n              width: width > 0 ? width : 0,\n              height: height > 0 ? height : 0,\n              fill: w.config.chart.selection.fill.color,\n              'fill-opacity': w.config.chart.selection.fill.opacity,\n              stroke: w.config.chart.selection.stroke.color,\n              'stroke-width': w.config.chart.selection.stroke.width,\n              'stroke-dasharray': w.config.chart.selection.stroke.dashArray,\n              'stroke-opacity': w.config.chart.selection.stroke.opacity\n            });\n            Graphics.setAttrs(selectionRect.node, scalingAttrs);\n          }\n        }\n      }\n    }, {\n      key: \"hideSelectionRect\",\n      value: function hideSelectionRect(rect) {\n        if (rect) {\n          rect.attr({\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          });\n        }\n      }\n    }, {\n      key: \"selectionDrawing\",\n      value: function selectionDrawing(_ref3) {\n        var context = _ref3.context,\n            zoomtype = _ref3.zoomtype;\n        var w = this.w;\n        var me = context;\n        var gridRectDim = this.gridRect.getBoundingClientRect();\n        var startX = me.startX - 1;\n        var startY = me.startY;\n        var inversedX = false;\n        var inversedY = false;\n        var selectionWidth = me.clientX - gridRectDim.left - startX;\n        var selectionHeight = me.clientY - gridRectDim.top - startY;\n        var selectionRect = {};\n\n        if (Math.abs(selectionWidth + startX) > w.globals.gridWidth) {\n          // user dragged the mouse outside drawing area to the right\n          selectionWidth = w.globals.gridWidth - startX;\n        } else if (me.clientX - gridRectDim.left < 0) {\n          // user dragged the mouse outside drawing area to the left\n          selectionWidth = startX;\n        } // inverse selection X\n\n\n        if (startX > me.clientX - gridRectDim.left) {\n          inversedX = true;\n          selectionWidth = Math.abs(selectionWidth);\n        } // inverse selection Y\n\n\n        if (startY > me.clientY - gridRectDim.top) {\n          inversedY = true;\n          selectionHeight = Math.abs(selectionHeight);\n        }\n\n        if (zoomtype === 'x') {\n          selectionRect = {\n            x: inversedX ? startX - selectionWidth : startX,\n            y: 0,\n            width: selectionWidth,\n            height: w.globals.gridHeight\n          };\n        } else if (zoomtype === 'y') {\n          selectionRect = {\n            x: 0,\n            y: inversedY ? startY - selectionHeight : startY,\n            width: w.globals.gridWidth,\n            height: selectionHeight\n          };\n        } else {\n          selectionRect = {\n            x: inversedX ? startX - selectionWidth : startX,\n            y: inversedY ? startY - selectionHeight : startY,\n            width: selectionWidth,\n            height: selectionHeight\n          };\n        }\n\n        me.drawSelectionRect(selectionRect);\n        me.selectionDragging('resizing');\n        return selectionRect;\n      }\n    }, {\n      key: \"selectionDragging\",\n      value: function selectionDragging(type, e) {\n        var _this3 = this;\n\n        var w = this.w;\n        var xyRatios = this.xyRatios;\n        var selRect = this.selectionRect;\n        var timerInterval = 0;\n\n        if (type === 'resizing') {\n          timerInterval = 30;\n        } // update selection when selection rect is dragged\n\n\n        var getSelAttr = function getSelAttr(attr) {\n          return parseFloat(selRect.node.getAttribute(attr));\n        };\n\n        var draggedProps = {\n          x: getSelAttr('x'),\n          y: getSelAttr('y'),\n          width: getSelAttr('width'),\n          height: getSelAttr('height')\n        };\n        w.globals.selection = draggedProps; // update selection ends\n\n        if (typeof w.config.chart.events.selection === 'function' && w.globals.selectionEnabled) {\n          // a small debouncer is required when resizing to avoid freezing the chart\n          clearTimeout(this.w.globals.selectionResizeTimer);\n          this.w.globals.selectionResizeTimer = window.setTimeout(function () {\n            var gridRectDim = _this3.gridRect.getBoundingClientRect();\n\n            var selectionRect = selRect.node.getBoundingClientRect();\n            var minX = w.globals.xAxisScale.niceMin + (selectionRect.left - gridRectDim.left) * xyRatios.xRatio;\n            var maxX = w.globals.xAxisScale.niceMin + (selectionRect.right - gridRectDim.left) * xyRatios.xRatio;\n            var minY = w.globals.yAxisScale[0].niceMin + (gridRectDim.bottom - selectionRect.bottom) * xyRatios.yRatio[0];\n            var maxY = w.globals.yAxisScale[0].niceMax - (selectionRect.top - gridRectDim.top) * xyRatios.yRatio[0];\n            var xyAxis = {\n              xaxis: {\n                min: minX,\n                max: maxX\n              },\n              yaxis: {\n                min: minY,\n                max: maxY\n              }\n            };\n            w.config.chart.events.selection(_this3.ctx, xyAxis);\n\n            if (w.config.chart.brush.enabled && w.config.chart.events.brushScrolled !== undefined) {\n              w.config.chart.events.brushScrolled(_this3.ctx, xyAxis);\n            }\n          }, timerInterval);\n        }\n      }\n    }, {\n      key: \"selectionDrawn\",\n      value: function selectionDrawn(_ref4) {\n        var context = _ref4.context,\n            zoomtype = _ref4.zoomtype;\n        var w = this.w;\n        var me = context;\n        var xyRatios = this.xyRatios;\n        var toolbar = this.ctx.toolbar;\n\n        if (me.startX > me.endX) {\n          var tempX = me.startX;\n          me.startX = me.endX;\n          me.endX = tempX;\n        }\n\n        if (me.startY > me.endY) {\n          var tempY = me.startY;\n          me.startY = me.endY;\n          me.endY = tempY;\n        }\n\n        var xLowestValue = undefined;\n        var xHighestValue = undefined;\n\n        if (!w.globals.isRangeBar) {\n          xLowestValue = w.globals.xAxisScale.niceMin + me.startX * xyRatios.xRatio;\n          xHighestValue = w.globals.xAxisScale.niceMin + me.endX * xyRatios.xRatio;\n        } else {\n          xLowestValue = w.globals.yAxisScale[0].niceMin + me.startX * xyRatios.invertedYRatio;\n          xHighestValue = w.globals.yAxisScale[0].niceMin + me.endX * xyRatios.invertedYRatio;\n        } // TODO: we will consider the 1st y axis values here for getting highest and lowest y\n\n\n        var yHighestValue = [];\n        var yLowestValue = [];\n        w.config.yaxis.forEach(function (yaxe, index) {\n          yHighestValue.push(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.startY);\n          yLowestValue.push(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.endY);\n        });\n\n        if (me.dragged && (me.dragX > 10 || me.dragY > 10) && xLowestValue !== xHighestValue) {\n          if (w.globals.zoomEnabled) {\n            var yaxis = Utils$1.clone(w.globals.initialConfig.yaxis);\n            var xaxis = Utils$1.clone(w.globals.initialConfig.xaxis);\n            w.globals.zoomed = true;\n\n            if (w.config.xaxis.convertedCatToNumeric) {\n              xLowestValue = Math.floor(xLowestValue);\n              xHighestValue = Math.floor(xHighestValue);\n\n              if (xLowestValue < 1) {\n                xLowestValue = 1;\n                xHighestValue = w.globals.dataPoints;\n              }\n\n              if (xHighestValue - xLowestValue < 2) {\n                xHighestValue = xLowestValue + 1;\n              }\n            }\n\n            if (zoomtype === 'xy' || zoomtype === 'x') {\n              xaxis = {\n                min: xLowestValue,\n                max: xHighestValue\n              };\n            }\n\n            if (zoomtype === 'xy' || zoomtype === 'y') {\n              yaxis.forEach(function (yaxe, index) {\n                yaxis[index].min = yLowestValue[index];\n                yaxis[index].max = yHighestValue[index];\n              });\n            }\n\n            if (w.config.chart.zoom.autoScaleYaxis) {\n              var scale = new Range$1(me.ctx);\n              yaxis = scale.autoScaleY(me.ctx, yaxis, {\n                xaxis: xaxis\n              });\n            }\n\n            if (toolbar) {\n              var beforeZoomRange = toolbar.getBeforeZoomRange(xaxis, yaxis);\n\n              if (beforeZoomRange) {\n                xaxis = beforeZoomRange.xaxis ? beforeZoomRange.xaxis : xaxis;\n                yaxis = beforeZoomRange.yaxis ? beforeZoomRange.yaxis : yaxis;\n              }\n            }\n\n            var options = {\n              xaxis: xaxis\n            };\n\n            if (!w.config.chart.group) {\n              // if chart in a group, prevent yaxis update here\n              // fix issue #650\n              options.yaxis = yaxis;\n            }\n\n            me.ctx.updateHelpers._updateOptions(options, false, me.w.config.chart.animations.dynamicAnimation.enabled);\n\n            if (typeof w.config.chart.events.zoomed === 'function') {\n              toolbar.zoomCallback(xaxis, yaxis);\n            }\n          } else if (w.globals.selectionEnabled) {\n            var _yaxis = null;\n            var _xaxis = null;\n            _xaxis = {\n              min: xLowestValue,\n              max: xHighestValue\n            };\n\n            if (zoomtype === 'xy' || zoomtype === 'y') {\n              _yaxis = Utils$1.clone(w.config.yaxis);\n\n              _yaxis.forEach(function (yaxe, index) {\n                _yaxis[index].min = yLowestValue[index];\n                _yaxis[index].max = yHighestValue[index];\n              });\n            }\n\n            w.globals.selection = me.selection;\n\n            if (typeof w.config.chart.events.selection === 'function') {\n              w.config.chart.events.selection(me.ctx, {\n                xaxis: _xaxis,\n                yaxis: _yaxis\n              });\n            }\n          }\n        }\n      }\n    }, {\n      key: \"panDragging\",\n      value: function panDragging(_ref5) {\n        var context = _ref5.context;\n        var w = this.w;\n        var me = context; // check to make sure there is data to compare against\n\n        if (typeof w.globals.lastClientPosition.x !== 'undefined') {\n          // get the change from last position to this position\n          var deltaX = w.globals.lastClientPosition.x - me.clientX;\n          var deltaY = w.globals.lastClientPosition.y - me.clientY; // check which direction had the highest amplitude and then figure out direction by checking if the value is greater or less than zero\n\n          if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {\n            this.moveDirection = 'left';\n          } else if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0) {\n            this.moveDirection = 'right';\n          } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {\n            this.moveDirection = 'up';\n          } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < 0) {\n            this.moveDirection = 'down';\n          }\n        } // set the new last position to the current for next time (to get the position of drag)\n\n\n        w.globals.lastClientPosition = {\n          x: me.clientX,\n          y: me.clientY\n        };\n        var xLowestValue = w.globals.isRangeBar ? w.globals.minY : w.globals.minX;\n        var xHighestValue = w.globals.isRangeBar ? w.globals.maxY : w.globals.maxX; // on a category, we don't pan continuosly as it causes bugs\n\n        if (!w.config.xaxis.convertedCatToNumeric) {\n          me.panScrolled(xLowestValue, xHighestValue);\n        }\n      }\n    }, {\n      key: \"delayedPanScrolled\",\n      value: function delayedPanScrolled() {\n        var w = this.w;\n        var newMinX = w.globals.minX;\n        var newMaxX = w.globals.maxX;\n        var centerX = (w.globals.maxX - w.globals.minX) / 2;\n\n        if (this.moveDirection === 'left') {\n          newMinX = w.globals.minX + centerX;\n          newMaxX = w.globals.maxX + centerX;\n        } else if (this.moveDirection === 'right') {\n          newMinX = w.globals.minX - centerX;\n          newMaxX = w.globals.maxX - centerX;\n        }\n\n        newMinX = Math.floor(newMinX);\n        newMaxX = Math.floor(newMaxX);\n        this.updateScrolledChart({\n          xaxis: {\n            min: newMinX,\n            max: newMaxX\n          }\n        }, newMinX, newMaxX);\n      }\n    }, {\n      key: \"panScrolled\",\n      value: function panScrolled(xLowestValue, xHighestValue) {\n        var w = this.w;\n        var xyRatios = this.xyRatios;\n        var yaxis = Utils$1.clone(w.globals.initialConfig.yaxis);\n        var xRatio = xyRatios.xRatio;\n        var minX = w.globals.minX;\n        var maxX = w.globals.maxX;\n\n        if (w.globals.isRangeBar) {\n          xRatio = xyRatios.invertedYRatio;\n          minX = w.globals.minY;\n          maxX = w.globals.maxY;\n        }\n\n        if (this.moveDirection === 'left') {\n          xLowestValue = minX + w.globals.gridWidth / 15 * xRatio;\n          xHighestValue = maxX + w.globals.gridWidth / 15 * xRatio;\n        } else if (this.moveDirection === 'right') {\n          xLowestValue = minX - w.globals.gridWidth / 15 * xRatio;\n          xHighestValue = maxX - w.globals.gridWidth / 15 * xRatio;\n        }\n\n        if (!w.globals.isRangeBar) {\n          if (xLowestValue < w.globals.initialMinX || xHighestValue > w.globals.initialMaxX) {\n            xLowestValue = minX;\n            xHighestValue = maxX;\n          }\n        }\n\n        var xaxis = {\n          min: xLowestValue,\n          max: xHighestValue\n        };\n\n        if (w.config.chart.zoom.autoScaleYaxis) {\n          var scale = new Range$1(this.ctx);\n          yaxis = scale.autoScaleY(this.ctx, yaxis, {\n            xaxis: xaxis\n          });\n        }\n\n        var options = {\n          xaxis: {\n            min: xLowestValue,\n            max: xHighestValue\n          }\n        };\n\n        if (!w.config.chart.group) {\n          // if chart in a group, prevent yaxis update here\n          // fix issue #650\n          options.yaxis = yaxis;\n        }\n\n        this.updateScrolledChart(options, xLowestValue, xHighestValue);\n      }\n    }, {\n      key: \"updateScrolledChart\",\n      value: function updateScrolledChart(options, xLowestValue, xHighestValue) {\n        var w = this.w;\n\n        this.ctx.updateHelpers._updateOptions(options, false, false);\n\n        if (typeof w.config.chart.events.scrolled === 'function') {\n          w.config.chart.events.scrolled(this.ctx, {\n            xaxis: {\n              min: xLowestValue,\n              max: xHighestValue\n            }\n          });\n        }\n      }\n    }]);\n\n    return ZoomPanSelection;\n  }(Toolbar);\n\n  /**\n   * ApexCharts Tooltip.Utils Class to support Tooltip functionality.\n   *\n   * @module Tooltip.Utils\n   **/\n\n  var Utils = /*#__PURE__*/function () {\n    function Utils(tooltipContext) {\n      _classCallCheck(this, Utils);\n\n      this.w = tooltipContext.w;\n      this.ttCtx = tooltipContext;\n      this.ctx = tooltipContext.ctx;\n    }\n    /**\n     ** When hovering over series, you need to capture which series is being hovered on.\n     ** This function will return both capturedseries index as well as inner index of that series\n     * @memberof Utils\n     * @param {object}\n     * - hoverArea = the rect on which user hovers\n     * - elGrid = dimensions of the hover rect (it can be different than hoverarea)\n     */\n\n\n    _createClass(Utils, [{\n      key: \"getNearestValues\",\n      value: function getNearestValues(_ref) {\n        var hoverArea = _ref.hoverArea,\n            elGrid = _ref.elGrid,\n            clientX = _ref.clientX,\n            clientY = _ref.clientY;\n        var w = this.w;\n        var seriesBound = elGrid.getBoundingClientRect();\n        var hoverWidth = seriesBound.width;\n        var hoverHeight = seriesBound.height;\n        var xDivisor = hoverWidth / (w.globals.dataPoints - 1);\n        var yDivisor = hoverHeight / w.globals.dataPoints;\n        var hasBars = this.hasBars();\n\n        if ((w.globals.comboCharts || hasBars) && !w.config.xaxis.convertedCatToNumeric) {\n          xDivisor = hoverWidth / w.globals.dataPoints;\n        }\n\n        var hoverX = clientX - seriesBound.left - w.globals.barPadForNumericAxis;\n        var hoverY = clientY - seriesBound.top;\n        var notInRect = hoverX < 0 || hoverY < 0 || hoverX > hoverWidth || hoverY > hoverHeight;\n\n        if (notInRect) {\n          hoverArea.classList.remove('hovering-zoom');\n          hoverArea.classList.remove('hovering-pan');\n        } else {\n          if (w.globals.zoomEnabled) {\n            hoverArea.classList.remove('hovering-pan');\n            hoverArea.classList.add('hovering-zoom');\n          } else if (w.globals.panEnabled) {\n            hoverArea.classList.remove('hovering-zoom');\n            hoverArea.classList.add('hovering-pan');\n          }\n        }\n\n        var j = Math.round(hoverX / xDivisor);\n        var jHorz = Math.floor(hoverY / yDivisor);\n\n        if (hasBars && !w.config.xaxis.convertedCatToNumeric) {\n          j = Math.ceil(hoverX / xDivisor);\n          j = j - 1;\n        }\n\n        var capturedSeries = null;\n        var closest = null;\n        var seriesXValArr = w.globals.seriesXvalues.map(function (seriesXVal) {\n          return seriesXVal.filter(function (s) {\n            return Utils$1.isNumber(s);\n          });\n        });\n        var seriesYValArr = w.globals.seriesYvalues.map(function (seriesYVal) {\n          return seriesYVal.filter(function (s) {\n            return Utils$1.isNumber(s);\n          });\n        }); // if X axis type is not category and tooltip is not shared, then we need to find the cursor position and get the nearest value\n\n        if (w.globals.isXNumeric) {\n          // Change origin of cursor position so that we can compute the relative nearest point to the cursor on our chart\n          // we only need to scale because all points are relative to the bounds.left and bounds.top => origin is virtually (0, 0)\n          var chartGridEl = this.ttCtx.getElGrid();\n          var chartGridElBoundingRect = chartGridEl.getBoundingClientRect();\n          var transformedHoverX = hoverX * (chartGridElBoundingRect.width / hoverWidth);\n          var transformedHoverY = hoverY * (chartGridElBoundingRect.height / hoverHeight);\n          closest = this.closestInMultiArray(transformedHoverX, transformedHoverY, seriesXValArr, seriesYValArr);\n          capturedSeries = closest.index;\n          j = closest.j;\n\n          if (capturedSeries !== null) {\n            // initial push, it should be a little smaller than the 1st val\n            seriesXValArr = w.globals.seriesXvalues[capturedSeries];\n            closest = this.closestInArray(transformedHoverX, seriesXValArr);\n            j = closest.index;\n          }\n        }\n\n        w.globals.capturedSeriesIndex = capturedSeries === null ? -1 : capturedSeries;\n        if (!j || j < 1) j = 0;\n\n        if (w.globals.isBarHorizontal) {\n          w.globals.capturedDataPointIndex = jHorz;\n        } else {\n          w.globals.capturedDataPointIndex = j;\n        }\n\n        return {\n          capturedSeries: capturedSeries,\n          j: w.globals.isBarHorizontal ? jHorz : j,\n          hoverX: hoverX,\n          hoverY: hoverY\n        };\n      }\n    }, {\n      key: \"closestInMultiArray\",\n      value: function closestInMultiArray(hoverX, hoverY, Xarrays, Yarrays) {\n        var w = this.w;\n        var activeIndex = 0;\n        var currIndex = null;\n        var j = -1;\n\n        if (w.globals.series.length > 1) {\n          activeIndex = this.getFirstActiveXArray(Xarrays);\n        } else {\n          currIndex = 0;\n        }\n\n        var currX = Xarrays[activeIndex][0];\n        var diffX = Math.abs(hoverX - currX); // find nearest point on x-axis\n\n        Xarrays.forEach(function (arrX) {\n          arrX.forEach(function (x, iX) {\n            var newDiff = Math.abs(hoverX - x);\n\n            if (newDiff <= diffX) {\n              diffX = newDiff;\n              j = iX;\n            }\n          });\n        });\n\n        if (j !== -1) {\n          // find nearest graph on y-axis relevanted to nearest point on x-axis\n          var currY = Yarrays[activeIndex][j];\n          var diffY = Math.abs(hoverY - currY);\n          currIndex = activeIndex;\n          Yarrays.forEach(function (arrY, iAY) {\n            var newDiff = Math.abs(hoverY - arrY[j]);\n\n            if (newDiff <= diffY) {\n              diffY = newDiff;\n              currIndex = iAY;\n            }\n          });\n        }\n\n        return {\n          index: currIndex,\n          j: j\n        };\n      }\n    }, {\n      key: \"getFirstActiveXArray\",\n      value: function getFirstActiveXArray(Xarrays) {\n        var w = this.w;\n        var activeIndex = 0;\n        var firstActiveSeriesIndex = Xarrays.map(function (xarr, index) {\n          return xarr.length > 0 ? index : -1;\n        });\n\n        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {\n          if (firstActiveSeriesIndex[a] !== -1 && w.globals.collapsedSeriesIndices.indexOf(a) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(a) === -1) {\n            activeIndex = firstActiveSeriesIndex[a];\n            break;\n          }\n        }\n\n        return activeIndex;\n      }\n    }, {\n      key: \"closestInArray\",\n      value: function closestInArray(val, arr) {\n        var curr = arr[0];\n        var currIndex = null;\n        var diff = Math.abs(val - curr);\n\n        for (var i = 0; i < arr.length; i++) {\n          var newdiff = Math.abs(val - arr[i]);\n\n          if (newdiff < diff) {\n            diff = newdiff;\n            currIndex = i;\n          }\n        }\n\n        return {\n          index: currIndex\n        };\n      }\n      /**\n       * When there are multiple series, it is possible to have different x values for each series.\n       * But it may be possible in those multiple series, that there is same x value for 2 or more\n       * series.\n       * @memberof Utils\n       * @param {int}\n       * - j = is the inner index of series -> (series[i][j])\n       * @return {bool}\n       */\n\n    }, {\n      key: \"isXoverlap\",\n      value: function isXoverlap(j) {\n        var w = this.w;\n        var xSameForAllSeriesJArr = [];\n        var seriesX = w.globals.seriesX.filter(function (s) {\n          return typeof s[0] !== 'undefined';\n        });\n\n        if (seriesX.length > 0) {\n          for (var i = 0; i < seriesX.length - 1; i++) {\n            if (typeof seriesX[i][j] !== 'undefined' && typeof seriesX[i + 1][j] !== 'undefined') {\n              if (seriesX[i][j] !== seriesX[i + 1][j]) {\n                xSameForAllSeriesJArr.push('unEqual');\n              }\n            }\n          }\n        }\n\n        if (xSameForAllSeriesJArr.length === 0) {\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"isInitialSeriesSameLen\",\n      value: function isInitialSeriesSameLen() {\n        var sameLen = true;\n        var initialSeries = this.w.globals.initialSeries;\n\n        for (var i = 0; i < initialSeries.length - 1; i++) {\n          if (initialSeries[i].data.length !== initialSeries[i + 1].data.length) {\n            sameLen = false;\n            break;\n          }\n        }\n\n        return sameLen;\n      }\n    }, {\n      key: \"getBarsHeight\",\n      value: function getBarsHeight(allbars) {\n        var bars = _toConsumableArray(allbars);\n\n        var totalHeight = bars.reduce(function (acc, bar) {\n          return acc + bar.getBBox().height;\n        }, 0);\n        return totalHeight;\n      }\n    }, {\n      key: \"getElMarkers\",\n      value: function getElMarkers(capturedSeries) {\n        // The selector .apexcharts-series-markers-wrap > * includes marker groups for which the\n        // .apexcharts-series-markers class is not added due to null values or discrete markers\n        if (typeof capturedSeries == 'number') {\n          return this.w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[data\\\\:realIndex='\".concat(capturedSeries, \"'] .apexcharts-series-markers-wrap > *\"));\n        }\n\n        return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers-wrap > *');\n      }\n    }, {\n      key: \"getAllMarkers\",\n      value: function getAllMarkers() {\n        // first get all marker parents. This parent class contains series-index\n        // which helps to sort the markers as they are dynamic\n        var markersWraps = this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers-wrap');\n        markersWraps = _toConsumableArray(markersWraps);\n        markersWraps.sort(function (a, b) {\n          var indexA = Number(a.getAttribute('data:realIndex'));\n          var indexB = Number(b.getAttribute('data:realIndex'));\n          return indexB < indexA ? 1 : indexB > indexA ? -1 : 0;\n        });\n        var markers = [];\n        markersWraps.forEach(function (m) {\n          markers.push(m.querySelector('.apexcharts-marker'));\n        });\n        return markers;\n      }\n    }, {\n      key: \"hasMarkers\",\n      value: function hasMarkers(capturedSeries) {\n        var markers = this.getElMarkers(capturedSeries);\n        return markers.length > 0;\n      }\n    }, {\n      key: \"getElBars\",\n      value: function getElBars() {\n        return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series');\n      }\n    }, {\n      key: \"hasBars\",\n      value: function hasBars() {\n        var bars = this.getElBars();\n        return bars.length > 0;\n      }\n    }, {\n      key: \"getHoverMarkerSize\",\n      value: function getHoverMarkerSize(index) {\n        var w = this.w;\n        var hoverSize = w.config.markers.hover.size;\n\n        if (hoverSize === undefined) {\n          hoverSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;\n        }\n\n        return hoverSize;\n      }\n    }, {\n      key: \"toggleAllTooltipSeriesGroups\",\n      value: function toggleAllTooltipSeriesGroups(state) {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n\n        if (ttCtx.allTooltipSeriesGroups.length === 0) {\n          ttCtx.allTooltipSeriesGroups = w.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group');\n        }\n\n        var allTooltipSeriesGroups = ttCtx.allTooltipSeriesGroups;\n\n        for (var i = 0; i < allTooltipSeriesGroups.length; i++) {\n          if (state === 'enable') {\n            allTooltipSeriesGroups[i].classList.add('apexcharts-active');\n            allTooltipSeriesGroups[i].style.display = w.config.tooltip.items.display;\n          } else {\n            allTooltipSeriesGroups[i].classList.remove('apexcharts-active');\n            allTooltipSeriesGroups[i].style.display = 'none';\n          }\n        }\n      }\n    }]);\n\n    return Utils;\n  }();\n\n  /**\n   * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.\n   * This file deals with printing actual text on the tooltip.\n   *\n   * @module Tooltip.Labels\n   **/\n\n  var Labels = /*#__PURE__*/function () {\n    function Labels(tooltipContext) {\n      _classCallCheck(this, Labels);\n\n      this.w = tooltipContext.w;\n      this.ctx = tooltipContext.ctx;\n      this.ttCtx = tooltipContext;\n      this.tooltipUtil = new Utils(tooltipContext);\n    }\n\n    _createClass(Labels, [{\n      key: \"drawSeriesTexts\",\n      value: function drawSeriesTexts(_ref) {\n        var _ref$shared = _ref.shared,\n            shared = _ref$shared === void 0 ? true : _ref$shared,\n            ttItems = _ref.ttItems,\n            _ref$i = _ref.i,\n            i = _ref$i === void 0 ? 0 : _ref$i,\n            _ref$j = _ref.j,\n            j = _ref$j === void 0 ? null : _ref$j,\n            y1 = _ref.y1,\n            y2 = _ref.y2,\n            e = _ref.e;\n        var w = this.w;\n\n        if (w.config.tooltip.custom !== undefined) {\n          this.handleCustomTooltip({\n            i: i,\n            j: j,\n            y1: y1,\n            y2: y2,\n            w: w\n          });\n        } else {\n          this.toggleActiveInactiveSeries(shared);\n        }\n\n        var values = this.getValuesToPrint({\n          i: i,\n          j: j\n        });\n        this.printLabels({\n          i: i,\n          j: j,\n          values: values,\n          ttItems: ttItems,\n          shared: shared,\n          e: e\n        }); // Re-calculate tooltip dimensions now that we have drawn the text\n\n        var tooltipEl = this.ttCtx.getElTooltip();\n        this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width;\n        this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height;\n      }\n    }, {\n      key: \"printLabels\",\n      value: function printLabels(_ref2) {\n        var _this = this;\n\n        var i = _ref2.i,\n            j = _ref2.j,\n            values = _ref2.values,\n            ttItems = _ref2.ttItems,\n            shared = _ref2.shared,\n            e = _ref2.e;\n        var w = this.w;\n        var val;\n        var goalVals = [];\n\n        var hasGoalValues = function hasGoalValues(gi) {\n          return w.globals.seriesGoals[gi] && w.globals.seriesGoals[gi][j] && Array.isArray(w.globals.seriesGoals[gi][j]);\n        };\n\n        var xVal = values.xVal,\n            zVal = values.zVal,\n            xAxisTTVal = values.xAxisTTVal;\n        var seriesName = '';\n        var pColor = w.globals.colors[i]; // The pColor here is for the markers inside tooltip\n\n        if (j !== null && w.config.plotOptions.bar.distributed) {\n          pColor = w.globals.colors[j];\n        }\n\n        var _loop = function _loop(t, inverset) {\n          var f = _this.getFormatters(i);\n\n          seriesName = _this.getSeriesName({\n            fn: f.yLbTitleFormatter,\n            index: i,\n            seriesIndex: i,\n            j: j\n          });\n\n          if (w.config.chart.type === 'treemap') {\n            seriesName = f.yLbTitleFormatter(String(w.config.series[i].data[j].x), {\n              series: w.globals.series,\n              seriesIndex: i,\n              dataPointIndex: j,\n              w: w\n            });\n          }\n\n          var tIndex = w.config.tooltip.inverseOrder ? inverset : t;\n\n          if (w.globals.axisCharts) {\n            var getValBySeriesIndex = function getValBySeriesIndex(index) {\n              if (w.globals.isRangeData) {\n                var _w$globals$seriesRang, _w$globals$seriesRang2, _w$globals$seriesRang3, _w$globals$seriesRang4;\n\n                return f.yLbFormatter((_w$globals$seriesRang = w.globals.seriesRangeStart) === null || _w$globals$seriesRang === void 0 ? void 0 : (_w$globals$seriesRang2 = _w$globals$seriesRang[index]) === null || _w$globals$seriesRang2 === void 0 ? void 0 : _w$globals$seriesRang2[j], {\n                  series: w.globals.seriesRangeStart,\n                  seriesIndex: index,\n                  dataPointIndex: j,\n                  w: w\n                }) + ' - ' + f.yLbFormatter((_w$globals$seriesRang3 = w.globals.seriesRangeEnd) === null || _w$globals$seriesRang3 === void 0 ? void 0 : (_w$globals$seriesRang4 = _w$globals$seriesRang3[index]) === null || _w$globals$seriesRang4 === void 0 ? void 0 : _w$globals$seriesRang4[j], {\n                  series: w.globals.seriesRangeEnd,\n                  seriesIndex: index,\n                  dataPointIndex: j,\n                  w: w\n                });\n              }\n\n              return f.yLbFormatter(w.globals.series[index][j], {\n                series: w.globals.series,\n                seriesIndex: index,\n                dataPointIndex: j,\n                w: w\n              });\n            };\n\n            if (shared) {\n              f = _this.getFormatters(tIndex);\n              seriesName = _this.getSeriesName({\n                fn: f.yLbTitleFormatter,\n                index: tIndex,\n                seriesIndex: i,\n                j: j\n              });\n              pColor = w.globals.colors[tIndex];\n              val = getValBySeriesIndex(tIndex);\n\n              if (hasGoalValues(tIndex)) {\n                goalVals = w.globals.seriesGoals[tIndex][j].map(function (goal) {\n                  return {\n                    attrs: goal,\n                    val: f.yLbFormatter(goal.value, {\n                      seriesIndex: tIndex,\n                      dataPointIndex: j,\n                      w: w\n                    })\n                  };\n                });\n              }\n            } else {\n              var _e$target;\n\n              // get a color from a hover area (if it's a line pattern then get from a first line)\n              var targetFill = e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.getAttribute('fill');\n\n              if (targetFill) {\n                pColor = targetFill.indexOf('url') !== -1 ? document.querySelector(targetFill.substr(4).slice(0, -1)).childNodes[0].getAttribute('stroke') : targetFill;\n              }\n\n              val = getValBySeriesIndex(i);\n\n              if (hasGoalValues(i) && Array.isArray(w.globals.seriesGoals[i][j])) {\n                goalVals = w.globals.seriesGoals[i][j].map(function (goal) {\n                  return {\n                    attrs: goal,\n                    val: f.yLbFormatter(goal.value, {\n                      seriesIndex: i,\n                      dataPointIndex: j,\n                      w: w\n                    })\n                  };\n                });\n              }\n            }\n          } // for pie / donuts\n\n\n          if (j === null) {\n            val = f.yLbFormatter(w.globals.series[i], _objectSpread2(_objectSpread2({}, w), {}, {\n              seriesIndex: i,\n              dataPointIndex: i\n            }));\n          }\n\n          _this.DOMHandling({\n            i: i,\n            t: tIndex,\n            j: j,\n            ttItems: ttItems,\n            values: {\n              val: val,\n              goalVals: goalVals,\n              xVal: xVal,\n              xAxisTTVal: xAxisTTVal,\n              zVal: zVal\n            },\n            seriesName: seriesName,\n            shared: shared,\n            pColor: pColor\n          });\n        };\n\n        for (var t = 0, inverset = w.globals.series.length - 1; t < w.globals.series.length; t++, inverset--) {\n          _loop(t, inverset);\n        }\n      }\n    }, {\n      key: \"getFormatters\",\n      value: function getFormatters(i) {\n        var w = this.w;\n        var yLbFormatter = w.globals.yLabelFormatters[i];\n        var yLbTitleFormatter;\n\n        if (w.globals.ttVal !== undefined) {\n          if (Array.isArray(w.globals.ttVal)) {\n            yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter;\n            yLbTitleFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].title && w.globals.ttVal[i].title.formatter;\n          } else {\n            yLbFormatter = w.globals.ttVal.formatter;\n\n            if (typeof w.globals.ttVal.title.formatter === 'function') {\n              yLbTitleFormatter = w.globals.ttVal.title.formatter;\n            }\n          }\n        } else {\n          yLbTitleFormatter = w.config.tooltip.y.title.formatter;\n        }\n\n        if (typeof yLbFormatter !== 'function') {\n          if (w.globals.yLabelFormatters[0]) {\n            yLbFormatter = w.globals.yLabelFormatters[0];\n          } else {\n            yLbFormatter = function yLbFormatter(label) {\n              return label;\n            };\n          }\n        }\n\n        if (typeof yLbTitleFormatter !== 'function') {\n          yLbTitleFormatter = function yLbTitleFormatter(label) {\n            return label;\n          };\n        }\n\n        return {\n          yLbFormatter: yLbFormatter,\n          yLbTitleFormatter: yLbTitleFormatter\n        };\n      }\n    }, {\n      key: \"getSeriesName\",\n      value: function getSeriesName(_ref3) {\n        var fn = _ref3.fn,\n            index = _ref3.index,\n            seriesIndex = _ref3.seriesIndex,\n            j = _ref3.j;\n        var w = this.w;\n        return fn(String(w.globals.seriesNames[index]), {\n          series: w.globals.series,\n          seriesIndex: seriesIndex,\n          dataPointIndex: j,\n          w: w\n        });\n      }\n    }, {\n      key: \"DOMHandling\",\n      value: function DOMHandling(_ref4) {\n        _ref4.i;\n            var t = _ref4.t,\n            j = _ref4.j,\n            ttItems = _ref4.ttItems,\n            values = _ref4.values,\n            seriesName = _ref4.seriesName,\n            shared = _ref4.shared,\n            pColor = _ref4.pColor;\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n        var val = values.val,\n            goalVals = values.goalVals,\n            xVal = values.xVal,\n            xAxisTTVal = values.xAxisTTVal,\n            zVal = values.zVal;\n        var ttItemsChildren = null;\n        ttItemsChildren = ttItems[t].children;\n\n        if (w.config.tooltip.fillSeriesColor) {\n          ttItems[t].style.backgroundColor = pColor;\n          ttItemsChildren[0].style.display = 'none';\n        }\n\n        if (ttCtx.showTooltipTitle) {\n          if (ttCtx.tooltipTitle === null) {\n            // get it once if null, and store it in class property\n            ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title');\n          }\n\n          ttCtx.tooltipTitle.innerHTML = xVal;\n        } // if xaxis tooltip is constructed, we need to replace the innerHTML\n\n\n        if (ttCtx.isXAxisTooltipEnabled) {\n          ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal;\n        }\n\n        var ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-y-label');\n\n        if (ttYLabel) {\n          ttYLabel.innerHTML = seriesName ? seriesName : '';\n        }\n\n        var ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-y-value');\n\n        if (ttYVal) {\n          ttYVal.innerHTML = typeof val !== 'undefined' ? val : '';\n        }\n\n        if (ttItemsChildren[0] && ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')) {\n          if (w.config.tooltip.marker.fillColors && Array.isArray(w.config.tooltip.marker.fillColors)) {\n            pColor = w.config.tooltip.marker.fillColors[t];\n          }\n\n          ttItemsChildren[0].style.backgroundColor = pColor;\n        }\n\n        if (!w.config.tooltip.marker.show) {\n          ttItemsChildren[0].style.display = 'none';\n        }\n\n        var ttGLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-goals-label');\n        var ttGVal = ttItems[t].querySelector('.apexcharts-tooltip-text-goals-value');\n\n        if (goalVals.length && w.globals.seriesGoals[t]) {\n          var createGoalsHtml = function createGoalsHtml() {\n            var gLabels = '<div >';\n            var gVals = '<div>';\n            goalVals.forEach(function (goal, gi) {\n              gLabels += \" <div style=\\\"display: flex\\\"><span class=\\\"apexcharts-tooltip-marker\\\" style=\\\"background-color: \".concat(goal.attrs.strokeColor, \"; height: 3px; border-radius: 0; top: 5px;\\\"></span> \").concat(goal.attrs.name, \"</div>\");\n              gVals += \"<div>\".concat(goal.val, \"</div>\");\n            });\n            ttGLabel.innerHTML = gLabels + \"</div>\";\n            ttGVal.innerHTML = gVals + \"</div>\";\n          };\n\n          if (shared) {\n            if (w.globals.seriesGoals[t][j] && Array.isArray(w.globals.seriesGoals[t][j])) {\n              createGoalsHtml();\n            } else {\n              ttGLabel.innerHTML = '';\n              ttGVal.innerHTML = '';\n            }\n          } else {\n            createGoalsHtml();\n          }\n        } else {\n          ttGLabel.innerHTML = '';\n          ttGVal.innerHTML = '';\n        }\n\n        if (zVal !== null) {\n          var ttZLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-z-label');\n          ttZLabel.innerHTML = w.config.tooltip.z.title;\n          var ttZVal = ttItems[t].querySelector('.apexcharts-tooltip-text-z-value');\n          ttZVal.innerHTML = typeof zVal !== 'undefined' ? zVal : '';\n        }\n\n        if (shared && ttItemsChildren[0]) {\n          // hide when no Val or series collapsed\n          if (typeof val === 'undefined' || val === null || w.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || w.globals.collapsedSeriesIndices.indexOf(t) > -1) {\n            ttItemsChildren[0].parentNode.style.display = 'none';\n          } else {\n            ttItemsChildren[0].parentNode.style.display = w.config.tooltip.items.display;\n          }\n        }\n      }\n    }, {\n      key: \"toggleActiveInactiveSeries\",\n      value: function toggleActiveInactiveSeries(shared) {\n        var w = this.w;\n\n        if (shared) {\n          // make all tooltips active\n          this.tooltipUtil.toggleAllTooltipSeriesGroups('enable');\n        } else {\n          // disable all tooltip text groups\n          this.tooltipUtil.toggleAllTooltipSeriesGroups('disable'); // enable the first tooltip text group\n\n          var firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-series-group');\n\n          if (firstTooltipSeriesGroup) {\n            firstTooltipSeriesGroup.classList.add('apexcharts-active');\n            firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display;\n          }\n        }\n      }\n    }, {\n      key: \"getValuesToPrint\",\n      value: function getValuesToPrint(_ref5) {\n        var i = _ref5.i,\n            j = _ref5.j;\n        var w = this.w;\n        var filteredSeriesX = this.ctx.series.filteredSeriesX();\n        var xVal = '';\n        var xAxisTTVal = '';\n        var zVal = null;\n        var val = null;\n        var customFormatterOpts = {\n          series: w.globals.series,\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        };\n        var zFormatter = w.globals.ttZFormatter;\n\n        if (j === null) {\n          val = w.globals.series[i];\n        } else {\n          if (w.globals.isXNumeric && w.config.chart.type !== 'treemap') {\n            xVal = filteredSeriesX[i][j];\n\n            if (filteredSeriesX[i].length === 0) {\n              // a series (possibly the first one) might be collapsed, so get the next active index\n              var firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(filteredSeriesX);\n              xVal = filteredSeriesX[firstActiveSeriesIndex][j];\n            }\n          } else {\n            xVal = typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : '';\n          }\n        }\n\n        var bufferXVal = xVal;\n\n        if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {\n          var xFormat = new Formatters(this.ctx);\n          xVal = xFormat.xLabelFormat(w.globals.ttKeyFormatter, bufferXVal, bufferXVal, {\n            i: undefined,\n            dateFormatter: new DateTime(this.ctx).formatDate,\n            w: this.w\n          });\n        } else {\n          if (w.globals.isBarHorizontal) {\n            xVal = w.globals.yLabelFormatters[0](bufferXVal, customFormatterOpts);\n          } else {\n            xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts);\n          }\n        } // override default x-axis formatter with tooltip formatter\n\n\n        if (w.config.tooltip.x.formatter !== undefined) {\n          xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts);\n        }\n\n        if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[i].length > 0) {\n          zVal = zFormatter(w.globals.seriesZ[i][j], w);\n        }\n\n        if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n          xAxisTTVal = w.globals.xaxisTooltipFormatter(bufferXVal, customFormatterOpts);\n        } else {\n          xAxisTTVal = xVal;\n        }\n\n        return {\n          val: Array.isArray(val) ? val.join(' ') : val,\n          xVal: Array.isArray(xVal) ? xVal.join(' ') : xVal,\n          xAxisTTVal: Array.isArray(xAxisTTVal) ? xAxisTTVal.join(' ') : xAxisTTVal,\n          zVal: zVal\n        };\n      }\n    }, {\n      key: \"handleCustomTooltip\",\n      value: function handleCustomTooltip(_ref6) {\n        var i = _ref6.i,\n            j = _ref6.j,\n            y1 = _ref6.y1,\n            y2 = _ref6.y2,\n            w = _ref6.w;\n        var tooltipEl = this.ttCtx.getElTooltip();\n        var fn = w.config.tooltip.custom;\n\n        if (Array.isArray(fn) && fn[i]) {\n          fn = fn[i];\n        } // override everything with a custom html tooltip and replace it\n\n\n        tooltipEl.innerHTML = fn({\n          ctx: this.ctx,\n          series: w.globals.series,\n          seriesIndex: i,\n          dataPointIndex: j,\n          y1: y1,\n          y2: y2,\n          w: w\n        });\n      }\n    }]);\n\n    return Labels;\n  }();\n\n  /**\n   * ApexCharts Tooltip.Position Class to move the tooltip based on x and y position.\n   *\n   * @module Tooltip.Position\n   **/\n\n  var Position = /*#__PURE__*/function () {\n    function Position(tooltipContext) {\n      _classCallCheck(this, Position);\n\n      this.ttCtx = tooltipContext;\n      this.ctx = tooltipContext.ctx;\n      this.w = tooltipContext.w;\n    }\n    /**\n     * This will move the crosshair (the vertical/horz line that moves along with mouse)\n     * Along with this, this function also calls the xaxisMove function\n     * @memberof Position\n     * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair\n     */\n\n\n    _createClass(Position, [{\n      key: \"moveXCrosshairs\",\n      value: function moveXCrosshairs(cx) {\n        var j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var ttCtx = this.ttCtx;\n        var w = this.w;\n        var xcrosshairs = ttCtx.getElXCrosshairs();\n        var x = cx - ttCtx.xcrosshairsWidth / 2;\n        var tickAmount = w.globals.labels.slice().length;\n\n        if (j !== null) {\n          x = w.globals.gridWidth / tickAmount * j;\n        }\n\n        if (xcrosshairs !== null && !w.globals.isBarHorizontal) {\n          xcrosshairs.setAttribute('x', x);\n          xcrosshairs.setAttribute('x1', x);\n          xcrosshairs.setAttribute('x2', x);\n          xcrosshairs.setAttribute('y2', w.globals.gridHeight);\n          xcrosshairs.classList.add('apexcharts-active');\n        }\n\n        if (x < 0) {\n          x = 0;\n        }\n\n        if (x > w.globals.gridWidth) {\n          x = w.globals.gridWidth;\n        }\n\n        if (ttCtx.isXAxisTooltipEnabled) {\n          var tx = x;\n\n          if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {\n            tx = x + ttCtx.xcrosshairsWidth / 2;\n          }\n\n          this.moveXAxisTooltip(tx);\n        }\n      }\n      /**\n       * This will move the crosshair (the vertical/horz line that moves along with mouse)\n       * Along with this, this function also calls the xaxisMove function\n       * @memberof Position\n       * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair\n       */\n\n    }, {\n      key: \"moveYCrosshairs\",\n      value: function moveYCrosshairs(cy) {\n        var ttCtx = this.ttCtx;\n\n        if (ttCtx.ycrosshairs !== null) {\n          Graphics.setAttrs(ttCtx.ycrosshairs, {\n            y1: cy,\n            y2: cy\n          });\n        }\n\n        if (ttCtx.ycrosshairsHidden !== null) {\n          Graphics.setAttrs(ttCtx.ycrosshairsHidden, {\n            y1: cy,\n            y2: cy\n          });\n        }\n      }\n      /**\n       ** AxisTooltip is the small rectangle which appears on x axis with x value, when user moves\n       * @memberof Position\n       * @param {int} - cx = point's x position, wherever point's x is, you need to move\n       */\n\n    }, {\n      key: \"moveXAxisTooltip\",\n      value: function moveXAxisTooltip(cx) {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n\n        if (ttCtx.xaxisTooltip !== null && ttCtx.xcrosshairsWidth !== 0) {\n          ttCtx.xaxisTooltip.classList.add('apexcharts-active');\n          var cy = ttCtx.xaxisOffY + w.config.xaxis.tooltip.offsetY + w.globals.translateY + 1 + w.config.xaxis.offsetY;\n          var xaxisTTText = ttCtx.xaxisTooltip.getBoundingClientRect();\n          var xaxisTTTextWidth = xaxisTTText.width;\n          cx = cx - xaxisTTTextWidth / 2;\n\n          if (!isNaN(cx)) {\n            cx = cx + w.globals.translateX;\n            var textRect = 0;\n            var graphics = new Graphics(this.ctx);\n            textRect = graphics.getTextRects(ttCtx.xaxisTooltipText.innerHTML);\n            ttCtx.xaxisTooltipText.style.minWidth = textRect.width + 'px';\n            ttCtx.xaxisTooltip.style.left = cx + 'px';\n            ttCtx.xaxisTooltip.style.top = cy + 'px';\n          }\n        }\n      }\n    }, {\n      key: \"moveYAxisTooltip\",\n      value: function moveYAxisTooltip(index) {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n\n        if (ttCtx.yaxisTTEls === null) {\n          ttCtx.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');\n        }\n\n        var ycrosshairsHiddenRectY1 = parseInt(ttCtx.ycrosshairsHidden.getAttribute('y1'), 10);\n        var cy = w.globals.translateY + ycrosshairsHiddenRectY1;\n        var yAxisTTRect = ttCtx.yaxisTTEls[index].getBoundingClientRect();\n        var yAxisTTHeight = yAxisTTRect.height;\n        var cx = w.globals.translateYAxisX[index] - 2;\n\n        if (w.config.yaxis[index].opposite) {\n          cx = cx - 26;\n        }\n\n        cy = cy - yAxisTTHeight / 2;\n\n        if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1) {\n          ttCtx.yaxisTTEls[index].classList.add('apexcharts-active');\n          ttCtx.yaxisTTEls[index].style.top = cy + 'px';\n          ttCtx.yaxisTTEls[index].style.left = cx + w.config.yaxis[index].tooltip.offsetX + 'px';\n        } else {\n          ttCtx.yaxisTTEls[index].classList.remove('apexcharts-active');\n        }\n      }\n      /**\n       ** moves the whole tooltip by changing x, y attrs\n       * @memberof Position\n       * @param {int} - cx = point's x position, wherever point's x is, you need to move tooltip\n       * @param {int} - cy = point's y position, wherever point's y is, you need to move tooltip\n       * @param {int} - r = point's radius\n       */\n\n    }, {\n      key: \"moveTooltip\",\n      value: function moveTooltip(cx, cy) {\n        var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n        var tooltipEl = ttCtx.getElTooltip();\n        var tooltipRect = ttCtx.tooltipRect;\n        var pointR = r !== null ? parseFloat(r) : 1;\n        var x = parseFloat(cx) + pointR + 5;\n        var y = parseFloat(cy) + pointR / 2; // - tooltipRect.ttHeight / 2\n\n        if (x > w.globals.gridWidth / 2) {\n          x = x - tooltipRect.ttWidth - pointR - 10;\n        }\n\n        if (x > w.globals.gridWidth - tooltipRect.ttWidth - 10) {\n          x = w.globals.gridWidth - tooltipRect.ttWidth;\n        }\n\n        if (x < -20) {\n          x = -20;\n        }\n\n        if (w.config.tooltip.followCursor) {\n          var elGrid = ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect();\n          x = ttCtx.e.clientX - seriesBound.left;\n\n          if (x > w.globals.gridWidth / 2) {\n            x = x - ttCtx.tooltipRect.ttWidth;\n          }\n\n          y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top;\n\n          if (y > w.globals.gridHeight / 2) {\n            y = y - ttCtx.tooltipRect.ttHeight;\n          }\n        } else {\n          if (!w.globals.isBarHorizontal) {\n            if (tooltipRect.ttHeight / 2 + y > w.globals.gridHeight) {\n              y = w.globals.gridHeight - tooltipRect.ttHeight + w.globals.translateY;\n            }\n          }\n        }\n\n        if (!isNaN(x)) {\n          x = x + w.globals.translateX;\n          tooltipEl.style.left = x + 'px';\n          tooltipEl.style.top = y + 'px';\n        }\n      }\n    }, {\n      key: \"moveMarkers\",\n      value: function moveMarkers(i, j) {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n\n        if (w.globals.markers.size[i] > 0) {\n          var allPoints = w.globals.dom.baseEl.querySelectorAll(\" .apexcharts-series[data\\\\:realIndex='\".concat(i, \"'] .apexcharts-marker\"));\n\n          for (var p = 0; p < allPoints.length; p++) {\n            if (parseInt(allPoints[p].getAttribute('rel'), 10) === j) {\n              ttCtx.marker.resetPointsSize();\n              ttCtx.marker.enlargeCurrentPoint(j, allPoints[p]);\n            }\n          }\n        } else {\n          ttCtx.marker.resetPointsSize();\n          this.moveDynamicPointOnHover(j, i);\n        }\n      } // This function is used when you need to show markers/points only on hover -\n      // DIFFERENT X VALUES in multiple series\n\n    }, {\n      key: \"moveDynamicPointOnHover\",\n      value: function moveDynamicPointOnHover(j, capturedSeries) {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n        var cx = 0;\n        var cy = 0;\n        var pointsArr = w.globals.pointsArray;\n        var hoverSize = ttCtx.tooltipUtil.getHoverMarkerSize(capturedSeries);\n        var serType = w.config.series[capturedSeries].type;\n\n        if (serType && (serType === 'column' || serType === 'candlestick' || serType === 'boxPlot')) {\n          // fix error mentioned in #811\n          return;\n        }\n\n        cx = pointsArr[capturedSeries][j][0];\n        cy = pointsArr[capturedSeries][j][1] ? pointsArr[capturedSeries][j][1] : 0;\n        var point = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(capturedSeries, \"'] .apexcharts-series-markers circle\"));\n\n        if (point && cy < w.globals.gridHeight && cy > 0) {\n          point.setAttribute('r', hoverSize);\n          point.setAttribute('cx', cx);\n          point.setAttribute('cy', cy);\n        } // point.style.opacity = w.config.markers.hover.opacity\n\n\n        this.moveXCrosshairs(cx);\n\n        if (!ttCtx.fixedTooltip) {\n          this.moveTooltip(cx, cy, hoverSize);\n        }\n      } // This function is used when you need to show markers/points only on hover -\n      // SAME X VALUES in multiple series\n\n    }, {\n      key: \"moveDynamicPointsOnHover\",\n      value: function moveDynamicPointsOnHover(j) {\n        var ttCtx = this.ttCtx;\n        var w = ttCtx.w;\n        var cx = 0;\n        var cy = 0;\n        var activeSeries = 0;\n        var pointsArr = w.globals.pointsArray;\n        var series = new Series(this.ctx);\n        activeSeries = series.getActiveConfigSeriesIndex('asc', ['line', 'area', 'scatter', 'bubble']);\n        var hoverSize = ttCtx.tooltipUtil.getHoverMarkerSize(activeSeries);\n\n        if (pointsArr[activeSeries]) {\n          cx = pointsArr[activeSeries][j][0];\n          cy = pointsArr[activeSeries][j][1];\n        }\n\n        var points = ttCtx.tooltipUtil.getAllMarkers();\n\n        if (points !== null) {\n          for (var p = 0; p < w.globals.series.length; p++) {\n            var pointArr = pointsArr[p];\n\n            if (w.globals.comboCharts) {\n              // in a combo chart, if column charts are present, markers will not match with the number of series, hence this patch to push a null value in points array\n              if (typeof pointArr === 'undefined') {\n                // nodelist to array\n                points.splice(p, 0, null);\n              }\n            }\n\n            if (pointArr && pointArr.length) {\n              var pcy = pointsArr[p][j][1];\n              var pcy2 = void 0;\n              points[p].setAttribute('cx', cx);\n\n              if (w.config.chart.type === 'rangeArea' && !w.globals.comboCharts) {\n                var rangeStartIndex = j + w.globals.series[p].length;\n                pcy2 = pointsArr[p][rangeStartIndex][1];\n                var pcyDiff = Math.abs(pcy - pcy2) / 2;\n                pcy = pcy - pcyDiff;\n              }\n\n              if (pcy !== null && !isNaN(pcy) && pcy < w.globals.gridHeight + hoverSize && pcy + hoverSize > 0) {\n                points[p] && points[p].setAttribute('r', hoverSize);\n                points[p] && points[p].setAttribute('cy', pcy);\n              } else {\n                points[p] && points[p].setAttribute('r', 0);\n              }\n            }\n          }\n        }\n\n        this.moveXCrosshairs(cx);\n\n        if (!ttCtx.fixedTooltip) {\n          this.moveTooltip(cx, cy || w.globals.gridHeight, hoverSize);\n        }\n      }\n    }, {\n      key: \"moveStickyTooltipOverBars\",\n      value: function moveStickyTooltipOverBars(j, capturedSeries) {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n        var barLen = w.globals.columnSeries ? w.globals.columnSeries.length : w.globals.series.length;\n        var i = barLen >= 2 && barLen % 2 === 0 ? Math.floor(barLen / 2) : Math.floor(barLen / 2) + 1;\n\n        if (w.globals.isBarHorizontal) {\n          var series = new Series(this.ctx);\n          i = series.getActiveConfigSeriesIndex('desc') + 1;\n        }\n\n        var jBar = w.globals.dom.baseEl.querySelector(\".apexcharts-bar-series .apexcharts-series[rel='\".concat(i, \"'] path[j='\").concat(j, \"'], .apexcharts-candlestick-series .apexcharts-series[rel='\").concat(i, \"'] path[j='\").concat(j, \"'], .apexcharts-boxPlot-series .apexcharts-series[rel='\").concat(i, \"'] path[j='\").concat(j, \"'], .apexcharts-rangebar-series .apexcharts-series[rel='\").concat(i, \"'] path[j='\").concat(j, \"']\"));\n\n        if (!jBar && typeof capturedSeries === 'number') {\n          // Try with captured series index\n          jBar = w.globals.dom.baseEl.querySelector(\".apexcharts-bar-series .apexcharts-series[data\\\\:realIndex='\".concat(capturedSeries, \"'] path[j='\").concat(j, \"'],\\n        .apexcharts-candlestick-series .apexcharts-series[data\\\\:realIndex='\").concat(capturedSeries, \"'] path[j='\").concat(j, \"'],\\n        .apexcharts-boxPlot-series .apexcharts-series[data\\\\:realIndex='\").concat(capturedSeries, \"'] path[j='\").concat(j, \"'],\\n        .apexcharts-rangebar-series .apexcharts-series[data\\\\:realIndex='\").concat(capturedSeries, \"'] path[j='\").concat(j, \"']\"));\n        }\n\n        var bcx = jBar ? parseFloat(jBar.getAttribute('cx')) : 0;\n        var bcy = jBar ? parseFloat(jBar.getAttribute('cy')) : 0;\n        var bw = jBar ? parseFloat(jBar.getAttribute('barWidth')) : 0;\n        var elGrid = ttCtx.getElGrid();\n        var seriesBound = elGrid.getBoundingClientRect();\n        var isBoxOrCandle = jBar && (jBar.classList.contains('apexcharts-candlestick-area') || jBar.classList.contains('apexcharts-boxPlot-area'));\n\n        if (w.globals.isXNumeric) {\n          if (jBar && !isBoxOrCandle) {\n            bcx = bcx - (barLen % 2 !== 0 ? bw / 2 : 0);\n          }\n\n          if (jBar && // fixes apexcharts.js#2354\n          isBoxOrCandle && w.globals.comboCharts) {\n            bcx = bcx - bw / 2;\n          }\n        } else {\n          if (!w.globals.isBarHorizontal) {\n            bcx = ttCtx.xAxisTicksPositions[j - 1] + ttCtx.dataPointsDividedWidth / 2;\n\n            if (isNaN(bcx)) {\n              bcx = ttCtx.xAxisTicksPositions[j] - ttCtx.dataPointsDividedWidth / 2;\n            }\n          }\n        }\n\n        if (!w.globals.isBarHorizontal) {\n          if (w.config.tooltip.followCursor) {\n            bcy = ttCtx.e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2;\n          } else {\n            if (bcy + ttCtx.tooltipRect.ttHeight + 15 > w.globals.gridHeight) {\n              bcy = w.globals.gridHeight;\n            }\n          }\n        } else {\n          bcy = bcy - ttCtx.tooltipRect.ttHeight;\n        }\n\n        if (!w.globals.isBarHorizontal) {\n          this.moveXCrosshairs(bcx);\n        }\n\n        if (!ttCtx.fixedTooltip) {\n          this.moveTooltip(bcx, bcy || w.globals.gridHeight);\n        }\n      }\n    }]);\n\n    return Position;\n  }();\n\n  /**\n   * ApexCharts Tooltip.Marker Class to draw texts on the tooltip.\n   * This file deals with the markers that appear near tooltip in line/area charts.\n   * These markers helps the user to associate the data-points and the values\n   * that are shown in the tooltip\n   *\n   * @module Tooltip.Marker\n   **/\n\n  var Marker = /*#__PURE__*/function () {\n    function Marker(tooltipContext) {\n      _classCallCheck(this, Marker);\n\n      this.w = tooltipContext.w;\n      this.ttCtx = tooltipContext;\n      this.ctx = tooltipContext.ctx;\n      this.tooltipPosition = new Position(tooltipContext);\n    }\n\n    _createClass(Marker, [{\n      key: \"drawDynamicPoints\",\n      value: function drawDynamicPoints() {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var marker = new Markers(this.ctx);\n        var elsSeries = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');\n        elsSeries = _toConsumableArray(elsSeries);\n\n        if (w.config.chart.stacked) {\n          elsSeries.sort(function (a, b) {\n            return parseFloat(a.getAttribute('data:realIndex')) - parseFloat(b.getAttribute('data:realIndex'));\n          });\n        }\n\n        for (var i = 0; i < elsSeries.length; i++) {\n          var pointsMain = elsSeries[i].querySelector(\".apexcharts-series-markers-wrap\");\n\n          if (pointsMain !== null) {\n            // it can be null as we have tooltips in donut/bar charts\n            var point = void 0;\n            var PointClasses = \"apexcharts-marker w\".concat((Math.random() + 1).toString(36).substring(4));\n\n            if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {\n              PointClasses += ' no-pointer-events';\n            }\n\n            var elPointOptions = marker.getMarkerConfig({\n              cssClass: PointClasses,\n              seriesIndex: Number(pointsMain.getAttribute('data:realIndex')) // fixes apexcharts/apexcharts.js #1427\n\n            });\n            point = graphics.drawMarker(0, 0, elPointOptions);\n            point.node.setAttribute('default-marker-size', 0);\n            var elPointsG = document.createElementNS(w.globals.SVGNS, 'g');\n            elPointsG.classList.add('apexcharts-series-markers');\n            elPointsG.appendChild(point.node);\n            pointsMain.appendChild(elPointsG);\n          }\n        }\n      }\n    }, {\n      key: \"enlargeCurrentPoint\",\n      value: function enlargeCurrentPoint(rel, point) {\n        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var w = this.w;\n\n        if (w.config.chart.type !== 'bubble') {\n          this.newPointSize(rel, point);\n        }\n\n        var cx = point.getAttribute('cx');\n        var cy = point.getAttribute('cy');\n\n        if (x !== null && y !== null) {\n          cx = x;\n          cy = y;\n        }\n\n        this.tooltipPosition.moveXCrosshairs(cx);\n\n        if (!this.fixedTooltip) {\n          if (w.config.chart.type === 'radar') {\n            var elGrid = this.ttCtx.getElGrid();\n            var seriesBound = elGrid.getBoundingClientRect();\n            cx = this.ttCtx.e.clientX - seriesBound.left;\n          }\n\n          this.tooltipPosition.moveTooltip(cx, cy, w.config.markers.hover.size);\n        }\n      }\n    }, {\n      key: \"enlargePoints\",\n      value: function enlargePoints(j) {\n        var w = this.w;\n        var me = this;\n        var ttCtx = this.ttCtx;\n        var col = j;\n        var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');\n        var newSize = w.config.markers.hover.size;\n\n        for (var p = 0; p < points.length; p++) {\n          var rel = points[p].getAttribute('rel');\n          var index = points[p].getAttribute('index');\n\n          if (newSize === undefined) {\n            newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;\n          }\n\n          if (col === parseInt(rel, 10)) {\n            me.newPointSize(col, points[p]);\n            var cx = points[p].getAttribute('cx');\n            var cy = points[p].getAttribute('cy');\n            me.tooltipPosition.moveXCrosshairs(cx);\n\n            if (!ttCtx.fixedTooltip) {\n              me.tooltipPosition.moveTooltip(cx, cy, newSize);\n            }\n          } else {\n            me.oldPointSize(points[p]);\n          }\n        }\n      }\n    }, {\n      key: \"newPointSize\",\n      value: function newPointSize(rel, point) {\n        var w = this.w;\n        var newSize = w.config.markers.hover.size;\n        var elPoint = rel === 0 ? point.parentNode.firstChild : point.parentNode.lastChild;\n\n        if (elPoint.getAttribute('default-marker-size') !== '0') {\n          var index = parseInt(elPoint.getAttribute('index'), 10);\n\n          if (newSize === undefined) {\n            newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;\n          }\n\n          if (newSize < 0) newSize = 0;\n          elPoint.setAttribute('r', newSize);\n        }\n      }\n    }, {\n      key: \"oldPointSize\",\n      value: function oldPointSize(point) {\n        var size = parseFloat(point.getAttribute('default-marker-size'));\n        point.setAttribute('r', size);\n      }\n    }, {\n      key: \"resetPointsSize\",\n      value: function resetPointsSize() {\n        var w = this.w;\n        var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');\n\n        for (var p = 0; p < points.length; p++) {\n          var size = parseFloat(points[p].getAttribute('default-marker-size'));\n\n          if (Utils$1.isNumber(size) && size >= 0) {\n            points[p].setAttribute('r', size);\n          } else {\n            points[p].setAttribute('r', 0);\n          }\n        }\n      }\n    }]);\n\n    return Marker;\n  }();\n\n  /**\n   * ApexCharts Tooltip.Intersect Class.\n   * This file deals with functions related to intersecting tooltips\n   * (tooltips that appear when user hovers directly over a data-point whether)\n   *\n   * @module Tooltip.Intersect\n   **/\n\n  var Intersect = /*#__PURE__*/function () {\n    function Intersect(tooltipContext) {\n      _classCallCheck(this, Intersect);\n\n      this.w = tooltipContext.w;\n      var w = this.w;\n      this.ttCtx = tooltipContext;\n      this.isVerticalGroupedRangeBar = !w.globals.isBarHorizontal && w.config.chart.type === 'rangeBar' && w.config.plotOptions.bar.rangeBarGroupRows;\n    } // a helper function to get an element's attribute value\n\n\n    _createClass(Intersect, [{\n      key: \"getAttr\",\n      value: function getAttr(e, attr) {\n        return parseFloat(e.target.getAttribute(attr));\n      } // handle tooltip for heatmaps and treemaps\n\n    }, {\n      key: \"handleHeatTreeTooltip\",\n      value: function handleHeatTreeTooltip(_ref) {\n        var e = _ref.e,\n            opt = _ref.opt,\n            x = _ref.x,\n            y = _ref.y,\n            type = _ref.type;\n        var ttCtx = this.ttCtx;\n        var w = this.w;\n\n        if (e.target.classList.contains(\"apexcharts-\".concat(type, \"-rect\"))) {\n          var i = this.getAttr(e, 'i');\n          var j = this.getAttr(e, 'j');\n          var cx = this.getAttr(e, 'cx');\n          var cy = this.getAttr(e, 'cy');\n          var width = this.getAttr(e, 'width');\n          var height = this.getAttr(e, 'height');\n          ttCtx.tooltipLabels.drawSeriesTexts({\n            ttItems: opt.ttItems,\n            i: i,\n            j: j,\n            shared: false,\n            e: e\n          });\n          w.globals.capturedSeriesIndex = i;\n          w.globals.capturedDataPointIndex = j;\n          x = cx + ttCtx.tooltipRect.ttWidth / 2 + width;\n          y = cy + ttCtx.tooltipRect.ttHeight / 2 - height / 2;\n          ttCtx.tooltipPosition.moveXCrosshairs(cx + width / 2);\n\n          if (x > w.globals.gridWidth / 2) {\n            x = cx - ttCtx.tooltipRect.ttWidth / 2 + width;\n          }\n\n          if (ttCtx.w.config.tooltip.followCursor) {\n            var seriesBound = w.globals.dom.elWrap.getBoundingClientRect();\n            x = w.globals.clientX - seriesBound.left - (x > w.globals.gridWidth / 2 ? ttCtx.tooltipRect.ttWidth : 0);\n            y = w.globals.clientY - seriesBound.top - (y > w.globals.gridHeight / 2 ? ttCtx.tooltipRect.ttHeight : 0);\n          }\n        }\n\n        return {\n          x: x,\n          y: y\n        };\n      }\n      /**\n       * handle tooltips for line/area/scatter charts where tooltip.intersect is true\n       * when user hovers over the marker directly, this function is executed\n       */\n\n    }, {\n      key: \"handleMarkerTooltip\",\n      value: function handleMarkerTooltip(_ref2) {\n        var e = _ref2.e,\n            opt = _ref2.opt,\n            x = _ref2.x,\n            y = _ref2.y;\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n        var i;\n        var j;\n\n        if (e.target.classList.contains('apexcharts-marker')) {\n          var cx = parseInt(opt.paths.getAttribute('cx'), 10);\n          var cy = parseInt(opt.paths.getAttribute('cy'), 10);\n          var val = parseFloat(opt.paths.getAttribute('val'));\n          j = parseInt(opt.paths.getAttribute('rel'), 10);\n          i = parseInt(opt.paths.parentNode.parentNode.parentNode.getAttribute('rel'), 10) - 1;\n\n          if (ttCtx.intersect) {\n            var el = Utils$1.findAncestor(opt.paths, 'apexcharts-series');\n\n            if (el) {\n              i = parseInt(el.getAttribute('data:realIndex'), 10);\n            }\n          }\n\n          ttCtx.tooltipLabels.drawSeriesTexts({\n            ttItems: opt.ttItems,\n            i: i,\n            j: j,\n            shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared,\n            e: e\n          });\n\n          if (e.type === 'mouseup') {\n            ttCtx.markerClick(e, i, j);\n          }\n\n          w.globals.capturedSeriesIndex = i;\n          w.globals.capturedDataPointIndex = j;\n          x = cx;\n          y = cy + w.globals.translateY - ttCtx.tooltipRect.ttHeight * 1.4;\n\n          if (ttCtx.w.config.tooltip.followCursor) {\n            var elGrid = ttCtx.getElGrid();\n            var seriesBound = elGrid.getBoundingClientRect();\n            y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top;\n          }\n\n          if (val < 0) {\n            y = cy;\n          }\n\n          ttCtx.marker.enlargeCurrentPoint(j, opt.paths, x, y);\n        }\n\n        return {\n          x: x,\n          y: y\n        };\n      }\n      /**\n       * handle tooltips for bar/column charts\n       */\n\n    }, {\n      key: \"handleBarTooltip\",\n      value: function handleBarTooltip(_ref3) {\n        var e = _ref3.e,\n            opt = _ref3.opt;\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n        var tooltipEl = ttCtx.getElTooltip();\n        var bx = 0;\n        var x = 0;\n        var y = 0;\n        var i = 0;\n        var strokeWidth;\n        var barXY = this.getBarTooltipXY({\n          e: e,\n          opt: opt\n        });\n        i = barXY.i;\n        var barHeight = barXY.barHeight;\n        var j = barXY.j;\n        w.globals.capturedSeriesIndex = i;\n        w.globals.capturedDataPointIndex = j;\n\n        if (w.globals.isBarHorizontal && ttCtx.tooltipUtil.hasBars() || !w.config.tooltip.shared) {\n          x = barXY.x;\n          y = barXY.y;\n          strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width;\n          bx = x;\n        } else {\n          if (!w.globals.comboCharts && !w.config.tooltip.shared) {\n            // todo: re-check this condition as it's always 0\n            bx = bx / 2;\n          }\n        } // y is NaN, make it touch the bottom of grid area\n\n\n        if (isNaN(y)) {\n          y = w.globals.svgHeight - ttCtx.tooltipRect.ttHeight;\n        }\n\n        var seriesIndex = parseInt(opt.paths.parentNode.getAttribute('data:realIndex'), 10);\n        var isReversed = w.globals.isMultipleYAxis ? w.config.yaxis[seriesIndex] && w.config.yaxis[seriesIndex].reversed : w.config.yaxis[0].reversed;\n\n        if (x + ttCtx.tooltipRect.ttWidth > w.globals.gridWidth && !isReversed) {\n          x = x - ttCtx.tooltipRect.ttWidth;\n        } else if (x < 0) {\n          x = 0;\n        }\n\n        if (ttCtx.w.config.tooltip.followCursor) {\n          var elGrid = ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect();\n          y = ttCtx.e.clientY - seriesBound.top;\n        } // if tooltip is still null, querySelector\n\n\n        if (ttCtx.tooltip === null) {\n          ttCtx.tooltip = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');\n        }\n\n        if (!w.config.tooltip.shared) {\n          if (w.globals.comboBarCount > 0) {\n            ttCtx.tooltipPosition.moveXCrosshairs(bx + strokeWidth / 2);\n          } else {\n            ttCtx.tooltipPosition.moveXCrosshairs(bx);\n          }\n        } // move tooltip here\n\n\n        if (!ttCtx.fixedTooltip && (!w.config.tooltip.shared || w.globals.isBarHorizontal && ttCtx.tooltipUtil.hasBars())) {\n          if (isReversed) {\n            x = x - ttCtx.tooltipRect.ttWidth;\n\n            if (x < 0) {\n              x = 0;\n            }\n          }\n\n          if (isReversed && !(w.globals.isBarHorizontal && ttCtx.tooltipUtil.hasBars())) {\n            y = y + barHeight - (w.globals.series[i][j] < 0 ? barHeight : 0) * 2;\n          }\n\n          y = y + w.globals.translateY - ttCtx.tooltipRect.ttHeight / 2;\n          tooltipEl.style.left = x + w.globals.translateX + 'px';\n          tooltipEl.style.top = y + 'px';\n        }\n      }\n    }, {\n      key: \"getBarTooltipXY\",\n      value: function getBarTooltipXY(_ref4) {\n        var _this = this;\n\n        var e = _ref4.e,\n            opt = _ref4.opt;\n        var w = this.w;\n        var j = null;\n        var ttCtx = this.ttCtx;\n        var i = 0;\n        var x = 0;\n        var y = 0;\n        var barWidth = 0;\n        var barHeight = 0;\n        var cl = e.target.classList;\n\n        if (cl.contains('apexcharts-bar-area') || cl.contains('apexcharts-candlestick-area') || cl.contains('apexcharts-boxPlot-area') || cl.contains('apexcharts-rangebar-area')) {\n          var bar = e.target;\n          var barRect = bar.getBoundingClientRect();\n          var seriesBound = opt.elGrid.getBoundingClientRect();\n          var bh = barRect.height;\n          barHeight = barRect.height;\n          var bw = barRect.width;\n          var cx = parseInt(bar.getAttribute('cx'), 10);\n          var cy = parseInt(bar.getAttribute('cy'), 10);\n          barWidth = parseFloat(bar.getAttribute('barWidth'));\n          var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n          j = parseInt(bar.getAttribute('j'), 10);\n          i = parseInt(bar.parentNode.getAttribute('rel'), 10) - 1;\n          var y1 = bar.getAttribute('data-range-y1');\n          var y2 = bar.getAttribute('data-range-y2');\n\n          if (w.globals.comboCharts) {\n            i = parseInt(bar.parentNode.getAttribute('data:realIndex'), 10);\n          } // if (w.config.tooltip.shared) {\n          // this check not needed  at the moment\n          //   const yDivisor = w.globals.gridHeight / (w.globals.series.length)\n          //   const hoverY = ttCtx.clientY - ttCtx.seriesBound.top\n          //   j = Math.ceil(hoverY / yDivisor)\n          // }\n\n\n          var handleXForColumns = function handleXForColumns(x) {\n            if (w.globals.isXNumeric) {\n              x = cx - bw / 2;\n            } else {\n              if (_this.isVerticalGroupedRangeBar) {\n                x = cx + bw / 2;\n              } else {\n                x = cx - ttCtx.dataPointsDividedWidth + bw / 2;\n              }\n            }\n\n            return x;\n          };\n\n          var handleYForBars = function handleYForBars() {\n            return cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;\n          };\n\n          ttCtx.tooltipLabels.drawSeriesTexts({\n            ttItems: opt.ttItems,\n            i: i,\n            j: j,\n            y1: y1 ? parseInt(y1, 10) : null,\n            y2: y2 ? parseInt(y2, 10) : null,\n            shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared,\n            e: e\n          });\n\n          if (w.config.tooltip.followCursor) {\n            if (w.globals.isBarHorizontal) {\n              x = clientX - seriesBound.left + 15;\n              y = handleYForBars();\n            } else {\n              x = handleXForColumns(x);\n              y = e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2 - 15;\n            }\n          } else {\n            if (w.globals.isBarHorizontal) {\n              x = cx;\n\n              if (x < ttCtx.xyRatios.baseLineInvertedY) {\n                x = cx - ttCtx.tooltipRect.ttWidth;\n              }\n\n              y = handleYForBars();\n            } else {\n              x = handleXForColumns(x);\n              y = cy; // - ttCtx.tooltipRect.ttHeight / 2 + 10\n            }\n          }\n        }\n\n        return {\n          x: x,\n          y: y,\n          barHeight: barHeight,\n          barWidth: barWidth,\n          i: i,\n          j: j\n        };\n      }\n    }]);\n\n    return Intersect;\n  }();\n\n  /**\n   * ApexCharts Tooltip.AxesTooltip Class.\n   * This file deals with the x-axis and y-axis tooltips.\n   *\n   * @module Tooltip.AxesTooltip\n   **/\n  var AxesTooltip = /*#__PURE__*/function () {\n    function AxesTooltip(tooltipContext) {\n      _classCallCheck(this, AxesTooltip);\n\n      this.w = tooltipContext.w;\n      this.ttCtx = tooltipContext;\n    }\n    /**\n     * This method adds the secondary tooltip which appears below x axis\n     * @memberof Tooltip\n     **/\n\n\n    _createClass(AxesTooltip, [{\n      key: \"drawXaxisTooltip\",\n      value: function drawXaxisTooltip() {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n        var isBottom = w.config.xaxis.position === 'bottom';\n        ttCtx.xaxisOffY = isBottom ? w.globals.gridHeight + 1 : -w.globals.xAxisHeight - w.config.xaxis.axisTicks.height + 3;\n        var tooltipCssClass = isBottom ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top';\n        var renderTo = w.globals.dom.elWrap;\n\n        if (ttCtx.isXAxisTooltipEnabled) {\n          var xaxisTooltip = w.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip');\n\n          if (xaxisTooltip === null) {\n            ttCtx.xaxisTooltip = document.createElement('div');\n            ttCtx.xaxisTooltip.setAttribute('class', tooltipCssClass + ' apexcharts-theme-' + w.config.tooltip.theme);\n            renderTo.appendChild(ttCtx.xaxisTooltip);\n            ttCtx.xaxisTooltipText = document.createElement('div');\n            ttCtx.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text');\n            ttCtx.xaxisTooltipText.style.fontFamily = w.config.xaxis.tooltip.style.fontFamily || w.config.chart.fontFamily;\n            ttCtx.xaxisTooltipText.style.fontSize = w.config.xaxis.tooltip.style.fontSize;\n            ttCtx.xaxisTooltip.appendChild(ttCtx.xaxisTooltipText);\n          }\n        }\n      }\n      /**\n       * This method adds the secondary tooltip which appears below x axis\n       * @memberof Tooltip\n       **/\n\n    }, {\n      key: \"drawYaxisTooltip\",\n      value: function drawYaxisTooltip() {\n        var w = this.w;\n        var ttCtx = this.ttCtx;\n\n        var _loop = function _loop(i) {\n          var isRight = w.config.yaxis[i].opposite || w.config.yaxis[i].crosshairs.opposite;\n          ttCtx.yaxisOffX = isRight ? w.globals.gridWidth + 1 : 1;\n          var tooltipCssClass = isRight ? \"apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i, \" apexcharts-yaxistooltip-right\") : \"apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i, \" apexcharts-yaxistooltip-left\");\n          w.globals.yAxisSameScaleIndices.map(function (samescales, ssi) {\n            samescales.map(function (s, si) {\n              if (si === i) {\n                tooltipCssClass += w.config.yaxis[si].show ? \" \" : \" apexcharts-yaxistooltip-hidden\";\n              }\n            });\n          });\n          var renderTo = w.globals.dom.elWrap;\n          var yaxisTooltip = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i));\n\n          if (yaxisTooltip === null) {\n            ttCtx.yaxisTooltip = document.createElement('div');\n            ttCtx.yaxisTooltip.setAttribute('class', tooltipCssClass + ' apexcharts-theme-' + w.config.tooltip.theme);\n            renderTo.appendChild(ttCtx.yaxisTooltip);\n            if (i === 0) ttCtx.yaxisTooltipText = [];\n            ttCtx.yaxisTooltipText[i] = document.createElement('div');\n            ttCtx.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text');\n            ttCtx.yaxisTooltip.appendChild(ttCtx.yaxisTooltipText[i]);\n          }\n        };\n\n        for (var i = 0; i < w.config.yaxis.length; i++) {\n          _loop(i);\n        }\n      }\n      /**\n       * @memberof Tooltip\n       **/\n\n    }, {\n      key: \"setXCrosshairWidth\",\n      value: function setXCrosshairWidth() {\n        var w = this.w;\n        var ttCtx = this.ttCtx; // set xcrosshairs width\n\n        var xcrosshairs = ttCtx.getElXCrosshairs();\n        ttCtx.xcrosshairsWidth = parseInt(w.config.xaxis.crosshairs.width, 10);\n\n        if (!w.globals.comboCharts) {\n          if (w.config.xaxis.crosshairs.width === 'tickWidth') {\n            var count = w.globals.labels.length;\n            ttCtx.xcrosshairsWidth = w.globals.gridWidth / count;\n          } else if (w.config.xaxis.crosshairs.width === 'barWidth') {\n            var bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');\n\n            if (bar !== null) {\n              var barWidth = parseFloat(bar.getAttribute('barWidth'));\n              ttCtx.xcrosshairsWidth = barWidth;\n            } else {\n              ttCtx.xcrosshairsWidth = 1;\n            }\n          }\n        } else {\n          var _bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');\n\n          if (_bar !== null && w.config.xaxis.crosshairs.width === 'barWidth') {\n            var _barWidth = parseFloat(_bar.getAttribute('barWidth'));\n\n            ttCtx.xcrosshairsWidth = _barWidth;\n          } else {\n            if (w.config.xaxis.crosshairs.width === 'tickWidth') {\n              var _count = w.globals.labels.length;\n              ttCtx.xcrosshairsWidth = w.globals.gridWidth / _count;\n            }\n          }\n        }\n\n        if (w.globals.isBarHorizontal) {\n          ttCtx.xcrosshairsWidth = 0;\n        }\n\n        if (xcrosshairs !== null && ttCtx.xcrosshairsWidth > 0) {\n          xcrosshairs.setAttribute('width', ttCtx.xcrosshairsWidth);\n        }\n      }\n    }, {\n      key: \"handleYCrosshair\",\n      value: function handleYCrosshair() {\n        var w = this.w;\n        var ttCtx = this.ttCtx; // set ycrosshairs height\n\n        ttCtx.ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');\n        ttCtx.ycrosshairsHidden = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden');\n      }\n    }, {\n      key: \"drawYaxisTooltipText\",\n      value: function drawYaxisTooltipText(index, clientY, xyRatios) {\n        var ttCtx = this.ttCtx;\n        var w = this.w;\n        var lbFormatter = w.globals.yLabelFormatters[index];\n\n        if (ttCtx.yaxisTooltips[index]) {\n          var elGrid = ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect();\n          var hoverY = (clientY - seriesBound.top) * xyRatios.yRatio[index];\n          var height = w.globals.maxYArr[index] - w.globals.minYArr[index];\n          var val = w.globals.minYArr[index] + (height - hoverY);\n          ttCtx.tooltipPosition.moveYCrosshairs(clientY - seriesBound.top);\n          ttCtx.yaxisTooltipText[index].innerHTML = lbFormatter(val);\n          ttCtx.tooltipPosition.moveYAxisTooltip(index);\n        }\n      }\n    }]);\n\n    return AxesTooltip;\n  }();\n\n  /**\n   * ApexCharts Core Tooltip Class to handle the tooltip generation.\n   *\n   * @module Tooltip\n   **/\n\n  var Tooltip = /*#__PURE__*/function () {\n    function Tooltip(ctx) {\n      _classCallCheck(this, Tooltip);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      var w = this.w;\n      this.tConfig = w.config.tooltip;\n      this.tooltipUtil = new Utils(this);\n      this.tooltipLabels = new Labels(this);\n      this.tooltipPosition = new Position(this);\n      this.marker = new Marker(this);\n      this.intersect = new Intersect(this);\n      this.axesTooltip = new AxesTooltip(this);\n      this.showOnIntersect = this.tConfig.intersect;\n      this.showTooltipTitle = this.tConfig.x.show;\n      this.fixedTooltip = this.tConfig.fixed.enabled;\n      this.xaxisTooltip = null;\n      this.yaxisTTEls = null;\n      this.isBarShared = !w.globals.isBarHorizontal && this.tConfig.shared;\n      this.lastHoverTime = Date.now();\n    }\n\n    _createClass(Tooltip, [{\n      key: \"getElTooltip\",\n      value: function getElTooltip(ctx) {\n        if (!ctx) ctx = this;\n        if (!ctx.w.globals.dom.baseEl) return null;\n        return ctx.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');\n      }\n    }, {\n      key: \"getElXCrosshairs\",\n      value: function getElXCrosshairs() {\n        return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');\n      }\n    }, {\n      key: \"getElGrid\",\n      value: function getElGrid() {\n        return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid');\n      }\n    }, {\n      key: \"drawTooltip\",\n      value: function drawTooltip(xyRatios) {\n        var w = this.w;\n        this.xyRatios = xyRatios;\n        this.isXAxisTooltipEnabled = w.config.xaxis.tooltip.enabled && w.globals.axisCharts;\n        this.yaxisTooltips = w.config.yaxis.map(function (y, i) {\n          return y.show && y.tooltip.enabled && w.globals.axisCharts ? true : false;\n        });\n        this.allTooltipSeriesGroups = [];\n\n        if (!w.globals.axisCharts) {\n          this.showTooltipTitle = false;\n        }\n\n        var tooltipEl = document.createElement('div');\n        tooltipEl.classList.add('apexcharts-tooltip');\n\n        if (w.config.tooltip.cssClass) {\n          tooltipEl.classList.add(w.config.tooltip.cssClass);\n        }\n\n        tooltipEl.classList.add(\"apexcharts-theme-\".concat(this.tConfig.theme));\n        w.globals.dom.elWrap.appendChild(tooltipEl);\n\n        if (w.globals.axisCharts) {\n          this.axesTooltip.drawXaxisTooltip();\n          this.axesTooltip.drawYaxisTooltip();\n          this.axesTooltip.setXCrosshairWidth();\n          this.axesTooltip.handleYCrosshair();\n          var xAxis = new XAxis(this.ctx);\n          this.xAxisTicksPositions = xAxis.getXAxisTicksPositions();\n        } // we forcefully set intersect true for these conditions\n\n\n        if ((w.globals.comboCharts || this.tConfig.intersect || w.config.chart.type === 'rangeBar') && !this.tConfig.shared) {\n          this.showOnIntersect = true;\n        }\n\n        if (w.config.markers.size === 0 || w.globals.markers.largestSize === 0) {\n          // when user don't want to show points all the time, but only on when hovering on series\n          this.marker.drawDynamicPoints(this);\n        } // no visible series, exit\n\n\n        if (w.globals.collapsedSeries.length === w.globals.series.length) return;\n        this.dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;\n        this.dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;\n\n        if (this.showTooltipTitle) {\n          this.tooltipTitle = document.createElement('div');\n          this.tooltipTitle.classList.add('apexcharts-tooltip-title');\n          this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || w.config.chart.fontFamily;\n          this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize;\n          tooltipEl.appendChild(this.tooltipTitle);\n        }\n\n        var ttItemsCnt = w.globals.series.length; // whether shared or not, default is shared\n\n        if ((w.globals.xyCharts || w.globals.comboCharts) && this.tConfig.shared) {\n          if (!this.showOnIntersect) {\n            ttItemsCnt = w.globals.series.length;\n          } else {\n            ttItemsCnt = 1;\n          }\n        }\n\n        this.legendLabels = w.globals.dom.baseEl.querySelectorAll('.apexcharts-legend-text');\n        this.ttItems = this.createTTElements(ttItemsCnt);\n        this.addSVGEvents();\n      }\n    }, {\n      key: \"createTTElements\",\n      value: function createTTElements(ttItemsCnt) {\n        var _this = this;\n\n        var w = this.w;\n        var ttItems = [];\n        var tooltipEl = this.getElTooltip();\n\n        var _loop = function _loop(i) {\n          var gTxt = document.createElement('div');\n          gTxt.classList.add('apexcharts-tooltip-series-group');\n          gTxt.style.order = w.config.tooltip.inverseOrder ? ttItemsCnt - i : i + 1;\n\n          if (_this.tConfig.shared && _this.tConfig.enabledOnSeries && Array.isArray(_this.tConfig.enabledOnSeries)) {\n            if (_this.tConfig.enabledOnSeries.indexOf(i) < 0) {\n              gTxt.classList.add('apexcharts-tooltip-series-group-hidden');\n            }\n          }\n\n          var point = document.createElement('span');\n          point.classList.add('apexcharts-tooltip-marker');\n          point.style.backgroundColor = w.globals.colors[i];\n          gTxt.appendChild(point);\n          var gYZ = document.createElement('div');\n          gYZ.classList.add('apexcharts-tooltip-text');\n          gYZ.style.fontFamily = _this.tConfig.style.fontFamily || w.config.chart.fontFamily;\n          gYZ.style.fontSize = _this.tConfig.style.fontSize;\n          ['y', 'goals', 'z'].forEach(function (g) {\n            var gValText = document.createElement('div');\n            gValText.classList.add(\"apexcharts-tooltip-\".concat(g, \"-group\"));\n            var txtLabel = document.createElement('span');\n            txtLabel.classList.add(\"apexcharts-tooltip-text-\".concat(g, \"-label\"));\n            gValText.appendChild(txtLabel);\n            var txtValue = document.createElement('span');\n            txtValue.classList.add(\"apexcharts-tooltip-text-\".concat(g, \"-value\"));\n            gValText.appendChild(txtValue);\n            gYZ.appendChild(gValText);\n          });\n          gTxt.appendChild(gYZ);\n          tooltipEl.appendChild(gTxt);\n          ttItems.push(gTxt);\n        };\n\n        for (var i = 0; i < ttItemsCnt; i++) {\n          _loop(i);\n        }\n\n        return ttItems;\n      }\n    }, {\n      key: \"addSVGEvents\",\n      value: function addSVGEvents() {\n        var w = this.w;\n        var type = w.config.chart.type;\n        var tooltipEl = this.getElTooltip();\n        var commonBar = !!(type === 'bar' || type === 'candlestick' || type === 'boxPlot' || type === 'rangeBar');\n        var chartWithmarkers = type === 'area' || type === 'line' || type === 'scatter' || type === 'bubble' || type === 'radar';\n        var hoverArea = w.globals.dom.Paper.node;\n        var elGrid = this.getElGrid();\n\n        if (elGrid) {\n          this.seriesBound = elGrid.getBoundingClientRect();\n        }\n\n        var tooltipY = [];\n        var tooltipX = [];\n        var seriesHoverParams = {\n          hoverArea: hoverArea,\n          elGrid: elGrid,\n          tooltipEl: tooltipEl,\n          tooltipY: tooltipY,\n          tooltipX: tooltipX,\n          ttItems: this.ttItems\n        };\n        var points;\n\n        if (w.globals.axisCharts) {\n          if (chartWithmarkers) {\n            points = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[data\\\\:longestSeries='true'] .apexcharts-marker\");\n          } else if (commonBar) {\n            points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area');\n          } else if (type === 'heatmap' || type === 'treemap') {\n            points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap');\n          }\n\n          if (points && points.length) {\n            for (var p = 0; p < points.length; p++) {\n              tooltipY.push(points[p].getAttribute('cy'));\n              tooltipX.push(points[p].getAttribute('cx'));\n            }\n          }\n        }\n\n        var validSharedChartTypes = w.globals.xyCharts && !this.showOnIntersect || w.globals.comboCharts && !this.showOnIntersect || commonBar && this.tooltipUtil.hasBars() && this.tConfig.shared;\n\n        if (validSharedChartTypes) {\n          this.addPathsEventListeners([hoverArea], seriesHoverParams);\n        } else if (commonBar && !w.globals.comboCharts || chartWithmarkers && this.showOnIntersect) {\n          this.addDatapointEventsListeners(seriesHoverParams);\n        } else if (!w.globals.axisCharts || type === 'heatmap' || type === 'treemap') {\n          var seriesAll = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');\n          this.addPathsEventListeners(seriesAll, seriesHoverParams);\n        }\n\n        if (this.showOnIntersect) {\n          var lineAreaPoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker');\n\n          if (lineAreaPoints.length > 0) {\n            // if we find any lineSeries, addEventListeners for them\n            this.addPathsEventListeners(lineAreaPoints, seriesHoverParams);\n          } // combo charts may have bars, so add event listeners here too\n\n\n          if (this.tooltipUtil.hasBars() && !this.tConfig.shared) {\n            this.addDatapointEventsListeners(seriesHoverParams);\n          }\n        }\n      }\n    }, {\n      key: \"drawFixedTooltipRect\",\n      value: function drawFixedTooltipRect() {\n        var w = this.w;\n        var tooltipEl = this.getElTooltip();\n        var tooltipRect = tooltipEl.getBoundingClientRect();\n        var ttWidth = tooltipRect.width + 10;\n        var ttHeight = tooltipRect.height + 10;\n        var x = this.tConfig.fixed.offsetX;\n        var y = this.tConfig.fixed.offsetY;\n        var fixed = this.tConfig.fixed.position.toLowerCase();\n\n        if (fixed.indexOf('right') > -1) {\n          x = x + w.globals.svgWidth - ttWidth + 10;\n        }\n\n        if (fixed.indexOf('bottom') > -1) {\n          y = y + w.globals.svgHeight - ttHeight - 10;\n        }\n\n        tooltipEl.style.left = x + 'px';\n        tooltipEl.style.top = y + 'px';\n        return {\n          x: x,\n          y: y,\n          ttWidth: ttWidth,\n          ttHeight: ttHeight\n        };\n      }\n    }, {\n      key: \"addDatapointEventsListeners\",\n      value: function addDatapointEventsListeners(seriesHoverParams) {\n        var w = this.w;\n        var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area');\n        this.addPathsEventListeners(points, seriesHoverParams);\n      }\n    }, {\n      key: \"addPathsEventListeners\",\n      value: function addPathsEventListeners(paths, opts) {\n        var self = this;\n\n        var _loop2 = function _loop2(p) {\n          var extendedOpts = {\n            paths: paths[p],\n            tooltipEl: opts.tooltipEl,\n            tooltipY: opts.tooltipY,\n            tooltipX: opts.tooltipX,\n            elGrid: opts.elGrid,\n            hoverArea: opts.hoverArea,\n            ttItems: opts.ttItems\n          };\n          var events = ['mousemove', 'mouseup', 'touchmove', 'mouseout', 'touchend'];\n          events.map(function (ev) {\n            return paths[p].addEventListener(ev, self.onSeriesHover.bind(self, extendedOpts), {\n              capture: false,\n              passive: true\n            });\n          });\n        };\n\n        for (var p = 0; p < paths.length; p++) {\n          _loop2(p);\n        }\n      }\n      /*\n       ** Check to see if the tooltips should be updated based on a mouse / touch event\n       */\n\n    }, {\n      key: \"onSeriesHover\",\n      value: function onSeriesHover(opt, e) {\n        var _this2 = this;\n\n        // If a user is moving their mouse quickly, don't bother updating the tooltip every single frame\n        var targetDelay = 100;\n        var timeSinceLastUpdate = Date.now() - this.lastHoverTime;\n\n        if (timeSinceLastUpdate >= targetDelay) {\n          // The tooltip was last updated over 100ms ago - redraw it even if the user is still moving their\n          // mouse so they get some feedback that their moves are being registered\n          this.seriesHover(opt, e);\n        } else {\n          // The tooltip was last updated less than 100ms ago\n          // Cancel any other delayed draw, so we don't show stale data\n          clearTimeout(this.seriesHoverTimeout); // Schedule the next draw so that it happens about 100ms after the last update\n\n          this.seriesHoverTimeout = setTimeout(function () {\n            _this2.seriesHover(opt, e);\n          }, targetDelay - timeSinceLastUpdate);\n        }\n      }\n      /*\n       ** The actual series hover function\n       */\n\n    }, {\n      key: \"seriesHover\",\n      value: function seriesHover(opt, e) {\n        var _this3 = this;\n\n        this.lastHoverTime = Date.now();\n        var chartGroups = [];\n        var w = this.w; // if user has more than one charts in group, we need to sync\n\n        if (w.config.chart.group) {\n          chartGroups = this.ctx.getGroupedCharts();\n        }\n\n        if (w.globals.axisCharts && (w.globals.minX === -Infinity && w.globals.maxX === Infinity || w.globals.dataPoints === 0)) {\n          return;\n        }\n\n        if (chartGroups.length) {\n          chartGroups.forEach(function (ch) {\n            var tooltipEl = _this3.getElTooltip(ch);\n\n            var newOpts = {\n              paths: opt.paths,\n              tooltipEl: tooltipEl,\n              tooltipY: opt.tooltipY,\n              tooltipX: opt.tooltipX,\n              elGrid: opt.elGrid,\n              hoverArea: opt.hoverArea,\n              ttItems: ch.w.globals.tooltip.ttItems\n            }; // all the charts should have the same minX and maxX (same xaxis) for multiple tooltips to work correctly\n\n            if (ch.w.globals.minX === _this3.w.globals.minX && ch.w.globals.maxX === _this3.w.globals.maxX) {\n              ch.w.globals.tooltip.seriesHoverByContext({\n                chartCtx: ch,\n                ttCtx: ch.w.globals.tooltip,\n                opt: newOpts,\n                e: e\n              });\n            }\n          });\n        } else {\n          this.seriesHoverByContext({\n            chartCtx: this.ctx,\n            ttCtx: this.w.globals.tooltip,\n            opt: opt,\n            e: e\n          });\n        }\n      }\n    }, {\n      key: \"seriesHoverByContext\",\n      value: function seriesHoverByContext(_ref) {\n        var chartCtx = _ref.chartCtx,\n            ttCtx = _ref.ttCtx,\n            opt = _ref.opt,\n            e = _ref.e;\n        var w = chartCtx.w;\n        var tooltipEl = this.getElTooltip();\n        if (!tooltipEl) return; // tooltipRect is calculated on every mousemove, because the text is dynamic\n\n        ttCtx.tooltipRect = {\n          x: 0,\n          y: 0,\n          ttWidth: tooltipEl.getBoundingClientRect().width,\n          ttHeight: tooltipEl.getBoundingClientRect().height\n        };\n        ttCtx.e = e; // highlight the current hovered bars\n\n        if (ttCtx.tooltipUtil.hasBars() && !w.globals.comboCharts && !ttCtx.isBarShared) {\n          if (this.tConfig.onDatasetHover.highlightDataSeries) {\n            var series = new Series(chartCtx);\n            series.toggleSeriesOnHover(e, e.target.parentNode);\n          }\n        }\n\n        if (ttCtx.fixedTooltip) {\n          ttCtx.drawFixedTooltipRect();\n        }\n\n        if (w.globals.axisCharts) {\n          ttCtx.axisChartsTooltips({\n            e: e,\n            opt: opt,\n            tooltipRect: ttCtx.tooltipRect\n          });\n        } else {\n          // non-plot charts i.e pie/donut/circle\n          ttCtx.nonAxisChartsTooltips({\n            e: e,\n            opt: opt,\n            tooltipRect: ttCtx.tooltipRect\n          });\n        }\n      } // tooltip handling for line/area/bar/columns/scatter\n\n    }, {\n      key: \"axisChartsTooltips\",\n      value: function axisChartsTooltips(_ref2) {\n        var e = _ref2.e,\n            opt = _ref2.opt;\n        var w = this.w;\n        var x, y;\n        var seriesBound = opt.elGrid.getBoundingClientRect();\n        var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n        var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;\n        this.clientY = clientY;\n        this.clientX = clientX;\n        w.globals.capturedSeriesIndex = -1;\n        w.globals.capturedDataPointIndex = -1;\n\n        if (clientY < seriesBound.top || clientY > seriesBound.top + seriesBound.height) {\n          this.handleMouseOut(opt);\n          return;\n        }\n\n        if (Array.isArray(this.tConfig.enabledOnSeries) && !w.config.tooltip.shared) {\n          var index = parseInt(opt.paths.getAttribute('index'), 10);\n\n          if (this.tConfig.enabledOnSeries.indexOf(index) < 0) {\n            this.handleMouseOut(opt);\n            return;\n          }\n        }\n\n        var tooltipEl = this.getElTooltip();\n        var xcrosshairs = this.getElXCrosshairs();\n        var isStickyTooltip = w.globals.xyCharts || w.config.chart.type === 'bar' && !w.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || w.globals.comboCharts && this.tooltipUtil.hasBars();\n\n        if (e.type === 'mousemove' || e.type === 'touchmove' || e.type === 'mouseup') {\n          // there is no series to hover over\n          if (w.globals.collapsedSeries.length + w.globals.ancillaryCollapsedSeries.length === w.globals.series.length) {\n            return;\n          }\n\n          if (xcrosshairs !== null) {\n            xcrosshairs.classList.add('apexcharts-active');\n          }\n\n          var hasYAxisTooltip = this.yaxisTooltips.filter(function (b) {\n            return b === true;\n          });\n\n          if (this.ycrosshairs !== null && hasYAxisTooltip.length) {\n            this.ycrosshairs.classList.add('apexcharts-active');\n          }\n\n          if (isStickyTooltip && !this.showOnIntersect) {\n            this.handleStickyTooltip(e, clientX, clientY, opt);\n          } else {\n            if (w.config.chart.type === 'heatmap' || w.config.chart.type === 'treemap') {\n              var markerXY = this.intersect.handleHeatTreeTooltip({\n                e: e,\n                opt: opt,\n                x: x,\n                y: y,\n                type: w.config.chart.type\n              });\n              x = markerXY.x;\n              y = markerXY.y;\n              tooltipEl.style.left = x + 'px';\n              tooltipEl.style.top = y + 'px';\n            } else {\n              if (this.tooltipUtil.hasBars()) {\n                this.intersect.handleBarTooltip({\n                  e: e,\n                  opt: opt\n                });\n              }\n\n              if (this.tooltipUtil.hasMarkers()) {\n                // intersect - line/area/scatter/bubble\n                this.intersect.handleMarkerTooltip({\n                  e: e,\n                  opt: opt,\n                  x: x,\n                  y: y\n                });\n              }\n            }\n          }\n\n          if (this.yaxisTooltips.length) {\n            for (var yt = 0; yt < w.config.yaxis.length; yt++) {\n              this.axesTooltip.drawYaxisTooltipText(yt, clientY, this.xyRatios);\n            }\n          }\n\n          opt.tooltipEl.classList.add('apexcharts-active');\n        } else if (e.type === 'mouseout' || e.type === 'touchend') {\n          this.handleMouseOut(opt);\n        }\n      } // tooltip handling for pie/donuts\n\n    }, {\n      key: \"nonAxisChartsTooltips\",\n      value: function nonAxisChartsTooltips(_ref3) {\n        var e = _ref3.e,\n            opt = _ref3.opt,\n            tooltipRect = _ref3.tooltipRect;\n        var w = this.w;\n        var rel = opt.paths.getAttribute('rel');\n        var tooltipEl = this.getElTooltip();\n        var seriesBound = w.globals.dom.elWrap.getBoundingClientRect();\n\n        if (e.type === 'mousemove' || e.type === 'touchmove') {\n          tooltipEl.classList.add('apexcharts-active');\n          this.tooltipLabels.drawSeriesTexts({\n            ttItems: opt.ttItems,\n            i: parseInt(rel, 10) - 1,\n            shared: false\n          });\n          var x = w.globals.clientX - seriesBound.left - tooltipRect.ttWidth / 2;\n          var y = w.globals.clientY - seriesBound.top - tooltipRect.ttHeight - 10;\n          tooltipEl.style.left = x + 'px';\n          tooltipEl.style.top = y + 'px';\n\n          if (w.config.legend.tooltipHoverFormatter) {\n            var legendFormatter = w.config.legend.tooltipHoverFormatter;\n            var i = rel - 1;\n            var legendName = this.legendLabels[i].getAttribute('data:default-text');\n            var text = legendFormatter(legendName, {\n              seriesIndex: i,\n              dataPointIndex: i,\n              w: w\n            });\n            this.legendLabels[i].innerHTML = text;\n          }\n        } else if (e.type === 'mouseout' || e.type === 'touchend') {\n          tooltipEl.classList.remove('apexcharts-active');\n\n          if (w.config.legend.tooltipHoverFormatter) {\n            this.legendLabels.forEach(function (l) {\n              var defaultText = l.getAttribute('data:default-text');\n              l.innerHTML = decodeURIComponent(defaultText);\n            });\n          }\n        }\n      }\n    }, {\n      key: \"handleStickyTooltip\",\n      value: function handleStickyTooltip(e, clientX, clientY, opt) {\n        var w = this.w;\n        var capj = this.tooltipUtil.getNearestValues({\n          context: this,\n          hoverArea: opt.hoverArea,\n          elGrid: opt.elGrid,\n          clientX: clientX,\n          clientY: clientY\n        });\n        var j = capj.j;\n        var capturedSeries = capj.capturedSeries;\n        if (w.globals.collapsedSeriesIndices.includes(capturedSeries)) capturedSeries = null;\n        var bounds = opt.elGrid.getBoundingClientRect();\n\n        if (capj.hoverX < 0 || capj.hoverX > bounds.width) {\n          this.handleMouseOut(opt);\n          return;\n        }\n\n        if (capturedSeries !== null) {\n          this.handleStickyCapturedSeries(e, capturedSeries, opt, j);\n        } else {\n          // couldn't capture any series. check if shared X is same,\n          // if yes, draw a grouped tooltip\n          if (this.tooltipUtil.isXoverlap(j) || w.globals.isBarHorizontal) {\n            var firstVisibleSeries = w.globals.series.findIndex(function (s, i) {\n              return !w.globals.collapsedSeriesIndices.includes(i);\n            });\n            this.create(e, this, firstVisibleSeries, j, opt.ttItems);\n          }\n        }\n      }\n    }, {\n      key: \"handleStickyCapturedSeries\",\n      value: function handleStickyCapturedSeries(e, capturedSeries, opt, j) {\n        var w = this.w;\n\n        if (!this.tConfig.shared) {\n          var ignoreNull = w.globals.series[capturedSeries][j] === null;\n\n          if (ignoreNull) {\n            this.handleMouseOut(opt);\n            return;\n          }\n        }\n\n        if (typeof w.globals.series[capturedSeries][j] !== 'undefined') {\n          if (this.tConfig.shared && this.tooltipUtil.isXoverlap(j) && this.tooltipUtil.isInitialSeriesSameLen()) {\n            this.create(e, this, capturedSeries, j, opt.ttItems);\n          } else {\n            this.create(e, this, capturedSeries, j, opt.ttItems, false);\n          }\n        } else {\n          if (this.tooltipUtil.isXoverlap(j)) {\n            var firstVisibleSeries = w.globals.series.findIndex(function (s, i) {\n              return !w.globals.collapsedSeriesIndices.includes(i);\n            });\n            this.create(e, this, firstVisibleSeries, j, opt.ttItems);\n          }\n        }\n      }\n    }, {\n      key: \"deactivateHoverFilter\",\n      value: function deactivateHoverFilter() {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var allPaths = w.globals.dom.Paper.select(\".apexcharts-bar-area\");\n\n        for (var b = 0; b < allPaths.length; b++) {\n          graphics.pathMouseLeave(allPaths[b]);\n        }\n      }\n    }, {\n      key: \"handleMouseOut\",\n      value: function handleMouseOut(opt) {\n        var w = this.w;\n        var xcrosshairs = this.getElXCrosshairs();\n        opt.tooltipEl.classList.remove('apexcharts-active');\n        this.deactivateHoverFilter();\n\n        if (w.config.chart.type !== 'bubble') {\n          this.marker.resetPointsSize();\n        }\n\n        if (xcrosshairs !== null) {\n          xcrosshairs.classList.remove('apexcharts-active');\n        }\n\n        if (this.ycrosshairs !== null) {\n          this.ycrosshairs.classList.remove('apexcharts-active');\n        }\n\n        if (this.isXAxisTooltipEnabled) {\n          this.xaxisTooltip.classList.remove('apexcharts-active');\n        }\n\n        if (this.yaxisTooltips.length) {\n          if (this.yaxisTTEls === null) {\n            this.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');\n          }\n\n          for (var i = 0; i < this.yaxisTTEls.length; i++) {\n            this.yaxisTTEls[i].classList.remove('apexcharts-active');\n          }\n        }\n\n        if (w.config.legend.tooltipHoverFormatter) {\n          this.legendLabels.forEach(function (l) {\n            var defaultText = l.getAttribute('data:default-text');\n            l.innerHTML = decodeURIComponent(defaultText);\n          });\n        }\n      }\n    }, {\n      key: \"markerClick\",\n      value: function markerClick(e, seriesIndex, dataPointIndex) {\n        var w = this.w;\n\n        if (typeof w.config.chart.events.markerClick === 'function') {\n          w.config.chart.events.markerClick(e, this.ctx, {\n            seriesIndex: seriesIndex,\n            dataPointIndex: dataPointIndex,\n            w: w\n          });\n        }\n\n        this.ctx.events.fireEvent('markerClick', [e, this.ctx, {\n          seriesIndex: seriesIndex,\n          dataPointIndex: dataPointIndex,\n          w: w\n        }]);\n      }\n    }, {\n      key: \"create\",\n      value: function create(e, context, capturedSeries, j, ttItems) {\n        var _w$globals$seriesRang, _w$globals$seriesRang2, _w$globals$seriesRang3, _w$globals$seriesRang4, _w$globals$seriesRang5, _w$globals$seriesRang6, _w$globals$seriesRang7, _w$globals$seriesRang8, _w$globals$seriesRang9, _w$globals$seriesRang10, _w$globals$seriesRang11, _w$globals$seriesRang12, _w$globals$seriesRang13, _w$globals$seriesRang14, _w$globals$seriesRang15, _w$globals$seriesRang16;\n\n        var shared = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n        var w = this.w;\n        var ttCtx = context;\n\n        if (e.type === 'mouseup') {\n          this.markerClick(e, capturedSeries, j);\n        }\n\n        if (shared === null) shared = this.tConfig.shared;\n        var hasMarkers = this.tooltipUtil.hasMarkers(capturedSeries);\n        var bars = this.tooltipUtil.getElBars();\n\n        if (w.config.legend.tooltipHoverFormatter) {\n          var legendFormatter = w.config.legend.tooltipHoverFormatter;\n          var els = Array.from(this.legendLabels); // reset all legend values first\n\n          els.forEach(function (l) {\n            var legendName = l.getAttribute('data:default-text');\n            l.innerHTML = decodeURIComponent(legendName);\n          }); // for irregular time series\n\n          for (var i = 0; i < els.length; i++) {\n            var l = els[i];\n            var lsIndex = parseInt(l.getAttribute('i'), 10);\n            var legendName = decodeURIComponent(l.getAttribute('data:default-text'));\n            var text = legendFormatter(legendName, {\n              seriesIndex: shared ? lsIndex : capturedSeries,\n              dataPointIndex: j,\n              w: w\n            });\n\n            if (!shared) {\n              l.innerHTML = lsIndex === capturedSeries ? text : legendName;\n\n              if (capturedSeries === lsIndex) {\n                break;\n              }\n            } else {\n              l.innerHTML = w.globals.collapsedSeriesIndices.indexOf(lsIndex) < 0 ? text : legendName;\n            }\n          }\n        }\n\n        var commonSeriesTextsParams = _objectSpread2(_objectSpread2({\n          ttItems: ttItems,\n          i: capturedSeries,\n          j: j\n        }, typeof ((_w$globals$seriesRang = w.globals.seriesRange) === null || _w$globals$seriesRang === void 0 ? void 0 : (_w$globals$seriesRang2 = _w$globals$seriesRang[capturedSeries]) === null || _w$globals$seriesRang2 === void 0 ? void 0 : (_w$globals$seriesRang3 = _w$globals$seriesRang2[j]) === null || _w$globals$seriesRang3 === void 0 ? void 0 : (_w$globals$seriesRang4 = _w$globals$seriesRang3.y[0]) === null || _w$globals$seriesRang4 === void 0 ? void 0 : _w$globals$seriesRang4.y1) !== 'undefined' && {\n          y1: (_w$globals$seriesRang5 = w.globals.seriesRange) === null || _w$globals$seriesRang5 === void 0 ? void 0 : (_w$globals$seriesRang6 = _w$globals$seriesRang5[capturedSeries]) === null || _w$globals$seriesRang6 === void 0 ? void 0 : (_w$globals$seriesRang7 = _w$globals$seriesRang6[j]) === null || _w$globals$seriesRang7 === void 0 ? void 0 : (_w$globals$seriesRang8 = _w$globals$seriesRang7.y[0]) === null || _w$globals$seriesRang8 === void 0 ? void 0 : _w$globals$seriesRang8.y1\n        }), typeof ((_w$globals$seriesRang9 = w.globals.seriesRange) === null || _w$globals$seriesRang9 === void 0 ? void 0 : (_w$globals$seriesRang10 = _w$globals$seriesRang9[capturedSeries]) === null || _w$globals$seriesRang10 === void 0 ? void 0 : (_w$globals$seriesRang11 = _w$globals$seriesRang10[j]) === null || _w$globals$seriesRang11 === void 0 ? void 0 : (_w$globals$seriesRang12 = _w$globals$seriesRang11.y[0]) === null || _w$globals$seriesRang12 === void 0 ? void 0 : _w$globals$seriesRang12.y2) !== 'undefined' && {\n          y2: (_w$globals$seriesRang13 = w.globals.seriesRange) === null || _w$globals$seriesRang13 === void 0 ? void 0 : (_w$globals$seriesRang14 = _w$globals$seriesRang13[capturedSeries]) === null || _w$globals$seriesRang14 === void 0 ? void 0 : (_w$globals$seriesRang15 = _w$globals$seriesRang14[j]) === null || _w$globals$seriesRang15 === void 0 ? void 0 : (_w$globals$seriesRang16 = _w$globals$seriesRang15.y[0]) === null || _w$globals$seriesRang16 === void 0 ? void 0 : _w$globals$seriesRang16.y2\n        });\n\n        if (shared) {\n          ttCtx.tooltipLabels.drawSeriesTexts(_objectSpread2(_objectSpread2({}, commonSeriesTextsParams), {}, {\n            shared: this.showOnIntersect ? false : this.tConfig.shared\n          }));\n\n          if (hasMarkers) {\n            if (w.globals.markers.largestSize > 0) {\n              ttCtx.marker.enlargePoints(j);\n            } else {\n              ttCtx.tooltipPosition.moveDynamicPointsOnHover(j);\n            }\n          } else if (this.tooltipUtil.hasBars()) {\n            this.barSeriesHeight = this.tooltipUtil.getBarsHeight(bars);\n\n            if (this.barSeriesHeight > 0) {\n              // hover state, activate snap filter\n              var graphics = new Graphics(this.ctx);\n              var paths = w.globals.dom.Paper.select(\".apexcharts-bar-area[j='\".concat(j, \"']\")); // de-activate first\n\n              this.deactivateHoverFilter();\n              this.tooltipPosition.moveStickyTooltipOverBars(j, capturedSeries);\n\n              for (var b = 0; b < paths.length; b++) {\n                graphics.pathMouseEnter(paths[b]);\n              }\n            }\n          }\n        } else {\n          ttCtx.tooltipLabels.drawSeriesTexts(_objectSpread2({\n            shared: false\n          }, commonSeriesTextsParams));\n\n          if (this.tooltipUtil.hasBars()) {\n            ttCtx.tooltipPosition.moveStickyTooltipOverBars(j, capturedSeries);\n          }\n\n          if (hasMarkers) {\n            ttCtx.tooltipPosition.moveMarkers(capturedSeries, j);\n          }\n        }\n      }\n    }]);\n\n    return Tooltip;\n  }();\n\n  var BarDataLabels = /*#__PURE__*/function () {\n    function BarDataLabels(barCtx) {\n      _classCallCheck(this, BarDataLabels);\n\n      this.w = barCtx.w;\n      this.barCtx = barCtx;\n      this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter;\n\n      if (!this.totalFormatter) {\n        this.totalFormatter = this.w.config.dataLabels.formatter;\n      }\n    }\n    /** handleBarDataLabels is used to calculate the positions for the data-labels\n     * It also sets the element's data attr for bars and calls drawCalculatedBarDataLabels()\n     * After calculating, it also calls the function to draw data labels\n     * @memberof Bar\n     * @param {object} {barProps} most of the bar properties used throughout the bar\n     * drawing function\n     * @return {object} dataLabels node-element which you can append later\n     **/\n\n\n    _createClass(BarDataLabels, [{\n      key: \"handleBarDataLabels\",\n      value: function handleBarDataLabels(opts) {\n        var x = opts.x,\n            y = opts.y,\n            y1 = opts.y1,\n            y2 = opts.y2,\n            i = opts.i,\n            j = opts.j,\n            realIndex = opts.realIndex,\n            groupIndex = opts.groupIndex,\n            series = opts.series,\n            barHeight = opts.barHeight,\n            barWidth = opts.barWidth,\n            barXPosition = opts.barXPosition,\n            barYPosition = opts.barYPosition,\n            visibleSeries = opts.visibleSeries,\n            renderedPath = opts.renderedPath;\n        var w = this.w;\n        var graphics = new Graphics(this.barCtx.ctx);\n        var strokeWidth = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[realIndex] : this.barCtx.strokeWidth;\n        var bcx = x + parseFloat(barWidth * visibleSeries);\n        var bcy = y + parseFloat(barHeight * visibleSeries);\n\n        if (w.globals.isXNumeric && !w.globals.isBarHorizontal) {\n          bcx = x + parseFloat(barWidth * (visibleSeries + 1));\n          bcy = y + parseFloat(barHeight * (visibleSeries + 1)) - strokeWidth;\n        }\n\n        var dataLabels = null;\n        var totalDataLabels = null;\n        var dataLabelsX = x;\n        var dataLabelsY = y;\n        var dataLabelsPos = {};\n        var dataLabelsConfig = w.config.dataLabels;\n        var barDataLabelsConfig = this.barCtx.barOptions.dataLabels;\n        var barTotalDataLabelsConfig = this.barCtx.barOptions.dataLabels.total;\n\n        if (typeof barYPosition !== 'undefined' && this.barCtx.isRangeBar) {\n          bcy = barYPosition;\n          dataLabelsY = barYPosition;\n        }\n\n        if (typeof barXPosition !== 'undefined' && this.barCtx.isVerticalGroupedRangeBar) {\n          bcx = barXPosition;\n          dataLabelsX = barXPosition;\n        }\n\n        var offX = dataLabelsConfig.offsetX;\n        var offY = dataLabelsConfig.offsetY;\n        var textRects = {\n          width: 0,\n          height: 0\n        };\n\n        if (w.config.dataLabels.enabled) {\n          var yLabel = this.barCtx.series[i][j];\n          textRects = graphics.getTextRects(w.globals.yLabelFormatters[0](yLabel), parseFloat(dataLabelsConfig.style.fontSize));\n        }\n\n        var params = {\n          x: x,\n          y: y,\n          i: i,\n          j: j,\n          realIndex: realIndex,\n          groupIndex: !!groupIndex ? groupIndex : -1,\n          renderedPath: renderedPath,\n          bcx: bcx,\n          bcy: bcy,\n          barHeight: barHeight,\n          barWidth: barWidth,\n          textRects: textRects,\n          strokeWidth: strokeWidth,\n          dataLabelsX: dataLabelsX,\n          dataLabelsY: dataLabelsY,\n          dataLabelsConfig: dataLabelsConfig,\n          barDataLabelsConfig: barDataLabelsConfig,\n          barTotalDataLabelsConfig: barTotalDataLabelsConfig,\n          offX: offX,\n          offY: offY\n        };\n\n        if (this.barCtx.isHorizontal) {\n          dataLabelsPos = this.calculateBarsDataLabelsPosition(params);\n        } else {\n          dataLabelsPos = this.calculateColumnsDataLabelsPosition(params);\n        }\n\n        renderedPath.attr({\n          cy: dataLabelsPos.bcy,\n          cx: dataLabelsPos.bcx,\n          j: j,\n          val: series[i][j],\n          barHeight: barHeight,\n          barWidth: barWidth\n        });\n        dataLabels = this.drawCalculatedDataLabels({\n          x: dataLabelsPos.dataLabelsX,\n          y: dataLabelsPos.dataLabelsY,\n          val: this.barCtx.isRangeBar ? [y1, y2] : series[i][j],\n          i: realIndex,\n          j: j,\n          barWidth: barWidth,\n          barHeight: barHeight,\n          textRects: textRects,\n          dataLabelsConfig: dataLabelsConfig\n        });\n\n        if (w.config.chart.stacked && barTotalDataLabelsConfig.enabled) {\n          totalDataLabels = this.drawTotalDataLabels({\n            x: dataLabelsPos.totalDataLabelsX,\n            y: dataLabelsPos.totalDataLabelsY,\n            realIndex: realIndex,\n            textAnchor: dataLabelsPos.totalDataLabelsAnchor,\n            val: this.getStackedTotalDataLabel({\n              realIndex: realIndex,\n              j: j\n            }),\n            dataLabelsConfig: dataLabelsConfig,\n            barTotalDataLabelsConfig: barTotalDataLabelsConfig\n          });\n        }\n\n        return {\n          dataLabels: dataLabels,\n          totalDataLabels: totalDataLabels\n        };\n      }\n    }, {\n      key: \"getStackedTotalDataLabel\",\n      value: function getStackedTotalDataLabel(_ref) {\n        var realIndex = _ref.realIndex,\n            j = _ref.j;\n        var w = this.w;\n        var val = this.barCtx.stackedSeriesTotals[j];\n\n        if (this.totalFormatter) {\n          val = this.totalFormatter(val, _objectSpread2(_objectSpread2({}, w), {}, {\n            seriesIndex: realIndex,\n            dataPointIndex: j,\n            w: w\n          }));\n        }\n\n        return val;\n      }\n    }, {\n      key: \"calculateColumnsDataLabelsPosition\",\n      value: function calculateColumnsDataLabelsPosition(opts) {\n        var w = this.w;\n        var i = opts.i,\n            j = opts.j,\n            realIndex = opts.realIndex,\n            groupIndex = opts.groupIndex,\n            y = opts.y,\n            bcx = opts.bcx,\n            barWidth = opts.barWidth,\n            barHeight = opts.barHeight,\n            textRects = opts.textRects,\n            dataLabelsX = opts.dataLabelsX,\n            dataLabelsY = opts.dataLabelsY,\n            dataLabelsConfig = opts.dataLabelsConfig,\n            barDataLabelsConfig = opts.barDataLabelsConfig,\n            barTotalDataLabelsConfig = opts.barTotalDataLabelsConfig,\n            strokeWidth = opts.strokeWidth,\n            offX = opts.offX,\n            offY = opts.offY;\n        var totalDataLabelsY;\n        var totalDataLabelsX;\n        var totalDataLabelsAnchor = 'middle';\n        barHeight = Math.abs(barHeight);\n        var vertical = w.config.plotOptions.bar.dataLabels.orientation === 'vertical';\n\n        var _this$barCtx$barHelpe = this.barCtx.barHelpers.getZeroValueEncounters({\n          i: i,\n          j: j\n        }),\n            zeroEncounters = _this$barCtx$barHelpe.zeroEncounters;\n\n        bcx = bcx - strokeWidth / 2 + (groupIndex !== -1 ? groupIndex * barWidth : 0);\n        var dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;\n\n        if (this.barCtx.isVerticalGroupedRangeBar) {\n          dataLabelsX = dataLabelsX + barWidth / 2;\n        } else {\n          if (w.globals.isXNumeric) {\n            dataLabelsX = bcx - barWidth / 2 + offX;\n          } else {\n            dataLabelsX = bcx - dataPointsDividedWidth + barWidth / 2 + offX;\n          }\n\n          if (zeroEncounters > 0 && w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {\n            dataLabelsX = dataLabelsX - barWidth * zeroEncounters;\n          }\n        }\n\n        if (vertical) {\n          var offsetDLX = 2;\n          dataLabelsX = dataLabelsX + textRects.height / 2 - strokeWidth / 2 - offsetDLX;\n        }\n\n        var valIsNegative = this.barCtx.series[i][j] < 0;\n        var newY = y;\n\n        if (this.barCtx.isReversed) {\n          newY = y - barHeight + (valIsNegative ? barHeight * 2 : 0);\n          y = y - barHeight;\n        }\n\n        switch (barDataLabelsConfig.position) {\n          case 'center':\n            if (vertical) {\n              if (valIsNegative) {\n                dataLabelsY = newY - barHeight / 2 + offY;\n              } else {\n                dataLabelsY = newY + barHeight / 2 - offY;\n              }\n            } else {\n              if (valIsNegative) {\n                dataLabelsY = newY - barHeight / 2 + textRects.height / 2 + offY;\n              } else {\n                dataLabelsY = newY + barHeight / 2 + textRects.height / 2 - offY;\n              }\n            }\n\n            break;\n\n          case 'bottom':\n            if (vertical) {\n              if (valIsNegative) {\n                dataLabelsY = newY - barHeight + offY;\n              } else {\n                dataLabelsY = newY + barHeight - offY;\n              }\n            } else {\n              if (valIsNegative) {\n                dataLabelsY = newY - barHeight + textRects.height + strokeWidth + offY;\n              } else {\n                dataLabelsY = newY + barHeight - textRects.height / 2 + strokeWidth - offY;\n              }\n            }\n\n            break;\n\n          case 'top':\n            if (vertical) {\n              if (valIsNegative) {\n                dataLabelsY = newY + offY;\n              } else {\n                dataLabelsY = newY - offY;\n              }\n            } else {\n              if (valIsNegative) {\n                dataLabelsY = newY - textRects.height / 2 - offY;\n              } else {\n                dataLabelsY = newY + textRects.height + offY;\n              }\n            }\n\n            break;\n        }\n\n        if (this.barCtx.lastActiveBarSerieIndex === realIndex && barTotalDataLabelsConfig.enabled) {\n          var ADDITIONAL_OFFX = 18;\n          var graphics = new Graphics(this.barCtx.ctx);\n          var totalLabeltextRects = graphics.getTextRects(this.getStackedTotalDataLabel({\n            realIndex: realIndex,\n            j: j\n          }), dataLabelsConfig.fontSize);\n\n          if (valIsNegative) {\n            totalDataLabelsY = newY - totalLabeltextRects.height / 2 - offY - barTotalDataLabelsConfig.offsetY + ADDITIONAL_OFFX;\n          } else {\n            totalDataLabelsY = newY + totalLabeltextRects.height + offY + barTotalDataLabelsConfig.offsetY - ADDITIONAL_OFFX;\n          }\n\n          totalDataLabelsX = dataLabelsX + barTotalDataLabelsConfig.offsetX;\n        }\n\n        if (!w.config.chart.stacked) {\n          if (dataLabelsY < 0) {\n            dataLabelsY = 0 + strokeWidth;\n          } else if (dataLabelsY + textRects.height / 3 > w.globals.gridHeight) {\n            dataLabelsY = w.globals.gridHeight - strokeWidth;\n          }\n        }\n\n        return {\n          bcx: bcx,\n          bcy: y,\n          dataLabelsX: dataLabelsX,\n          dataLabelsY: dataLabelsY,\n          totalDataLabelsX: totalDataLabelsX,\n          totalDataLabelsY: totalDataLabelsY,\n          totalDataLabelsAnchor: totalDataLabelsAnchor\n        };\n      }\n    }, {\n      key: \"calculateBarsDataLabelsPosition\",\n      value: function calculateBarsDataLabelsPosition(opts) {\n        var w = this.w;\n        var x = opts.x,\n            i = opts.i,\n            j = opts.j,\n            realIndex = opts.realIndex,\n            groupIndex = opts.groupIndex,\n            bcy = opts.bcy,\n            barHeight = opts.barHeight,\n            barWidth = opts.barWidth,\n            textRects = opts.textRects,\n            dataLabelsX = opts.dataLabelsX,\n            strokeWidth = opts.strokeWidth,\n            dataLabelsConfig = opts.dataLabelsConfig,\n            barDataLabelsConfig = opts.barDataLabelsConfig,\n            barTotalDataLabelsConfig = opts.barTotalDataLabelsConfig,\n            offX = opts.offX,\n            offY = opts.offY;\n        var dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;\n        barWidth = Math.abs(barWidth);\n        bcy = bcy + (groupIndex !== -1 ? groupIndex * barHeight : 0);\n        var dataLabelsY = bcy - (this.barCtx.isRangeBar ? 0 : dataPointsDividedHeight) + barHeight / 2 + textRects.height / 2 + offY - 3;\n        var totalDataLabelsX;\n        var totalDataLabelsY;\n        var totalDataLabelsAnchor = 'start';\n        var valIsNegative = this.barCtx.series[i][j] < 0;\n        var newX = x;\n\n        if (this.barCtx.isReversed) {\n          newX = x + barWidth - (valIsNegative ? barWidth * 2 : 0);\n          x = w.globals.gridWidth - barWidth;\n        }\n\n        switch (barDataLabelsConfig.position) {\n          case 'center':\n            if (valIsNegative) {\n              dataLabelsX = newX + barWidth / 2 - offX;\n            } else {\n              dataLabelsX = Math.max(textRects.width / 2, newX - barWidth / 2) + offX;\n            }\n\n            break;\n\n          case 'bottom':\n            if (valIsNegative) {\n              dataLabelsX = newX + barWidth - strokeWidth - Math.round(textRects.width / 2) - offX;\n            } else {\n              dataLabelsX = newX - barWidth + strokeWidth + Math.round(textRects.width / 2) + offX;\n            }\n\n            break;\n\n          case 'top':\n            if (valIsNegative) {\n              dataLabelsX = newX - strokeWidth + Math.round(textRects.width / 2) - offX;\n            } else {\n              dataLabelsX = newX - strokeWidth - Math.round(textRects.width / 2) + offX;\n            }\n\n            break;\n        }\n\n        if (this.barCtx.lastActiveBarSerieIndex === realIndex && barTotalDataLabelsConfig.enabled) {\n          var ADDITIONAL_OFFX = 15;\n          var graphics = new Graphics(this.barCtx.ctx);\n          var totalLabeltextRects = graphics.getTextRects(this.getStackedTotalDataLabel({\n            realIndex: realIndex,\n            j: j\n          }), dataLabelsConfig.fontSize);\n\n          if (valIsNegative) {\n            totalDataLabelsX = newX - strokeWidth + Math.round(totalLabeltextRects.width / 2) - offX - barTotalDataLabelsConfig.offsetX - ADDITIONAL_OFFX;\n            totalDataLabelsAnchor = 'end';\n          } else {\n            totalDataLabelsX = newX - strokeWidth - Math.round(totalLabeltextRects.width / 2) + offX + barTotalDataLabelsConfig.offsetX + ADDITIONAL_OFFX;\n          }\n\n          totalDataLabelsY = dataLabelsY + barTotalDataLabelsConfig.offsetY;\n        }\n\n        if (!w.config.chart.stacked) {\n          if (dataLabelsX < 0) {\n            dataLabelsX = dataLabelsX + textRects.width + strokeWidth;\n          } else if (dataLabelsX + textRects.width / 2 > w.globals.gridWidth) {\n            dataLabelsX = w.globals.gridWidth - textRects.width - strokeWidth;\n          }\n        }\n\n        return {\n          bcx: x,\n          bcy: bcy,\n          dataLabelsX: dataLabelsX,\n          dataLabelsY: dataLabelsY,\n          totalDataLabelsX: totalDataLabelsX,\n          totalDataLabelsY: totalDataLabelsY,\n          totalDataLabelsAnchor: totalDataLabelsAnchor\n        };\n      }\n    }, {\n      key: \"drawCalculatedDataLabels\",\n      value: function drawCalculatedDataLabels(_ref2) {\n        var x = _ref2.x,\n            y = _ref2.y,\n            val = _ref2.val,\n            i = _ref2.i,\n            j = _ref2.j,\n            textRects = _ref2.textRects,\n            barHeight = _ref2.barHeight,\n            barWidth = _ref2.barWidth,\n            dataLabelsConfig = _ref2.dataLabelsConfig;\n        var w = this.w;\n        var rotate = 'rotate(0)';\n        if (w.config.plotOptions.bar.dataLabels.orientation === 'vertical') rotate = \"rotate(-90, \".concat(x, \", \").concat(y, \")\");\n        var dataLabels = new DataLabels(this.barCtx.ctx);\n        var graphics = new Graphics(this.barCtx.ctx);\n        var formatter = dataLabelsConfig.formatter;\n        var elDataLabelsWrap = null;\n        var isSeriesNotCollapsed = w.globals.collapsedSeriesIndices.indexOf(i) > -1;\n\n        if (dataLabelsConfig.enabled && !isSeriesNotCollapsed) {\n          elDataLabelsWrap = graphics.group({\n            class: 'apexcharts-data-labels',\n            transform: rotate\n          });\n          var text = '';\n\n          if (typeof val !== 'undefined') {\n            text = formatter(val, _objectSpread2(_objectSpread2({}, w), {}, {\n              seriesIndex: i,\n              dataPointIndex: j,\n              w: w\n            }));\n          }\n\n          if (!val && w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {\n            text = '';\n          }\n\n          var valIsNegative = w.globals.series[i][j] < 0;\n          var position = w.config.plotOptions.bar.dataLabels.position;\n\n          if (w.config.plotOptions.bar.dataLabels.orientation === 'vertical') {\n            if (position === 'top') {\n              if (valIsNegative) dataLabelsConfig.textAnchor = 'end';else dataLabelsConfig.textAnchor = 'start';\n            }\n\n            if (position === 'center') {\n              dataLabelsConfig.textAnchor = 'middle';\n            }\n\n            if (position === 'bottom') {\n              if (valIsNegative) dataLabelsConfig.textAnchor = 'end';else dataLabelsConfig.textAnchor = 'start';\n            }\n          }\n\n          if (this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) {\n            // hide the datalabel if it cannot fit into the rect\n            var txRect = graphics.getTextRects(text, parseFloat(dataLabelsConfig.style.fontSize));\n\n            if (barWidth < txRect.width) {\n              text = '';\n            }\n          }\n\n          if (w.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) {\n            // if there is not enough space to draw the label in the bar/column rect, check hideOverflowingLabels property to prevent overflowing on wrong rect\n            // Note: This issue is only seen in stacked charts\n            if (this.barCtx.isHorizontal) {\n              if (textRects.width / 1.6 > Math.abs(barWidth)) {\n                text = '';\n              }\n            } else {\n              if (textRects.height / 1.6 > Math.abs(barHeight)) {\n                text = '';\n              }\n            }\n          }\n\n          var modifiedDataLabelsConfig = _objectSpread2({}, dataLabelsConfig);\n\n          if (this.barCtx.isHorizontal) {\n            if (val < 0) {\n              if (dataLabelsConfig.textAnchor === 'start') {\n                modifiedDataLabelsConfig.textAnchor = 'end';\n              } else if (dataLabelsConfig.textAnchor === 'end') {\n                modifiedDataLabelsConfig.textAnchor = 'start';\n              }\n            }\n          }\n\n          dataLabels.plotDataLabelsText({\n            x: x,\n            y: y,\n            text: text,\n            i: i,\n            j: j,\n            parent: elDataLabelsWrap,\n            dataLabelsConfig: modifiedDataLabelsConfig,\n            alwaysDrawDataLabel: true,\n            offsetCorrection: true\n          });\n        }\n\n        return elDataLabelsWrap;\n      }\n    }, {\n      key: \"drawTotalDataLabels\",\n      value: function drawTotalDataLabels(_ref3) {\n        var x = _ref3.x,\n            y = _ref3.y,\n            val = _ref3.val,\n            realIndex = _ref3.realIndex,\n            textAnchor = _ref3.textAnchor,\n            barTotalDataLabelsConfig = _ref3.barTotalDataLabelsConfig;\n        var graphics = new Graphics(this.barCtx.ctx);\n        var totalDataLabelText;\n\n        if (barTotalDataLabelsConfig.enabled && typeof x !== 'undefined' && typeof y !== 'undefined' && this.barCtx.lastActiveBarSerieIndex === realIndex) {\n          totalDataLabelText = graphics.drawText({\n            x: x,\n            y: y,\n            foreColor: barTotalDataLabelsConfig.style.color,\n            text: val,\n            textAnchor: textAnchor,\n            fontFamily: barTotalDataLabelsConfig.style.fontFamily,\n            fontSize: barTotalDataLabelsConfig.style.fontSize,\n            fontWeight: barTotalDataLabelsConfig.style.fontWeight\n          });\n        }\n\n        return totalDataLabelText;\n      }\n    }]);\n\n    return BarDataLabels;\n  }();\n\n  var Helpers$1 = /*#__PURE__*/function () {\n    function Helpers(barCtx) {\n      _classCallCheck(this, Helpers);\n\n      this.w = barCtx.w;\n      this.barCtx = barCtx;\n    }\n\n    _createClass(Helpers, [{\n      key: \"initVariables\",\n      value: function initVariables(series) {\n        var w = this.w;\n        this.barCtx.series = series;\n        this.barCtx.totalItems = 0;\n        this.barCtx.seriesLen = 0;\n        this.barCtx.visibleI = -1; // visible Series\n\n        this.barCtx.visibleItems = 1; // number of visible bars after user zoomed in/out\n\n        for (var sl = 0; sl < series.length; sl++) {\n          if (series[sl].length > 0) {\n            this.barCtx.seriesLen = this.barCtx.seriesLen + 1;\n            this.barCtx.totalItems += series[sl].length;\n          }\n\n          if (w.globals.isXNumeric) {\n            // get max visible items\n            for (var j = 0; j < series[sl].length; j++) {\n              if (w.globals.seriesX[sl][j] > w.globals.minX && w.globals.seriesX[sl][j] < w.globals.maxX) {\n                this.barCtx.visibleItems++;\n              }\n            }\n          } else {\n            this.barCtx.visibleItems = w.globals.dataPoints;\n          }\n        }\n\n        if (this.barCtx.seriesLen === 0) {\n          // A small adjustment when combo charts are used\n          this.barCtx.seriesLen = 1;\n        }\n\n        this.barCtx.zeroSerieses = [];\n\n        if (!w.globals.comboCharts) {\n          this.checkZeroSeries({\n            series: series\n          });\n        }\n      }\n    }, {\n      key: \"initialPositions\",\n      value: function initialPositions() {\n        var w = this.w;\n        var x, y, yDivision, xDivision, barHeight, barWidth, zeroH, zeroW;\n        var dataPoints = w.globals.dataPoints;\n\n        if (this.barCtx.isRangeBar) {\n          // timeline rangebar chart\n          dataPoints = w.globals.labels.length;\n        }\n\n        var seriesLen = this.barCtx.seriesLen;\n\n        if (w.config.plotOptions.bar.rangeBarGroupRows) {\n          seriesLen = 1;\n        }\n\n        if (this.barCtx.isHorizontal) {\n          // height divided into equal parts\n          yDivision = w.globals.gridHeight / dataPoints;\n          barHeight = yDivision / seriesLen;\n\n          if (w.globals.isXNumeric) {\n            yDivision = w.globals.gridHeight / this.barCtx.totalItems;\n            barHeight = yDivision / this.barCtx.seriesLen;\n          }\n\n          barHeight = barHeight * parseInt(this.barCtx.barOptions.barHeight, 10) / 100;\n\n          if (String(this.barCtx.barOptions.barHeight).indexOf('%') === -1) {\n            barHeight = parseInt(this.barCtx.barOptions.barHeight, 10);\n          }\n\n          zeroW = this.barCtx.baseLineInvertedY + w.globals.padHorizontal + (this.barCtx.isReversed ? w.globals.gridWidth : 0) - (this.barCtx.isReversed ? this.barCtx.baseLineInvertedY * 2 : 0);\n\n          if (this.barCtx.isFunnel) {\n            zeroW = w.globals.gridWidth / 2;\n          }\n\n          y = (yDivision - barHeight * this.barCtx.seriesLen) / 2;\n        } else {\n          // width divided into equal parts\n          xDivision = w.globals.gridWidth / this.barCtx.visibleItems;\n\n          if (w.config.xaxis.convertedCatToNumeric) {\n            xDivision = w.globals.gridWidth / w.globals.dataPoints;\n          }\n\n          barWidth = xDivision / seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100;\n\n          if (w.globals.isXNumeric) {\n            // max barwidth should be equal to minXDiff to avoid overlap\n            var xRatio = this.barCtx.xRatio;\n\n            if (w.config.xaxis.convertedCatToNumeric) {\n              xRatio = this.barCtx.initialXRatio;\n            }\n\n            if (w.globals.minXDiff && w.globals.minXDiff !== 0.5 && w.globals.minXDiff / xRatio > 0) {\n              xDivision = w.globals.minXDiff / xRatio;\n            }\n\n            barWidth = xDivision / seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100;\n\n            if (barWidth < 1) {\n              barWidth = 1;\n            }\n          }\n\n          if (String(this.barCtx.barOptions.columnWidth).indexOf('%') === -1) {\n            barWidth = parseInt(this.barCtx.barOptions.columnWidth, 10);\n          }\n\n          zeroH = w.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? w.globals.gridHeight : 0) + (this.barCtx.isReversed ? this.barCtx.baseLineY[this.barCtx.yaxisIndex] * 2 : 0);\n          x = w.globals.padHorizontal + (xDivision - barWidth * this.barCtx.seriesLen) / 2;\n        }\n\n        return {\n          x: x,\n          y: y,\n          yDivision: yDivision,\n          xDivision: xDivision,\n          barHeight: barHeight,\n          barWidth: barWidth,\n          zeroH: zeroH,\n          zeroW: zeroW\n        };\n      }\n    }, {\n      key: \"initializeStackedPrevVars\",\n      value: function initializeStackedPrevVars(ctx) {\n        var w = ctx.w;\n\n        if (w.globals.hasSeriesGroups) {\n          w.globals.seriesGroups.forEach(function (group) {\n            if (!ctx[group]) ctx[group] = {};\n            ctx[group].prevY = [];\n            ctx[group].prevX = [];\n            ctx[group].prevYF = [];\n            ctx[group].prevXF = [];\n            ctx[group].prevYVal = [];\n            ctx[group].prevXVal = [];\n          });\n        } else {\n          ctx.prevY = []; // y position on chart (in columns)\n\n          ctx.prevX = []; // x position on chart (in horz bars)\n\n          ctx.prevYF = []; // starting y and ending y (height) in columns\n\n          ctx.prevXF = []; // starting x and ending x (width) in bars\n\n          ctx.prevYVal = []; // y values (series[i][j]) in columns\n\n          ctx.prevXVal = []; // x values (series[i][j]) in bars\n        }\n      }\n    }, {\n      key: \"initializeStackedXYVars\",\n      value: function initializeStackedXYVars(ctx) {\n        var w = ctx.w;\n\n        if (w.globals.hasSeriesGroups) {\n          w.globals.seriesGroups.forEach(function (group) {\n            if (!ctx[group]) ctx[group] = {};\n            ctx[group].xArrj = [];\n            ctx[group].xArrjF = [];\n            ctx[group].xArrjVal = [];\n            ctx[group].yArrj = [];\n            ctx[group].yArrjF = [];\n            ctx[group].yArrjVal = [];\n          });\n        } else {\n          ctx.xArrj = []; // xj indicates x position on graph in bars\n\n          ctx.xArrjF = []; // xjF indicates bar's x position + x2 positions in bars\n\n          ctx.xArrjVal = []; // x val means the actual series's y values in horizontal/bars\n\n          ctx.yArrj = []; // yj indicates y position on graph in columns\n\n          ctx.yArrjF = []; // yjF indicates bar's y position + y2 positions in columns\n\n          ctx.yArrjVal = []; // y val means the actual series's y values in columns\n        }\n      }\n    }, {\n      key: \"getPathFillColor\",\n      value: function getPathFillColor(series, i, j, realIndex) {\n        var _w$config$series$i$da, _w$config$series$i$da2, _w$config$series$i$da3, _w$config$series$i$da4;\n\n        var w = this.w;\n        var fill = new Fill(this.barCtx.ctx);\n        var fillColor = null;\n        var seriesNumber = this.barCtx.barOptions.distributed ? j : i;\n\n        if (this.barCtx.barOptions.colors.ranges.length > 0) {\n          var colorRange = this.barCtx.barOptions.colors.ranges;\n          colorRange.map(function (range) {\n            if (series[i][j] >= range.from && series[i][j] <= range.to) {\n              fillColor = range.color;\n            }\n          });\n        }\n\n        if (w.config.series[i].data[j] && w.config.series[i].data[j].fillColor) {\n          fillColor = w.config.series[i].data[j].fillColor;\n        }\n\n        var pathFill = fill.fillPath({\n          seriesNumber: this.barCtx.barOptions.distributed ? seriesNumber : realIndex,\n          dataPointIndex: j,\n          color: fillColor,\n          value: series[i][j],\n          fillConfig: (_w$config$series$i$da = w.config.series[i].data[j]) === null || _w$config$series$i$da === void 0 ? void 0 : _w$config$series$i$da.fill,\n          fillType: (_w$config$series$i$da2 = w.config.series[i].data[j]) !== null && _w$config$series$i$da2 !== void 0 && (_w$config$series$i$da3 = _w$config$series$i$da2.fill) !== null && _w$config$series$i$da3 !== void 0 && _w$config$series$i$da3.type ? (_w$config$series$i$da4 = w.config.series[i].data[j]) === null || _w$config$series$i$da4 === void 0 ? void 0 : _w$config$series$i$da4.fill.type : w.config.fill.type\n        });\n        return pathFill;\n      }\n    }, {\n      key: \"getStrokeWidth\",\n      value: function getStrokeWidth(i, j, realIndex) {\n        var strokeWidth = 0;\n        var w = this.w;\n\n        if (!this.barCtx.series[i][j]) {\n          this.barCtx.isNullValue = true;\n        } else {\n          this.barCtx.isNullValue = false;\n        }\n\n        if (w.config.stroke.show) {\n          if (!this.barCtx.isNullValue) {\n            strokeWidth = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[realIndex] : this.barCtx.strokeWidth;\n          }\n        }\n\n        return strokeWidth;\n      }\n    }, {\n      key: \"shouldApplyRadius\",\n      value: function shouldApplyRadius(realIndex) {\n        var w = this.w;\n        var applyRadius = false;\n\n        if (w.config.plotOptions.bar.borderRadius > 0) {\n          if (w.config.chart.stacked) {\n            if (w.config.plotOptions.bar.borderRadiusWhenStacked === 'last') {\n              if (this.barCtx.lastActiveBarSerieIndex === realIndex) {\n                applyRadius = true;\n              }\n            } else {\n              applyRadius = true;\n            }\n          } else {\n            applyRadius = true;\n          }\n        }\n\n        return applyRadius;\n      }\n    }, {\n      key: \"barBackground\",\n      value: function barBackground(_ref) {\n        var j = _ref.j,\n            i = _ref.i,\n            x1 = _ref.x1,\n            x2 = _ref.x2,\n            y1 = _ref.y1,\n            y2 = _ref.y2,\n            elSeries = _ref.elSeries;\n        var w = this.w;\n        var graphics = new Graphics(this.barCtx.ctx);\n        var sr = new Series(this.barCtx.ctx);\n        var activeSeriesIndex = sr.getActiveConfigSeriesIndex();\n\n        if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && activeSeriesIndex === i) {\n          if (j >= this.barCtx.barOptions.colors.backgroundBarColors.length) {\n            j %= this.barCtx.barOptions.colors.backgroundBarColors.length;\n          }\n\n          var bcolor = this.barCtx.barOptions.colors.backgroundBarColors[j];\n          var rect = graphics.drawRect(typeof x1 !== 'undefined' ? x1 : 0, typeof y1 !== 'undefined' ? y1 : 0, typeof x2 !== 'undefined' ? x2 : w.globals.gridWidth, typeof y2 !== 'undefined' ? y2 : w.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, bcolor, this.barCtx.barOptions.colors.backgroundBarOpacity);\n          elSeries.add(rect);\n          rect.node.classList.add('apexcharts-backgroundBar');\n        }\n      }\n    }, {\n      key: \"getColumnPaths\",\n      value: function getColumnPaths(_ref2) {\n        var _w$config$series$real;\n\n        var barWidth = _ref2.barWidth,\n            barXPosition = _ref2.barXPosition,\n            y1 = _ref2.y1,\n            y2 = _ref2.y2,\n            strokeWidth = _ref2.strokeWidth,\n            seriesGroup = _ref2.seriesGroup,\n            realIndex = _ref2.realIndex,\n            i = _ref2.i,\n            j = _ref2.j,\n            w = _ref2.w;\n        var graphics = new Graphics(this.barCtx.ctx);\n        strokeWidth = Array.isArray(strokeWidth) ? strokeWidth[realIndex] : strokeWidth;\n        if (!strokeWidth) strokeWidth = 0;\n        var bW = barWidth;\n        var bXP = barXPosition;\n\n        if ((_w$config$series$real = w.config.series[realIndex].data[j]) !== null && _w$config$series$real !== void 0 && _w$config$series$real.columnWidthOffset) {\n          bXP = barXPosition - w.config.series[realIndex].data[j].columnWidthOffset / 2;\n          bW = barWidth + w.config.series[realIndex].data[j].columnWidthOffset;\n        }\n\n        var x1 = bXP;\n        var x2 = bXP + bW; // append tiny pixels to avoid exponentials (which cause issues in border-radius)\n\n        y1 += 0.001;\n        y2 += 0.001;\n        var pathTo = graphics.move(x1, y1);\n        var pathFrom = graphics.move(x1, y1);\n        var sl = graphics.line(x2 - strokeWidth, y1);\n\n        if (w.globals.previousPaths.length > 0) {\n          pathFrom = this.barCtx.getPreviousPath(realIndex, j, false);\n        }\n\n        pathTo = pathTo + graphics.line(x1, y2) + graphics.line(x2 - strokeWidth, y2) + graphics.line(x2 - strokeWidth, y1) + (w.config.plotOptions.bar.borderRadiusApplication === 'around' ? ' Z' : ' z'); // the lines in pathFrom are repeated to equal it to the points of pathTo\n        // this is to avoid weird animation (bug in svg.js)\n\n        pathFrom = pathFrom + graphics.line(x1, y1) + sl + sl + sl + sl + sl + graphics.line(x1, y1) + (w.config.plotOptions.bar.borderRadiusApplication === 'around' ? ' Z' : ' z');\n\n        if (this.shouldApplyRadius(realIndex)) {\n          pathTo = graphics.roundPathCorners(pathTo, w.config.plotOptions.bar.borderRadius);\n        }\n\n        if (w.config.chart.stacked) {\n          var _ctx = this.barCtx;\n\n          if (w.globals.hasSeriesGroups && seriesGroup) {\n            _ctx = this.barCtx[seriesGroup];\n          }\n\n          _ctx.yArrj.push(y2);\n\n          _ctx.yArrjF.push(Math.abs(y1 - y2));\n\n          _ctx.yArrjVal.push(this.barCtx.series[i][j]);\n        }\n\n        return {\n          pathTo: pathTo,\n          pathFrom: pathFrom\n        };\n      }\n    }, {\n      key: \"getBarpaths\",\n      value: function getBarpaths(_ref3) {\n        var _w$config$series$real2;\n\n        var barYPosition = _ref3.barYPosition,\n            barHeight = _ref3.barHeight,\n            x1 = _ref3.x1,\n            x2 = _ref3.x2,\n            strokeWidth = _ref3.strokeWidth,\n            seriesGroup = _ref3.seriesGroup,\n            realIndex = _ref3.realIndex,\n            i = _ref3.i,\n            j = _ref3.j,\n            w = _ref3.w;\n        var graphics = new Graphics(this.barCtx.ctx);\n        strokeWidth = Array.isArray(strokeWidth) ? strokeWidth[realIndex] : strokeWidth;\n        if (!strokeWidth) strokeWidth = 0;\n        var bYP = barYPosition;\n        var bH = barHeight;\n\n        if ((_w$config$series$real2 = w.config.series[realIndex].data[j]) !== null && _w$config$series$real2 !== void 0 && _w$config$series$real2.barHeightOffset) {\n          bYP = barYPosition - w.config.series[realIndex].data[j].barHeightOffset / 2;\n          bH = barHeight + w.config.series[realIndex].data[j].barHeightOffset;\n        }\n\n        var y1 = bYP;\n        var y2 = bYP + bH; // append tiny pixels to avoid exponentials (which cause issues in border-radius)\n\n        x1 += 0.001;\n        x2 += 0.001;\n        var pathTo = graphics.move(x1, y1);\n        var pathFrom = graphics.move(x1, y1);\n\n        if (w.globals.previousPaths.length > 0) {\n          pathFrom = this.barCtx.getPreviousPath(realIndex, j, false);\n        }\n\n        var sl = graphics.line(x1, y2 - strokeWidth);\n        pathTo = pathTo + graphics.line(x2, y1) + graphics.line(x2, y2 - strokeWidth) + sl + (w.config.plotOptions.bar.borderRadiusApplication === 'around' ? ' Z' : ' z');\n        pathFrom = pathFrom + graphics.line(x1, y1) + sl + sl + sl + sl + sl + graphics.line(x1, y1) + (w.config.plotOptions.bar.borderRadiusApplication === 'around' ? ' Z' : ' z');\n\n        if (this.shouldApplyRadius(realIndex)) {\n          pathTo = graphics.roundPathCorners(pathTo, w.config.plotOptions.bar.borderRadius);\n        }\n\n        if (w.config.chart.stacked) {\n          var _ctx = this.barCtx;\n\n          if (w.globals.hasSeriesGroups && seriesGroup) {\n            _ctx = this.barCtx[seriesGroup];\n          }\n\n          _ctx.xArrj.push(x2);\n\n          _ctx.xArrjF.push(Math.abs(x1 - x2));\n\n          _ctx.xArrjVal.push(this.barCtx.series[i][j]);\n        }\n\n        return {\n          pathTo: pathTo,\n          pathFrom: pathFrom\n        };\n      }\n    }, {\n      key: \"checkZeroSeries\",\n      value: function checkZeroSeries(_ref4) {\n        var series = _ref4.series;\n        var w = this.w;\n\n        for (var zs = 0; zs < series.length; zs++) {\n          var total = 0;\n\n          for (var zsj = 0; zsj < series[w.globals.maxValsInArrayIndex].length; zsj++) {\n            total += series[zs][zsj];\n          }\n\n          if (total === 0) {\n            this.barCtx.zeroSerieses.push(zs);\n          }\n        }\n      }\n    }, {\n      key: \"getXForValue\",\n      value: function getXForValue(value, zeroW) {\n        var zeroPositionForNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var xForVal = zeroPositionForNull ? zeroW : null;\n\n        if (typeof value !== 'undefined' && value !== null) {\n          xForVal = zeroW + value / this.barCtx.invertedYRatio - (this.barCtx.isReversed ? value / this.barCtx.invertedYRatio : 0) * 2;\n        }\n\n        return xForVal;\n      }\n    }, {\n      key: \"getYForValue\",\n      value: function getYForValue(value, zeroH) {\n        var zeroPositionForNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var yForVal = zeroPositionForNull ? zeroH : null;\n\n        if (typeof value !== 'undefined' && value !== null) {\n          yForVal = zeroH - value / this.barCtx.yRatio[this.barCtx.yaxisIndex] + (this.barCtx.isReversed ? value / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0) * 2;\n        }\n\n        return yForVal;\n      }\n    }, {\n      key: \"getGoalValues\",\n      value: function getGoalValues(type, zeroW, zeroH, i, j) {\n        var _this = this;\n\n        var w = this.w;\n        var goals = [];\n\n        var pushGoal = function pushGoal(value, attrs) {\n          var _goals$push;\n\n          goals.push((_goals$push = {}, _defineProperty(_goals$push, type, type === 'x' ? _this.getXForValue(value, zeroW, false) : _this.getYForValue(value, zeroH, false)), _defineProperty(_goals$push, \"attrs\", attrs), _goals$push));\n        };\n\n        if (w.globals.seriesGoals[i] && w.globals.seriesGoals[i][j] && Array.isArray(w.globals.seriesGoals[i][j])) {\n          w.globals.seriesGoals[i][j].forEach(function (goal) {\n            pushGoal(goal.value, goal);\n          });\n        }\n\n        if (this.barCtx.barOptions.isDumbbell && w.globals.seriesRange.length) {\n          var colors = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : w.globals.colors;\n          var commonAttrs = {\n            strokeHeight: type === 'x' ? 0 : w.globals.markers.size[i],\n            strokeWidth: type === 'x' ? w.globals.markers.size[i] : 0,\n            strokeDashArray: 0,\n            strokeLineCap: 'round',\n            strokeColor: Array.isArray(colors[i]) ? colors[i][0] : colors[i]\n          };\n          pushGoal(w.globals.seriesRangeStart[i][j], commonAttrs);\n          pushGoal(w.globals.seriesRangeEnd[i][j], _objectSpread2(_objectSpread2({}, commonAttrs), {}, {\n            strokeColor: Array.isArray(colors[i]) ? colors[i][1] : colors[i]\n          }));\n        }\n\n        return goals;\n      }\n    }, {\n      key: \"drawGoalLine\",\n      value: function drawGoalLine(_ref5) {\n        var barXPosition = _ref5.barXPosition,\n            barYPosition = _ref5.barYPosition,\n            goalX = _ref5.goalX,\n            goalY = _ref5.goalY,\n            barWidth = _ref5.barWidth,\n            barHeight = _ref5.barHeight;\n        var graphics = new Graphics(this.barCtx.ctx);\n        var lineGroup = graphics.group({\n          className: 'apexcharts-bar-goals-groups'\n        });\n        lineGroup.node.classList.add('apexcharts-element-hidden');\n        this.barCtx.w.globals.delayedElements.push({\n          el: lineGroup.node\n        });\n        lineGroup.attr('clip-path', \"url(#gridRectMarkerMask\".concat(this.barCtx.w.globals.cuid, \")\"));\n        var line = null;\n\n        if (this.barCtx.isHorizontal) {\n          if (Array.isArray(goalX)) {\n            goalX.forEach(function (goal) {\n              var sHeight = typeof goal.attrs.strokeHeight !== 'undefined' ? goal.attrs.strokeHeight : barHeight / 2;\n              var y = barYPosition + sHeight + barHeight / 2;\n              line = graphics.drawLine(goal.x, y - sHeight * 2, goal.x, y, goal.attrs.strokeColor ? goal.attrs.strokeColor : undefined, goal.attrs.strokeDashArray, goal.attrs.strokeWidth ? goal.attrs.strokeWidth : 2, goal.attrs.strokeLineCap);\n              lineGroup.add(line);\n            });\n          }\n        } else {\n          if (Array.isArray(goalY)) {\n            goalY.forEach(function (goal) {\n              var sWidth = typeof goal.attrs.strokeWidth !== 'undefined' ? goal.attrs.strokeWidth : barWidth / 2;\n              var x = barXPosition + sWidth + barWidth / 2;\n              line = graphics.drawLine(x - sWidth * 2, goal.y, x, goal.y, goal.attrs.strokeColor ? goal.attrs.strokeColor : undefined, goal.attrs.strokeDashArray, goal.attrs.strokeHeight ? goal.attrs.strokeHeight : 2, goal.attrs.strokeLineCap);\n              lineGroup.add(line);\n            });\n          }\n        }\n\n        return lineGroup;\n      }\n    }, {\n      key: \"drawBarShadow\",\n      value: function drawBarShadow(_ref6) {\n        var prevPaths = _ref6.prevPaths,\n            currPaths = _ref6.currPaths,\n            color = _ref6.color;\n        var w = this.w;\n        var prevX2 = prevPaths.x,\n            prevX1 = prevPaths.x1,\n            prevY1 = prevPaths.barYPosition;\n        var currX2 = currPaths.x,\n            currX1 = currPaths.x1,\n            currY1 = currPaths.barYPosition;\n        var prevY2 = prevY1 + currPaths.barHeight;\n        var graphics = new Graphics(this.barCtx.ctx);\n        var utils = new Utils$1();\n        var shadowPath = graphics.move(prevX1, prevY2) + graphics.line(prevX2, prevY2) + graphics.line(currX2, currY1) + graphics.line(currX1, currY1) + graphics.line(prevX1, prevY2) + (w.config.plotOptions.bar.borderRadiusApplication === 'around' ? ' Z' : ' z');\n        return graphics.drawPath({\n          d: shadowPath,\n          fill: utils.shadeColor(0.5, Utils$1.rgb2hex(color)),\n          stroke: 'none',\n          strokeWidth: 0,\n          fillOpacity: 1,\n          classes: 'apexcharts-bar-shadows'\n        });\n      }\n    }, {\n      key: \"getZeroValueEncounters\",\n      value: function getZeroValueEncounters(_ref7) {\n        var i = _ref7.i,\n            j = _ref7.j;\n        var w = this.w;\n        var nonZeroColumns = 0;\n        var zeroEncounters = 0;\n        w.globals.seriesPercent.forEach(function (_s, _si) {\n          if (_s[j]) {\n            nonZeroColumns++;\n          }\n\n          if (_si < i && _s[j] === 0) {\n            zeroEncounters++;\n          }\n        });\n        return {\n          nonZeroColumns: nonZeroColumns,\n          zeroEncounters: zeroEncounters\n        };\n      }\n    }]);\n\n    return Helpers;\n  }();\n\n  /**\n   * ApexCharts Bar Class responsible for drawing both Columns and Bars.\n   *\n   * @module Bar\n   **/\n\n  var Bar = /*#__PURE__*/function () {\n    function Bar(ctx, xyRatios) {\n      _classCallCheck(this, Bar);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      var w = this.w;\n      this.barOptions = w.config.plotOptions.bar;\n      this.isHorizontal = this.barOptions.horizontal;\n      this.strokeWidth = w.config.stroke.width;\n      this.isNullValue = false;\n      this.isRangeBar = w.globals.seriesRange.length && this.isHorizontal;\n      this.isVerticalGroupedRangeBar = !w.globals.isBarHorizontal && w.globals.seriesRange.length && w.config.plotOptions.bar.rangeBarGroupRows;\n      this.isFunnel = this.barOptions.isFunnel;\n      this.xyRatios = xyRatios;\n\n      if (this.xyRatios !== null) {\n        this.xRatio = xyRatios.xRatio;\n        this.initialXRatio = xyRatios.initialXRatio;\n        this.yRatio = xyRatios.yRatio;\n        this.invertedXRatio = xyRatios.invertedXRatio;\n        this.invertedYRatio = xyRatios.invertedYRatio;\n        this.baseLineY = xyRatios.baseLineY;\n        this.baseLineInvertedY = xyRatios.baseLineInvertedY;\n      }\n\n      this.yaxisIndex = 0;\n      this.seriesLen = 0;\n      this.pathArr = [];\n      var ser = new Series(this.ctx);\n      this.lastActiveBarSerieIndex = ser.getActiveConfigSeriesIndex('desc', ['bar', 'column']);\n      var barSeriesIndices = ser.getBarSeriesIndices();\n      var coreUtils = new CoreUtils(this.ctx);\n      this.stackedSeriesTotals = coreUtils.getStackedSeriesTotals(this.w.config.series.map(function (s, i) {\n        return barSeriesIndices.indexOf(i) === -1 ? i : -1;\n      }).filter(function (s) {\n        return s !== -1;\n      }));\n      this.barHelpers = new Helpers$1(this);\n    }\n    /** primary draw method which is called on bar object\n     * @memberof Bar\n     * @param {array} series - user supplied series values\n     * @param {int} seriesIndex - the index by which series will be drawn on the svg\n     * @return {node} element which is supplied to parent chart draw method for appending\n     **/\n\n\n    _createClass(Bar, [{\n      key: \"draw\",\n      value: function draw(series, seriesIndex) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var coreUtils = new CoreUtils(this.ctx, w);\n        series = coreUtils.getLogSeries(series);\n        this.series = series;\n        this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n        this.barHelpers.initVariables(series);\n        var ret = graphics.group({\n          class: 'apexcharts-bar-series apexcharts-plot-series'\n        });\n\n        if (w.config.dataLabels.enabled) {\n          if (this.totalItems > this.barOptions.dataLabels.maxItems) {\n            console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts');\n          }\n        }\n\n        for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n          var x = void 0,\n              y = void 0,\n              xDivision = void 0,\n              // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n          yDivision = void 0,\n              // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n          zeroH = void 0,\n              // zeroH is the baseline where 0 meets y axis\n          zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n          var yArrj = []; // hold y values of current iterating series\n\n          var xArrj = []; // hold x values of current iterating series\n\n          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n          var elSeries = graphics.group({\n            class: \"apexcharts-series\",\n            rel: i + 1,\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),\n            'data:realIndex': realIndex\n          });\n          this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);\n\n          if (series[i].length > 0) {\n            this.visibleI = this.visibleI + 1;\n          }\n\n          var barHeight = 0;\n          var barWidth = 0;\n\n          if (this.yRatio.length > 1) {\n            this.yaxisIndex = realIndex;\n          }\n\n          this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;\n          var initPositions = this.barHelpers.initialPositions();\n          y = initPositions.y;\n          barHeight = initPositions.barHeight;\n          yDivision = initPositions.yDivision;\n          zeroW = initPositions.zeroW;\n          x = initPositions.x;\n          barWidth = initPositions.barWidth;\n          xDivision = initPositions.xDivision;\n          zeroH = initPositions.zeroH;\n\n          if (!this.horizontal) {\n            xArrj.push(x + barWidth / 2);\n          } // eldatalabels\n\n\n          var elDataLabelsWrap = graphics.group({\n            class: 'apexcharts-datalabels',\n            'data:realIndex': realIndex\n          });\n          w.globals.delayedElements.push({\n            el: elDataLabelsWrap.node\n          });\n          elDataLabelsWrap.node.classList.add('apexcharts-element-hidden');\n          var elGoalsMarkers = graphics.group({\n            class: 'apexcharts-bar-goals-markers'\n          });\n          var elBarShadows = graphics.group({\n            class: 'apexcharts-bar-shadows'\n          });\n          w.globals.delayedElements.push({\n            el: elBarShadows.node\n          });\n          elBarShadows.node.classList.add('apexcharts-element-hidden');\n\n          for (var j = 0; j < w.globals.dataPoints; j++) {\n            var strokeWidth = this.barHelpers.getStrokeWidth(i, j, realIndex);\n            var paths = null;\n            var pathsParams = {\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              x: x,\n              y: y,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            };\n\n            if (this.isHorizontal) {\n              paths = this.drawBarPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {\n                barHeight: barHeight,\n                zeroW: zeroW,\n                yDivision: yDivision\n              }));\n              barWidth = this.series[i][j] / this.invertedYRatio;\n            } else {\n              paths = this.drawColumnPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {\n                xDivision: xDivision,\n                barWidth: barWidth,\n                zeroH: zeroH\n              }));\n              barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];\n            }\n\n            var pathFill = this.barHelpers.getPathFillColor(series, i, j, realIndex);\n\n            if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && j > 0) {\n              var barShadow = this.barHelpers.drawBarShadow({\n                color: typeof pathFill === 'string' && (pathFill === null || pathFill === void 0 ? void 0 : pathFill.indexOf('url')) === -1 ? pathFill : Utils$1.hexToRgba(w.globals.colors[i]),\n                prevPaths: this.pathArr[this.pathArr.length - 1],\n                currPaths: paths\n              });\n\n              if (barShadow) {\n                elBarShadows.add(barShadow);\n              }\n            }\n\n            this.pathArr.push(paths);\n            var barGoalLine = this.barHelpers.drawGoalLine({\n              barXPosition: paths.barXPosition,\n              barYPosition: paths.barYPosition,\n              goalX: paths.goalX,\n              goalY: paths.goalY,\n              barHeight: barHeight,\n              barWidth: barWidth\n            });\n\n            if (barGoalLine) {\n              elGoalsMarkers.add(barGoalLine);\n            }\n\n            y = paths.y;\n            x = paths.x; // push current X\n\n            if (j > 0) {\n              xArrj.push(x + barWidth / 2);\n            }\n\n            yArrj.push(y);\n            this.renderSeries({\n              realIndex: realIndex,\n              pathFill: pathFill,\n              j: j,\n              i: i,\n              pathFrom: paths.pathFrom,\n              pathTo: paths.pathTo,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries,\n              x: x,\n              y: y,\n              series: series,\n              barHeight: paths.barHeight ? paths.barHeight : barHeight,\n              barWidth: paths.barWidth ? paths.barWidth : barWidth,\n              elDataLabelsWrap: elDataLabelsWrap,\n              elGoalsMarkers: elGoalsMarkers,\n              elBarShadows: elBarShadows,\n              visibleSeries: this.visibleI,\n              type: 'bar'\n            });\n          } // push all x val arrays into main xArr\n\n\n          w.globals.seriesXvalues[realIndex] = xArrj;\n          w.globals.seriesYvalues[realIndex] = yArrj;\n          ret.add(elSeries);\n        }\n\n        return ret;\n      }\n    }, {\n      key: \"renderSeries\",\n      value: function renderSeries(_ref) {\n        var realIndex = _ref.realIndex,\n            pathFill = _ref.pathFill,\n            lineFill = _ref.lineFill,\n            j = _ref.j,\n            i = _ref.i,\n            groupIndex = _ref.groupIndex,\n            pathFrom = _ref.pathFrom,\n            pathTo = _ref.pathTo,\n            strokeWidth = _ref.strokeWidth,\n            elSeries = _ref.elSeries,\n            x = _ref.x,\n            y = _ref.y,\n            y1 = _ref.y1,\n            y2 = _ref.y2,\n            series = _ref.series,\n            barHeight = _ref.barHeight,\n            barWidth = _ref.barWidth,\n            barXPosition = _ref.barXPosition,\n            barYPosition = _ref.barYPosition,\n            elDataLabelsWrap = _ref.elDataLabelsWrap,\n            elGoalsMarkers = _ref.elGoalsMarkers,\n            elBarShadows = _ref.elBarShadows,\n            visibleSeries = _ref.visibleSeries,\n            type = _ref.type;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n\n        if (!lineFill) {\n          /* fix apexcharts#341 */\n          lineFill = this.barOptions.distributed ? w.globals.stroke.colors[j] : w.globals.stroke.colors[realIndex];\n        }\n\n        if (w.config.series[i].data[j] && w.config.series[i].data[j].strokeColor) {\n          lineFill = w.config.series[i].data[j].strokeColor;\n        }\n\n        if (this.isNullValue) {\n          pathFill = 'none';\n        }\n\n        var delay = j / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4;\n        var renderedPath = graphics.renderPaths({\n          i: i,\n          j: j,\n          realIndex: realIndex,\n          pathFrom: pathFrom,\n          pathTo: pathTo,\n          stroke: lineFill,\n          strokeWidth: strokeWidth,\n          strokeLineCap: w.config.stroke.lineCap,\n          fill: pathFill,\n          animationDelay: delay,\n          initialSpeed: w.config.chart.animations.speed,\n          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n          className: \"apexcharts-\".concat(type, \"-area\")\n        });\n        renderedPath.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n        var forecast = w.config.forecastDataPoints;\n\n        if (forecast.count > 0) {\n          if (j >= w.globals.dataPoints - forecast.count) {\n            renderedPath.node.setAttribute('stroke-dasharray', forecast.dashArray);\n            renderedPath.node.setAttribute('stroke-width', forecast.strokeWidth);\n            renderedPath.node.setAttribute('fill-opacity', forecast.fillOpacity);\n          }\n        }\n\n        if (typeof y1 !== 'undefined' && typeof y2 !== 'undefined') {\n          renderedPath.attr('data-range-y1', y1);\n          renderedPath.attr('data-range-y2', y2);\n        }\n\n        var filters = new Filters(this.ctx);\n        filters.setSelectionFilter(renderedPath, realIndex, j);\n        elSeries.add(renderedPath);\n        var barDataLabels = new BarDataLabels(this);\n        var dataLabelsObj = barDataLabels.handleBarDataLabels({\n          x: x,\n          y: y,\n          y1: y1,\n          y2: y2,\n          i: i,\n          j: j,\n          series: series,\n          realIndex: realIndex,\n          groupIndex: groupIndex,\n          barHeight: barHeight,\n          barWidth: barWidth,\n          barXPosition: barXPosition,\n          barYPosition: barYPosition,\n          renderedPath: renderedPath,\n          visibleSeries: visibleSeries\n        });\n\n        if (dataLabelsObj.dataLabels !== null) {\n          elDataLabelsWrap.add(dataLabelsObj.dataLabels);\n        }\n\n        if (dataLabelsObj.totalDataLabels) {\n          elDataLabelsWrap.add(dataLabelsObj.totalDataLabels);\n        }\n\n        elSeries.add(elDataLabelsWrap);\n\n        if (elGoalsMarkers) {\n          elSeries.add(elGoalsMarkers);\n        }\n\n        if (elBarShadows) {\n          elSeries.add(elBarShadows);\n        }\n\n        return elSeries;\n      }\n    }, {\n      key: \"drawBarPaths\",\n      value: function drawBarPaths(_ref2) {\n        var indexes = _ref2.indexes,\n            barHeight = _ref2.barHeight,\n            strokeWidth = _ref2.strokeWidth,\n            zeroW = _ref2.zeroW,\n            x = _ref2.x,\n            y = _ref2.y,\n            yDivision = _ref2.yDivision,\n            elSeries = _ref2.elSeries;\n        var w = this.w;\n        var i = indexes.i;\n        var j = indexes.j;\n        var barYPosition;\n\n        if (w.globals.isXNumeric) {\n          y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;\n          barYPosition = y + barHeight * this.visibleI;\n        } else {\n          if (w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {\n            var nonZeroColumns = 0;\n            var zeroEncounters = 0;\n            w.globals.seriesPercent.forEach(function (_s, _si) {\n              if (_s[j]) {\n                nonZeroColumns++;\n              }\n\n              if (_si < i && _s[j] === 0) {\n                zeroEncounters++;\n              }\n            });\n\n            if (nonZeroColumns > 0) {\n              barHeight = this.seriesLen * barHeight / nonZeroColumns;\n            }\n\n            barYPosition = y + barHeight * this.visibleI;\n            barYPosition -= barHeight * zeroEncounters;\n          } else {\n            barYPosition = y + barHeight * this.visibleI;\n          }\n        }\n\n        if (this.isFunnel) {\n          zeroW = zeroW - (this.barHelpers.getXForValue(this.series[i][j], zeroW) - zeroW) / 2;\n        }\n\n        x = this.barHelpers.getXForValue(this.series[i][j], zeroW);\n        var paths = this.barHelpers.getBarpaths({\n          barYPosition: barYPosition,\n          barHeight: barHeight,\n          x1: zeroW,\n          x2: x,\n          strokeWidth: strokeWidth,\n          series: this.series,\n          realIndex: indexes.realIndex,\n          i: i,\n          j: j,\n          w: w\n        });\n\n        if (!w.globals.isXNumeric) {\n          y = y + yDivision;\n        }\n\n        this.barHelpers.barBackground({\n          j: j,\n          i: i,\n          y1: barYPosition - barHeight * this.visibleI,\n          y2: barHeight * this.seriesLen,\n          elSeries: elSeries\n        });\n        return {\n          pathTo: paths.pathTo,\n          pathFrom: paths.pathFrom,\n          x1: zeroW,\n          x: x,\n          y: y,\n          goalX: this.barHelpers.getGoalValues('x', zeroW, null, i, j),\n          barYPosition: barYPosition,\n          barHeight: barHeight\n        };\n      }\n    }, {\n      key: \"drawColumnPaths\",\n      value: function drawColumnPaths(_ref3) {\n        var indexes = _ref3.indexes,\n            x = _ref3.x,\n            y = _ref3.y,\n            xDivision = _ref3.xDivision,\n            barWidth = _ref3.barWidth,\n            zeroH = _ref3.zeroH,\n            strokeWidth = _ref3.strokeWidth,\n            elSeries = _ref3.elSeries;\n        var w = this.w;\n        var realIndex = indexes.realIndex;\n        var i = indexes.i;\n        var j = indexes.j;\n        var bc = indexes.bc;\n        var barXPosition;\n\n        if (w.globals.isXNumeric) {\n          var sxI = realIndex;\n\n          if (!w.globals.seriesX[realIndex].length) {\n            sxI = w.globals.maxValsInArrayIndex;\n          }\n\n          if (w.globals.seriesX[sxI][j]) {\n            x = (w.globals.seriesX[sxI][j] - w.globals.minX) / this.xRatio - barWidth * this.seriesLen / 2;\n          } // re-calc barXPosition as x changed\n\n\n          barXPosition = x + barWidth * this.visibleI;\n        } else {\n          if (w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {\n            var _this$barHelpers$getZ = this.barHelpers.getZeroValueEncounters({\n              i: i,\n              j: j\n            }),\n                nonZeroColumns = _this$barHelpers$getZ.nonZeroColumns,\n                zeroEncounters = _this$barHelpers$getZ.zeroEncounters;\n\n            if (nonZeroColumns > 0) {\n              barWidth = this.seriesLen * barWidth / nonZeroColumns;\n            }\n\n            barXPosition = x + barWidth * this.visibleI;\n            barXPosition -= barWidth * zeroEncounters;\n          } else {\n            barXPosition = x + barWidth * this.visibleI;\n          }\n        }\n\n        y = this.barHelpers.getYForValue(this.series[i][j], zeroH);\n        var paths = this.barHelpers.getColumnPaths({\n          barXPosition: barXPosition,\n          barWidth: barWidth,\n          y1: zeroH,\n          y2: y,\n          strokeWidth: strokeWidth,\n          series: this.series,\n          realIndex: indexes.realIndex,\n          i: i,\n          j: j,\n          w: w\n        });\n\n        if (!w.globals.isXNumeric) {\n          x = x + xDivision;\n        }\n\n        this.barHelpers.barBackground({\n          bc: bc,\n          j: j,\n          i: i,\n          x1: barXPosition - strokeWidth / 2 - barWidth * this.visibleI,\n          x2: barWidth * this.seriesLen + strokeWidth / 2,\n          elSeries: elSeries\n        });\n        return {\n          pathTo: paths.pathTo,\n          pathFrom: paths.pathFrom,\n          x: x,\n          y: y,\n          goalY: this.barHelpers.getGoalValues('y', null, zeroH, i, j),\n          barXPosition: barXPosition,\n          barWidth: barWidth\n        };\n      }\n      /** getPreviousPath is a common function for bars/columns which is used to get previous paths when data changes.\n       * @memberof Bar\n       * @param {int} realIndex - current iterating i\n       * @param {int} j - current iterating series's j index\n       * @return {string} pathFrom is the string which will be appended in animations\n       **/\n\n    }, {\n      key: \"getPreviousPath\",\n      value: function getPreviousPath(realIndex, j) {\n        var w = this.w;\n        var pathFrom;\n\n        for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n          var gpp = w.globals.previousPaths[pp];\n\n          if (gpp.paths && gpp.paths.length > 0 && parseInt(gpp.realIndex, 10) === parseInt(realIndex, 10)) {\n            if (typeof w.globals.previousPaths[pp].paths[j] !== 'undefined') {\n              pathFrom = w.globals.previousPaths[pp].paths[j].d;\n            }\n          }\n        }\n\n        return pathFrom;\n      }\n    }]);\n\n    return Bar;\n  }();\n\n  /**\n   * ApexCharts BarStacked Class responsible for drawing both Stacked Columns and Bars.\n   *\n   * @module BarStacked\n   * The whole calculation for stacked bar/column is different from normal bar/column,\n   * hence it makes sense to derive a new class for it extending most of the props of Parent Bar\n   **/\n\n  var BarStacked = /*#__PURE__*/function (_Bar) {\n    _inherits(BarStacked, _Bar);\n\n    var _super = _createSuper(BarStacked);\n\n    function BarStacked() {\n      _classCallCheck(this, BarStacked);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(BarStacked, [{\n      key: \"draw\",\n      value: function draw(series, seriesIndex) {\n        var _this = this;\n\n        var w = this.w;\n        this.graphics = new Graphics(this.ctx);\n        this.bar = new Bar(this.ctx, this.xyRatios);\n        var coreUtils = new CoreUtils(this.ctx, w);\n        series = coreUtils.getLogSeries(series);\n        this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n        this.barHelpers.initVariables(series);\n\n        if (w.config.chart.stackType === '100%') {\n          series = w.globals.seriesPercent.slice();\n        }\n\n        this.series = series;\n        this.barHelpers.initializeStackedPrevVars(this);\n        var ret = this.graphics.group({\n          class: 'apexcharts-bar-series apexcharts-plot-series'\n        });\n        var x = 0;\n        var y = 0;\n\n        var _loop = function _loop(i, bc) {\n          var xDivision = void 0; // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n\n          var yDivision = void 0; // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n\n          var zeroH = void 0; // zeroH is the baseline where 0 meets y axis\n\n          var zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n          var groupIndex = -1; // groupIndex is the index of group buckets (group1, group2, ...)\n\n          _this.groupCtx = _this;\n          w.globals.seriesGroups.forEach(function (group, gIndex) {\n            if (group.indexOf(w.config.series[i].name) > -1) {\n              groupIndex = gIndex;\n            }\n          });\n\n          if (groupIndex !== -1) {\n            _this.groupCtx = _this[w.globals.seriesGroups[groupIndex]];\n          }\n\n          var xArrValues = [];\n          var yArrValues = [];\n          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;\n\n          if (_this.yRatio.length > 1) {\n            _this.yaxisIndex = realIndex;\n          }\n\n          _this.isReversed = w.config.yaxis[_this.yaxisIndex] && w.config.yaxis[_this.yaxisIndex].reversed; // el to which series will be drawn\n\n          var elSeries = _this.graphics.group({\n            class: \"apexcharts-series\",\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),\n            rel: i + 1,\n            'data:realIndex': realIndex\n          });\n\n          _this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex); // eldatalabels\n\n\n          var elDataLabelsWrap = _this.graphics.group({\n            class: 'apexcharts-datalabels',\n            'data:realIndex': realIndex\n          });\n\n          var elGoalsMarkers = _this.graphics.group({\n            class: 'apexcharts-bar-goals-markers'\n          });\n\n          var barHeight = 0;\n          var barWidth = 0;\n\n          var initPositions = _this.initialPositions(x, y, xDivision, yDivision, zeroH, zeroW);\n\n          y = initPositions.y;\n          barHeight = initPositions.barHeight;\n          yDivision = initPositions.yDivision;\n          zeroW = initPositions.zeroW;\n          x = initPositions.x;\n          barWidth = initPositions.barWidth;\n          xDivision = initPositions.xDivision;\n          zeroH = initPositions.zeroH;\n\n          _this.barHelpers.initializeStackedXYVars(_this); // where all stack bar disappear after collapsing the first series\n\n\n          if (_this.groupCtx.prevY.length === 1 && _this.groupCtx.prevY[0].every(function (val) {\n            return isNaN(val);\n          })) {\n            _this.groupCtx.prevY[0] = _this.groupCtx.prevY[0].map(function (val) {\n              return zeroH;\n            });\n            _this.groupCtx.prevYF[0] = _this.groupCtx.prevYF[0].map(function (val) {\n              return 0;\n            });\n          }\n\n          for (var j = 0; j < w.globals.dataPoints; j++) {\n            var strokeWidth = _this.barHelpers.getStrokeWidth(i, j, realIndex);\n\n            var commonPathOpts = {\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              strokeWidth: strokeWidth,\n              x: x,\n              y: y,\n              elSeries: elSeries,\n              groupIndex: groupIndex,\n              seriesGroup: w.globals.seriesGroups[groupIndex]\n            };\n            var paths = null;\n\n            if (_this.isHorizontal) {\n              paths = _this.drawStackedBarPaths(_objectSpread2(_objectSpread2({}, commonPathOpts), {}, {\n                zeroW: zeroW,\n                barHeight: barHeight,\n                yDivision: yDivision\n              }));\n              barWidth = _this.series[i][j] / _this.invertedYRatio;\n            } else {\n              paths = _this.drawStackedColumnPaths(_objectSpread2(_objectSpread2({}, commonPathOpts), {}, {\n                xDivision: xDivision,\n                barWidth: barWidth,\n                zeroH: zeroH\n              }));\n              barHeight = _this.series[i][j] / _this.yRatio[_this.yaxisIndex];\n            }\n\n            var barGoalLine = _this.barHelpers.drawGoalLine({\n              barXPosition: paths.barXPosition,\n              barYPosition: paths.barYPosition,\n              goalX: paths.goalX,\n              goalY: paths.goalY,\n              barHeight: barHeight,\n              barWidth: barWidth\n            });\n\n            if (barGoalLine) {\n              elGoalsMarkers.add(barGoalLine);\n            }\n\n            y = paths.y;\n            x = paths.x;\n            xArrValues.push(x);\n            yArrValues.push(y);\n\n            var pathFill = _this.barHelpers.getPathFillColor(series, i, j, realIndex);\n\n            elSeries = _this.renderSeries({\n              realIndex: realIndex,\n              pathFill: pathFill,\n              j: j,\n              i: i,\n              groupIndex: groupIndex,\n              pathFrom: paths.pathFrom,\n              pathTo: paths.pathTo,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries,\n              x: x,\n              y: y,\n              series: series,\n              barHeight: barHeight,\n              barWidth: barWidth,\n              elDataLabelsWrap: elDataLabelsWrap,\n              elGoalsMarkers: elGoalsMarkers,\n              type: 'bar',\n              visibleSeries: 0\n            });\n          } // push all x val arrays into main xArr\n\n\n          w.globals.seriesXvalues[realIndex] = xArrValues;\n          w.globals.seriesYvalues[realIndex] = yArrValues; // push all current y values array to main PrevY Array\n\n          _this.groupCtx.prevY.push(_this.groupCtx.yArrj);\n\n          _this.groupCtx.prevYF.push(_this.groupCtx.yArrjF);\n\n          _this.groupCtx.prevYVal.push(_this.groupCtx.yArrjVal);\n\n          _this.groupCtx.prevX.push(_this.groupCtx.xArrj);\n\n          _this.groupCtx.prevXF.push(_this.groupCtx.xArrjF);\n\n          _this.groupCtx.prevXVal.push(_this.groupCtx.xArrjVal);\n\n          ret.add(elSeries);\n        };\n\n        for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n          _loop(i, bc);\n        }\n\n        return ret;\n      }\n    }, {\n      key: \"initialPositions\",\n      value: function initialPositions(x, y, xDivision, yDivision, zeroH, zeroW) {\n        var _w$globals$seriesGrou, _w$globals$seriesGrou2;\n\n        var w = this.w;\n        var barHeight, barWidth;\n\n        if (this.isHorizontal) {\n          // height divided into equal parts\n          yDivision = w.globals.gridHeight / w.globals.dataPoints;\n          barHeight = yDivision;\n          barHeight = barHeight * parseInt(w.config.plotOptions.bar.barHeight, 10) / 100;\n\n          if (String(w.config.plotOptions.bar.barHeight).indexOf('%') === -1) {\n            barHeight = parseInt(w.config.plotOptions.bar.barHeight, 10);\n          }\n\n          zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0); // initial y position is half of barHeight * half of number of Bars\n\n          y = (yDivision - barHeight) / 2;\n        } else {\n          // width divided into equal parts\n          xDivision = w.globals.gridWidth / w.globals.dataPoints;\n          barWidth = xDivision;\n\n          if (w.globals.isXNumeric && w.globals.dataPoints > 1) {\n            // the check (w.globals.dataPoints > 1) fixes apexcharts.js #1617\n            xDivision = w.globals.minXDiff / this.xRatio;\n            barWidth = xDivision * parseInt(this.barOptions.columnWidth, 10) / 100;\n          } else {\n            barWidth = barWidth * parseInt(w.config.plotOptions.bar.columnWidth, 10) / 100;\n          }\n\n          if (String(w.config.plotOptions.bar.columnWidth).indexOf('%') === -1) {\n            barWidth = parseInt(w.config.plotOptions.bar.columnWidth, 10);\n          }\n\n          zeroH = w.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0); // initial x position is one third of barWidth\n\n          x = w.globals.padHorizontal + (xDivision - barWidth) / 2;\n        }\n\n        return {\n          x: x,\n          y: y,\n          yDivision: yDivision,\n          xDivision: xDivision,\n          barHeight: (_w$globals$seriesGrou = w.globals.seriesGroups) !== null && _w$globals$seriesGrou !== void 0 && _w$globals$seriesGrou.length ? barHeight / w.globals.seriesGroups.length : barHeight,\n          barWidth: (_w$globals$seriesGrou2 = w.globals.seriesGroups) !== null && _w$globals$seriesGrou2 !== void 0 && _w$globals$seriesGrou2.length ? barWidth / w.globals.seriesGroups.length : barWidth,\n          zeroH: zeroH,\n          zeroW: zeroW\n        };\n      }\n    }, {\n      key: \"drawStackedBarPaths\",\n      value: function drawStackedBarPaths(_ref) {\n        var indexes = _ref.indexes,\n            barHeight = _ref.barHeight,\n            strokeWidth = _ref.strokeWidth,\n            zeroW = _ref.zeroW,\n            x = _ref.x,\n            y = _ref.y,\n            groupIndex = _ref.groupIndex,\n            seriesGroup = _ref.seriesGroup,\n            yDivision = _ref.yDivision,\n            elSeries = _ref.elSeries;\n        var w = this.w;\n        var barYPosition = y + (groupIndex !== -1 ? groupIndex * barHeight : 0);\n        var barXPosition;\n        var i = indexes.i;\n        var j = indexes.j;\n        var prevBarW = 0;\n\n        for (var k = 0; k < this.groupCtx.prevXF.length; k++) {\n          prevBarW = prevBarW + this.groupCtx.prevXF[k][j];\n        }\n\n        var gsi = i; // an index to keep track of the series inside a group\n\n        if (seriesGroup) {\n          gsi = seriesGroup.indexOf(w.config.series[i].name);\n        }\n\n        if (gsi > 0) {\n          var bXP = zeroW;\n\n          if (this.groupCtx.prevXVal[gsi - 1][j] < 0) {\n            bXP = this.series[i][j] >= 0 ? this.groupCtx.prevX[gsi - 1][j] + prevBarW - (this.isReversed ? prevBarW : 0) * 2 : this.groupCtx.prevX[gsi - 1][j];\n          } else if (this.groupCtx.prevXVal[gsi - 1][j] >= 0) {\n            bXP = this.series[i][j] >= 0 ? this.groupCtx.prevX[gsi - 1][j] : this.groupCtx.prevX[gsi - 1][j] - prevBarW + (this.isReversed ? prevBarW : 0) * 2;\n          }\n\n          barXPosition = bXP;\n        } else {\n          // the first series will not have prevX values\n          barXPosition = zeroW;\n        }\n\n        if (this.series[i][j] === null) {\n          x = barXPosition;\n        } else {\n          x = barXPosition + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;\n        }\n\n        var paths = this.barHelpers.getBarpaths({\n          barYPosition: barYPosition,\n          barHeight: barHeight,\n          x1: barXPosition,\n          x2: x,\n          strokeWidth: strokeWidth,\n          series: this.series,\n          realIndex: indexes.realIndex,\n          seriesGroup: seriesGroup,\n          i: i,\n          j: j,\n          w: w\n        });\n        this.barHelpers.barBackground({\n          j: j,\n          i: i,\n          y1: barYPosition,\n          y2: barHeight,\n          elSeries: elSeries\n        });\n        y = y + yDivision;\n        return {\n          pathTo: paths.pathTo,\n          pathFrom: paths.pathFrom,\n          goalX: this.barHelpers.getGoalValues('x', zeroW, null, i, j),\n          barYPosition: barYPosition,\n          x: x,\n          y: y\n        };\n      }\n    }, {\n      key: \"drawStackedColumnPaths\",\n      value: function drawStackedColumnPaths(_ref2) {\n        var indexes = _ref2.indexes,\n            x = _ref2.x,\n            y = _ref2.y,\n            xDivision = _ref2.xDivision,\n            barWidth = _ref2.barWidth,\n            zeroH = _ref2.zeroH,\n            groupIndex = _ref2.groupIndex,\n            seriesGroup = _ref2.seriesGroup,\n            elSeries = _ref2.elSeries;\n        var w = this.w;\n        var i = indexes.i;\n        var j = indexes.j;\n        var bc = indexes.bc;\n\n        if (w.globals.isXNumeric) {\n          var seriesVal = w.globals.seriesX[i][j];\n          if (!seriesVal) seriesVal = 0;\n          x = (seriesVal - w.globals.minX) / this.xRatio - barWidth / 2;\n\n          if (w.globals.seriesGroups.length) {\n            x = (seriesVal - w.globals.minX) / this.xRatio - barWidth / 2 * w.globals.seriesGroups.length;\n          }\n        }\n\n        var barXPosition = x + (groupIndex !== -1 ? groupIndex * barWidth : 0);\n        var barYPosition;\n        var prevBarH = 0;\n\n        for (var k = 0; k < this.groupCtx.prevYF.length; k++) {\n          // fix issue #1215\n          // in case where this.groupCtx.prevYF[k][j] is NaN, use 0 instead\n          prevBarH = prevBarH + (!isNaN(this.groupCtx.prevYF[k][j]) ? this.groupCtx.prevYF[k][j] : 0);\n        }\n\n        var gsi = i; // an index to keep track of the series inside a group\n\n        if (seriesGroup) {\n          gsi = seriesGroup.indexOf(w.config.series[i].name);\n        }\n\n        if (gsi > 0 && !w.globals.isXNumeric || gsi > 0 && w.globals.isXNumeric && w.globals.seriesX[i - 1][j] === w.globals.seriesX[i][j]) {\n          var _this$groupCtx$prevYF;\n\n          var bYP;\n          var prevYValue;\n          var p = Math.min(this.yRatio.length + 1, i + 1);\n\n          if (this.groupCtx.prevY[gsi - 1] !== undefined && this.groupCtx.prevY[gsi - 1].length) {\n            for (var ii = 1; ii < p; ii++) {\n              var _this$groupCtx$prevY;\n\n              if (!isNaN((_this$groupCtx$prevY = this.groupCtx.prevY[gsi - ii]) === null || _this$groupCtx$prevY === void 0 ? void 0 : _this$groupCtx$prevY[j])) {\n                // find the previous available value to give prevYValue\n                prevYValue = this.groupCtx.prevY[gsi - ii][j]; // if found it, break the loop\n\n                break;\n              }\n            }\n          }\n\n          for (var _ii = 1; _ii < p; _ii++) {\n            var _this$groupCtx$prevYV, _this$groupCtx$prevYV2;\n\n            // find the previous available value(non-NaN) to give bYP\n            if (((_this$groupCtx$prevYV = this.groupCtx.prevYVal[gsi - _ii]) === null || _this$groupCtx$prevYV === void 0 ? void 0 : _this$groupCtx$prevYV[j]) < 0) {\n              bYP = this.series[i][j] >= 0 ? prevYValue - prevBarH + (this.isReversed ? prevBarH : 0) * 2 : prevYValue; // found it? break the loop\n\n              break;\n            } else if (((_this$groupCtx$prevYV2 = this.groupCtx.prevYVal[gsi - _ii]) === null || _this$groupCtx$prevYV2 === void 0 ? void 0 : _this$groupCtx$prevYV2[j]) >= 0) {\n              bYP = this.series[i][j] >= 0 ? prevYValue : prevYValue + prevBarH - (this.isReversed ? prevBarH : 0) * 2; // found it? break the loop\n\n              break;\n            }\n          }\n\n          if (typeof bYP === 'undefined') bYP = w.globals.gridHeight; // if this.prevYF[0] is all 0 resulted from line #486\n          // AND every arr starting from the second only contains NaN\n\n          if ((_this$groupCtx$prevYF = this.groupCtx.prevYF[0]) !== null && _this$groupCtx$prevYF !== void 0 && _this$groupCtx$prevYF.every(function (val) {\n            return val === 0;\n          }) && this.groupCtx.prevYF.slice(1, gsi).every(function (arr) {\n            return arr.every(function (val) {\n              return isNaN(val);\n            });\n          })) {\n            barYPosition = zeroH;\n          } else {\n            // Nothing special\n            barYPosition = bYP;\n          }\n        } else {\n          // the first series will not have prevY values, also if the prev index's series X doesn't matches the current index's series X, then start from zero\n          barYPosition = zeroH;\n        }\n\n        if (this.series[i][j]) {\n          y = barYPosition - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;\n        } else {\n          // fixes #3610\n          y = barYPosition;\n        }\n\n        var paths = this.barHelpers.getColumnPaths({\n          barXPosition: barXPosition,\n          barWidth: barWidth,\n          y1: barYPosition,\n          y2: y,\n          yRatio: this.yRatio[this.yaxisIndex],\n          strokeWidth: this.strokeWidth,\n          series: this.series,\n          seriesGroup: seriesGroup,\n          realIndex: indexes.realIndex,\n          i: i,\n          j: j,\n          w: w\n        });\n        this.barHelpers.barBackground({\n          bc: bc,\n          j: j,\n          i: i,\n          x1: barXPosition,\n          x2: barWidth,\n          elSeries: elSeries\n        });\n        x = x + xDivision;\n        return {\n          pathTo: paths.pathTo,\n          pathFrom: paths.pathFrom,\n          goalY: this.barHelpers.getGoalValues('y', null, zeroH, i, j),\n          barXPosition: barXPosition,\n          x: w.globals.isXNumeric ? x - xDivision : x,\n          y: y\n        };\n      }\n    }]);\n\n    return BarStacked;\n  }(Bar);\n\n  /**\n   * ApexCharts BoxCandleStick Class responsible for drawing both Stacked Columns and Bars.\n   *\n   * @module BoxCandleStick\n   **/\n\n  var BoxCandleStick = /*#__PURE__*/function (_Bar) {\n    _inherits(BoxCandleStick, _Bar);\n\n    var _super = _createSuper(BoxCandleStick);\n\n    function BoxCandleStick() {\n      _classCallCheck(this, BoxCandleStick);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(BoxCandleStick, [{\n      key: \"draw\",\n      value: function draw(series, ctype, seriesIndex) {\n        var _this = this;\n\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var type = w.globals.comboCharts ? ctype : w.config.chart.type;\n        var fill = new Fill(this.ctx);\n        this.candlestickOptions = this.w.config.plotOptions.candlestick;\n        this.boxOptions = this.w.config.plotOptions.boxPlot;\n        this.isHorizontal = w.config.plotOptions.bar.horizontal;\n        var coreUtils = new CoreUtils(this.ctx, w);\n        series = coreUtils.getLogSeries(series);\n        this.series = series;\n        this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n        this.barHelpers.initVariables(series);\n        var ret = graphics.group({\n          class: \"apexcharts-\".concat(type, \"-series apexcharts-plot-series\")\n        });\n\n        var _loop = function _loop(i) {\n          _this.isBoxPlot = w.config.chart.type === 'boxPlot' || w.config.series[i].type === 'boxPlot';\n          var x = void 0,\n              y = void 0,\n              xDivision = void 0,\n              // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n          yDivision = void 0,\n              // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n          zeroH = void 0,\n              // zeroH is the baseline where 0 meets y axis\n          zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n          var yArrj = []; // hold y values of current iterating series\n\n          var xArrj = []; // hold x values of current iterating series\n\n          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n          var elSeries = graphics.group({\n            class: \"apexcharts-series\",\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),\n            rel: i + 1,\n            'data:realIndex': realIndex\n          });\n\n          _this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);\n\n          if (series[i].length > 0) {\n            _this.visibleI = _this.visibleI + 1;\n          }\n\n          var barHeight = 0;\n          var barWidth = 0;\n\n          if (_this.yRatio.length > 1) {\n            _this.yaxisIndex = realIndex;\n          }\n\n          var initPositions = _this.barHelpers.initialPositions();\n\n          y = initPositions.y;\n          barHeight = initPositions.barHeight;\n          yDivision = initPositions.yDivision;\n          zeroW = initPositions.zeroW;\n          x = initPositions.x;\n          barWidth = initPositions.barWidth;\n          xDivision = initPositions.xDivision;\n          zeroH = initPositions.zeroH;\n          xArrj.push(x + barWidth / 2); // eldatalabels\n\n          var elDataLabelsWrap = graphics.group({\n            class: 'apexcharts-datalabels',\n            'data:realIndex': realIndex\n          });\n\n          var _loop2 = function _loop2(j) {\n            var strokeWidth = _this.barHelpers.getStrokeWidth(i, j, realIndex);\n\n            var paths = null;\n            var pathsParams = {\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex\n              },\n              x: x,\n              y: y,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            };\n\n            if (_this.isHorizontal) {\n              paths = _this.drawHorizontalBoxPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {\n                yDivision: yDivision,\n                barHeight: barHeight,\n                zeroW: zeroW\n              }));\n            } else {\n              paths = _this.drawVerticalBoxPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {\n                xDivision: xDivision,\n                barWidth: barWidth,\n                zeroH: zeroH\n              }));\n            }\n\n            y = paths.y;\n            x = paths.x; // push current X\n\n            if (j > 0) {\n              xArrj.push(x + barWidth / 2);\n            }\n\n            yArrj.push(y);\n            paths.pathTo.forEach(function (pathTo, pi) {\n              var lineFill = !_this.isBoxPlot && _this.candlestickOptions.wick.useFillColor ? paths.color[pi] : w.globals.stroke.colors[i];\n              var pathFill = fill.fillPath({\n                seriesNumber: realIndex,\n                dataPointIndex: j,\n                color: paths.color[pi],\n                value: series[i][j]\n              });\n\n              _this.renderSeries({\n                realIndex: realIndex,\n                pathFill: pathFill,\n                lineFill: lineFill,\n                j: j,\n                i: i,\n                pathFrom: paths.pathFrom,\n                pathTo: pathTo,\n                strokeWidth: strokeWidth,\n                elSeries: elSeries,\n                x: x,\n                y: y,\n                series: series,\n                barHeight: barHeight,\n                barWidth: barWidth,\n                elDataLabelsWrap: elDataLabelsWrap,\n                visibleSeries: _this.visibleI,\n                type: w.config.chart.type\n              });\n            });\n          };\n\n          for (var j = 0; j < w.globals.dataPoints; j++) {\n            _loop2(j);\n          } // push all x val arrays into main xArr\n\n\n          w.globals.seriesXvalues[realIndex] = xArrj;\n          w.globals.seriesYvalues[realIndex] = yArrj;\n          ret.add(elSeries);\n        };\n\n        for (var i = 0; i < series.length; i++) {\n          _loop(i);\n        }\n\n        return ret;\n      }\n    }, {\n      key: \"drawVerticalBoxPaths\",\n      value: function drawVerticalBoxPaths(_ref) {\n        var indexes = _ref.indexes,\n            x = _ref.x;\n            _ref.y;\n            var xDivision = _ref.xDivision,\n            barWidth = _ref.barWidth,\n            zeroH = _ref.zeroH,\n            strokeWidth = _ref.strokeWidth;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var i = indexes.i;\n        var j = indexes.j;\n        var isPositive = true;\n        var colorPos = w.config.plotOptions.candlestick.colors.upward;\n        var colorNeg = w.config.plotOptions.candlestick.colors.downward;\n        var color = '';\n\n        if (this.isBoxPlot) {\n          color = [this.boxOptions.colors.lower, this.boxOptions.colors.upper];\n        }\n\n        var yRatio = this.yRatio[this.yaxisIndex];\n        var realIndex = indexes.realIndex;\n        var ohlc = this.getOHLCValue(realIndex, j);\n        var l1 = zeroH;\n        var l2 = zeroH;\n\n        if (ohlc.o > ohlc.c) {\n          isPositive = false;\n        }\n\n        var y1 = Math.min(ohlc.o, ohlc.c);\n        var y2 = Math.max(ohlc.o, ohlc.c);\n        var m = ohlc.m;\n\n        if (w.globals.isXNumeric) {\n          x = (w.globals.seriesX[realIndex][j] - w.globals.minX) / this.xRatio - barWidth / 2;\n        }\n\n        var barXPosition = x + barWidth * this.visibleI;\n\n        if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n          y1 = zeroH;\n          y2 = zeroH;\n        } else {\n          y1 = zeroH - y1 / yRatio;\n          y2 = zeroH - y2 / yRatio;\n          l1 = zeroH - ohlc.h / yRatio;\n          l2 = zeroH - ohlc.l / yRatio;\n          m = zeroH - ohlc.m / yRatio;\n        }\n\n        var pathTo = graphics.move(barXPosition, zeroH);\n        var pathFrom = graphics.move(barXPosition + barWidth / 2, y1);\n\n        if (w.globals.previousPaths.length > 0) {\n          pathFrom = this.getPreviousPath(realIndex, j, true);\n        }\n\n        if (this.isBoxPlot) {\n          pathTo = [graphics.move(barXPosition, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 4, l1) + graphics.line(barXPosition + barWidth - barWidth / 4, l1) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth, m) + graphics.line(barXPosition, m) + graphics.line(barXPosition, y1 + strokeWidth / 2), graphics.move(barXPosition, m) + graphics.line(barXPosition + barWidth, m) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth - barWidth / 4, l2) + graphics.line(barXPosition + barWidth / 4, l2) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition, y2) + graphics.line(barXPosition, m) + 'z'];\n        } else {\n          // candlestick\n          pathTo = [graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2)];\n        }\n\n        pathFrom = pathFrom + graphics.move(barXPosition, y1);\n\n        if (!w.globals.isXNumeric) {\n          x = x + xDivision;\n        }\n\n        return {\n          pathTo: pathTo,\n          pathFrom: pathFrom,\n          x: x,\n          y: y2,\n          barXPosition: barXPosition,\n          color: this.isBoxPlot ? color : isPositive ? [colorPos] : [colorNeg]\n        };\n      }\n    }, {\n      key: \"drawHorizontalBoxPaths\",\n      value: function drawHorizontalBoxPaths(_ref2) {\n        var indexes = _ref2.indexes;\n            _ref2.x;\n            var y = _ref2.y,\n            yDivision = _ref2.yDivision,\n            barHeight = _ref2.barHeight,\n            zeroW = _ref2.zeroW,\n            strokeWidth = _ref2.strokeWidth;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var i = indexes.i;\n        var j = indexes.j;\n        var color = this.boxOptions.colors.lower;\n\n        if (this.isBoxPlot) {\n          color = [this.boxOptions.colors.lower, this.boxOptions.colors.upper];\n        }\n\n        var yRatio = this.invertedYRatio;\n        var realIndex = indexes.realIndex;\n        var ohlc = this.getOHLCValue(realIndex, j);\n        var l1 = zeroW;\n        var l2 = zeroW;\n        var x1 = Math.min(ohlc.o, ohlc.c);\n        var x2 = Math.max(ohlc.o, ohlc.c);\n        var m = ohlc.m;\n\n        if (w.globals.isXNumeric) {\n          y = (w.globals.seriesX[realIndex][j] - w.globals.minX) / this.invertedXRatio - barHeight / 2;\n        }\n\n        var barYPosition = y + barHeight * this.visibleI;\n\n        if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n          x1 = zeroW;\n          x2 = zeroW;\n        } else {\n          x1 = zeroW + x1 / yRatio;\n          x2 = zeroW + x2 / yRatio;\n          l1 = zeroW + ohlc.h / yRatio;\n          l2 = zeroW + ohlc.l / yRatio;\n          m = zeroW + ohlc.m / yRatio;\n        }\n\n        var pathTo = graphics.move(zeroW, barYPosition);\n        var pathFrom = graphics.move(x1, barYPosition + barHeight / 2);\n\n        if (w.globals.previousPaths.length > 0) {\n          pathFrom = this.getPreviousPath(realIndex, j, true);\n        }\n\n        pathTo = [graphics.move(x1, barYPosition) + graphics.line(x1, barYPosition + barHeight / 2) + graphics.line(l1, barYPosition + barHeight / 2) + graphics.line(l1, barYPosition + barHeight / 2 - barHeight / 4) + graphics.line(l1, barYPosition + barHeight / 2 + barHeight / 4) + graphics.line(l1, barYPosition + barHeight / 2) + graphics.line(x1, barYPosition + barHeight / 2) + graphics.line(x1, barYPosition + barHeight) + graphics.line(m, barYPosition + barHeight) + graphics.line(m, barYPosition) + graphics.line(x1 + strokeWidth / 2, barYPosition), graphics.move(m, barYPosition) + graphics.line(m, barYPosition + barHeight) + graphics.line(x2, barYPosition + barHeight) + graphics.line(x2, barYPosition + barHeight / 2) + graphics.line(l2, barYPosition + barHeight / 2) + graphics.line(l2, barYPosition + barHeight - barHeight / 4) + graphics.line(l2, barYPosition + barHeight / 4) + graphics.line(l2, barYPosition + barHeight / 2) + graphics.line(x2, barYPosition + barHeight / 2) + graphics.line(x2, barYPosition) + graphics.line(m, barYPosition) + 'z'];\n        pathFrom = pathFrom + graphics.move(x1, barYPosition);\n\n        if (!w.globals.isXNumeric) {\n          y = y + yDivision;\n        }\n\n        return {\n          pathTo: pathTo,\n          pathFrom: pathFrom,\n          x: x2,\n          y: y,\n          barYPosition: barYPosition,\n          color: color\n        };\n      }\n    }, {\n      key: \"getOHLCValue\",\n      value: function getOHLCValue(i, j) {\n        var w = this.w;\n        return {\n          o: this.isBoxPlot ? w.globals.seriesCandleH[i][j] : w.globals.seriesCandleO[i][j],\n          h: this.isBoxPlot ? w.globals.seriesCandleO[i][j] : w.globals.seriesCandleH[i][j],\n          m: w.globals.seriesCandleM[i][j],\n          l: this.isBoxPlot ? w.globals.seriesCandleC[i][j] : w.globals.seriesCandleL[i][j],\n          c: this.isBoxPlot ? w.globals.seriesCandleL[i][j] : w.globals.seriesCandleC[i][j]\n        };\n      }\n    }]);\n\n    return BoxCandleStick;\n  }(Bar);\n\n  var TreemapHelpers = /*#__PURE__*/function () {\n    function TreemapHelpers(ctx) {\n      _classCallCheck(this, TreemapHelpers);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(TreemapHelpers, [{\n      key: \"checkColorRange\",\n      value: function checkColorRange() {\n        var w = this.w;\n        var negRange = false;\n        var chartOpts = w.config.plotOptions[w.config.chart.type];\n\n        if (chartOpts.colorScale.ranges.length > 0) {\n          chartOpts.colorScale.ranges.map(function (range, index) {\n            if (range.from <= 0) {\n              negRange = true;\n            }\n          });\n        }\n\n        return negRange;\n      }\n    }, {\n      key: \"getShadeColor\",\n      value: function getShadeColor(chartType, i, j, negRange) {\n        var w = this.w;\n        var colorShadePercent = 1;\n        var shadeIntensity = w.config.plotOptions[chartType].shadeIntensity;\n        var colorProps = this.determineColor(chartType, i, j);\n\n        if (w.globals.hasNegs || negRange) {\n          if (w.config.plotOptions[chartType].reverseNegativeShade) {\n            if (colorProps.percent < 0) {\n              colorShadePercent = colorProps.percent / 100 * (shadeIntensity * 1.25);\n            } else {\n              colorShadePercent = (1 - colorProps.percent / 100) * (shadeIntensity * 1.25);\n            }\n          } else {\n            if (colorProps.percent <= 0) {\n              colorShadePercent = 1 - (1 + colorProps.percent / 100) * shadeIntensity;\n            } else {\n              colorShadePercent = (1 - colorProps.percent / 100) * shadeIntensity;\n            }\n          }\n        } else {\n          colorShadePercent = 1 - colorProps.percent / 100;\n\n          if (chartType === 'treemap') {\n            colorShadePercent = (1 - colorProps.percent / 100) * (shadeIntensity * 1.25);\n          }\n        }\n\n        var color = colorProps.color;\n        var utils = new Utils$1();\n\n        if (w.config.plotOptions[chartType].enableShades) {\n          if (this.w.config.theme.mode === 'dark') {\n            color = Utils$1.hexToRgba(utils.shadeColor(colorShadePercent * -1, colorProps.color), w.config.fill.opacity);\n          } else {\n            color = Utils$1.hexToRgba(utils.shadeColor(colorShadePercent, colorProps.color), w.config.fill.opacity);\n          }\n        }\n\n        return {\n          color: color,\n          colorProps: colorProps\n        };\n      }\n    }, {\n      key: \"determineColor\",\n      value: function determineColor(chartType, i, j) {\n        var w = this.w;\n        var val = w.globals.series[i][j];\n        var chartOpts = w.config.plotOptions[chartType];\n        var seriesNumber = chartOpts.colorScale.inverse ? j : i;\n\n        if (chartOpts.distributed && w.config.chart.type === 'treemap') {\n          seriesNumber = j;\n        }\n\n        var color = w.globals.colors[seriesNumber];\n        var foreColor = null;\n        var min = Math.min.apply(Math, _toConsumableArray(w.globals.series[i]));\n        var max = Math.max.apply(Math, _toConsumableArray(w.globals.series[i]));\n\n        if (!chartOpts.distributed && chartType === 'heatmap') {\n          min = w.globals.minY;\n          max = w.globals.maxY;\n        }\n\n        if (typeof chartOpts.colorScale.min !== 'undefined') {\n          min = chartOpts.colorScale.min < w.globals.minY ? chartOpts.colorScale.min : w.globals.minY;\n          max = chartOpts.colorScale.max > w.globals.maxY ? chartOpts.colorScale.max : w.globals.maxY;\n        }\n\n        var total = Math.abs(max) + Math.abs(min);\n        var percent = 100 * val / (total === 0 ? total - 0.000001 : total);\n\n        if (chartOpts.colorScale.ranges.length > 0) {\n          var colorRange = chartOpts.colorScale.ranges;\n          colorRange.map(function (range, index) {\n            if (val >= range.from && val <= range.to) {\n              color = range.color;\n              foreColor = range.foreColor ? range.foreColor : null;\n              min = range.from;\n              max = range.to;\n              var rTotal = Math.abs(max) + Math.abs(min);\n              percent = 100 * val / (rTotal === 0 ? rTotal - 0.000001 : rTotal);\n            }\n          });\n        }\n\n        return {\n          color: color,\n          foreColor: foreColor,\n          percent: percent\n        };\n      }\n    }, {\n      key: \"calculateDataLabels\",\n      value: function calculateDataLabels(_ref) {\n        var text = _ref.text,\n            x = _ref.x,\n            y = _ref.y,\n            i = _ref.i,\n            j = _ref.j,\n            colorProps = _ref.colorProps,\n            fontSize = _ref.fontSize;\n        var w = this.w;\n        var dataLabelsConfig = w.config.dataLabels;\n        var graphics = new Graphics(this.ctx);\n        var dataLabels = new DataLabels(this.ctx);\n        var elDataLabelsWrap = null;\n\n        if (dataLabelsConfig.enabled) {\n          elDataLabelsWrap = graphics.group({\n            class: 'apexcharts-data-labels'\n          });\n          var offX = dataLabelsConfig.offsetX;\n          var offY = dataLabelsConfig.offsetY;\n          var dataLabelsX = x + offX;\n          var dataLabelsY = y + parseFloat(dataLabelsConfig.style.fontSize) / 3 + offY;\n          dataLabels.plotDataLabelsText({\n            x: dataLabelsX,\n            y: dataLabelsY,\n            text: text,\n            i: i,\n            j: j,\n            color: colorProps.foreColor,\n            parent: elDataLabelsWrap,\n            fontSize: fontSize,\n            dataLabelsConfig: dataLabelsConfig\n          });\n        }\n\n        return elDataLabelsWrap;\n      }\n    }, {\n      key: \"addListeners\",\n      value: function addListeners(elRect) {\n        var graphics = new Graphics(this.ctx);\n        elRect.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elRect));\n        elRect.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elRect));\n        elRect.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elRect));\n      }\n    }]);\n\n    return TreemapHelpers;\n  }();\n\n  /**\n   * ApexCharts HeatMap Class.\n   * @module HeatMap\n   **/\n\n  var HeatMap = /*#__PURE__*/function () {\n    function HeatMap(ctx, xyRatios) {\n      _classCallCheck(this, HeatMap);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.xRatio = xyRatios.xRatio;\n      this.yRatio = xyRatios.yRatio;\n      this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;\n      this.helpers = new TreemapHelpers(ctx);\n      this.rectRadius = this.w.config.plotOptions.heatmap.radius;\n      this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;\n    }\n\n    _createClass(HeatMap, [{\n      key: \"draw\",\n      value: function draw(series) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var ret = graphics.group({\n          class: 'apexcharts-heatmap'\n        });\n        ret.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\")); // width divided into equal parts\n\n        var xDivision = w.globals.gridWidth / w.globals.dataPoints;\n        var yDivision = w.globals.gridHeight / w.globals.series.length;\n        var y1 = 0;\n        var rev = false;\n        this.negRange = this.helpers.checkColorRange();\n        var heatSeries = series.slice();\n\n        if (w.config.yaxis[0].reversed) {\n          rev = true;\n          heatSeries.reverse();\n        }\n\n        for (var i = rev ? 0 : heatSeries.length - 1; rev ? i < heatSeries.length : i >= 0; rev ? i++ : i--) {\n          // el to which series will be drawn\n          var elSeries = graphics.group({\n            class: \"apexcharts-series apexcharts-heatmap-series\",\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),\n            rel: i + 1,\n            'data:realIndex': i\n          });\n          this.ctx.series.addCollapsedClassToSeries(elSeries, i);\n\n          if (w.config.chart.dropShadow.enabled) {\n            var shadow = w.config.chart.dropShadow;\n            var filters = new Filters(this.ctx);\n            filters.dropShadow(elSeries, shadow, i);\n          }\n\n          var x1 = 0;\n          var shadeIntensity = w.config.plotOptions.heatmap.shadeIntensity;\n\n          for (var j = 0; j < heatSeries[i].length; j++) {\n            var heatColor = this.helpers.getShadeColor(w.config.chart.type, i, j, this.negRange);\n            var color = heatColor.color;\n            var heatColorProps = heatColor.colorProps;\n\n            if (w.config.fill.type === 'image') {\n              var fill = new Fill(this.ctx);\n              color = fill.fillPath({\n                seriesNumber: i,\n                dataPointIndex: j,\n                opacity: w.globals.hasNegs ? heatColorProps.percent < 0 ? 1 - (1 + heatColorProps.percent / 100) : shadeIntensity + heatColorProps.percent / 100 : heatColorProps.percent / 100,\n                patternID: Utils$1.randomId(),\n                width: w.config.fill.image.width ? w.config.fill.image.width : xDivision,\n                height: w.config.fill.image.height ? w.config.fill.image.height : yDivision\n              });\n            }\n\n            var radius = this.rectRadius;\n            var rect = graphics.drawRect(x1, y1, xDivision, yDivision, radius);\n            rect.attr({\n              cx: x1,\n              cy: y1\n            });\n            rect.node.classList.add('apexcharts-heatmap-rect');\n            elSeries.add(rect);\n            rect.attr({\n              fill: color,\n              i: i,\n              index: i,\n              j: j,\n              val: heatSeries[i][j],\n              'stroke-width': this.strokeWidth,\n              stroke: w.config.plotOptions.heatmap.useFillColorAsStroke ? color : w.globals.stroke.colors[0],\n              color: color\n            });\n            this.helpers.addListeners(rect);\n\n            if (w.config.chart.animations.enabled && !w.globals.dataChanged) {\n              var speed = 1;\n\n              if (!w.globals.resized) {\n                speed = w.config.chart.animations.speed;\n              }\n\n              this.animateHeatMap(rect, x1, y1, xDivision, yDivision, speed);\n            }\n\n            if (w.globals.dataChanged) {\n              var _speed = 1;\n\n              if (this.dynamicAnim.enabled && w.globals.shouldAnimate) {\n                _speed = this.dynamicAnim.speed;\n                var colorFrom = w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].color;\n                if (!colorFrom) colorFrom = 'rgba(255, 255, 255, 0)';\n                this.animateHeatColor(rect, Utils$1.isColorHex(colorFrom) ? colorFrom : Utils$1.rgb2hex(colorFrom), Utils$1.isColorHex(color) ? color : Utils$1.rgb2hex(color), _speed);\n              }\n            }\n\n            var formatter = w.config.dataLabels.formatter;\n            var formattedText = formatter(w.globals.series[i][j], {\n              value: w.globals.series[i][j],\n              seriesIndex: i,\n              dataPointIndex: j,\n              w: w\n            });\n            var dataLabels = this.helpers.calculateDataLabels({\n              text: formattedText,\n              x: x1 + xDivision / 2,\n              y: y1 + yDivision / 2,\n              i: i,\n              j: j,\n              colorProps: heatColorProps,\n              series: heatSeries\n            });\n\n            if (dataLabels !== null) {\n              elSeries.add(dataLabels);\n            }\n\n            x1 = x1 + xDivision;\n          }\n\n          y1 = y1 + yDivision;\n          ret.add(elSeries);\n        } // adjust yaxis labels for heatmap\n\n\n        var yAxisScale = w.globals.yAxisScale[0].result.slice();\n\n        if (w.config.yaxis[0].reversed) {\n          yAxisScale.unshift('');\n        } else {\n          yAxisScale.push('');\n        }\n\n        w.globals.yAxisScale[0].result = yAxisScale;\n        return ret;\n      }\n    }, {\n      key: \"animateHeatMap\",\n      value: function animateHeatMap(el, x, y, width, height, speed) {\n        var animations = new Animations(this.ctx);\n        animations.animateRect(el, {\n          x: x + width / 2,\n          y: y + height / 2,\n          width: 0,\n          height: 0\n        }, {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        }, speed, function () {\n          animations.animationCompleted(el);\n        });\n      }\n    }, {\n      key: \"animateHeatColor\",\n      value: function animateHeatColor(el, colorFrom, colorTo, speed) {\n        el.attr({\n          fill: colorFrom\n        }).animate(speed).attr({\n          fill: colorTo\n        });\n      }\n    }]);\n\n    return HeatMap;\n  }();\n\n  var CircularChartsHelpers = /*#__PURE__*/function () {\n    function CircularChartsHelpers(ctx) {\n      _classCallCheck(this, CircularChartsHelpers);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(CircularChartsHelpers, [{\n      key: \"drawYAxisTexts\",\n      value: function drawYAxisTexts(x, y, i, text) {\n        var w = this.w;\n        var yaxisConfig = w.config.yaxis[0];\n        var formatter = w.globals.yLabelFormatters[0];\n        var graphics = new Graphics(this.ctx);\n        var yaxisLabel = graphics.drawText({\n          x: x + yaxisConfig.labels.offsetX,\n          y: y + yaxisConfig.labels.offsetY,\n          text: formatter(text, i),\n          textAnchor: 'middle',\n          fontSize: yaxisConfig.labels.style.fontSize,\n          fontFamily: yaxisConfig.labels.style.fontFamily,\n          foreColor: Array.isArray(yaxisConfig.labels.style.colors) ? yaxisConfig.labels.style.colors[i] : yaxisConfig.labels.style.colors\n        });\n        return yaxisLabel;\n      }\n    }]);\n\n    return CircularChartsHelpers;\n  }();\n\n  /**\n   * ApexCharts Pie Class for drawing Pie / Donut Charts.\n   * @module Pie\n   **/\n\n  var Pie = /*#__PURE__*/function () {\n    function Pie(ctx) {\n      _classCallCheck(this, Pie);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      var w = this.w;\n      this.chartType = this.w.config.chart.type;\n      this.initialAnim = this.w.config.chart.animations.enabled;\n      this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n      this.animBeginArr = [0];\n      this.animDur = 0;\n      this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels;\n      this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;\n      this.defaultSize = Math.min(w.globals.gridWidth, w.globals.gridHeight);\n      this.centerY = this.defaultSize / 2;\n      this.centerX = w.globals.gridWidth / 2;\n\n      if (w.config.chart.type === 'radialBar') {\n        this.fullAngle = 360;\n      } else {\n        this.fullAngle = Math.abs(w.config.plotOptions.pie.endAngle - w.config.plotOptions.pie.startAngle);\n      }\n\n      this.initialAngle = w.config.plotOptions.pie.startAngle % this.fullAngle;\n      w.globals.radialSize = this.defaultSize / 2.05 - w.config.stroke.width - (!w.config.chart.sparkline.enabled ? w.config.chart.dropShadow.blur : 0);\n      this.donutSize = w.globals.radialSize * parseInt(w.config.plotOptions.pie.donut.size, 10) / 100;\n      this.maxY = 0;\n      this.sliceLabels = [];\n      this.sliceSizes = [];\n      this.prevSectorAngleArr = []; // for dynamic animations\n    }\n\n    _createClass(Pie, [{\n      key: \"draw\",\n      value: function draw(series) {\n        var _this = this;\n\n        var self = this;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        this.ret = graphics.group({\n          class: 'apexcharts-pie'\n        });\n        if (w.globals.noData) return this.ret;\n        var total = 0;\n\n        for (var k = 0; k < series.length; k++) {\n          // CALCULATE THE TOTAL\n          total += Utils$1.negToZero(series[k]);\n        }\n\n        var sectorAngleArr = []; // el to which series will be drawn\n\n        var elSeries = graphics.group(); // prevent division by zero error if there is no data\n\n        if (total === 0) {\n          total = 0.00001;\n        }\n\n        series.forEach(function (m) {\n          _this.maxY = Math.max(_this.maxY, m);\n        }); // override maxY if user provided in config\n\n        if (w.config.yaxis[0].max) {\n          this.maxY = w.config.yaxis[0].max;\n        }\n\n        if (w.config.grid.position === 'back' && this.chartType === 'polarArea') {\n          this.drawPolarElements(this.ret);\n        }\n\n        for (var i = 0; i < series.length; i++) {\n          // CALCULATE THE ANGLES\n          var angle = this.fullAngle * Utils$1.negToZero(series[i]) / total;\n          sectorAngleArr.push(angle);\n\n          if (this.chartType === 'polarArea') {\n            sectorAngleArr[i] = this.fullAngle / series.length;\n            this.sliceSizes.push(w.globals.radialSize * series[i] / this.maxY);\n          } else {\n            this.sliceSizes.push(w.globals.radialSize);\n          }\n        }\n\n        if (w.globals.dataChanged) {\n          var prevTotal = 0;\n\n          for (var _k = 0; _k < w.globals.previousPaths.length; _k++) {\n            // CALCULATE THE PREV TOTAL\n            prevTotal += Utils$1.negToZero(w.globals.previousPaths[_k]);\n          }\n\n          var previousAngle;\n\n          for (var _i = 0; _i < w.globals.previousPaths.length; _i++) {\n            // CALCULATE THE PREVIOUS ANGLES\n            previousAngle = this.fullAngle * Utils$1.negToZero(w.globals.previousPaths[_i]) / prevTotal;\n            this.prevSectorAngleArr.push(previousAngle);\n          }\n        } // on small chart size after few count of resizes browser window donutSize can be negative\n\n\n        if (this.donutSize < 0) {\n          this.donutSize = 0;\n        }\n\n        var scaleSize = w.config.plotOptions.pie.customScale;\n        var halfW = w.globals.gridWidth / 2;\n        var halfH = w.globals.gridHeight / 2;\n        var translateX = halfW - w.globals.gridWidth / 2 * scaleSize;\n        var translateY = halfH - w.globals.gridHeight / 2 * scaleSize;\n\n        if (this.chartType === 'donut') {\n          // draw the inner circle and add some text to it\n          var circle = graphics.drawCircle(this.donutSize);\n          circle.attr({\n            cx: this.centerX,\n            cy: this.centerY,\n            fill: w.config.plotOptions.pie.donut.background ? w.config.plotOptions.pie.donut.background : 'transparent'\n          });\n          elSeries.add(circle);\n        }\n\n        var elG = self.drawArcs(sectorAngleArr, series); // add slice dataLabels at the end\n\n        this.sliceLabels.forEach(function (s) {\n          elG.add(s);\n        });\n        elSeries.attr({\n          transform: \"translate(\".concat(translateX, \", \").concat(translateY, \") scale(\").concat(scaleSize, \")\")\n        });\n        elSeries.add(elG);\n        this.ret.add(elSeries);\n\n        if (this.donutDataLabels.show) {\n          var dataLabels = this.renderInnerDataLabels(this.donutDataLabels, {\n            hollowSize: this.donutSize,\n            centerX: this.centerX,\n            centerY: this.centerY,\n            opacity: this.donutDataLabels.show,\n            translateX: translateX,\n            translateY: translateY\n          });\n          this.ret.add(dataLabels);\n        }\n\n        if (w.config.grid.position === 'front' && this.chartType === 'polarArea') {\n          this.drawPolarElements(this.ret);\n        }\n\n        return this.ret;\n      } // core function for drawing pie arcs\n\n    }, {\n      key: \"drawArcs\",\n      value: function drawArcs(sectorAngleArr, series) {\n        var w = this.w;\n        var filters = new Filters(this.ctx);\n        var graphics = new Graphics(this.ctx);\n        var fill = new Fill(this.ctx);\n        var g = graphics.group({\n          class: 'apexcharts-slices'\n        });\n        var startAngle = this.initialAngle;\n        var prevStartAngle = this.initialAngle;\n        var endAngle = this.initialAngle;\n        var prevEndAngle = this.initialAngle;\n        this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;\n\n        for (var i = 0; i < sectorAngleArr.length; i++) {\n          var elPieArc = graphics.group({\n            class: \"apexcharts-series apexcharts-pie-series\",\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),\n            rel: i + 1,\n            'data:realIndex': i\n          });\n          g.add(elPieArc);\n          startAngle = endAngle;\n          prevStartAngle = prevEndAngle;\n          endAngle = startAngle + sectorAngleArr[i];\n          prevEndAngle = prevStartAngle + this.prevSectorAngleArr[i];\n          var angle = endAngle < startAngle ? this.fullAngle + endAngle - startAngle : endAngle - startAngle;\n          var pathFill = fill.fillPath({\n            seriesNumber: i,\n            size: this.sliceSizes[i],\n            value: series[i]\n          }); // additionally, pass size for gradient drawing in the fillPath function\n\n          var path = this.getChangedPath(prevStartAngle, prevEndAngle);\n          var elPath = graphics.drawPath({\n            d: path,\n            stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[i] : this.lineColorArr,\n            strokeWidth: 0,\n            fill: pathFill,\n            fillOpacity: w.config.fill.opacity,\n            classes: \"apexcharts-pie-area apexcharts-\".concat(this.chartType.toLowerCase(), \"-slice-\").concat(i)\n          });\n          elPath.attr({\n            index: 0,\n            j: i\n          });\n          filters.setSelectionFilter(elPath, 0, i);\n\n          if (w.config.chart.dropShadow.enabled) {\n            var shadow = w.config.chart.dropShadow;\n            filters.dropShadow(elPath, shadow, i);\n          }\n\n          this.addListeners(elPath, this.donutDataLabels);\n          Graphics.setAttrs(elPath.node, {\n            'data:angle': angle,\n            'data:startAngle': startAngle,\n            'data:strokeWidth': this.strokeWidth,\n            'data:value': series[i]\n          });\n          var labelPosition = {\n            x: 0,\n            y: 0\n          };\n\n          if (this.chartType === 'pie' || this.chartType === 'polarArea') {\n            labelPosition = Utils$1.polarToCartesian(this.centerX, this.centerY, w.globals.radialSize / 1.25 + w.config.plotOptions.pie.dataLabels.offset, (startAngle + angle / 2) % this.fullAngle);\n          } else if (this.chartType === 'donut') {\n            labelPosition = Utils$1.polarToCartesian(this.centerX, this.centerY, (w.globals.radialSize + this.donutSize) / 2 + w.config.plotOptions.pie.dataLabels.offset, (startAngle + angle / 2) % this.fullAngle);\n          }\n\n          elPieArc.add(elPath); // Animation code starts\n\n          var dur = 0;\n\n          if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n            dur = angle / this.fullAngle * w.config.chart.animations.speed;\n            if (dur === 0) dur = 1;\n            this.animDur = dur + this.animDur;\n            this.animBeginArr.push(this.animDur);\n          } else {\n            this.animBeginArr.push(0);\n          }\n\n          if (this.dynamicAnim && w.globals.dataChanged) {\n            this.animatePaths(elPath, {\n              size: this.sliceSizes[i],\n              endAngle: endAngle,\n              startAngle: startAngle,\n              prevStartAngle: prevStartAngle,\n              prevEndAngle: prevEndAngle,\n              animateStartingPos: true,\n              i: i,\n              animBeginArr: this.animBeginArr,\n              shouldSetPrevPaths: true,\n              dur: w.config.chart.animations.dynamicAnimation.speed\n            });\n          } else {\n            this.animatePaths(elPath, {\n              size: this.sliceSizes[i],\n              endAngle: endAngle,\n              startAngle: startAngle,\n              i: i,\n              totalItems: sectorAngleArr.length - 1,\n              animBeginArr: this.animBeginArr,\n              dur: dur\n            });\n          } // animation code ends\n\n\n          if (w.config.plotOptions.pie.expandOnClick && this.chartType !== 'polarArea') {\n            elPath.click(this.pieClicked.bind(this, i));\n          }\n\n          if (typeof w.globals.selectedDataPoints[0] !== 'undefined' && w.globals.selectedDataPoints[0].indexOf(i) > -1) {\n            this.pieClicked(i);\n          }\n\n          if (w.config.dataLabels.enabled) {\n            var xPos = labelPosition.x;\n            var yPos = labelPosition.y;\n            var text = 100 * angle / this.fullAngle + '%';\n\n            if (angle !== 0 && w.config.plotOptions.pie.dataLabels.minAngleToShowLabel < sectorAngleArr[i]) {\n              var formatter = w.config.dataLabels.formatter;\n\n              if (formatter !== undefined) {\n                text = formatter(w.globals.seriesPercent[i][0], {\n                  seriesIndex: i,\n                  w: w\n                });\n              }\n\n              var foreColor = w.globals.dataLabels.style.colors[i];\n              var elPieLabelWrap = graphics.group({\n                class: \"apexcharts-datalabels\"\n              });\n              var elPieLabel = graphics.drawText({\n                x: xPos,\n                y: yPos,\n                text: text,\n                textAnchor: 'middle',\n                fontSize: w.config.dataLabels.style.fontSize,\n                fontFamily: w.config.dataLabels.style.fontFamily,\n                fontWeight: w.config.dataLabels.style.fontWeight,\n                foreColor: foreColor\n              });\n              elPieLabelWrap.add(elPieLabel);\n\n              if (w.config.dataLabels.dropShadow.enabled) {\n                var textShadow = w.config.dataLabels.dropShadow;\n                filters.dropShadow(elPieLabel, textShadow);\n              }\n\n              elPieLabel.node.classList.add('apexcharts-pie-label');\n\n              if (w.config.chart.animations.animate && w.globals.resized === false) {\n                elPieLabel.node.classList.add('apexcharts-pie-label-delay');\n                elPieLabel.node.style.animationDelay = w.config.chart.animations.speed / 940 + 's';\n              }\n\n              this.sliceLabels.push(elPieLabelWrap);\n            }\n          }\n        }\n\n        return g;\n      }\n    }, {\n      key: \"addListeners\",\n      value: function addListeners(elPath, dataLabels) {\n        var graphics = new Graphics(this.ctx); // append filters on mouseenter and mouseleave\n\n        elPath.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elPath));\n        elPath.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elPath));\n        elPath.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, elPath.node, dataLabels));\n        elPath.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elPath));\n\n        if (!this.donutDataLabels.total.showAlways) {\n          elPath.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));\n          elPath.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));\n        }\n      } // This function can be used for other circle charts too\n\n    }, {\n      key: \"animatePaths\",\n      value: function animatePaths(el, opts) {\n        var w = this.w;\n        var me = this;\n        var angle = opts.endAngle < opts.startAngle ? this.fullAngle + opts.endAngle - opts.startAngle : opts.endAngle - opts.startAngle;\n        var prevAngle = angle;\n        var fromStartAngle = opts.startAngle;\n        var toStartAngle = opts.startAngle;\n\n        if (opts.prevStartAngle !== undefined && opts.prevEndAngle !== undefined) {\n          fromStartAngle = opts.prevEndAngle;\n          prevAngle = opts.prevEndAngle < opts.prevStartAngle ? this.fullAngle + opts.prevEndAngle - opts.prevStartAngle : opts.prevEndAngle - opts.prevStartAngle;\n        }\n\n        if (opts.i === w.config.series.length - 1) {\n          // some adjustments for the last overlapping paths\n          if (angle + toStartAngle > this.fullAngle) {\n            opts.endAngle = opts.endAngle - (angle + toStartAngle);\n          } else if (angle + toStartAngle < this.fullAngle) {\n            opts.endAngle = opts.endAngle + (this.fullAngle - (angle + toStartAngle));\n          }\n        }\n\n        if (angle === this.fullAngle) angle = this.fullAngle - 0.01;\n        me.animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts);\n      }\n    }, {\n      key: \"animateArc\",\n      value: function animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts) {\n        var me = this;\n        var w = this.w;\n        var animations = new Animations(this.ctx);\n        var size = opts.size;\n        var path;\n\n        if (isNaN(fromStartAngle) || isNaN(prevAngle)) {\n          fromStartAngle = toStartAngle;\n          prevAngle = angle;\n          opts.dur = 0;\n        }\n\n        var currAngle = angle;\n        var startAngle = toStartAngle;\n        var fromAngle = fromStartAngle < toStartAngle ? this.fullAngle + fromStartAngle - toStartAngle : fromStartAngle - toStartAngle;\n\n        if (w.globals.dataChanged && opts.shouldSetPrevPaths) {\n          // to avoid flicker when updating, set prev path first and then animate from there\n          if (opts.prevEndAngle) {\n            path = me.getPiePath({\n              me: me,\n              startAngle: opts.prevStartAngle,\n              angle: opts.prevEndAngle < opts.prevStartAngle ? this.fullAngle + opts.prevEndAngle - opts.prevStartAngle : opts.prevEndAngle - opts.prevStartAngle,\n              size: size\n            });\n            el.attr({\n              d: path\n            });\n          }\n        }\n\n        if (opts.dur !== 0) {\n          el.animate(opts.dur, w.globals.easing, opts.animBeginArr[opts.i]).afterAll(function () {\n            if (me.chartType === 'pie' || me.chartType === 'donut' || me.chartType === 'polarArea') {\n              this.animate(w.config.chart.animations.dynamicAnimation.speed).attr({\n                'stroke-width': me.strokeWidth\n              });\n            }\n\n            if (opts.i === w.config.series.length - 1) {\n              animations.animationCompleted(el);\n            }\n          }).during(function (pos) {\n            currAngle = fromAngle + (angle - fromAngle) * pos;\n\n            if (opts.animateStartingPos) {\n              currAngle = prevAngle + (angle - prevAngle) * pos;\n              startAngle = fromStartAngle - prevAngle + (toStartAngle - (fromStartAngle - prevAngle)) * pos;\n            }\n\n            path = me.getPiePath({\n              me: me,\n              startAngle: startAngle,\n              angle: currAngle,\n              size: size\n            });\n            el.node.setAttribute('data:pathOrig', path);\n            el.attr({\n              d: path\n            });\n          });\n        } else {\n          path = me.getPiePath({\n            me: me,\n            startAngle: startAngle,\n            angle: angle,\n            size: size\n          });\n\n          if (!opts.isTrack) {\n            w.globals.animationEnded = true;\n          }\n\n          el.node.setAttribute('data:pathOrig', path);\n          el.attr({\n            d: path,\n            'stroke-width': me.strokeWidth\n          });\n        }\n      }\n    }, {\n      key: \"pieClicked\",\n      value: function pieClicked(i) {\n        var w = this.w;\n        var me = this;\n        var path;\n        var size = me.sliceSizes[i] + (w.config.plotOptions.pie.expandOnClick ? 4 : 0);\n        var elPath = w.globals.dom.Paper.select(\".apexcharts-\".concat(me.chartType.toLowerCase(), \"-slice-\").concat(i)).members[0];\n\n        if (elPath.attr('data:pieClicked') === 'true') {\n          elPath.attr({\n            'data:pieClicked': 'false'\n          });\n          this.revertDataLabelsInner(elPath.node, this.donutDataLabels);\n          var origPath = elPath.attr('data:pathOrig');\n          elPath.attr({\n            d: origPath\n          });\n          return;\n        } else {\n          // reset all elems\n          var allEls = w.globals.dom.baseEl.getElementsByClassName('apexcharts-pie-area');\n          Array.prototype.forEach.call(allEls, function (pieSlice) {\n            pieSlice.setAttribute('data:pieClicked', 'false');\n            var origPath = pieSlice.getAttribute('data:pathOrig');\n\n            if (origPath) {\n              pieSlice.setAttribute('d', origPath);\n            }\n          });\n          elPath.attr('data:pieClicked', 'true');\n        }\n\n        var startAngle = parseInt(elPath.attr('data:startAngle'), 10);\n        var angle = parseInt(elPath.attr('data:angle'), 10);\n        path = me.getPiePath({\n          me: me,\n          startAngle: startAngle,\n          angle: angle,\n          size: size\n        });\n        if (angle === 360) return;\n        elPath.plot(path);\n      }\n    }, {\n      key: \"getChangedPath\",\n      value: function getChangedPath(prevStartAngle, prevEndAngle) {\n        var path = '';\n\n        if (this.dynamicAnim && this.w.globals.dataChanged) {\n          path = this.getPiePath({\n            me: this,\n            startAngle: prevStartAngle,\n            angle: prevEndAngle - prevStartAngle,\n            size: this.size\n          });\n        }\n\n        return path;\n      }\n    }, {\n      key: \"getPiePath\",\n      value: function getPiePath(_ref) {\n        var me = _ref.me,\n            startAngle = _ref.startAngle,\n            angle = _ref.angle,\n            size = _ref.size;\n        var path;\n        var startDeg = startAngle;\n        var startRadians = Math.PI * (startDeg - 90) / 180;\n        var endDeg = angle + startAngle; // prevent overlap\n\n        if (Math.ceil(endDeg) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle) {\n          endDeg = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01;\n        }\n\n        if (Math.ceil(endDeg) > this.fullAngle) endDeg -= this.fullAngle;\n        var endRadians = Math.PI * (endDeg - 90) / 180;\n        var x1 = me.centerX + size * Math.cos(startRadians);\n        var y1 = me.centerY + size * Math.sin(startRadians);\n        var x2 = me.centerX + size * Math.cos(endRadians);\n        var y2 = me.centerY + size * Math.sin(endRadians);\n        var startInner = Utils$1.polarToCartesian(me.centerX, me.centerY, me.donutSize, endDeg);\n        var endInner = Utils$1.polarToCartesian(me.centerX, me.centerY, me.donutSize, startDeg);\n        var largeArc = angle > 180 ? 1 : 0;\n        var pathBeginning = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2];\n\n        if (me.chartType === 'donut') {\n          path = [].concat(pathBeginning, ['L', startInner.x, startInner.y, 'A', me.donutSize, me.donutSize, 0, largeArc, 0, endInner.x, endInner.y, 'L', x1, y1, 'z']).join(' ');\n        } else if (me.chartType === 'pie' || me.chartType === 'polarArea') {\n          path = [].concat(pathBeginning, ['L', me.centerX, me.centerY, 'L', x1, y1]).join(' ');\n        } else {\n          path = [].concat(pathBeginning).join(' ');\n        }\n\n        return path;\n      }\n    }, {\n      key: \"drawPolarElements\",\n      value: function drawPolarElements(parent) {\n        var w = this.w;\n        var scale = new Range$1(this.ctx);\n        var graphics = new Graphics(this.ctx);\n        var helpers = new CircularChartsHelpers(this.ctx);\n        var gCircles = graphics.group();\n        var gYAxis = graphics.group();\n        var yScale = scale.niceScale(0, Math.ceil(this.maxY), w.config.yaxis[0].tickAmount, 0, true);\n        var yTexts = yScale.result.reverse();\n        var len = yScale.result.length;\n        this.maxY = yScale.niceMax;\n        var circleSize = w.globals.radialSize;\n        var diff = circleSize / (len - 1);\n\n        for (var i = 0; i < len - 1; i++) {\n          var circle = graphics.drawCircle(circleSize);\n          circle.attr({\n            cx: this.centerX,\n            cy: this.centerY,\n            fill: 'none',\n            'stroke-width': w.config.plotOptions.polarArea.rings.strokeWidth,\n            stroke: w.config.plotOptions.polarArea.rings.strokeColor\n          });\n\n          if (w.config.yaxis[0].show) {\n            var yLabel = helpers.drawYAxisTexts(this.centerX, this.centerY - circleSize + parseInt(w.config.yaxis[0].labels.style.fontSize, 10) / 2, i, yTexts[i]);\n            gYAxis.add(yLabel);\n          }\n\n          gCircles.add(circle);\n          circleSize = circleSize - diff;\n        }\n\n        this.drawSpokes(parent);\n        parent.add(gCircles);\n        parent.add(gYAxis);\n      }\n    }, {\n      key: \"renderInnerDataLabels\",\n      value: function renderInnerDataLabels(dataLabelsConfig, opts) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var g = graphics.group({\n          class: 'apexcharts-datalabels-group',\n          transform: \"translate(\".concat(opts.translateX ? opts.translateX : 0, \", \").concat(opts.translateY ? opts.translateY : 0, \") scale(\").concat(w.config.plotOptions.pie.customScale, \")\")\n        });\n        var showTotal = dataLabelsConfig.total.show;\n        g.node.style.opacity = opts.opacity;\n        var x = opts.centerX;\n        var y = opts.centerY;\n        var labelColor, valueColor;\n\n        if (dataLabelsConfig.name.color === undefined) {\n          labelColor = w.globals.colors[0];\n        } else {\n          labelColor = dataLabelsConfig.name.color;\n        }\n\n        var labelFontSize = dataLabelsConfig.name.fontSize;\n        var labelFontFamily = dataLabelsConfig.name.fontFamily;\n        var labelFontWeight = dataLabelsConfig.name.fontWeight;\n\n        if (dataLabelsConfig.value.color === undefined) {\n          valueColor = w.config.chart.foreColor;\n        } else {\n          valueColor = dataLabelsConfig.value.color;\n        }\n\n        var lbFormatter = dataLabelsConfig.value.formatter;\n        var val = '';\n        var name = '';\n\n        if (showTotal) {\n          labelColor = dataLabelsConfig.total.color;\n          labelFontSize = dataLabelsConfig.total.fontSize;\n          labelFontFamily = dataLabelsConfig.total.fontFamily;\n          labelFontWeight = dataLabelsConfig.total.fontWeight;\n          name = dataLabelsConfig.total.label;\n          val = dataLabelsConfig.total.formatter(w);\n        } else {\n          if (w.globals.series.length === 1) {\n            val = lbFormatter(w.globals.series[0], w);\n            name = w.globals.seriesNames[0];\n          }\n        }\n\n        if (name) {\n          name = dataLabelsConfig.name.formatter(name, dataLabelsConfig.total.show, w);\n        }\n\n        if (dataLabelsConfig.name.show) {\n          var elLabel = graphics.drawText({\n            x: x,\n            y: y + parseFloat(dataLabelsConfig.name.offsetY),\n            text: name,\n            textAnchor: 'middle',\n            foreColor: labelColor,\n            fontSize: labelFontSize,\n            fontWeight: labelFontWeight,\n            fontFamily: labelFontFamily\n          });\n          elLabel.node.classList.add('apexcharts-datalabel-label');\n          g.add(elLabel);\n        }\n\n        if (dataLabelsConfig.value.show) {\n          var valOffset = dataLabelsConfig.name.show ? parseFloat(dataLabelsConfig.value.offsetY) + 16 : dataLabelsConfig.value.offsetY;\n          var elValue = graphics.drawText({\n            x: x,\n            y: y + valOffset,\n            text: val,\n            textAnchor: 'middle',\n            foreColor: valueColor,\n            fontWeight: dataLabelsConfig.value.fontWeight,\n            fontSize: dataLabelsConfig.value.fontSize,\n            fontFamily: dataLabelsConfig.value.fontFamily\n          });\n          elValue.node.classList.add('apexcharts-datalabel-value');\n          g.add(elValue);\n        } // for a multi-series circle chart, we need to show total value instead of first series labels\n\n\n        return g;\n      }\n      /**\n       *\n       * @param {string} name - The name of the series\n       * @param {string} val - The value of that series\n       * @param {object} el - Optional el (indicates which series was hovered/clicked). If this param is not present, means we need to show total\n       */\n\n    }, {\n      key: \"printInnerLabels\",\n      value: function printInnerLabels(labelsConfig, name, val, el) {\n        var w = this.w;\n        var labelColor;\n\n        if (el) {\n          if (labelsConfig.name.color === undefined) {\n            labelColor = w.globals.colors[parseInt(el.parentNode.getAttribute('rel'), 10) - 1];\n          } else {\n            labelColor = labelsConfig.name.color;\n          }\n        } else {\n          if (w.globals.series.length > 1 && labelsConfig.total.show) {\n            labelColor = labelsConfig.total.color;\n          }\n        }\n\n        var elLabel = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label');\n        var elValue = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value');\n        var lbFormatter = labelsConfig.value.formatter;\n        val = lbFormatter(val, w); // we need to show Total Val - so get the formatter of it\n\n        if (!el && typeof labelsConfig.total.formatter === 'function') {\n          val = labelsConfig.total.formatter(w);\n        }\n\n        var isTotal = name === labelsConfig.total.label;\n        name = labelsConfig.name.formatter(name, isTotal, w);\n\n        if (elLabel !== null) {\n          elLabel.textContent = name;\n        }\n\n        if (elValue !== null) {\n          elValue.textContent = val;\n        }\n\n        if (elLabel !== null) {\n          elLabel.style.fill = labelColor;\n        }\n      }\n    }, {\n      key: \"printDataLabelsInner\",\n      value: function printDataLabelsInner(el, dataLabelsConfig) {\n        var w = this.w;\n        var val = el.getAttribute('data:value');\n        var name = w.globals.seriesNames[parseInt(el.parentNode.getAttribute('rel'), 10) - 1];\n\n        if (w.globals.series.length > 1) {\n          this.printInnerLabels(dataLabelsConfig, name, val, el);\n        }\n\n        var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');\n\n        if (dataLabelsGroup !== null) {\n          dataLabelsGroup.style.opacity = 1;\n        }\n      }\n    }, {\n      key: \"drawSpokes\",\n      value: function drawSpokes(parent) {\n        var _this2 = this;\n\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var spokeConfig = w.config.plotOptions.polarArea.spokes;\n        if (spokeConfig.strokeWidth === 0) return;\n        var spokes = [];\n        var angleDivision = 360 / w.globals.series.length;\n\n        for (var i = 0; i < w.globals.series.length; i++) {\n          spokes.push(Utils$1.polarToCartesian(this.centerX, this.centerY, w.globals.radialSize, w.config.plotOptions.pie.startAngle + angleDivision * i));\n        }\n\n        spokes.forEach(function (p, i) {\n          var line = graphics.drawLine(p.x, p.y, _this2.centerX, _this2.centerY, Array.isArray(spokeConfig.connectorColors) ? spokeConfig.connectorColors[i] : spokeConfig.connectorColors);\n          parent.add(line);\n        });\n      }\n    }, {\n      key: \"revertDataLabelsInner\",\n      value: function revertDataLabelsInner(elem, dataLabelsConfig, event) {\n        var _this3 = this;\n\n        var w = this.w;\n        var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');\n        var sliceOut = false;\n        var slices = w.globals.dom.baseEl.getElementsByClassName(\"apexcharts-pie-area\");\n\n        var selectSlice = function selectSlice(_ref2) {\n          var makeSliceOut = _ref2.makeSliceOut,\n              printLabel = _ref2.printLabel;\n          Array.prototype.forEach.call(slices, function (s) {\n            if (s.getAttribute('data:pieClicked') === 'true') {\n              if (makeSliceOut) {\n                sliceOut = true;\n              }\n\n              if (printLabel) {\n                _this3.printDataLabelsInner(s, dataLabelsConfig);\n              }\n            }\n          });\n        };\n\n        selectSlice({\n          makeSliceOut: true,\n          printLabel: false\n        });\n\n        if (dataLabelsConfig.total.show && w.globals.series.length > 1) {\n          if (sliceOut && !dataLabelsConfig.total.showAlways) {\n            selectSlice({\n              makeSliceOut: false,\n              printLabel: true\n            });\n          } else {\n            this.printInnerLabels(dataLabelsConfig, dataLabelsConfig.total.label, dataLabelsConfig.total.formatter(w));\n          }\n        } else {\n          selectSlice({\n            makeSliceOut: false,\n            printLabel: true\n          });\n\n          if (!sliceOut) {\n            if (w.globals.selectedDataPoints.length && w.globals.series.length > 1) {\n              if (w.globals.selectedDataPoints[0].length > 0) {\n                var index = w.globals.selectedDataPoints[0];\n                var el = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(this.chartType.toLowerCase(), \"-slice-\").concat(index));\n                this.printDataLabelsInner(el, dataLabelsConfig);\n              } else if (dataLabelsGroup && w.globals.selectedDataPoints.length && w.globals.selectedDataPoints[0].length === 0) {\n                dataLabelsGroup.style.opacity = 0;\n              }\n            } else {\n              if (dataLabelsGroup && w.globals.series.length > 1) {\n                dataLabelsGroup.style.opacity = 0;\n              }\n            }\n          }\n        }\n      }\n    }]);\n\n    return Pie;\n  }();\n\n  /**\n   * ApexCharts Radar Class for Spider/Radar Charts.\n   * @module Radar\n   **/\n\n  var Radar = /*#__PURE__*/function () {\n    function Radar(ctx) {\n      _classCallCheck(this, Radar);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.chartType = this.w.config.chart.type;\n      this.initialAnim = this.w.config.chart.animations.enabled;\n      this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n      this.animDur = 0;\n      var w = this.w;\n      this.graphics = new Graphics(this.ctx);\n      this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;\n      this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.gridHeight + w.globals.goldenPadding * 1.5 : w.globals.gridWidth;\n      this.isLog = w.config.yaxis[0].logarithmic;\n      this.coreUtils = new CoreUtils(this.ctx);\n      this.maxValue = this.isLog ? this.coreUtils.getLogVal(w.globals.maxY, 0) : w.globals.maxY;\n      this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : w.globals.minY;\n      this.polygons = w.config.plotOptions.radar.polygons;\n      this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;\n      this.size = this.defaultSize / 2.1 - this.strokeWidth - w.config.chart.dropShadow.blur;\n\n      if (w.config.xaxis.labels.show) {\n        this.size = this.size - w.globals.xAxisLabelsWidth / 1.75;\n      }\n\n      if (w.config.plotOptions.radar.size !== undefined) {\n        this.size = w.config.plotOptions.radar.size;\n      }\n\n      this.dataRadiusOfPercent = [];\n      this.dataRadius = [];\n      this.angleArr = [];\n      this.yaxisLabelsTextsPos = [];\n    }\n\n    _createClass(Radar, [{\n      key: \"draw\",\n      value: function draw(series) {\n        var _this = this;\n\n        var w = this.w;\n        var fill = new Fill(this.ctx);\n        var allSeries = [];\n        var dataLabels = new DataLabels(this.ctx);\n\n        if (series.length) {\n          this.dataPointsLen = series[w.globals.maxValsInArrayIndex].length;\n        }\n\n        this.disAngle = Math.PI * 2 / this.dataPointsLen;\n        var halfW = w.globals.gridWidth / 2;\n        var halfH = w.globals.gridHeight / 2;\n        var translateX = halfW + w.config.plotOptions.radar.offsetX;\n        var translateY = halfH + w.config.plotOptions.radar.offsetY;\n        var ret = this.graphics.group({\n          class: 'apexcharts-radar-series apexcharts-plot-series',\n          transform: \"translate(\".concat(translateX || 0, \", \").concat(translateY || 0, \")\")\n        });\n        var dataPointsPos = [];\n        var elPointsMain = null;\n        var elDataPointsMain = null;\n        this.yaxisLabels = this.graphics.group({\n          class: 'apexcharts-yaxis'\n        });\n        series.forEach(function (s, i) {\n          var longestSeries = s.length === w.globals.dataPoints; // el to which series will be drawn\n\n          var elSeries = _this.graphics.group().attr({\n            class: \"apexcharts-series\",\n            'data:longestSeries': longestSeries,\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),\n            rel: i + 1,\n            'data:realIndex': i\n          });\n\n          _this.dataRadiusOfPercent[i] = [];\n          _this.dataRadius[i] = [];\n          _this.angleArr[i] = [];\n          s.forEach(function (dv, j) {\n            var range = Math.abs(_this.maxValue - _this.minValue);\n            dv = dv + Math.abs(_this.minValue);\n\n            if (_this.isLog) {\n              dv = _this.coreUtils.getLogVal(dv, 0);\n            }\n\n            _this.dataRadiusOfPercent[i][j] = dv / range;\n            _this.dataRadius[i][j] = _this.dataRadiusOfPercent[i][j] * _this.size;\n            _this.angleArr[i][j] = j * _this.disAngle;\n          });\n          dataPointsPos = _this.getDataPointsPos(_this.dataRadius[i], _this.angleArr[i]);\n\n          var paths = _this.createPaths(dataPointsPos, {\n            x: 0,\n            y: 0\n          }); // points\n\n\n          elPointsMain = _this.graphics.group({\n            class: 'apexcharts-series-markers-wrap apexcharts-element-hidden'\n          }); // datapoints\n\n          elDataPointsMain = _this.graphics.group({\n            class: \"apexcharts-datalabels\",\n            'data:realIndex': i\n          });\n          w.globals.delayedElements.push({\n            el: elPointsMain.node,\n            index: i\n          });\n          var defaultRenderedPathOptions = {\n            i: i,\n            realIndex: i,\n            animationDelay: i,\n            initialSpeed: w.config.chart.animations.speed,\n            dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n            className: \"apexcharts-radar\",\n            shouldClipToGrid: false,\n            bindEventsOnPaths: false,\n            stroke: w.globals.stroke.colors[i],\n            strokeLineCap: w.config.stroke.lineCap\n          };\n          var pathFrom = null;\n\n          if (w.globals.previousPaths.length > 0) {\n            pathFrom = _this.getPreviousPath(i);\n          }\n\n          for (var p = 0; p < paths.linePathsTo.length; p++) {\n            var renderedLinePath = _this.graphics.renderPaths(_objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {\n              pathFrom: pathFrom === null ? paths.linePathsFrom[p] : pathFrom,\n              pathTo: paths.linePathsTo[p],\n              strokeWidth: Array.isArray(_this.strokeWidth) ? _this.strokeWidth[i] : _this.strokeWidth,\n              fill: 'none',\n              drawShadow: false\n            }));\n\n            elSeries.add(renderedLinePath);\n            var pathFill = fill.fillPath({\n              seriesNumber: i\n            });\n\n            var renderedAreaPath = _this.graphics.renderPaths(_objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {\n              pathFrom: pathFrom === null ? paths.areaPathsFrom[p] : pathFrom,\n              pathTo: paths.areaPathsTo[p],\n              strokeWidth: 0,\n              fill: pathFill,\n              drawShadow: false\n            }));\n\n            if (w.config.chart.dropShadow.enabled) {\n              var filters = new Filters(_this.ctx);\n              var shadow = w.config.chart.dropShadow;\n              filters.dropShadow(renderedAreaPath, Object.assign({}, shadow, {\n                noUserSpaceOnUse: true\n              }), i);\n            }\n\n            elSeries.add(renderedAreaPath);\n          }\n\n          s.forEach(function (sj, j) {\n            var markers = new Markers(_this.ctx);\n            var opts = markers.getMarkerConfig({\n              cssClass: 'apexcharts-marker',\n              seriesIndex: i,\n              dataPointIndex: j\n            });\n\n            var point = _this.graphics.drawMarker(dataPointsPos[j].x, dataPointsPos[j].y, opts);\n\n            point.attr('rel', j);\n            point.attr('j', j);\n            point.attr('index', i);\n            point.node.setAttribute('default-marker-size', opts.pSize);\n\n            var elPointsWrap = _this.graphics.group({\n              class: 'apexcharts-series-markers'\n            });\n\n            if (elPointsWrap) {\n              elPointsWrap.add(point);\n            }\n\n            elPointsMain.add(elPointsWrap);\n            elSeries.add(elPointsMain);\n            var dataLabelsConfig = w.config.dataLabels;\n\n            if (dataLabelsConfig.enabled) {\n              var text = dataLabelsConfig.formatter(w.globals.series[i][j], {\n                seriesIndex: i,\n                dataPointIndex: j,\n                w: w\n              });\n              dataLabels.plotDataLabelsText({\n                x: dataPointsPos[j].x,\n                y: dataPointsPos[j].y,\n                text: text,\n                textAnchor: 'middle',\n                i: i,\n                j: i,\n                parent: elDataPointsMain,\n                offsetCorrection: false,\n                dataLabelsConfig: _objectSpread2({}, dataLabelsConfig)\n              });\n            }\n\n            elSeries.add(elDataPointsMain);\n          });\n          allSeries.push(elSeries);\n        });\n        this.drawPolygons({\n          parent: ret\n        });\n\n        if (w.config.xaxis.labels.show) {\n          var xaxisTexts = this.drawXAxisTexts();\n          ret.add(xaxisTexts);\n        }\n\n        allSeries.forEach(function (elS) {\n          ret.add(elS);\n        });\n        ret.add(this.yaxisLabels);\n        return ret;\n      }\n    }, {\n      key: \"drawPolygons\",\n      value: function drawPolygons(opts) {\n        var _this2 = this;\n\n        var w = this.w;\n        var parent = opts.parent;\n        var helpers = new CircularChartsHelpers(this.ctx);\n        var yaxisTexts = w.globals.yAxisScale[0].result.reverse();\n        var layers = yaxisTexts.length;\n        var radiusSizes = [];\n        var layerDis = this.size / (layers - 1);\n\n        for (var i = 0; i < layers; i++) {\n          radiusSizes[i] = layerDis * i;\n        }\n\n        radiusSizes.reverse();\n        var polygonStrings = [];\n        var lines = [];\n        radiusSizes.forEach(function (radiusSize, r) {\n          var polygon = Utils$1.getPolygonPos(radiusSize, _this2.dataPointsLen);\n          var string = '';\n          polygon.forEach(function (p, i) {\n            if (r === 0) {\n              var line = _this2.graphics.drawLine(p.x, p.y, 0, 0, Array.isArray(_this2.polygons.connectorColors) ? _this2.polygons.connectorColors[i] : _this2.polygons.connectorColors);\n\n              lines.push(line);\n            }\n\n            if (i === 0) {\n              _this2.yaxisLabelsTextsPos.push({\n                x: p.x,\n                y: p.y\n              });\n            }\n\n            string += p.x + ',' + p.y + ' ';\n          });\n          polygonStrings.push(string);\n        });\n        polygonStrings.forEach(function (p, i) {\n          var strokeColors = _this2.polygons.strokeColors;\n          var strokeWidth = _this2.polygons.strokeWidth;\n\n          var polygon = _this2.graphics.drawPolygon(p, Array.isArray(strokeColors) ? strokeColors[i] : strokeColors, Array.isArray(strokeWidth) ? strokeWidth[i] : strokeWidth, w.globals.radarPolygons.fill.colors[i]);\n\n          parent.add(polygon);\n        });\n        lines.forEach(function (l) {\n          parent.add(l);\n        });\n\n        if (w.config.yaxis[0].show) {\n          this.yaxisLabelsTextsPos.forEach(function (p, i) {\n            var yText = helpers.drawYAxisTexts(p.x, p.y, i, yaxisTexts[i]);\n\n            _this2.yaxisLabels.add(yText);\n          });\n        }\n      }\n    }, {\n      key: \"drawXAxisTexts\",\n      value: function drawXAxisTexts() {\n        var _this3 = this;\n\n        var w = this.w;\n        var xaxisLabelsConfig = w.config.xaxis.labels;\n        var elXAxisWrap = this.graphics.group({\n          class: 'apexcharts-xaxis'\n        });\n        var polygonPos = Utils$1.getPolygonPos(this.size, this.dataPointsLen);\n        w.globals.labels.forEach(function (label, i) {\n          var formatter = w.config.xaxis.labels.formatter;\n          var dataLabels = new DataLabels(_this3.ctx);\n\n          if (polygonPos[i]) {\n            var textPos = _this3.getTextPos(polygonPos[i], _this3.size);\n\n            var text = formatter(label, {\n              seriesIndex: -1,\n              dataPointIndex: i,\n              w: w\n            });\n            dataLabels.plotDataLabelsText({\n              x: textPos.newX,\n              y: textPos.newY,\n              text: text,\n              textAnchor: textPos.textAnchor,\n              i: i,\n              j: i,\n              parent: elXAxisWrap,\n              color: Array.isArray(xaxisLabelsConfig.style.colors) && xaxisLabelsConfig.style.colors[i] ? xaxisLabelsConfig.style.colors[i] : '#a8a8a8',\n              dataLabelsConfig: _objectSpread2({\n                textAnchor: textPos.textAnchor,\n                dropShadow: {\n                  enabled: false\n                }\n              }, xaxisLabelsConfig),\n              offsetCorrection: false\n            });\n          }\n        });\n        return elXAxisWrap;\n      }\n    }, {\n      key: \"createPaths\",\n      value: function createPaths(pos, origin) {\n        var _this4 = this;\n\n        var linePathsTo = [];\n        var linePathsFrom = [];\n        var areaPathsTo = [];\n        var areaPathsFrom = [];\n\n        if (pos.length) {\n          linePathsFrom = [this.graphics.move(origin.x, origin.y)];\n          areaPathsFrom = [this.graphics.move(origin.x, origin.y)];\n          var linePathTo = this.graphics.move(pos[0].x, pos[0].y);\n          var areaPathTo = this.graphics.move(pos[0].x, pos[0].y);\n          pos.forEach(function (p, i) {\n            linePathTo += _this4.graphics.line(p.x, p.y);\n            areaPathTo += _this4.graphics.line(p.x, p.y);\n\n            if (i === pos.length - 1) {\n              linePathTo += 'Z';\n              areaPathTo += 'Z';\n            }\n          });\n          linePathsTo.push(linePathTo);\n          areaPathsTo.push(areaPathTo);\n        }\n\n        return {\n          linePathsFrom: linePathsFrom,\n          linePathsTo: linePathsTo,\n          areaPathsFrom: areaPathsFrom,\n          areaPathsTo: areaPathsTo\n        };\n      }\n    }, {\n      key: \"getTextPos\",\n      value: function getTextPos(pos, polygonSize) {\n        var limit = 10;\n        var textAnchor = 'middle';\n        var newX = pos.x;\n        var newY = pos.y;\n\n        if (Math.abs(pos.x) >= limit) {\n          if (pos.x > 0) {\n            textAnchor = 'start';\n            newX += 10;\n          } else if (pos.x < 0) {\n            textAnchor = 'end';\n            newX -= 10;\n          }\n        } else {\n          textAnchor = 'middle';\n        }\n\n        if (Math.abs(pos.y) >= polygonSize - limit) {\n          if (pos.y < 0) {\n            newY -= 10;\n          } else if (pos.y > 0) {\n            newY += 10;\n          }\n        }\n\n        return {\n          textAnchor: textAnchor,\n          newX: newX,\n          newY: newY\n        };\n      }\n    }, {\n      key: \"getPreviousPath\",\n      value: function getPreviousPath(realIndex) {\n        var w = this.w;\n        var pathFrom = null;\n\n        for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n          var gpp = w.globals.previousPaths[pp];\n\n          if (gpp.paths.length > 0 && parseInt(gpp.realIndex, 10) === parseInt(realIndex, 10)) {\n            if (typeof w.globals.previousPaths[pp].paths[0] !== 'undefined') {\n              pathFrom = w.globals.previousPaths[pp].paths[0].d;\n            }\n          }\n        }\n\n        return pathFrom;\n      }\n    }, {\n      key: \"getDataPointsPos\",\n      value: function getDataPointsPos(dataRadiusArr, angleArr) {\n        var dataPointsLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dataPointsLen;\n        dataRadiusArr = dataRadiusArr || [];\n        angleArr = angleArr || [];\n        var dataPointsPosArray = [];\n\n        for (var j = 0; j < dataPointsLen; j++) {\n          var curPointPos = {};\n          curPointPos.x = dataRadiusArr[j] * Math.sin(angleArr[j]);\n          curPointPos.y = -dataRadiusArr[j] * Math.cos(angleArr[j]);\n          dataPointsPosArray.push(curPointPos);\n        }\n\n        return dataPointsPosArray;\n      }\n    }]);\n\n    return Radar;\n  }();\n\n  /**\n   * ApexCharts Radial Class for drawing Circle / Semi Circle Charts.\n   * @module Radial\n   **/\n\n  var Radial = /*#__PURE__*/function (_Pie) {\n    _inherits(Radial, _Pie);\n\n    var _super = _createSuper(Radial);\n\n    function Radial(ctx) {\n      var _this;\n\n      _classCallCheck(this, Radial);\n\n      _this = _super.call(this, ctx);\n      _this.ctx = ctx;\n      _this.w = ctx.w;\n      _this.animBeginArr = [0];\n      _this.animDur = 0;\n      var w = _this.w;\n      _this.startAngle = w.config.plotOptions.radialBar.startAngle;\n      _this.endAngle = w.config.plotOptions.radialBar.endAngle;\n      _this.totalAngle = Math.abs(w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle);\n      _this.trackStartAngle = w.config.plotOptions.radialBar.track.startAngle;\n      _this.trackEndAngle = w.config.plotOptions.radialBar.track.endAngle;\n      _this.donutDataLabels = _this.w.config.plotOptions.radialBar.dataLabels;\n      _this.radialDataLabels = _this.donutDataLabels; // make a copy for easy reference\n\n      if (!_this.trackStartAngle) _this.trackStartAngle = _this.startAngle;\n      if (!_this.trackEndAngle) _this.trackEndAngle = _this.endAngle;\n      if (_this.endAngle === 360) _this.endAngle = 359.99;\n      _this.margin = parseInt(w.config.plotOptions.radialBar.track.margin, 10);\n      return _this;\n    }\n\n    _createClass(Radial, [{\n      key: \"draw\",\n      value: function draw(series) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var ret = graphics.group({\n          class: 'apexcharts-radialbar'\n        });\n        if (w.globals.noData) return ret;\n        var elSeries = graphics.group();\n        var centerY = this.defaultSize / 2;\n        var centerX = w.globals.gridWidth / 2;\n        var size = this.defaultSize / 2.05;\n\n        if (!w.config.chart.sparkline.enabled) {\n          size = size - w.config.stroke.width - w.config.chart.dropShadow.blur;\n        }\n\n        var colorArr = w.globals.fill.colors;\n\n        if (w.config.plotOptions.radialBar.track.show) {\n          var elTracks = this.drawTracks({\n            size: size,\n            centerX: centerX,\n            centerY: centerY,\n            colorArr: colorArr,\n            series: series\n          });\n          elSeries.add(elTracks);\n        }\n\n        var elG = this.drawArcs({\n          size: size,\n          centerX: centerX,\n          centerY: centerY,\n          colorArr: colorArr,\n          series: series\n        });\n        var totalAngle = 360;\n\n        if (w.config.plotOptions.radialBar.startAngle < 0) {\n          totalAngle = this.totalAngle;\n        }\n\n        var angleRatio = (360 - totalAngle) / 360;\n        w.globals.radialSize = size - size * angleRatio;\n\n        if (this.radialDataLabels.value.show) {\n          var offset = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);\n          w.globals.radialSize += offset * angleRatio;\n        }\n\n        elSeries.add(elG.g);\n\n        if (w.config.plotOptions.radialBar.hollow.position === 'front') {\n          elG.g.add(elG.elHollow);\n\n          if (elG.dataLabels) {\n            elG.g.add(elG.dataLabels);\n          }\n        }\n\n        ret.add(elSeries);\n        return ret;\n      }\n    }, {\n      key: \"drawTracks\",\n      value: function drawTracks(opts) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var g = graphics.group({\n          class: 'apexcharts-tracks'\n        });\n        var filters = new Filters(this.ctx);\n        var fill = new Fill(this.ctx);\n        var strokeWidth = this.getStrokeWidth(opts);\n        opts.size = opts.size - strokeWidth / 2;\n\n        for (var i = 0; i < opts.series.length; i++) {\n          var elRadialBarTrack = graphics.group({\n            class: 'apexcharts-radialbar-track apexcharts-track'\n          });\n          g.add(elRadialBarTrack);\n          elRadialBarTrack.attr({\n            rel: i + 1\n          });\n          opts.size = opts.size - strokeWidth - this.margin;\n          var trackConfig = w.config.plotOptions.radialBar.track;\n          var pathFill = fill.fillPath({\n            seriesNumber: 0,\n            size: opts.size,\n            fillColors: Array.isArray(trackConfig.background) ? trackConfig.background[i] : trackConfig.background,\n            solid: true\n          });\n          var startAngle = this.trackStartAngle;\n          var endAngle = this.trackEndAngle;\n          if (Math.abs(endAngle) + Math.abs(startAngle) >= 360) endAngle = 360 - Math.abs(this.startAngle) - 0.1;\n          var elPath = graphics.drawPath({\n            d: '',\n            stroke: pathFill,\n            strokeWidth: strokeWidth * parseInt(trackConfig.strokeWidth, 10) / 100,\n            fill: 'none',\n            strokeOpacity: trackConfig.opacity,\n            classes: 'apexcharts-radialbar-area'\n          });\n\n          if (trackConfig.dropShadow.enabled) {\n            var shadow = trackConfig.dropShadow;\n            filters.dropShadow(elPath, shadow);\n          }\n\n          elRadialBarTrack.add(elPath);\n          elPath.attr('id', 'apexcharts-radialbarTrack-' + i);\n          this.animatePaths(elPath, {\n            centerX: opts.centerX,\n            centerY: opts.centerY,\n            endAngle: endAngle,\n            startAngle: startAngle,\n            size: opts.size,\n            i: i,\n            totalItems: 2,\n            animBeginArr: 0,\n            dur: 0,\n            isTrack: true,\n            easing: w.globals.easing\n          });\n        }\n\n        return g;\n      }\n    }, {\n      key: \"drawArcs\",\n      value: function drawArcs(opts) {\n        var w = this.w; // size, donutSize, centerX, centerY, colorArr, lineColorArr, sectorAngleArr, series\n\n        var graphics = new Graphics(this.ctx);\n        var fill = new Fill(this.ctx);\n        var filters = new Filters(this.ctx);\n        var g = graphics.group();\n        var strokeWidth = this.getStrokeWidth(opts);\n        opts.size = opts.size - strokeWidth / 2;\n        var hollowFillID = w.config.plotOptions.radialBar.hollow.background;\n        var hollowSize = opts.size - strokeWidth * opts.series.length - this.margin * opts.series.length - strokeWidth * parseInt(w.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2;\n        var hollowRadius = hollowSize - w.config.plotOptions.radialBar.hollow.margin;\n\n        if (w.config.plotOptions.radialBar.hollow.image !== undefined) {\n          hollowFillID = this.drawHollowImage(opts, g, hollowSize, hollowFillID);\n        }\n\n        var elHollow = this.drawHollow({\n          size: hollowRadius,\n          centerX: opts.centerX,\n          centerY: opts.centerY,\n          fill: hollowFillID ? hollowFillID : 'transparent'\n        });\n\n        if (w.config.plotOptions.radialBar.hollow.dropShadow.enabled) {\n          var shadow = w.config.plotOptions.radialBar.hollow.dropShadow;\n          filters.dropShadow(elHollow, shadow);\n        }\n\n        var shown = 1;\n\n        if (!this.radialDataLabels.total.show && w.globals.series.length > 1) {\n          shown = 0;\n        }\n\n        var dataLabels = null;\n\n        if (this.radialDataLabels.show) {\n          dataLabels = this.renderInnerDataLabels(this.radialDataLabels, {\n            hollowSize: hollowSize,\n            centerX: opts.centerX,\n            centerY: opts.centerY,\n            opacity: shown\n          });\n        }\n\n        if (w.config.plotOptions.radialBar.hollow.position === 'back') {\n          g.add(elHollow);\n\n          if (dataLabels) {\n            g.add(dataLabels);\n          }\n        }\n\n        var reverseLoop = false;\n\n        if (w.config.plotOptions.radialBar.inverseOrder) {\n          reverseLoop = true;\n        }\n\n        for (var i = reverseLoop ? opts.series.length - 1 : 0; reverseLoop ? i >= 0 : i < opts.series.length; reverseLoop ? i-- : i++) {\n          var elRadialBarArc = graphics.group({\n            class: \"apexcharts-series apexcharts-radial-series\",\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[i])\n          });\n          g.add(elRadialBarArc);\n          elRadialBarArc.attr({\n            rel: i + 1,\n            'data:realIndex': i\n          });\n          this.ctx.series.addCollapsedClassToSeries(elRadialBarArc, i);\n          opts.size = opts.size - strokeWidth - this.margin;\n          var pathFill = fill.fillPath({\n            seriesNumber: i,\n            size: opts.size,\n            value: opts.series[i]\n          });\n          var startAngle = this.startAngle;\n          var prevStartAngle = void 0; // if data exceeds 100, make it 100\n\n          var dataValue = Utils$1.negToZero(opts.series[i] > 100 ? 100 : opts.series[i]) / 100;\n          var endAngle = Math.round(this.totalAngle * dataValue) + this.startAngle;\n          var prevEndAngle = void 0;\n\n          if (w.globals.dataChanged) {\n            prevStartAngle = this.startAngle;\n            prevEndAngle = Math.round(this.totalAngle * Utils$1.negToZero(w.globals.previousPaths[i]) / 100) + prevStartAngle;\n          }\n\n          var currFullAngle = Math.abs(endAngle) + Math.abs(startAngle);\n\n          if (currFullAngle >= 360) {\n            endAngle = endAngle - 0.01;\n          }\n\n          var prevFullAngle = Math.abs(prevEndAngle) + Math.abs(prevStartAngle);\n\n          if (prevFullAngle >= 360) {\n            prevEndAngle = prevEndAngle - 0.01;\n          }\n\n          var angle = endAngle - startAngle;\n          var dashArray = Array.isArray(w.config.stroke.dashArray) ? w.config.stroke.dashArray[i] : w.config.stroke.dashArray;\n          var elPath = graphics.drawPath({\n            d: '',\n            stroke: pathFill,\n            strokeWidth: strokeWidth,\n            fill: 'none',\n            fillOpacity: w.config.fill.opacity,\n            classes: 'apexcharts-radialbar-area apexcharts-radialbar-slice-' + i,\n            strokeDashArray: dashArray\n          });\n          Graphics.setAttrs(elPath.node, {\n            'data:angle': angle,\n            'data:value': opts.series[i]\n          });\n\n          if (w.config.chart.dropShadow.enabled) {\n            var _shadow = w.config.chart.dropShadow;\n            filters.dropShadow(elPath, _shadow, i);\n          }\n\n          filters.setSelectionFilter(elPath, 0, i);\n          this.addListeners(elPath, this.radialDataLabels);\n          elRadialBarArc.add(elPath);\n          elPath.attr({\n            index: 0,\n            j: i\n          });\n          var dur = 0;\n\n          if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n            dur = w.config.chart.animations.speed;\n          }\n\n          if (w.globals.dataChanged) {\n            dur = w.config.chart.animations.dynamicAnimation.speed;\n          }\n\n          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;\n          this.animBeginArr.push(this.animDur);\n          this.animatePaths(elPath, {\n            centerX: opts.centerX,\n            centerY: opts.centerY,\n            endAngle: endAngle,\n            startAngle: startAngle,\n            prevEndAngle: prevEndAngle,\n            prevStartAngle: prevStartAngle,\n            size: opts.size,\n            i: i,\n            totalItems: 2,\n            animBeginArr: this.animBeginArr,\n            dur: dur,\n            shouldSetPrevPaths: true,\n            easing: w.globals.easing\n          });\n        }\n\n        return {\n          g: g,\n          elHollow: elHollow,\n          dataLabels: dataLabels\n        };\n      }\n    }, {\n      key: \"drawHollow\",\n      value: function drawHollow(opts) {\n        var graphics = new Graphics(this.ctx);\n        var circle = graphics.drawCircle(opts.size * 2);\n        circle.attr({\n          class: 'apexcharts-radialbar-hollow',\n          cx: opts.centerX,\n          cy: opts.centerY,\n          r: opts.size,\n          fill: opts.fill\n        });\n        return circle;\n      }\n    }, {\n      key: \"drawHollowImage\",\n      value: function drawHollowImage(opts, g, hollowSize, hollowFillID) {\n        var w = this.w;\n        var fill = new Fill(this.ctx);\n        var randID = Utils$1.randomId();\n        var hollowFillImg = w.config.plotOptions.radialBar.hollow.image;\n\n        if (w.config.plotOptions.radialBar.hollow.imageClipped) {\n          fill.clippedImgArea({\n            width: hollowSize,\n            height: hollowSize,\n            image: hollowFillImg,\n            patternID: \"pattern\".concat(w.globals.cuid).concat(randID)\n          });\n          hollowFillID = \"url(#pattern\".concat(w.globals.cuid).concat(randID, \")\");\n        } else {\n          var imgWidth = w.config.plotOptions.radialBar.hollow.imageWidth;\n          var imgHeight = w.config.plotOptions.radialBar.hollow.imageHeight;\n\n          if (imgWidth === undefined && imgHeight === undefined) {\n            var image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {\n              this.move(opts.centerX - loader.width / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - loader.height / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);\n            });\n            g.add(image);\n          } else {\n            var _image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {\n              this.move(opts.centerX - imgWidth / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - imgHeight / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);\n              this.size(imgWidth, imgHeight);\n            });\n\n            g.add(_image);\n          }\n        }\n\n        return hollowFillID;\n      }\n    }, {\n      key: \"getStrokeWidth\",\n      value: function getStrokeWidth(opts) {\n        var w = this.w;\n        return opts.size * (100 - parseInt(w.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (opts.series.length + 1) - this.margin;\n      }\n    }]);\n\n    return Radial;\n  }(Pie);\n\n  /**\n   * ApexCharts RangeBar Class responsible for drawing Range/Timeline Bars.\n   *\n   * @module RangeBar\n   **/\n\n  var RangeBar = /*#__PURE__*/function (_Bar) {\n    _inherits(RangeBar, _Bar);\n\n    var _super = _createSuper(RangeBar);\n\n    function RangeBar() {\n      _classCallCheck(this, RangeBar);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(RangeBar, [{\n      key: \"draw\",\n      value: function draw(series, seriesIndex) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        this.rangeBarOptions = this.w.config.plotOptions.rangeBar;\n        this.series = series;\n        this.seriesRangeStart = w.globals.seriesRangeStart;\n        this.seriesRangeEnd = w.globals.seriesRangeEnd;\n        this.barHelpers.initVariables(series);\n        var ret = graphics.group({\n          class: 'apexcharts-rangebar-series apexcharts-plot-series'\n        });\n\n        for (var i = 0; i < series.length; i++) {\n          var x = void 0,\n              y = void 0,\n              xDivision = void 0,\n              // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n          yDivision = void 0,\n              // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n          zeroH = void 0,\n              // zeroH is the baseline where 0 meets y axis\n          zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n          var elSeries = graphics.group({\n            class: \"apexcharts-series\",\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),\n            rel: i + 1,\n            'data:realIndex': realIndex\n          });\n          this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);\n\n          if (series[i].length > 0) {\n            this.visibleI = this.visibleI + 1;\n          }\n\n          var barHeight = 0;\n          var barWidth = 0;\n\n          if (this.yRatio.length > 1) {\n            this.yaxisIndex = realIndex;\n          }\n\n          var initPositions = this.barHelpers.initialPositions();\n          y = initPositions.y;\n          zeroW = initPositions.zeroW;\n          x = initPositions.x;\n          barWidth = initPositions.barWidth;\n          barHeight = initPositions.barHeight;\n          xDivision = initPositions.xDivision;\n          yDivision = initPositions.yDivision;\n          zeroH = initPositions.zeroH; // eldatalabels\n\n          var elDataLabelsWrap = graphics.group({\n            class: 'apexcharts-datalabels',\n            'data:realIndex': realIndex\n          });\n          var elGoalsMarkers = graphics.group({\n            class: 'apexcharts-rangebar-goals-markers'\n          });\n\n          for (var j = 0; j < w.globals.dataPoints; j++) {\n            var _this$renderSeries;\n\n            var strokeWidth = this.barHelpers.getStrokeWidth(i, j, realIndex);\n            var y1 = this.seriesRangeStart[i][j];\n            var y2 = this.seriesRangeEnd[i][j];\n            var paths = null;\n            var barXPosition = null;\n            var barYPosition = null;\n            var params = {\n              x: x,\n              y: y,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            };\n            var seriesLen = this.seriesLen;\n\n            if (w.config.plotOptions.bar.rangeBarGroupRows) {\n              seriesLen = 1;\n            }\n\n            if (typeof w.config.series[i].data[j] === 'undefined') {\n              // no data exists for further indexes, hence we need to get out the innr loop.\n              // As we are iterating over total datapoints, there is a possiblity the series might not have data for j index\n              break;\n            }\n\n            if (this.isHorizontal) {\n              barYPosition = y + barHeight * this.visibleI;\n              var srty = (yDivision - barHeight * seriesLen) / 2;\n\n              if (w.config.series[i].data[j].x) {\n                var positions = this.detectOverlappingBars({\n                  i: i,\n                  j: j,\n                  barYPosition: barYPosition,\n                  srty: srty,\n                  barHeight: barHeight,\n                  yDivision: yDivision,\n                  initPositions: initPositions\n                });\n                barHeight = positions.barHeight;\n                barYPosition = positions.barYPosition;\n              }\n\n              paths = this.drawRangeBarPaths(_objectSpread2({\n                indexes: {\n                  i: i,\n                  j: j,\n                  realIndex: realIndex\n                },\n                barHeight: barHeight,\n                barYPosition: barYPosition,\n                zeroW: zeroW,\n                yDivision: yDivision,\n                y1: y1,\n                y2: y2\n              }, params));\n              barWidth = paths.barWidth;\n            } else {\n              if (w.globals.isXNumeric) {\n                x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;\n              }\n\n              barXPosition = x + barWidth * this.visibleI;\n              var srtx = (xDivision - barWidth * seriesLen) / 2;\n\n              if (w.config.series[i].data[j].x) {\n                var _positions = this.detectOverlappingBars({\n                  i: i,\n                  j: j,\n                  barXPosition: barXPosition,\n                  srtx: srtx,\n                  barWidth: barWidth,\n                  xDivision: xDivision,\n                  initPositions: initPositions\n                });\n\n                barWidth = _positions.barWidth;\n                barXPosition = _positions.barXPosition;\n              }\n\n              paths = this.drawRangeColumnPaths(_objectSpread2({\n                indexes: {\n                  i: i,\n                  j: j,\n                  realIndex: realIndex\n                },\n                barWidth: barWidth,\n                barXPosition: barXPosition,\n                zeroH: zeroH,\n                xDivision: xDivision\n              }, params));\n              barHeight = paths.barHeight;\n            }\n\n            var barGoalLine = this.barHelpers.drawGoalLine({\n              barXPosition: paths.barXPosition,\n              barYPosition: barYPosition,\n              goalX: paths.goalX,\n              goalY: paths.goalY,\n              barHeight: barHeight,\n              barWidth: barWidth\n            });\n\n            if (barGoalLine) {\n              elGoalsMarkers.add(barGoalLine);\n            }\n\n            y = paths.y;\n            x = paths.x;\n            var pathFill = this.barHelpers.getPathFillColor(series, i, j, realIndex);\n            var lineFill = w.globals.stroke.colors[realIndex];\n            this.renderSeries((_this$renderSeries = {\n              realIndex: realIndex,\n              pathFill: pathFill,\n              lineFill: lineFill,\n              j: j,\n              i: i,\n              x: x,\n              y: y,\n              y1: y1,\n              y2: y2,\n              pathFrom: paths.pathFrom,\n              pathTo: paths.pathTo,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries,\n              series: series,\n              barHeight: barHeight,\n              barWidth: barWidth,\n              barXPosition: barXPosition,\n              barYPosition: barYPosition\n            }, _defineProperty(_this$renderSeries, \"barWidth\", barWidth), _defineProperty(_this$renderSeries, \"elDataLabelsWrap\", elDataLabelsWrap), _defineProperty(_this$renderSeries, \"elGoalsMarkers\", elGoalsMarkers), _defineProperty(_this$renderSeries, \"visibleSeries\", this.visibleI), _defineProperty(_this$renderSeries, \"type\", 'rangebar'), _this$renderSeries));\n          }\n\n          ret.add(elSeries);\n        }\n\n        return ret;\n      }\n    }, {\n      key: \"detectOverlappingBars\",\n      value: function detectOverlappingBars(_ref) {\n        var i = _ref.i,\n            j = _ref.j,\n            barYPosition = _ref.barYPosition,\n            barXPosition = _ref.barXPosition,\n            srty = _ref.srty,\n            srtx = _ref.srtx,\n            barHeight = _ref.barHeight,\n            barWidth = _ref.barWidth,\n            yDivision = _ref.yDivision,\n            xDivision = _ref.xDivision,\n            initPositions = _ref.initPositions;\n        var w = this.w;\n        var overlaps = [];\n        var rangeName = w.config.series[i].data[j].rangeName;\n        var x = w.config.series[i].data[j].x;\n        var labelX = Array.isArray(x) ? x.join(' ') : x;\n        var rowIndex = w.globals.labels.map(function (_) {\n          return Array.isArray(_) ? _.join(' ') : _;\n        }).indexOf(labelX);\n        var overlappedIndex = w.globals.seriesRange[i].findIndex(function (tx) {\n          return tx.x === labelX && tx.overlaps.length > 0;\n        });\n\n        if (this.isHorizontal) {\n          if (w.config.plotOptions.bar.rangeBarGroupRows) {\n            barYPosition = srty + yDivision * rowIndex;\n          } else {\n            barYPosition = srty + barHeight * this.visibleI + yDivision * rowIndex;\n          }\n\n          if (overlappedIndex > -1 && !w.config.plotOptions.bar.rangeBarOverlap) {\n            overlaps = w.globals.seriesRange[i][overlappedIndex].overlaps;\n\n            if (overlaps.indexOf(rangeName) > -1) {\n              barHeight = initPositions.barHeight / overlaps.length;\n              barYPosition = barHeight * this.visibleI + yDivision * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + barHeight * (this.visibleI + overlaps.indexOf(rangeName)) + yDivision * rowIndex;\n            }\n          }\n        } else {\n          if (rowIndex > -1) {\n            if (w.config.plotOptions.bar.rangeBarGroupRows) {\n              barXPosition = srtx + xDivision * rowIndex;\n            } else {\n              barXPosition = srtx + barWidth * this.visibleI + xDivision * rowIndex;\n            }\n          }\n\n          if (overlappedIndex > -1 && !w.config.plotOptions.bar.rangeBarOverlap) {\n            overlaps = w.globals.seriesRange[i][overlappedIndex].overlaps;\n\n            if (overlaps.indexOf(rangeName) > -1) {\n              barWidth = initPositions.barWidth / overlaps.length;\n              barXPosition = barWidth * this.visibleI + xDivision * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + barWidth * (this.visibleI + overlaps.indexOf(rangeName)) + xDivision * rowIndex;\n            }\n          }\n        }\n\n        return {\n          barYPosition: barYPosition,\n          barXPosition: barXPosition,\n          barHeight: barHeight,\n          barWidth: barWidth\n        };\n      }\n    }, {\n      key: \"drawRangeColumnPaths\",\n      value: function drawRangeColumnPaths(_ref2) {\n        var indexes = _ref2.indexes,\n            x = _ref2.x,\n            xDivision = _ref2.xDivision,\n            barWidth = _ref2.barWidth,\n            barXPosition = _ref2.barXPosition,\n            zeroH = _ref2.zeroH;\n        var w = this.w;\n        var i = indexes.i;\n        var j = indexes.j;\n        var yRatio = this.yRatio[this.yaxisIndex];\n        var realIndex = indexes.realIndex;\n        var range = this.getRangeValue(realIndex, j);\n        var y1 = Math.min(range.start, range.end);\n        var y2 = Math.max(range.start, range.end);\n\n        if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n          y1 = zeroH;\n        } else {\n          y1 = zeroH - y1 / yRatio;\n          y2 = zeroH - y2 / yRatio;\n        }\n\n        var barHeight = Math.abs(y2 - y1);\n        var paths = this.barHelpers.getColumnPaths({\n          barXPosition: barXPosition,\n          barWidth: barWidth,\n          y1: y1,\n          y2: y2,\n          strokeWidth: this.strokeWidth,\n          series: this.seriesRangeEnd,\n          realIndex: indexes.realIndex,\n          i: realIndex,\n          j: j,\n          w: w\n        });\n\n        if (!w.globals.isXNumeric) {\n          x = x + xDivision;\n        }\n\n        return {\n          pathTo: paths.pathTo,\n          pathFrom: paths.pathFrom,\n          barHeight: barHeight,\n          x: x,\n          y: y2,\n          goalY: this.barHelpers.getGoalValues('y', null, zeroH, i, j),\n          barXPosition: barXPosition\n        };\n      }\n    }, {\n      key: \"drawRangeBarPaths\",\n      value: function drawRangeBarPaths(_ref3) {\n        var indexes = _ref3.indexes,\n            y = _ref3.y,\n            y1 = _ref3.y1,\n            y2 = _ref3.y2,\n            yDivision = _ref3.yDivision,\n            barHeight = _ref3.barHeight,\n            barYPosition = _ref3.barYPosition,\n            zeroW = _ref3.zeroW;\n        var w = this.w;\n        var x1 = zeroW + y1 / this.invertedYRatio;\n        var x2 = zeroW + y2 / this.invertedYRatio;\n        var barWidth = Math.abs(x2 - x1);\n        var paths = this.barHelpers.getBarpaths({\n          barYPosition: barYPosition,\n          barHeight: barHeight,\n          x1: x1,\n          x2: x2,\n          strokeWidth: this.strokeWidth,\n          series: this.seriesRangeEnd,\n          i: indexes.realIndex,\n          realIndex: indexes.realIndex,\n          j: indexes.j,\n          w: w\n        });\n\n        if (!w.globals.isXNumeric) {\n          y = y + yDivision;\n        }\n\n        return {\n          pathTo: paths.pathTo,\n          pathFrom: paths.pathFrom,\n          barWidth: barWidth,\n          x: x2,\n          goalX: this.barHelpers.getGoalValues('x', zeroW, null, indexes.realIndex, indexes.j),\n          y: y\n        };\n      }\n    }, {\n      key: \"getRangeValue\",\n      value: function getRangeValue(i, j) {\n        var w = this.w;\n        return {\n          start: w.globals.seriesRangeStart[i][j],\n          end: w.globals.seriesRangeEnd[i][j]\n        };\n      }\n    }]);\n\n    return RangeBar;\n  }(Bar);\n\n  var Helpers = /*#__PURE__*/function () {\n    function Helpers(lineCtx) {\n      _classCallCheck(this, Helpers);\n\n      this.w = lineCtx.w;\n      this.lineCtx = lineCtx;\n    }\n\n    _createClass(Helpers, [{\n      key: \"sameValueSeriesFix\",\n      value: function sameValueSeriesFix(i, series) {\n        var w = this.w;\n\n        if (w.config.fill.type === 'gradient' || w.config.fill.type[i] === 'gradient') {\n          var coreUtils = new CoreUtils(this.lineCtx.ctx, w); // applied only to LINE chart\n          // a small adjustment to allow gradient line to draw correctly for all same values\n\n          /* #fix https://github.com/apexcharts/apexcharts.js/issues/358 */\n\n          if (coreUtils.seriesHaveSameValues(i)) {\n            var gSeries = series[i].slice();\n            gSeries[gSeries.length - 1] = gSeries[gSeries.length - 1] + 0.000001;\n            series[i] = gSeries;\n          }\n        }\n\n        return series;\n      }\n    }, {\n      key: \"calculatePoints\",\n      value: function calculatePoints(_ref) {\n        var series = _ref.series,\n            realIndex = _ref.realIndex,\n            x = _ref.x,\n            y = _ref.y,\n            i = _ref.i,\n            j = _ref.j,\n            prevY = _ref.prevY;\n        var w = this.w;\n        var ptX = [];\n        var ptY = [];\n\n        if (j === 0) {\n          var xPT1st = this.lineCtx.categoryAxisCorrection + w.config.markers.offsetX; // the first point for line series\n          // we need to check whether it's not a time series, because a time series may\n          // start from the middle of the x axis\n\n          if (w.globals.isXNumeric) {\n            xPT1st = (w.globals.seriesX[realIndex][0] - w.globals.minX) / this.lineCtx.xRatio + w.config.markers.offsetX;\n          } // push 2 points for the first data values\n\n\n          ptX.push(xPT1st);\n          ptY.push(Utils$1.isNumber(series[i][0]) ? prevY + w.config.markers.offsetY : null);\n          ptX.push(x + w.config.markers.offsetX);\n          ptY.push(Utils$1.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);\n        } else {\n          ptX.push(x + w.config.markers.offsetX);\n          ptY.push(Utils$1.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);\n        }\n\n        var pointsPos = {\n          x: ptX,\n          y: ptY\n        };\n        return pointsPos;\n      }\n    }, {\n      key: \"checkPreviousPaths\",\n      value: function checkPreviousPaths(_ref2) {\n        var pathFromLine = _ref2.pathFromLine,\n            pathFromArea = _ref2.pathFromArea,\n            realIndex = _ref2.realIndex;\n        var w = this.w;\n\n        for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n          var gpp = w.globals.previousPaths[pp];\n\n          if ((gpp.type === 'line' || gpp.type === 'area') && gpp.paths.length > 0 && parseInt(gpp.realIndex, 10) === parseInt(realIndex, 10)) {\n            if (gpp.type === 'line') {\n              this.lineCtx.appendPathFrom = false;\n              pathFromLine = w.globals.previousPaths[pp].paths[0].d;\n            } else if (gpp.type === 'area') {\n              this.lineCtx.appendPathFrom = false;\n              pathFromArea = w.globals.previousPaths[pp].paths[0].d;\n\n              if (w.config.stroke.show && w.globals.previousPaths[pp].paths[1]) {\n                pathFromLine = w.globals.previousPaths[pp].paths[1].d;\n              }\n            }\n          }\n        }\n\n        return {\n          pathFromLine: pathFromLine,\n          pathFromArea: pathFromArea\n        };\n      }\n    }, {\n      key: \"determineFirstPrevY\",\n      value: function determineFirstPrevY(_ref3) {\n        var _series$i;\n\n        var i = _ref3.i,\n            series = _ref3.series,\n            prevY = _ref3.prevY,\n            lineYPosition = _ref3.lineYPosition;\n        var w = this.w;\n\n        if (typeof ((_series$i = series[i]) === null || _series$i === void 0 ? void 0 : _series$i[0]) !== 'undefined') {\n          if (w.config.chart.stacked) {\n            if (i > 0) {\n              // 1st y value of previous series\n              lineYPosition = this.lineCtx.prevSeriesY[i - 1][0];\n            } else {\n              // the first series will not have prevY values\n              lineYPosition = this.lineCtx.zeroY;\n            }\n          } else {\n            lineYPosition = this.lineCtx.zeroY;\n          }\n\n          prevY = lineYPosition - series[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + (this.lineCtx.isReversed ? series[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0) * 2;\n        } else {\n          // the first value in the current series is null\n          if (w.config.chart.stacked && i > 0 && typeof series[i][0] === 'undefined') {\n            // check for undefined value (undefined value will occur when we clear the series while user clicks on legend to hide serieses)\n            for (var s = i - 1; s >= 0; s--) {\n              // for loop to get to 1st previous value until we get it\n              if (series[s][0] !== null && typeof series[s][0] !== 'undefined') {\n                lineYPosition = this.lineCtx.prevSeriesY[s][0];\n                prevY = lineYPosition;\n                break;\n              }\n            }\n          }\n        }\n\n        return {\n          prevY: prevY,\n          lineYPosition: lineYPosition\n        };\n      }\n    }]);\n\n    return Helpers;\n  }();\n\n  /**\n   *\n   * @yr/monotone-cubic-spline (https://github.com/YR/monotone-cubic-spline)\n   *\n   * The MIT License (MIT)\n   *\n   * Copyright (c) 2015 yr.no\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy of\n   * this software and associated documentation files (the \"Software\"), to deal in\n   * the Software without restriction, including without limitation the rights to\n   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n   * the Software, and to permit persons to whom the Software is furnished to do so,\n   * subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in all\n   * copies or substantial portions of the Software.\n\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n   */\n\n  /**\n   * Generate tangents for 'points'\n   * @param {Array} points\n   * @returns {Array}\n   */\n  var tangents = function tangents(points) {\n    var m = finiteDifferences(points);\n    var n = points.length - 1;\n    var ε = 1e-6;\n    var tgts = [];\n    var a, b, d, s;\n\n    for (var i = 0; i < n; i++) {\n      d = slope(points[i], points[i + 1]);\n\n      if (Math.abs(d) < ε) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n\n    for (var _i = 0; _i <= n; _i++) {\n      s = (points[Math.min(n, _i + 1)][0] - points[Math.max(0, _i - 1)][0]) / (6 * (1 + m[_i] * m[_i]));\n      tgts.push([s || 0, m[_i] * s || 0]);\n    }\n\n    return tgts;\n  };\n  /**\n   * Convert 'points' to svg path\n   * @param {Array} points\n   * @returns {String}\n   */\n\n  var svgPath = function svgPath(points) {\n    var p = '';\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var n = point.length;\n\n      if (n > 4) {\n        p += \"C\".concat(point[0], \", \").concat(point[1]);\n        p += \", \".concat(point[2], \", \").concat(point[3]);\n        p += \", \".concat(point[4], \", \").concat(point[5]);\n      } else if (n > 2) {\n        p += \"S\".concat(point[0], \", \").concat(point[1]);\n        p += \", \".concat(point[2], \", \").concat(point[3]);\n      }\n    }\n\n    return p;\n  };\n  var spline = {\n    /**\n     * Convert 'points' to bezier\n     * @param {Array} points\n     * @returns {Array}\n     */\n    points: function points(_points) {\n      var tgts = tangents(_points);\n      var p = _points[1];\n      var p0 = _points[0];\n      var pts = [];\n      var t = tgts[1];\n      var t0 = tgts[0]; // Add starting 'M' and 'C' points\n\n      pts.push(p0, [p0[0] + t0[0], p0[1] + t0[1], p[0] - t[0], p[1] - t[1], p[0], p[1]]); // Add 'S' points\n\n      for (var i = 2, n = tgts.length; i < n; i++) {\n        var _p = _points[i];\n        var _t = tgts[i];\n        pts.push([_p[0] - _t[0], _p[1] - _t[1], _p[0], _p[1]]);\n      }\n\n      return pts;\n    },\n\n    /**\n     * Slice out a segment of 'points'\n     * @param {Array} points\n     * @param {Number} start\n     * @param {Number} end\n     * @returns {Array}\n     */\n    slice: function slice(points, start, end) {\n      var pts = points.slice(start, end);\n\n      if (start) {\n        // Add additional 'C' points\n        if (pts[1].length < 6) {\n          var n = pts[0].length;\n          pts[1] = [pts[0][n - 2] * 2 - pts[0][n - 4], pts[0][n - 1] * 2 - pts[0][n - 3]].concat(pts[1]);\n        } // Remove control points for 'M'\n\n\n        pts[0] = pts[0].slice(-2);\n      }\n\n      return pts;\n    }\n  };\n  /**\n   * Compute slope from point 'p0' to 'p1'\n   * @param {Array} p0\n   * @param {Array} p1\n   * @returns {Number}\n   */\n\n  function slope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n  /**\n   * Compute three-point differences for 'points'\n   * @param {Array} points\n   * @returns {Array}\n   */\n\n\n  function finiteDifferences(points) {\n    var m = [];\n    var p0 = points[0];\n    var p1 = points[1];\n    var d = m[0] = slope(p0, p1);\n    var i = 1;\n\n    for (var n = points.length - 1; i < n; i++) {\n      p0 = p1;\n      p1 = points[i + 1];\n      m[i] = (d + (d = slope(p0, p1))) * 0.5;\n    }\n\n    m[i] = d;\n    return m;\n  }\n\n  /**\n   * ApexCharts Line Class responsible for drawing Line / Area / RangeArea Charts.\n   * This class is also responsible for generating values for Bubble/Scatter charts, so need to rename it to Axis Charts to avoid confusions\n   * @module Line\n   **/\n\n  var Line = /*#__PURE__*/function () {\n    function Line(ctx, xyRatios, isPointsChart) {\n      _classCallCheck(this, Line);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.xyRatios = xyRatios;\n      this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || isPointsChart;\n      this.scatter = new Scatter(this.ctx);\n      this.noNegatives = this.w.globals.minX === Number.MAX_VALUE;\n      this.lineHelpers = new Helpers(this);\n      this.markers = new Markers(this.ctx);\n      this.prevSeriesY = [];\n      this.categoryAxisCorrection = 0;\n      this.yaxisIndex = 0;\n    }\n\n    _createClass(Line, [{\n      key: \"draw\",\n      value: function draw(series, ctype, seriesIndex, seriesRangeEnd) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var type = w.globals.comboCharts ? ctype : w.config.chart.type;\n        var ret = graphics.group({\n          class: \"apexcharts-\".concat(type, \"-series apexcharts-plot-series\")\n        });\n        var coreUtils = new CoreUtils(this.ctx, w);\n        this.yRatio = this.xyRatios.yRatio;\n        this.zRatio = this.xyRatios.zRatio;\n        this.xRatio = this.xyRatios.xRatio;\n        this.baseLineY = this.xyRatios.baseLineY;\n        series = coreUtils.getLogSeries(series);\n        this.yRatio = coreUtils.getLogYRatios(this.yRatio); // push all series in an array, so we can draw in reverse order (for stacked charts)\n\n        var allSeries = [];\n\n        for (var i = 0; i < series.length; i++) {\n          series = this.lineHelpers.sameValueSeriesFix(i, series);\n          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;\n\n          this._initSerieVariables(series, i, realIndex);\n\n          var yArrj = []; // hold y values of current iterating series\n\n          var y2Arrj = []; // holds y2 values in range-area charts\n\n          var xArrj = []; // hold x values of current iterating series\n\n          var x = w.globals.padHorizontal + this.categoryAxisCorrection;\n          var y = 1;\n          var linePaths = [];\n          var areaPaths = [];\n          this.ctx.series.addCollapsedClassToSeries(this.elSeries, realIndex);\n\n          if (w.globals.isXNumeric && w.globals.seriesX.length > 0) {\n            x = (w.globals.seriesX[realIndex][0] - w.globals.minX) / this.xRatio;\n          }\n\n          xArrj.push(x);\n          var prevX = x;\n          var prevY = this.zeroY;\n          var prevY2 = this.zeroY;\n          var lineYPosition = 0; // the first value in the current series is not null or undefined\n\n          var firstPrevY = this.lineHelpers.determineFirstPrevY({\n            i: i,\n            series: series,\n            prevY: prevY,\n            lineYPosition: lineYPosition\n          });\n          prevY = firstPrevY.prevY;\n\n          if (w.config.stroke.curve === 'smooth' && series[i][0] === null) {\n            // we have to discard the y position if 1st dataPoint is null as it causes issues with monotoneCubic path creation\n            yArrj.push(null);\n          } else {\n            yArrj.push(prevY);\n          } // y2 are needed for range-area charts\n\n\n          var firstPrevY2 = void 0;\n\n          if (type === 'rangeArea') {\n            firstPrevY2 = this.lineHelpers.determineFirstPrevY({\n              i: i,\n              series: seriesRangeEnd,\n              prevY: prevY2,\n              lineYPosition: lineYPosition\n            });\n            prevY2 = firstPrevY2.prevY;\n            y2Arrj.push(prevY2);\n          }\n\n          var pathsFrom = this._calculatePathsFrom({\n            type: type,\n            series: series,\n            i: i,\n            realIndex: realIndex,\n            prevX: prevX,\n            prevY: prevY,\n            prevY2: prevY2\n          });\n\n          var iteratingOpts = {\n            type: type,\n            series: series,\n            realIndex: realIndex,\n            i: i,\n            x: x,\n            y: y,\n            pathsFrom: pathsFrom,\n            linePaths: linePaths,\n            areaPaths: areaPaths,\n            seriesIndex: seriesIndex,\n            lineYPosition: lineYPosition,\n            xArrj: xArrj,\n            yArrj: yArrj,\n            y2Arrj: y2Arrj,\n            seriesRangeEnd: seriesRangeEnd\n          };\n\n          var paths = this._iterateOverDataPoints(_objectSpread2(_objectSpread2({}, iteratingOpts), {}, {\n            iterations: type === 'rangeArea' ? series[i].length - 1 : undefined,\n            isRangeStart: true\n          }));\n\n          if (type === 'rangeArea') {\n            var pathsFrom2 = this._calculatePathsFrom({\n              series: seriesRangeEnd,\n              i: i,\n              realIndex: realIndex,\n              prevX: prevX,\n              prevY: prevY2\n            });\n\n            var rangePaths = this._iterateOverDataPoints(_objectSpread2(_objectSpread2({}, iteratingOpts), {}, {\n              series: seriesRangeEnd,\n              pathsFrom: pathsFrom2,\n              iterations: seriesRangeEnd[i].length - 1,\n              isRangeStart: false\n            }));\n\n            paths.linePaths[0] = rangePaths.linePath + paths.linePath;\n            paths.pathFromLine = rangePaths.pathFromLine + paths.pathFromLine;\n          }\n\n          this._handlePaths({\n            type: type,\n            realIndex: realIndex,\n            i: i,\n            paths: paths\n          });\n\n          this.elSeries.add(this.elPointsMain);\n          this.elSeries.add(this.elDataLabelsWrap);\n          allSeries.push(this.elSeries);\n        }\n\n        if (w.config.chart.stacked) {\n          for (var s = allSeries.length; s > 0; s--) {\n            ret.add(allSeries[s - 1]);\n          }\n        } else {\n          for (var _s = 0; _s < allSeries.length; _s++) {\n            ret.add(allSeries[_s]);\n          }\n        }\n\n        return ret;\n      }\n    }, {\n      key: \"_initSerieVariables\",\n      value: function _initSerieVariables(series, i, realIndex) {\n        var w = this.w;\n        var graphics = new Graphics(this.ctx); // width divided into equal parts\n\n        this.xDivision = w.globals.gridWidth / (w.globals.dataPoints - (w.config.xaxis.tickPlacement === 'on' ? 1 : 0));\n        this.strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[realIndex] : w.config.stroke.width;\n\n        if (this.yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed; // zeroY is the 0 value in y series which can be used in negative charts\n\n        this.zeroY = w.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0);\n        this.areaBottomY = this.zeroY;\n\n        if (this.zeroY > w.globals.gridHeight || w.config.plotOptions.area.fillTo === 'end') {\n          this.areaBottomY = w.globals.gridHeight;\n        }\n\n        this.categoryAxisCorrection = this.xDivision / 2; // el to which series will be drawn\n\n        this.elSeries = graphics.group({\n          class: \"apexcharts-series\",\n          seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex])\n        }); // points\n\n        this.elPointsMain = graphics.group({\n          class: 'apexcharts-series-markers-wrap',\n          'data:realIndex': realIndex\n        }); // eldatalabels\n\n        this.elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels',\n          'data:realIndex': realIndex\n        });\n        var longestSeries = series[i].length === w.globals.dataPoints;\n        this.elSeries.attr({\n          'data:longestSeries': longestSeries,\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n        this.appendPathFrom = true;\n      }\n    }, {\n      key: \"_calculatePathsFrom\",\n      value: function _calculatePathsFrom(_ref) {\n        var type = _ref.type,\n            series = _ref.series,\n            i = _ref.i,\n            realIndex = _ref.realIndex,\n            prevX = _ref.prevX,\n            prevY = _ref.prevY,\n            prevY2 = _ref.prevY2;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var linePath, areaPath, pathFromLine, pathFromArea;\n\n        if (series[i][0] === null) {\n          // when the first value itself is null, we need to move the pointer to a location where a null value is not found\n          for (var s = 0; s < series[i].length; s++) {\n            if (series[i][s] !== null) {\n              prevX = this.xDivision * s;\n              prevY = this.zeroY - series[i][s] / this.yRatio[this.yaxisIndex];\n              linePath = graphics.move(prevX, prevY);\n              areaPath = graphics.move(prevX, this.areaBottomY);\n              break;\n            }\n          }\n        } else {\n          linePath = graphics.move(prevX, prevY);\n\n          if (type === 'rangeArea') {\n            linePath = graphics.move(prevX, prevY2) + graphics.line(prevX, prevY);\n          }\n\n          areaPath = graphics.move(prevX, this.areaBottomY) + graphics.line(prevX, prevY);\n        }\n\n        pathFromLine = graphics.move(-1, this.zeroY) + graphics.line(-1, this.zeroY);\n        pathFromArea = graphics.move(-1, this.zeroY) + graphics.line(-1, this.zeroY);\n\n        if (w.globals.previousPaths.length > 0) {\n          var pathFrom = this.lineHelpers.checkPreviousPaths({\n            pathFromLine: pathFromLine,\n            pathFromArea: pathFromArea,\n            realIndex: realIndex\n          });\n          pathFromLine = pathFrom.pathFromLine;\n          pathFromArea = pathFrom.pathFromArea;\n        }\n\n        return {\n          prevX: prevX,\n          prevY: prevY,\n          linePath: linePath,\n          areaPath: areaPath,\n          pathFromLine: pathFromLine,\n          pathFromArea: pathFromArea\n        };\n      }\n    }, {\n      key: \"_handlePaths\",\n      value: function _handlePaths(_ref2) {\n        var type = _ref2.type,\n            realIndex = _ref2.realIndex,\n            i = _ref2.i,\n            paths = _ref2.paths;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var fill = new Fill(this.ctx); // push all current y values array to main PrevY Array\n\n        this.prevSeriesY.push(paths.yArrj); // push all x val arrays into main xArr\n\n        w.globals.seriesXvalues[realIndex] = paths.xArrj;\n        w.globals.seriesYvalues[realIndex] = paths.yArrj;\n        var forecast = w.config.forecastDataPoints;\n\n        if (forecast.count > 0 && type !== 'rangeArea') {\n          var forecastCutoff = w.globals.seriesXvalues[realIndex][w.globals.seriesXvalues[realIndex].length - forecast.count - 1];\n          var elForecastMask = graphics.drawRect(forecastCutoff, 0, w.globals.gridWidth, w.globals.gridHeight, 0);\n          w.globals.dom.elForecastMask.appendChild(elForecastMask.node);\n          var elNonForecastMask = graphics.drawRect(0, 0, forecastCutoff, w.globals.gridHeight, 0);\n          w.globals.dom.elNonForecastMask.appendChild(elNonForecastMask.node);\n        } // these elements will be shown after area path animation completes\n\n\n        if (!this.pointsChart) {\n          w.globals.delayedElements.push({\n            el: this.elPointsMain.node,\n            index: realIndex\n          });\n        }\n\n        var defaultRenderedPathOptions = {\n          i: i,\n          realIndex: realIndex,\n          animationDelay: i,\n          initialSpeed: w.config.chart.animations.speed,\n          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n          className: \"apexcharts-\".concat(type)\n        };\n\n        if (type === 'area') {\n          var pathFill = fill.fillPath({\n            seriesNumber: realIndex\n          });\n\n          for (var p = 0; p < paths.areaPaths.length; p++) {\n            var renderedPath = graphics.renderPaths(_objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {\n              pathFrom: paths.pathFromArea,\n              pathTo: paths.areaPaths[p],\n              stroke: 'none',\n              strokeWidth: 0,\n              strokeLineCap: null,\n              fill: pathFill\n            }));\n            this.elSeries.add(renderedPath);\n          }\n        }\n\n        if (w.config.stroke.show && !this.pointsChart) {\n          var lineFill = null;\n\n          if (type === 'line') {\n            lineFill = fill.fillPath({\n              seriesNumber: realIndex,\n              i: i\n            });\n          } else {\n            if (w.config.stroke.fill.type === 'solid') {\n              lineFill = w.globals.stroke.colors[realIndex];\n            } else {\n              var prevFill = w.config.fill;\n              w.config.fill = w.config.stroke.fill;\n              lineFill = fill.fillPath({\n                seriesNumber: realIndex,\n                i: i\n              });\n              w.config.fill = prevFill;\n            }\n          } // range-area paths are drawn using linePaths\n\n\n          for (var _p = 0; _p < paths.linePaths.length; _p++) {\n            var _pathFill = lineFill;\n\n            if (type === 'rangeArea') {\n              _pathFill = fill.fillPath({\n                seriesNumber: realIndex\n              });\n            }\n\n            var linePathCommonOpts = _objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {\n              pathFrom: paths.pathFromLine,\n              pathTo: paths.linePaths[_p],\n              stroke: lineFill,\n              strokeWidth: this.strokeWidth,\n              strokeLineCap: w.config.stroke.lineCap,\n              fill: type === 'rangeArea' ? _pathFill : 'none'\n            });\n\n            var _renderedPath = graphics.renderPaths(linePathCommonOpts);\n\n            this.elSeries.add(_renderedPath);\n\n            _renderedPath.attr('fill-rule', \"evenodd\");\n\n            if (forecast.count > 0 && type !== 'rangeArea') {\n              var renderedForecastPath = graphics.renderPaths(linePathCommonOpts);\n              renderedForecastPath.node.setAttribute('stroke-dasharray', forecast.dashArray);\n\n              if (forecast.strokeWidth) {\n                renderedForecastPath.node.setAttribute('stroke-width', forecast.strokeWidth);\n              }\n\n              this.elSeries.add(renderedForecastPath);\n              renderedForecastPath.attr('clip-path', \"url(#forecastMask\".concat(w.globals.cuid, \")\"));\n\n              _renderedPath.attr('clip-path', \"url(#nonForecastMask\".concat(w.globals.cuid, \")\"));\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_iterateOverDataPoints\",\n      value: function _iterateOverDataPoints(_ref3) {\n        var _this = this;\n\n        var type = _ref3.type,\n            series = _ref3.series,\n            iterations = _ref3.iterations,\n            realIndex = _ref3.realIndex,\n            i = _ref3.i,\n            x = _ref3.x,\n            y = _ref3.y,\n            pathsFrom = _ref3.pathsFrom,\n            linePaths = _ref3.linePaths,\n            areaPaths = _ref3.areaPaths,\n            seriesIndex = _ref3.seriesIndex,\n            lineYPosition = _ref3.lineYPosition,\n            xArrj = _ref3.xArrj,\n            yArrj = _ref3.yArrj,\n            y2Arrj = _ref3.y2Arrj,\n            isRangeStart = _ref3.isRangeStart,\n            seriesRangeEnd = _ref3.seriesRangeEnd;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var yRatio = this.yRatio;\n        var prevY = pathsFrom.prevY,\n            linePath = pathsFrom.linePath,\n            areaPath = pathsFrom.areaPath,\n            pathFromLine = pathsFrom.pathFromLine,\n            pathFromArea = pathsFrom.pathFromArea;\n        var minY = Utils$1.isNumber(w.globals.minYArr[realIndex]) ? w.globals.minYArr[realIndex] : w.globals.minY;\n\n        if (!iterations) {\n          iterations = w.globals.dataPoints > 1 ? w.globals.dataPoints - 1 : w.globals.dataPoints;\n        }\n\n        var getY = function getY(_y, lineYPos) {\n          return lineYPos - _y / yRatio[_this.yaxisIndex] + (_this.isReversed ? _y / yRatio[_this.yaxisIndex] : 0) * 2;\n        };\n\n        var y2 = y;\n\n        for (var j = 0; j < iterations; j++) {\n          var isNull = typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null;\n\n          if (w.globals.isXNumeric) {\n            var sX = w.globals.seriesX[realIndex][j + 1];\n\n            if (typeof w.globals.seriesX[realIndex][j + 1] === 'undefined') {\n              /* fix #374 */\n              sX = w.globals.seriesX[realIndex][iterations - 1];\n            }\n\n            x = (sX - w.globals.minX) / this.xRatio;\n          } else {\n            x = x + this.xDivision;\n          }\n\n          if (w.config.chart.stacked) {\n            if (i > 0 && w.globals.collapsedSeries.length < w.config.series.length - 1) {\n              // a collapsed series in a stacked bar chart may provide wrong result for the next series, hence find the prevIndex of prev series which is not collapsed - fixes apexcharts.js#1372\n              var prevIndex = function prevIndex(pi) {\n                var pii = pi;\n\n                for (var cpi = 0; cpi < w.globals.series.length; cpi++) {\n                  if (w.globals.collapsedSeriesIndices.indexOf(pi) > -1) {\n                    pii--;\n                    break;\n                  }\n                }\n\n                return pii >= 0 ? pii : 0;\n              };\n\n              lineYPosition = this.prevSeriesY[prevIndex(i - 1)][j + 1];\n            } else {\n              // the first series will not have prevY values\n              lineYPosition = this.zeroY;\n            }\n          } else {\n            lineYPosition = this.zeroY;\n          }\n\n          if (isNull) {\n            y = getY(minY, lineYPosition);\n          } else {\n            y = getY(series[i][j + 1], lineYPosition);\n\n            if (type === 'rangeArea') {\n              y2 = getY(seriesRangeEnd[i][j + 1], lineYPosition);\n            }\n          } // push current X\n\n\n          xArrj.push(x); // push current Y that will be used as next series's bottom position\n\n          if (isNull && w.config.stroke.curve === 'smooth') {\n            yArrj.push(null);\n          } else {\n            yArrj.push(y);\n          }\n\n          y2Arrj.push(y2);\n          var pointsPos = this.lineHelpers.calculatePoints({\n            series: series,\n            x: x,\n            y: y,\n            realIndex: realIndex,\n            i: i,\n            j: j,\n            prevY: prevY\n          });\n\n          var calculatedPaths = this._createPaths({\n            type: type,\n            series: series,\n            i: i,\n            realIndex: realIndex,\n            j: j,\n            x: x,\n            y: y,\n            y2: y2,\n            xArrj: xArrj,\n            yArrj: yArrj,\n            y2Arrj: y2Arrj,\n            linePath: linePath,\n            areaPath: areaPath,\n            linePaths: linePaths,\n            areaPaths: areaPaths,\n            seriesIndex: seriesIndex,\n            isRangeStart: isRangeStart\n          });\n\n          areaPaths = calculatedPaths.areaPaths;\n          linePaths = calculatedPaths.linePaths;\n          areaPath = calculatedPaths.areaPath;\n          linePath = calculatedPaths.linePath;\n\n          if (this.appendPathFrom && !(w.config.stroke.curve === 'smooth' && type === 'rangeArea')) {\n            pathFromLine = pathFromLine + graphics.line(x, this.zeroY);\n            pathFromArea = pathFromArea + graphics.line(x, this.zeroY);\n          }\n\n          this.handleNullDataPoints(series, pointsPos, i, j, realIndex);\n\n          this._handleMarkersAndLabels({\n            type: type,\n            pointsPos: pointsPos,\n            i: i,\n            j: j,\n            realIndex: realIndex,\n            isRangeStart: isRangeStart\n          });\n        }\n\n        return {\n          yArrj: yArrj,\n          xArrj: xArrj,\n          pathFromArea: pathFromArea,\n          areaPaths: areaPaths,\n          pathFromLine: pathFromLine,\n          linePaths: linePaths,\n          linePath: linePath,\n          areaPath: areaPath\n        };\n      }\n    }, {\n      key: \"_handleMarkersAndLabels\",\n      value: function _handleMarkersAndLabels(_ref4) {\n        var type = _ref4.type,\n            pointsPos = _ref4.pointsPos,\n            isRangeStart = _ref4.isRangeStart,\n            i = _ref4.i,\n            j = _ref4.j,\n            realIndex = _ref4.realIndex;\n        var w = this.w;\n        var dataLabels = new DataLabels(this.ctx);\n\n        if (!this.pointsChart) {\n          if (w.globals.series[i].length > 1) {\n            this.elPointsMain.node.classList.add('apexcharts-element-hidden');\n          }\n\n          var elPointsWrap = this.markers.plotChartMarkers(pointsPos, realIndex, j + 1);\n\n          if (elPointsWrap !== null) {\n            this.elPointsMain.add(elPointsWrap);\n          }\n        } else {\n          // scatter / bubble chart points creation\n          this.scatter.draw(this.elSeries, j, {\n            realIndex: realIndex,\n            pointsPos: pointsPos,\n            zRatio: this.zRatio,\n            elParent: this.elPointsMain\n          });\n        }\n\n        var drawnLabels = dataLabels.drawDataLabel({\n          type: type,\n          isRangeStart: isRangeStart,\n          pos: pointsPos,\n          i: realIndex,\n          j: j + 1\n        });\n\n        if (drawnLabels !== null) {\n          this.elDataLabelsWrap.add(drawnLabels);\n        }\n      }\n    }, {\n      key: \"_createPaths\",\n      value: function _createPaths(_ref5) {\n        var type = _ref5.type,\n            series = _ref5.series,\n            i = _ref5.i,\n            realIndex = _ref5.realIndex,\n            j = _ref5.j,\n            x = _ref5.x,\n            y = _ref5.y,\n            xArrj = _ref5.xArrj,\n            yArrj = _ref5.yArrj,\n            y2 = _ref5.y2,\n            y2Arrj = _ref5.y2Arrj,\n            linePath = _ref5.linePath,\n            areaPath = _ref5.areaPath,\n            linePaths = _ref5.linePaths,\n            areaPaths = _ref5.areaPaths,\n            seriesIndex = _ref5.seriesIndex,\n            isRangeStart = _ref5.isRangeStart;\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var curve = w.config.stroke.curve;\n        var areaBottomY = this.areaBottomY;\n\n        if (Array.isArray(w.config.stroke.curve)) {\n          if (Array.isArray(seriesIndex)) {\n            curve = w.config.stroke.curve[seriesIndex[i]];\n          } else {\n            curve = w.config.stroke.curve[i];\n          }\n        }\n\n        if (type === 'rangeArea' && (w.globals.hasNullValues || w.config.forecastDataPoints.count > 0) && curve === 'smooth') {\n          curve = 'straight';\n        }\n\n        if (curve === 'smooth') {\n          var shouldRenderMonotone = type === 'rangeArea' ? xArrj.length === w.globals.dataPoints : j === series[i].length - 2;\n\n          if (shouldRenderMonotone) {\n            var smoothInputs = xArrj.map(function (_, i) {\n              return [xArrj[i], yArrj[i]];\n            }).filter(function (_) {\n              return _[1] !== null;\n            });\n            var points = spline.points(smoothInputs);\n            linePath += svgPath(points);\n\n            if (series[i][0] === null) {\n              // if the first dataPoint is null, we use the linePath directly\n              areaPath = linePath;\n            } else {\n              // else, we append the areaPath\n              areaPath += svgPath(points);\n            }\n\n            if (type === 'rangeArea' && isRangeStart) {\n              // draw the line to connect y with y2; then draw the other end of range\n              linePath += graphics.line(xArrj[xArrj.length - 1], y2Arrj[y2Arrj.length - 1]);\n              var xArrjInversed = xArrj.slice().reverse();\n              var y2ArrjInversed = y2Arrj.slice().reverse();\n              var smoothInputsY2 = xArrjInversed.map(function (_, i) {\n                return [xArrjInversed[i], y2ArrjInversed[i]];\n              });\n              var pointsY2 = spline.points(smoothInputsY2);\n              linePath += svgPath(pointsY2); // in range area, we don't have separate line and area path\n\n              areaPath = linePath;\n            } else {\n              areaPath += graphics.line(smoothInputs[smoothInputs.length - 1][0], areaBottomY) + graphics.line(smoothInputs[0][0], areaBottomY) + graphics.move(smoothInputs[0][0], smoothInputs[0][1]) + 'z';\n            }\n\n            linePaths.push(linePath);\n            areaPaths.push(areaPath);\n          }\n        } else {\n          if (series[i][j + 1] === null) {\n            linePath = linePath + graphics.move(x, y);\n            var numericOrCatX = w.globals.isXNumeric ? (w.globals.seriesX[realIndex][j] - w.globals.minX) / this.xRatio : x - this.xDivision;\n            areaPath = areaPath + graphics.line(numericOrCatX, areaBottomY) + graphics.move(x, y) + 'z';\n          }\n\n          if (series[i][j] === null) {\n            linePath = linePath + graphics.move(x, y);\n            areaPath = areaPath + graphics.move(x, areaBottomY);\n          }\n\n          if (curve === 'stepline') {\n            linePath = linePath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');\n            areaPath = areaPath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');\n          } else if (curve === 'straight') {\n            linePath = linePath + graphics.line(x, y);\n            areaPath = areaPath + graphics.line(x, y);\n          }\n\n          if (j === series[i].length - 2) {\n            // last loop, close path\n            areaPath = areaPath + graphics.line(x, areaBottomY) + graphics.move(x, y) + 'z';\n\n            if (type === 'rangeArea' && isRangeStart) {\n              linePath = linePath + graphics.line(x, y2) + graphics.move(x, y2) + 'z';\n            } else {\n              linePaths.push(linePath);\n              areaPaths.push(areaPath);\n            }\n          }\n        }\n\n        return {\n          linePaths: linePaths,\n          areaPaths: areaPaths,\n          linePath: linePath,\n          areaPath: areaPath\n        };\n      }\n    }, {\n      key: \"handleNullDataPoints\",\n      value: function handleNullDataPoints(series, pointsPos, i, j, realIndex) {\n        var w = this.w;\n\n        if (series[i][j] === null && w.config.markers.showNullDataPoints || series[i].length === 1) {\n          // fixes apexcharts.js#1282, #1252\n          var elPointsWrap = this.markers.plotChartMarkers(pointsPos, realIndex, j + 1, this.strokeWidth - w.config.markers.strokeWidth / 2, true);\n\n          if (elPointsWrap !== null) {\n            this.elPointsMain.add(elPointsWrap);\n          }\n        }\n      }\n    }]);\n\n    return Line;\n  }();\n\n  /*\n   * treemap-squarify.js - open source implementation of squarified treemaps\n   *\n   * Treemap Squared 0.5 - Treemap Charting library\n   *\n   * https://github.com/imranghory/treemap-squared/\n   *\n   * Copyright (c) 2012 Imran Ghory (imranghory@gmail.com)\n   * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\n   *\n   *\n   * Implementation of the squarify treemap algorithm described in:\n   *\n   * Bruls, Mark; Huizing, Kees; van Wijk, Jarke J. (2000), \"Squarified treemaps\"\n   * in de Leeuw, W.; van Liere, R., Data Visualization 2000:\n   * Proc. Joint Eurographics and IEEE TCVG Symp. on Visualization, Springer-Verlag, pp. 33–42.\n   *\n   * Paper is available online at: http://www.win.tue.nl/~vanwijk/stm.pdf\n   *\n   * The code in this file is completeley decoupled from the drawing code so it should be trivial\n   * to port it to any other vector drawing library. Given an array of datapoints this library returns\n   * an array of cartesian coordinates that represent the rectangles that make up the treemap.\n   *\n   * The library also supports multidimensional data (nested treemaps) and performs normalization on the data.\n   *\n   * See the README file for more details.\n   */\n  window.TreemapSquared = {};\n\n  (function () {\n\n    window.TreemapSquared.generate = function () {\n      function Container(xoffset, yoffset, width, height) {\n        this.xoffset = xoffset; // offset from the the top left hand corner\n\n        this.yoffset = yoffset; // ditto\n\n        this.height = height;\n        this.width = width;\n\n        this.shortestEdge = function () {\n          return Math.min(this.height, this.width);\n        }; // getCoordinates - for a row of boxes which we've placed\n        //                  return an array of their cartesian coordinates\n\n\n        this.getCoordinates = function (row) {\n          var coordinates = [];\n          var subxoffset = this.xoffset,\n              subyoffset = this.yoffset; //our offset within the container\n\n          var areawidth = sumArray(row) / this.height;\n          var areaheight = sumArray(row) / this.width;\n          var i;\n\n          if (this.width >= this.height) {\n            for (i = 0; i < row.length; i++) {\n              coordinates.push([subxoffset, subyoffset, subxoffset + areawidth, subyoffset + row[i] / areawidth]);\n              subyoffset = subyoffset + row[i] / areawidth;\n            }\n          } else {\n            for (i = 0; i < row.length; i++) {\n              coordinates.push([subxoffset, subyoffset, subxoffset + row[i] / areaheight, subyoffset + areaheight]);\n              subxoffset = subxoffset + row[i] / areaheight;\n            }\n          }\n\n          return coordinates;\n        }; // cutArea - once we've placed some boxes into an row we then need to identify the remaining area,\n        //           this function takes the area of the boxes we've placed and calculates the location and\n        //           dimensions of the remaining space and returns a container box defined by the remaining area\n\n\n        this.cutArea = function (area) {\n          var newcontainer;\n\n          if (this.width >= this.height) {\n            var areawidth = area / this.height;\n            var newwidth = this.width - areawidth;\n            newcontainer = new Container(this.xoffset + areawidth, this.yoffset, newwidth, this.height);\n          } else {\n            var areaheight = area / this.width;\n            var newheight = this.height - areaheight;\n            newcontainer = new Container(this.xoffset, this.yoffset + areaheight, this.width, newheight);\n          }\n\n          return newcontainer;\n        };\n      } // normalize - the Bruls algorithm assumes we're passing in areas that nicely fit into our\n      //             container box, this method takes our raw data and normalizes the data values into\n      //             area values so that this assumption is valid.\n\n\n      function normalize(data, area) {\n        var normalizeddata = [];\n        var sum = sumArray(data);\n        var multiplier = area / sum;\n        var i;\n\n        for (i = 0; i < data.length; i++) {\n          normalizeddata[i] = data[i] * multiplier;\n        }\n\n        return normalizeddata;\n      } // treemapMultidimensional - takes multidimensional data (aka [[23,11],[11,32]] - nested array)\n      //                           and recursively calls itself using treemapSingledimensional\n      //                           to create a patchwork of treemaps and merge them\n\n\n      function treemapMultidimensional(data, width, height, xoffset, yoffset) {\n        xoffset = typeof xoffset === 'undefined' ? 0 : xoffset;\n        yoffset = typeof yoffset === 'undefined' ? 0 : yoffset;\n        var mergeddata = [];\n        var mergedtreemap;\n        var results = [];\n        var i;\n\n        if (isArray(data[0])) {\n          // if we've got more dimensions of depth\n          for (i = 0; i < data.length; i++) {\n            mergeddata[i] = sumMultidimensionalArray(data[i]);\n          }\n\n          mergedtreemap = treemapSingledimensional(mergeddata, width, height, xoffset, yoffset);\n\n          for (i = 0; i < data.length; i++) {\n            results.push(treemapMultidimensional(data[i], mergedtreemap[i][2] - mergedtreemap[i][0], mergedtreemap[i][3] - mergedtreemap[i][1], mergedtreemap[i][0], mergedtreemap[i][1]));\n          }\n        } else {\n          results = treemapSingledimensional(data, width, height, xoffset, yoffset);\n        }\n\n        return results;\n      } // treemapSingledimensional - simple wrapper around squarify\n\n\n      function treemapSingledimensional(data, width, height, xoffset, yoffset) {\n        xoffset = typeof xoffset === 'undefined' ? 0 : xoffset;\n        yoffset = typeof yoffset === 'undefined' ? 0 : yoffset;\n        var rawtreemap = squarify(normalize(data, width * height), [], new Container(xoffset, yoffset, width, height), []);\n        return flattenTreemap(rawtreemap);\n      } // flattenTreemap - squarify implementation returns an array of arrays of coordinates\n      //                  because we have a new array everytime we switch to building a new row\n      //                  this converts it into an array of coordinates.\n\n\n      function flattenTreemap(rawtreemap) {\n        var flattreemap = [];\n        var i, j;\n\n        for (i = 0; i < rawtreemap.length; i++) {\n          for (j = 0; j < rawtreemap[i].length; j++) {\n            flattreemap.push(rawtreemap[i][j]);\n          }\n        }\n\n        return flattreemap;\n      } // squarify  - as per the Bruls paper\n      //             plus coordinates stack and containers so we get\n      //             usable data out of it\n\n\n      function squarify(data, currentrow, container, stack) {\n        var length;\n        var nextdatapoint;\n        var newcontainer;\n\n        if (data.length === 0) {\n          stack.push(container.getCoordinates(currentrow));\n          return;\n        }\n\n        length = container.shortestEdge();\n        nextdatapoint = data[0];\n\n        if (improvesRatio(currentrow, nextdatapoint, length)) {\n          currentrow.push(nextdatapoint);\n          squarify(data.slice(1), currentrow, container, stack);\n        } else {\n          newcontainer = container.cutArea(sumArray(currentrow), stack);\n          stack.push(container.getCoordinates(currentrow));\n          squarify(data, [], newcontainer, stack);\n        }\n\n        return stack;\n      } // improveRatio - implements the worse calculation and comparision as given in Bruls\n      //                (note the error in the original paper; fixed here)\n\n\n      function improvesRatio(currentrow, nextnode, length) {\n        var newrow;\n\n        if (currentrow.length === 0) {\n          return true;\n        }\n\n        newrow = currentrow.slice();\n        newrow.push(nextnode);\n        var currentratio = calculateRatio(currentrow, length);\n        var newratio = calculateRatio(newrow, length); // the pseudocode in the Bruls paper has the direction of the comparison\n        // wrong, this is the correct one.\n\n        return currentratio >= newratio;\n      } // calculateRatio - calculates the maximum width to height ratio of the\n      //                  boxes in this row\n\n\n      function calculateRatio(row, length) {\n        var min = Math.min.apply(Math, row);\n        var max = Math.max.apply(Math, row);\n        var sum = sumArray(row);\n        return Math.max(Math.pow(length, 2) * max / Math.pow(sum, 2), Math.pow(sum, 2) / (Math.pow(length, 2) * min));\n      } // isArray - checks if arr is an array\n\n\n      function isArray(arr) {\n        return arr && arr.constructor === Array;\n      } // sumArray - sums a single dimensional array\n\n\n      function sumArray(arr) {\n        var sum = 0;\n        var i;\n\n        for (i = 0; i < arr.length; i++) {\n          sum += arr[i];\n        }\n\n        return sum;\n      } // sumMultidimensionalArray - sums the values in a nested array (aka [[0,1],[[2,3]]])\n\n\n      function sumMultidimensionalArray(arr) {\n        var i,\n            total = 0;\n\n        if (isArray(arr[0])) {\n          for (i = 0; i < arr.length; i++) {\n            total += sumMultidimensionalArray(arr[i]);\n          }\n        } else {\n          total = sumArray(arr);\n        }\n\n        return total;\n      }\n\n      return treemapMultidimensional;\n    }();\n  })();\n\n  /**\n   * ApexCharts TreemapChart Class.\n   * @module TreemapChart\n   **/\n\n  var TreemapChart = /*#__PURE__*/function () {\n    function TreemapChart(ctx, xyRatios) {\n      _classCallCheck(this, TreemapChart);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.strokeWidth = this.w.config.stroke.width;\n      this.helpers = new TreemapHelpers(ctx);\n      this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;\n      this.labels = [];\n    }\n\n    _createClass(TreemapChart, [{\n      key: \"draw\",\n      value: function draw(series) {\n        var _this = this;\n\n        var w = this.w;\n        var graphics = new Graphics(this.ctx);\n        var fill = new Fill(this.ctx);\n        var ret = graphics.group({\n          class: 'apexcharts-treemap'\n        });\n        if (w.globals.noData) return ret;\n        var ser = [];\n        series.forEach(function (s) {\n          var d = s.map(function (v) {\n            return Math.abs(v);\n          });\n          ser.push(d);\n        });\n        this.negRange = this.helpers.checkColorRange();\n        w.config.series.forEach(function (s, i) {\n          s.data.forEach(function (l) {\n            if (!Array.isArray(_this.labels[i])) _this.labels[i] = [];\n\n            _this.labels[i].push(l.x);\n          });\n        });\n        var nodes = window.TreemapSquared.generate(ser, w.globals.gridWidth, w.globals.gridHeight);\n        nodes.forEach(function (node, i) {\n          var elSeries = graphics.group({\n            class: \"apexcharts-series apexcharts-treemap-series\",\n            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),\n            rel: i + 1,\n            'data:realIndex': i\n          });\n\n          if (w.config.chart.dropShadow.enabled) {\n            var shadow = w.config.chart.dropShadow;\n            var filters = new Filters(_this.ctx);\n            filters.dropShadow(ret, shadow, i);\n          }\n\n          var elDataLabelWrap = graphics.group({\n            class: 'apexcharts-data-labels'\n          });\n          node.forEach(function (r, j) {\n            var x1 = r[0];\n            var y1 = r[1];\n            var x2 = r[2];\n            var y2 = r[3];\n            var elRect = graphics.drawRect(x1, y1, x2 - x1, y2 - y1, 0, '#fff', 1, _this.strokeWidth, w.config.plotOptions.treemap.useFillColorAsStroke ? color : w.globals.stroke.colors[i]);\n            elRect.attr({\n              cx: x1,\n              cy: y1,\n              index: i,\n              i: i,\n              j: j,\n              width: x2 - x1,\n              height: y2 - y1\n            });\n\n            var colorProps = _this.helpers.getShadeColor(w.config.chart.type, i, j, _this.negRange);\n\n            var color = colorProps.color;\n\n            if (typeof w.config.series[i].data[j] !== 'undefined' && w.config.series[i].data[j].fillColor) {\n              color = w.config.series[i].data[j].fillColor;\n            }\n\n            var pathFill = fill.fillPath({\n              color: color,\n              seriesNumber: i,\n              dataPointIndex: j\n            });\n            elRect.node.classList.add('apexcharts-treemap-rect');\n            elRect.attr({\n              fill: pathFill\n            });\n\n            _this.helpers.addListeners(elRect);\n\n            var fromRect = {\n              x: x1 + (x2 - x1) / 2,\n              y: y1 + (y2 - y1) / 2,\n              width: 0,\n              height: 0\n            };\n            var toRect = {\n              x: x1,\n              y: y1,\n              width: x2 - x1,\n              height: y2 - y1\n            };\n\n            if (w.config.chart.animations.enabled && !w.globals.dataChanged) {\n              var speed = 1;\n\n              if (!w.globals.resized) {\n                speed = w.config.chart.animations.speed;\n              }\n\n              _this.animateTreemap(elRect, fromRect, toRect, speed);\n            }\n\n            if (w.globals.dataChanged) {\n              var _speed = 1;\n\n              if (_this.dynamicAnim.enabled && w.globals.shouldAnimate) {\n                _speed = _this.dynamicAnim.speed;\n\n                if (w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].rect) {\n                  fromRect = w.globals.previousPaths[i][j].rect;\n                }\n\n                _this.animateTreemap(elRect, fromRect, toRect, _speed);\n              }\n            }\n\n            var fontSize = _this.getFontSize(r);\n\n            var formattedText = w.config.dataLabels.formatter(_this.labels[i][j], {\n              value: w.globals.series[i][j],\n              seriesIndex: i,\n              dataPointIndex: j,\n              w: w\n            });\n\n            if (w.config.plotOptions.treemap.dataLabels.format === 'truncate') {\n              fontSize = parseInt(w.config.dataLabels.style.fontSize, 10);\n              formattedText = _this.truncateLabels(formattedText, fontSize, x1, y1, x2, y2);\n            }\n\n            var dataLabels = _this.helpers.calculateDataLabels({\n              text: formattedText,\n              x: (x1 + x2) / 2,\n              y: (y1 + y2) / 2 + _this.strokeWidth / 2 + fontSize / 3,\n              i: i,\n              j: j,\n              colorProps: colorProps,\n              fontSize: fontSize,\n              series: series\n            });\n\n            if (w.config.dataLabels.enabled && dataLabels) {\n              _this.rotateToFitLabel(dataLabels, fontSize, formattedText, x1, y1, x2, y2);\n            }\n\n            elSeries.add(elRect);\n\n            if (dataLabels !== null) {\n              elSeries.add(dataLabels);\n            }\n          });\n          elSeries.add(elDataLabelWrap);\n          ret.add(elSeries);\n        });\n        return ret;\n      } // This calculates a font-size based upon\n      // average label length and the size of the box the label is\n      // going into. The maximum font size is set in chart config.\n\n    }, {\n      key: \"getFontSize\",\n      value: function getFontSize(coordinates) {\n        var w = this.w; // total length of labels (i.e [[\"Italy\"],[\"Spain\", \"Greece\"]] -> 16)\n\n        function totalLabelLength(arr) {\n          var i,\n              total = 0;\n\n          if (Array.isArray(arr[0])) {\n            for (i = 0; i < arr.length; i++) {\n              total += totalLabelLength(arr[i]);\n            }\n          } else {\n            for (i = 0; i < arr.length; i++) {\n              total += arr[i].length;\n            }\n          }\n\n          return total;\n        } // count of labels (i.e [[\"Italy\"],[\"Spain\", \"Greece\"]] -> 3)\n\n\n        function countLabels(arr) {\n          var i,\n              total = 0;\n\n          if (Array.isArray(arr[0])) {\n            for (i = 0; i < arr.length; i++) {\n              total += countLabels(arr[i]);\n            }\n          } else {\n            for (i = 0; i < arr.length; i++) {\n              total += 1;\n            }\n          }\n\n          return total;\n        }\n\n        var averagelabelsize = totalLabelLength(this.labels) / countLabels(this.labels);\n\n        function fontSize(width, height) {\n          // the font size should be proportional to the size of the box (and the value)\n          // otherwise you can end up creating a visual distortion where two boxes of identical\n          // size have different sized labels, and thus make it look as if the two boxes\n          // represent different sizes\n          var area = width * height;\n          var arearoot = Math.pow(area, 0.5);\n          return Math.min(arearoot / averagelabelsize, parseInt(w.config.dataLabels.style.fontSize, 10));\n        }\n\n        return fontSize(coordinates[2] - coordinates[0], coordinates[3] - coordinates[1]);\n      }\n    }, {\n      key: \"rotateToFitLabel\",\n      value: function rotateToFitLabel(elText, fontSize, text, x1, y1, x2, y2) {\n        var graphics = new Graphics(this.ctx);\n        var textRect = graphics.getTextRects(text, fontSize); //if the label fits better sideways then rotate it\n\n        if (textRect.width + this.w.config.stroke.width + 5 > x2 - x1 && textRect.width <= y2 - y1) {\n          var labelRotatingCenter = graphics.rotateAroundCenter(elText.node);\n          elText.node.setAttribute('transform', \"rotate(-90 \".concat(labelRotatingCenter.x, \" \").concat(labelRotatingCenter.y, \") translate(\").concat(textRect.height / 3, \")\"));\n        }\n      } // This is an alternative label formatting method that uses a\n      // consistent font size, and trims the edge of long labels\n\n    }, {\n      key: \"truncateLabels\",\n      value: function truncateLabels(text, fontSize, x1, y1, x2, y2) {\n        var graphics = new Graphics(this.ctx);\n        var textRect = graphics.getTextRects(text, fontSize); // Determine max width based on ideal orientation of text\n\n        var labelMaxWidth = textRect.width + this.w.config.stroke.width + 5 > x2 - x1 && y2 - y1 > x2 - x1 ? y2 - y1 : x2 - x1;\n        var truncatedText = graphics.getTextBasedOnMaxWidth({\n          text: text,\n          maxWidth: labelMaxWidth,\n          fontSize: fontSize\n        }); // Return empty label when text has been trimmed for very small rects\n\n        if (text.length !== truncatedText.length && labelMaxWidth / fontSize < 5) {\n          return '';\n        } else {\n          return truncatedText;\n        }\n      }\n    }, {\n      key: \"animateTreemap\",\n      value: function animateTreemap(el, fromRect, toRect, speed) {\n        var animations = new Animations(this.ctx);\n        animations.animateRect(el, {\n          x: fromRect.x,\n          y: fromRect.y,\n          width: fromRect.width,\n          height: fromRect.height\n        }, {\n          x: toRect.x,\n          y: toRect.y,\n          width: toRect.width,\n          height: toRect.height\n        }, speed, function () {\n          animations.animationCompleted(el);\n        });\n      }\n    }]);\n\n    return TreemapChart;\n  }();\n\n  var MINUTES_IN_DAY = 24 * 60;\n  var SECONDS_IN_DAY = MINUTES_IN_DAY * 60;\n  var MIN_ZOOM_DAYS = 10 / SECONDS_IN_DAY;\n  /**\n   * ApexCharts TimeScale Class for generating time ticks for x-axis.\n   *\n   * @module TimeScale\n   **/\n\n  var TimeScale = /*#__PURE__*/function () {\n    function TimeScale(ctx) {\n      _classCallCheck(this, TimeScale);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.timeScaleArray = [];\n      this.utc = this.w.config.xaxis.labels.datetimeUTC;\n    }\n\n    _createClass(TimeScale, [{\n      key: \"calculateTimeScaleTicks\",\n      value: function calculateTimeScaleTicks(minX, maxX) {\n        var _this = this;\n\n        var w = this.w; // null check when no series to show\n\n        if (w.globals.allSeriesCollapsed) {\n          w.globals.labels = [];\n          w.globals.timescaleLabels = [];\n          return [];\n        }\n\n        var dt = new DateTime(this.ctx);\n        var daysDiff = (maxX - minX) / (1000 * SECONDS_IN_DAY);\n        this.determineInterval(daysDiff);\n        w.globals.disableZoomIn = false;\n        w.globals.disableZoomOut = false;\n\n        if (daysDiff < MIN_ZOOM_DAYS) {\n          w.globals.disableZoomIn = true;\n        } else if (daysDiff > 50000) {\n          w.globals.disableZoomOut = true;\n        }\n\n        var timeIntervals = dt.getTimeUnitsfromTimestamp(minX, maxX, this.utc);\n        var daysWidthOnXAxis = w.globals.gridWidth / daysDiff;\n        var hoursWidthOnXAxis = daysWidthOnXAxis / 24;\n        var minutesWidthOnXAxis = hoursWidthOnXAxis / 60;\n        var secondsWidthOnXAxis = minutesWidthOnXAxis / 60;\n        var numberOfHours = Math.floor(daysDiff * 24);\n        var numberOfMinutes = Math.floor(daysDiff * MINUTES_IN_DAY);\n        var numberOfSeconds = Math.floor(daysDiff * SECONDS_IN_DAY);\n        var numberOfDays = Math.floor(daysDiff);\n        var numberOfMonths = Math.floor(daysDiff / 30);\n        var numberOfYears = Math.floor(daysDiff / 365);\n        var firstVal = {\n          minMillisecond: timeIntervals.minMillisecond,\n          minSecond: timeIntervals.minSecond,\n          minMinute: timeIntervals.minMinute,\n          minHour: timeIntervals.minHour,\n          minDate: timeIntervals.minDate,\n          minMonth: timeIntervals.minMonth,\n          minYear: timeIntervals.minYear\n        };\n        var currentMillisecond = firstVal.minMillisecond;\n        var currentSecond = firstVal.minSecond;\n        var currentMinute = firstVal.minMinute;\n        var currentHour = firstVal.minHour;\n        var currentMonthDate = firstVal.minDate;\n        var currentDate = firstVal.minDate;\n        var currentMonth = firstVal.minMonth;\n        var currentYear = firstVal.minYear;\n        var params = {\n          firstVal: firstVal,\n          currentMillisecond: currentMillisecond,\n          currentSecond: currentSecond,\n          currentMinute: currentMinute,\n          currentHour: currentHour,\n          currentMonthDate: currentMonthDate,\n          currentDate: currentDate,\n          currentMonth: currentMonth,\n          currentYear: currentYear,\n          daysWidthOnXAxis: daysWidthOnXAxis,\n          hoursWidthOnXAxis: hoursWidthOnXAxis,\n          minutesWidthOnXAxis: minutesWidthOnXAxis,\n          secondsWidthOnXAxis: secondsWidthOnXAxis,\n          numberOfSeconds: numberOfSeconds,\n          numberOfMinutes: numberOfMinutes,\n          numberOfHours: numberOfHours,\n          numberOfDays: numberOfDays,\n          numberOfMonths: numberOfMonths,\n          numberOfYears: numberOfYears\n        };\n\n        switch (this.tickInterval) {\n          case 'years':\n            {\n              this.generateYearScale(params);\n              break;\n            }\n\n          case 'months':\n          case 'half_year':\n            {\n              this.generateMonthScale(params);\n              break;\n            }\n\n          case 'months_days':\n          case 'months_fortnight':\n          case 'days':\n          case 'week_days':\n            {\n              this.generateDayScale(params);\n              break;\n            }\n\n          case 'hours':\n            {\n              this.generateHourScale(params);\n              break;\n            }\n\n          case 'minutes_fives':\n          case 'minutes':\n            this.generateMinuteScale(params);\n            break;\n\n          case 'seconds_tens':\n          case 'seconds_fives':\n          case 'seconds':\n            this.generateSecondScale(params);\n            break;\n        } // first, we will adjust the month values index\n        // as in the upper function, it is starting from 0\n        // we will start them from 1\n\n\n        var adjustedMonthInTimeScaleArray = this.timeScaleArray.map(function (ts) {\n          var defaultReturn = {\n            position: ts.position,\n            unit: ts.unit,\n            year: ts.year,\n            day: ts.day ? ts.day : 1,\n            hour: ts.hour ? ts.hour : 0,\n            month: ts.month + 1\n          };\n\n          if (ts.unit === 'month') {\n            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {\n              day: 1,\n              value: ts.value + 1\n            });\n          } else if (ts.unit === 'day' || ts.unit === 'hour') {\n            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {\n              value: ts.value\n            });\n          } else if (ts.unit === 'minute') {\n            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {\n              value: ts.value,\n              minute: ts.value\n            });\n          } else if (ts.unit === 'second') {\n            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {\n              value: ts.value,\n              minute: ts.minute,\n              second: ts.second\n            });\n          }\n\n          return ts;\n        });\n        var filteredTimeScale = adjustedMonthInTimeScaleArray.filter(function (ts) {\n          var modulo = 1;\n          var ticks = Math.ceil(w.globals.gridWidth / 120);\n          var value = ts.value;\n\n          if (w.config.xaxis.tickAmount !== undefined) {\n            ticks = w.config.xaxis.tickAmount;\n          }\n\n          if (adjustedMonthInTimeScaleArray.length > ticks) {\n            modulo = Math.floor(adjustedMonthInTimeScaleArray.length / ticks);\n          }\n\n          var shouldNotSkipUnit = false; // there is a big change in unit i.e days to months\n\n          var shouldNotPrint = false; // should skip these values\n\n          switch (_this.tickInterval) {\n            case 'years':\n              // make years label denser\n              if (ts.unit === 'year') {\n                shouldNotSkipUnit = true;\n              }\n\n              break;\n\n            case 'half_year':\n              modulo = 7;\n\n              if (ts.unit === 'year') {\n                shouldNotSkipUnit = true;\n              }\n\n              break;\n\n            case 'months':\n              modulo = 1;\n\n              if (ts.unit === 'year') {\n                shouldNotSkipUnit = true;\n              }\n\n              break;\n\n            case 'months_fortnight':\n              modulo = 15;\n\n              if (ts.unit === 'year' || ts.unit === 'month') {\n                shouldNotSkipUnit = true;\n              }\n\n              if (value === 30) {\n                shouldNotPrint = true;\n              }\n\n              break;\n\n            case 'months_days':\n              modulo = 10;\n\n              if (ts.unit === 'month') {\n                shouldNotSkipUnit = true;\n              }\n\n              if (value === 30) {\n                shouldNotPrint = true;\n              }\n\n              break;\n\n            case 'week_days':\n              modulo = 8;\n\n              if (ts.unit === 'month') {\n                shouldNotSkipUnit = true;\n              }\n\n              break;\n\n            case 'days':\n              modulo = 1;\n\n              if (ts.unit === 'month') {\n                shouldNotSkipUnit = true;\n              }\n\n              break;\n\n            case 'hours':\n              if (ts.unit === 'day') {\n                shouldNotSkipUnit = true;\n              }\n\n              break;\n\n            case 'minutes_fives':\n              if (value % 5 !== 0) {\n                shouldNotPrint = true;\n              }\n\n              break;\n\n            case 'seconds_tens':\n              if (value % 10 !== 0) {\n                shouldNotPrint = true;\n              }\n\n              break;\n\n            case 'seconds_fives':\n              if (value % 5 !== 0) {\n                shouldNotPrint = true;\n              }\n\n              break;\n          }\n\n          if (_this.tickInterval === 'hours' || _this.tickInterval === 'minutes_fives' || _this.tickInterval === 'seconds_tens' || _this.tickInterval === 'seconds_fives') {\n            if (!shouldNotPrint) {\n              return true;\n            }\n          } else {\n            if ((value % modulo === 0 || shouldNotSkipUnit) && !shouldNotPrint) {\n              return true;\n            }\n          }\n        });\n        return filteredTimeScale;\n      }\n    }, {\n      key: \"recalcDimensionsBasedOnFormat\",\n      value: function recalcDimensionsBasedOnFormat(filteredTimeScale, inverted) {\n        var w = this.w;\n        var reformattedTimescaleArray = this.formatDates(filteredTimeScale);\n        var removedOverlappingTS = this.removeOverlappingTS(reformattedTimescaleArray);\n        w.globals.timescaleLabels = removedOverlappingTS.slice(); // at this stage, we need to re-calculate coords of the grid as timeline labels may have altered the xaxis labels coords\n        // The reason we can't do this prior to this stage is because timeline labels depends on gridWidth, and as the ticks are calculated based on available gridWidth, there can be unknown number of ticks generated for different minX and maxX\n        // Dependency on Dimensions(), need to refactor correctly\n        // TODO - find an alternate way to avoid calling this Heavy method twice\n\n        var dimensions = new Dimensions(this.ctx);\n        dimensions.plotCoords();\n      }\n    }, {\n      key: \"determineInterval\",\n      value: function determineInterval(daysDiff) {\n        var yearsDiff = daysDiff / 365;\n        var hoursDiff = daysDiff * 24;\n        var minutesDiff = hoursDiff * 60;\n        var secondsDiff = minutesDiff * 60;\n\n        switch (true) {\n          case yearsDiff > 5:\n            this.tickInterval = 'years';\n            break;\n\n          case daysDiff > 800:\n            this.tickInterval = 'half_year';\n            break;\n\n          case daysDiff > 180:\n            this.tickInterval = 'months';\n            break;\n\n          case daysDiff > 90:\n            this.tickInterval = 'months_fortnight';\n            break;\n\n          case daysDiff > 60:\n            this.tickInterval = 'months_days';\n            break;\n\n          case daysDiff > 30:\n            this.tickInterval = 'week_days';\n            break;\n\n          case daysDiff > 2:\n            this.tickInterval = 'days';\n            break;\n\n          case hoursDiff > 2.4:\n            this.tickInterval = 'hours';\n            break;\n\n          case minutesDiff > 15:\n            this.tickInterval = 'minutes_fives';\n            break;\n\n          case minutesDiff > 5:\n            this.tickInterval = 'minutes';\n            break;\n\n          case minutesDiff > 1:\n            this.tickInterval = 'seconds_tens';\n            break;\n\n          case secondsDiff > 20:\n            this.tickInterval = 'seconds_fives';\n            break;\n\n          default:\n            this.tickInterval = 'seconds';\n            break;\n        }\n      }\n    }, {\n      key: \"generateYearScale\",\n      value: function generateYearScale(_ref) {\n        var firstVal = _ref.firstVal,\n            currentMonth = _ref.currentMonth,\n            currentYear = _ref.currentYear,\n            daysWidthOnXAxis = _ref.daysWidthOnXAxis,\n            numberOfYears = _ref.numberOfYears;\n        var firstTickValue = firstVal.minYear;\n        var firstTickPosition = 0;\n        var dt = new DateTime(this.ctx);\n        var unit = 'year';\n\n        if (firstVal.minDate > 1 || firstVal.minMonth > 0) {\n          var remainingDays = dt.determineRemainingDaysOfYear(firstVal.minYear, firstVal.minMonth, firstVal.minDate); // remainingDaysofFirstMonth is used to reacht the 2nd tick position\n\n          var remainingDaysOfFirstYear = dt.determineDaysOfYear(firstVal.minYear) - remainingDays + 1; // calculate the first tick position\n\n          firstTickPosition = remainingDaysOfFirstYear * daysWidthOnXAxis;\n          firstTickValue = firstVal.minYear + 1; // push the first tick in the array\n\n          this.timeScaleArray.push({\n            position: firstTickPosition,\n            value: firstTickValue,\n            unit: unit,\n            year: firstTickValue,\n            month: Utils$1.monthMod(currentMonth + 1)\n          });\n        } else if (firstVal.minDate === 1 && firstVal.minMonth === 0) {\n          // push the first tick in the array\n          this.timeScaleArray.push({\n            position: firstTickPosition,\n            value: firstTickValue,\n            unit: unit,\n            year: currentYear,\n            month: Utils$1.monthMod(currentMonth + 1)\n          });\n        }\n\n        var year = firstTickValue;\n        var pos = firstTickPosition; // keep drawing rest of the ticks\n\n        for (var i = 0; i < numberOfYears; i++) {\n          year++;\n          pos = dt.determineDaysOfYear(year - 1) * daysWidthOnXAxis + pos;\n          this.timeScaleArray.push({\n            position: pos,\n            value: year,\n            unit: unit,\n            year: year,\n            month: 1\n          });\n        }\n      }\n    }, {\n      key: \"generateMonthScale\",\n      value: function generateMonthScale(_ref2) {\n        var firstVal = _ref2.firstVal,\n            currentMonthDate = _ref2.currentMonthDate,\n            currentMonth = _ref2.currentMonth,\n            currentYear = _ref2.currentYear,\n            daysWidthOnXAxis = _ref2.daysWidthOnXAxis,\n            numberOfMonths = _ref2.numberOfMonths;\n        var firstTickValue = currentMonth;\n        var firstTickPosition = 0;\n        var dt = new DateTime(this.ctx);\n        var unit = 'month';\n        var yrCounter = 0;\n\n        if (firstVal.minDate > 1) {\n          // remainingDaysofFirstMonth is used to reacht the 2nd tick position\n          var remainingDaysOfFirstMonth = dt.determineDaysOfMonths(currentMonth + 1, firstVal.minYear) - currentMonthDate + 1; // calculate the first tick position\n\n          firstTickPosition = remainingDaysOfFirstMonth * daysWidthOnXAxis;\n          firstTickValue = Utils$1.monthMod(currentMonth + 1);\n          var year = currentYear + yrCounter;\n\n          var _month = Utils$1.monthMod(firstTickValue);\n\n          var value = firstTickValue; // it's Jan, so update the year\n\n          if (firstTickValue === 0) {\n            unit = 'year';\n            value = year;\n            _month = 1;\n            yrCounter += 1;\n            year = year + yrCounter;\n          } // push the first tick in the array\n\n\n          this.timeScaleArray.push({\n            position: firstTickPosition,\n            value: value,\n            unit: unit,\n            year: year,\n            month: _month\n          });\n        } else {\n          // push the first tick in the array\n          this.timeScaleArray.push({\n            position: firstTickPosition,\n            value: firstTickValue,\n            unit: unit,\n            year: currentYear,\n            month: Utils$1.monthMod(currentMonth)\n          });\n        }\n\n        var month = firstTickValue + 1;\n        var pos = firstTickPosition; // keep drawing rest of the ticks\n\n        for (var i = 0, j = 1; i < numberOfMonths; i++, j++) {\n          month = Utils$1.monthMod(month);\n\n          if (month === 0) {\n            unit = 'year';\n            yrCounter += 1;\n          } else {\n            unit = 'month';\n          }\n\n          var _year = this._getYear(currentYear, month, yrCounter);\n\n          pos = dt.determineDaysOfMonths(month, _year) * daysWidthOnXAxis + pos;\n          var monthVal = month === 0 ? _year : month;\n          this.timeScaleArray.push({\n            position: pos,\n            value: monthVal,\n            unit: unit,\n            year: _year,\n            month: month === 0 ? 1 : month\n          });\n          month++;\n        }\n      }\n    }, {\n      key: \"generateDayScale\",\n      value: function generateDayScale(_ref3) {\n        var firstVal = _ref3.firstVal,\n            currentMonth = _ref3.currentMonth,\n            currentYear = _ref3.currentYear,\n            hoursWidthOnXAxis = _ref3.hoursWidthOnXAxis,\n            numberOfDays = _ref3.numberOfDays;\n        var dt = new DateTime(this.ctx);\n        var unit = 'day';\n        var firstTickValue = firstVal.minDate + 1;\n        var date = firstTickValue;\n\n        var changeMonth = function changeMonth(dateVal, month, year) {\n          var monthdays = dt.determineDaysOfMonths(month + 1, year);\n\n          if (dateVal > monthdays) {\n            month = month + 1;\n            date = 1;\n            unit = 'month';\n            val = month;\n            return month;\n          }\n\n          return month;\n        };\n\n        var remainingHours = 24 - firstVal.minHour;\n        var yrCounter = 0; // calculate the first tick position\n\n        var firstTickPosition = remainingHours * hoursWidthOnXAxis;\n        var val = firstTickValue;\n        var month = changeMonth(date, currentMonth, currentYear);\n\n        if (firstVal.minHour === 0 && firstVal.minDate === 1) {\n          // the first value is the first day of month\n          firstTickPosition = 0;\n          val = Utils$1.monthMod(firstVal.minMonth);\n          unit = 'month';\n          date = firstVal.minDate; // numberOfDays++\n          // removed the above line to fix https://github.com/apexcharts/apexcharts.js/issues/305#issuecomment-1019520513\n        } else if (firstVal.minDate !== 1 && firstVal.minHour === 0 && firstVal.minMinute === 0) {\n          // fixes apexcharts/apexcharts.js/issues/1730\n          firstTickPosition = 0;\n          firstTickValue = firstVal.minDate;\n          date = firstTickValue;\n          val = firstTickValue; // in case it's the last date of month, we need to check it\n\n          month = changeMonth(date, currentMonth, currentYear);\n        } // push the first tick in the array\n\n\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: val,\n          unit: unit,\n          year: this._getYear(currentYear, month, yrCounter),\n          month: Utils$1.monthMod(month),\n          day: date\n        });\n        var pos = firstTickPosition; // keep drawing rest of the ticks\n\n        for (var i = 0; i < numberOfDays; i++) {\n          date += 1;\n          unit = 'day';\n          month = changeMonth(date, month, this._getYear(currentYear, month, yrCounter));\n\n          var year = this._getYear(currentYear, month, yrCounter);\n\n          pos = 24 * hoursWidthOnXAxis + pos;\n          var value = date === 1 ? Utils$1.monthMod(month) : date;\n          this.timeScaleArray.push({\n            position: pos,\n            value: value,\n            unit: unit,\n            year: year,\n            month: Utils$1.monthMod(month),\n            day: value\n          });\n        }\n      }\n    }, {\n      key: \"generateHourScale\",\n      value: function generateHourScale(_ref4) {\n        var firstVal = _ref4.firstVal,\n            currentDate = _ref4.currentDate,\n            currentMonth = _ref4.currentMonth,\n            currentYear = _ref4.currentYear,\n            minutesWidthOnXAxis = _ref4.minutesWidthOnXAxis,\n            numberOfHours = _ref4.numberOfHours;\n        var dt = new DateTime(this.ctx);\n        var yrCounter = 0;\n        var unit = 'hour';\n\n        var changeDate = function changeDate(dateVal, month) {\n          var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);\n\n          if (dateVal > monthdays) {\n            date = 1;\n            month = month + 1;\n          }\n\n          return {\n            month: month,\n            date: date\n          };\n        };\n\n        var changeMonth = function changeMonth(dateVal, month) {\n          var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);\n\n          if (dateVal > monthdays) {\n            month = month + 1;\n            return month;\n          }\n\n          return month;\n        }; // factor in minSeconds as well\n\n\n        var remainingMins = 60 - (firstVal.minMinute + firstVal.minSecond / 60.0);\n        var firstTickPosition = remainingMins * minutesWidthOnXAxis;\n        var firstTickValue = firstVal.minHour + 1;\n        var hour = firstTickValue;\n\n        if (remainingMins === 60) {\n          firstTickPosition = 0;\n          firstTickValue = firstVal.minHour;\n          hour = firstTickValue + 1;\n        }\n\n        var date = currentDate; // we need to apply date switching logic here as well, to avoid duplicated labels\n\n        if (hour >= 24) {\n          hour = 0;\n          date += 1;\n          unit = 'day';\n        }\n\n        var checkNextMonth = changeDate(date, currentMonth);\n        var month = checkNextMonth.month;\n        month = changeMonth(date, month); // push the first tick in the array\n\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: firstTickValue,\n          unit: unit,\n          day: date,\n          hour: hour,\n          year: currentYear,\n          month: Utils$1.monthMod(month)\n        });\n        hour++;\n        var pos = firstTickPosition; // keep drawing rest of the ticks\n\n        for (var i = 0; i < numberOfHours; i++) {\n          unit = 'hour';\n\n          if (hour >= 24) {\n            hour = 0;\n            date += 1;\n            unit = 'day';\n\n            var _checkNextMonth = changeDate(date, month);\n\n            month = _checkNextMonth.month;\n            month = changeMonth(date, month);\n          }\n\n          var year = this._getYear(currentYear, month, yrCounter);\n\n          pos = 60 * minutesWidthOnXAxis + pos;\n          var val = hour === 0 ? date : hour;\n          this.timeScaleArray.push({\n            position: pos,\n            value: val,\n            unit: unit,\n            hour: hour,\n            day: date,\n            year: year,\n            month: Utils$1.monthMod(month)\n          });\n          hour++;\n        }\n      }\n    }, {\n      key: \"generateMinuteScale\",\n      value: function generateMinuteScale(_ref5) {\n        var currentMillisecond = _ref5.currentMillisecond,\n            currentSecond = _ref5.currentSecond,\n            currentMinute = _ref5.currentMinute,\n            currentHour = _ref5.currentHour,\n            currentDate = _ref5.currentDate,\n            currentMonth = _ref5.currentMonth,\n            currentYear = _ref5.currentYear,\n            minutesWidthOnXAxis = _ref5.minutesWidthOnXAxis,\n            secondsWidthOnXAxis = _ref5.secondsWidthOnXAxis,\n            numberOfMinutes = _ref5.numberOfMinutes;\n        var yrCounter = 0;\n        var unit = 'minute';\n        var remainingSecs = 60 - currentSecond;\n        var firstTickPosition = (remainingSecs - currentMillisecond / 1000) * secondsWidthOnXAxis;\n        var minute = currentMinute + 1;\n        var date = currentDate;\n        var month = currentMonth;\n        var year = currentYear;\n        var hour = currentHour;\n        var pos = firstTickPosition;\n\n        for (var i = 0; i < numberOfMinutes; i++) {\n          if (minute >= 60) {\n            minute = 0;\n            hour += 1;\n\n            if (hour === 24) {\n              hour = 0;\n            }\n          }\n\n          this.timeScaleArray.push({\n            position: pos,\n            value: minute,\n            unit: unit,\n            hour: hour,\n            minute: minute,\n            day: date,\n            year: this._getYear(year, month, yrCounter),\n            month: Utils$1.monthMod(month)\n          });\n          pos += minutesWidthOnXAxis;\n          minute++;\n        }\n      }\n    }, {\n      key: \"generateSecondScale\",\n      value: function generateSecondScale(_ref6) {\n        var currentMillisecond = _ref6.currentMillisecond,\n            currentSecond = _ref6.currentSecond,\n            currentMinute = _ref6.currentMinute,\n            currentHour = _ref6.currentHour,\n            currentDate = _ref6.currentDate,\n            currentMonth = _ref6.currentMonth,\n            currentYear = _ref6.currentYear,\n            secondsWidthOnXAxis = _ref6.secondsWidthOnXAxis,\n            numberOfSeconds = _ref6.numberOfSeconds;\n        var yrCounter = 0;\n        var unit = 'second';\n        var remainingMillisecs = 1000 - currentMillisecond;\n        var firstTickPosition = remainingMillisecs / 1000 * secondsWidthOnXAxis;\n        var second = currentSecond + 1;\n        var minute = currentMinute;\n        var date = currentDate;\n        var month = currentMonth;\n        var year = currentYear;\n        var hour = currentHour;\n        var pos = firstTickPosition;\n\n        for (var i = 0; i < numberOfSeconds; i++) {\n          if (second >= 60) {\n            minute++;\n            second = 0;\n\n            if (minute >= 60) {\n              hour++;\n              minute = 0;\n\n              if (hour === 24) {\n                hour = 0;\n              }\n            }\n          }\n\n          this.timeScaleArray.push({\n            position: pos,\n            value: second,\n            unit: unit,\n            hour: hour,\n            minute: minute,\n            second: second,\n            day: date,\n            year: this._getYear(year, month, yrCounter),\n            month: Utils$1.monthMod(month)\n          });\n          pos += secondsWidthOnXAxis;\n          second++;\n        }\n      }\n    }, {\n      key: \"createRawDateString\",\n      value: function createRawDateString(ts, value) {\n        var raw = ts.year;\n\n        if (ts.month === 0) {\n          // invalid month, correct it\n          ts.month = 1;\n        }\n\n        raw += '-' + ('0' + ts.month.toString()).slice(-2); // unit is day\n\n        if (ts.unit === 'day') {\n          raw += ts.unit === 'day' ? '-' + ('0' + value).slice(-2) : '-01';\n        } else {\n          raw += '-' + ('0' + (ts.day ? ts.day : '1')).slice(-2);\n        } // unit is hour\n\n\n        if (ts.unit === 'hour') {\n          raw += ts.unit === 'hour' ? 'T' + ('0' + value).slice(-2) : 'T00';\n        } else {\n          raw += 'T' + ('0' + (ts.hour ? ts.hour : '0')).slice(-2);\n        }\n\n        if (ts.unit === 'minute') {\n          raw += ':' + ('0' + value).slice(-2);\n        } else {\n          raw += ':' + (ts.minute ? ('0' + ts.minute).slice(-2) : '00');\n        }\n\n        if (ts.unit === 'second') {\n          raw += ':' + ('0' + value).slice(-2);\n        } else {\n          raw += ':00';\n        }\n\n        if (this.utc) {\n          raw += '.000Z';\n        }\n\n        return raw;\n      }\n    }, {\n      key: \"formatDates\",\n      value: function formatDates(filteredTimeScale) {\n        var _this2 = this;\n\n        var w = this.w;\n        var reformattedTimescaleArray = filteredTimeScale.map(function (ts) {\n          var value = ts.value.toString();\n          var dt = new DateTime(_this2.ctx);\n\n          var raw = _this2.createRawDateString(ts, value);\n\n          var dateToFormat = dt.getDate(dt.parseDate(raw));\n\n          if (!_this2.utc) {\n            // Fixes #1726, #1544, #1485, #1255\n            dateToFormat = dt.getDate(dt.parseDateWithTimezone(raw));\n          }\n\n          if (w.config.xaxis.labels.format === undefined) {\n            var customFormat = 'dd MMM';\n            var dtFormatter = w.config.xaxis.labels.datetimeFormatter;\n            if (ts.unit === 'year') customFormat = dtFormatter.year;\n            if (ts.unit === 'month') customFormat = dtFormatter.month;\n            if (ts.unit === 'day') customFormat = dtFormatter.day;\n            if (ts.unit === 'hour') customFormat = dtFormatter.hour;\n            if (ts.unit === 'minute') customFormat = dtFormatter.minute;\n            if (ts.unit === 'second') customFormat = dtFormatter.second;\n            value = dt.formatDate(dateToFormat, customFormat);\n          } else {\n            value = dt.formatDate(dateToFormat, w.config.xaxis.labels.format);\n          }\n\n          return {\n            dateString: raw,\n            position: ts.position,\n            value: value,\n            unit: ts.unit,\n            year: ts.year,\n            month: ts.month\n          };\n        });\n        return reformattedTimescaleArray;\n      }\n    }, {\n      key: \"removeOverlappingTS\",\n      value: function removeOverlappingTS(arr) {\n        var _this3 = this;\n\n        var graphics = new Graphics(this.ctx);\n        var equalLabelLengthFlag = false; // These labels got same length?\n\n        var constantLabelWidth; // If true, what is the constant length to use\n\n        if (arr.length > 0 && // check arr length\n        arr[0].value && // check arr[0] contains value\n        arr.every(function (lb) {\n          return lb.value.length === arr[0].value.length;\n        }) // check every arr label value is the same as the first one\n        ) {\n          equalLabelLengthFlag = true; // These labels got same length\n\n          constantLabelWidth = graphics.getTextRects(arr[0].value).width; // The constant label width to use\n        }\n\n        var lastDrawnIndex = 0;\n        var filteredArray = arr.map(function (item, index) {\n          if (index > 0 && _this3.w.config.xaxis.labels.hideOverlappingLabels) {\n            var prevLabelWidth = !equalLabelLengthFlag // if vary in label length\n            ? graphics.getTextRects(arr[lastDrawnIndex].value).width // get individual length\n            : constantLabelWidth; // else: use constant length\n\n            var prevPos = arr[lastDrawnIndex].position;\n            var pos = item.position;\n\n            if (pos > prevPos + prevLabelWidth + 10) {\n              lastDrawnIndex = index;\n              return item;\n            } else {\n              return null;\n            }\n          } else {\n            return item;\n          }\n        });\n        filteredArray = filteredArray.filter(function (f) {\n          return f !== null;\n        });\n        return filteredArray;\n      }\n    }, {\n      key: \"_getYear\",\n      value: function _getYear(currentYear, month, yrCounter) {\n        return currentYear + Math.floor(month / 12) + yrCounter;\n      }\n    }]);\n\n    return TimeScale;\n  }();\n\n  /**\n   * ApexCharts Core Class responsible for major calculations and creating elements.\n   *\n   * @module Core\n   **/\n\n  var Core = /*#__PURE__*/function () {\n    function Core(el, ctx) {\n      _classCallCheck(this, Core);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n      this.el = el;\n    } // get data and store into appropriate vars\n\n\n    _createClass(Core, [{\n      key: \"setupElements\",\n      value: function setupElements() {\n        var gl = this.w.globals;\n        var cnf = this.w.config; // const graphics = new Graphics(this.ctx)\n\n        var ct = cnf.chart.type;\n        var axisChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', 'rangeArea', 'candlestick', 'boxPlot', 'scatter', 'bubble', 'radar', 'heatmap', 'treemap'];\n        var xyChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', 'rangeArea', 'candlestick', 'boxPlot', 'scatter', 'bubble'];\n        gl.axisCharts = axisChartsArrTypes.indexOf(ct) > -1;\n        gl.xyCharts = xyChartsArrTypes.indexOf(ct) > -1;\n        gl.isBarHorizontal = (cnf.chart.type === 'bar' || cnf.chart.type === 'rangeBar' || cnf.chart.type === 'boxPlot') && cnf.plotOptions.bar.horizontal;\n        gl.chartClass = '.apexcharts' + gl.chartID;\n        gl.dom.baseEl = this.el;\n        gl.dom.elWrap = document.createElement('div');\n        Graphics.setAttrs(gl.dom.elWrap, {\n          id: gl.chartClass.substring(1),\n          class: 'apexcharts-canvas ' + gl.chartClass.substring(1)\n        });\n        this.el.appendChild(gl.dom.elWrap);\n        gl.dom.Paper = new window.SVG.Doc(gl.dom.elWrap);\n        gl.dom.Paper.attr({\n          class: 'apexcharts-svg',\n          'xmlns:data': 'ApexChartsNS',\n          transform: \"translate(\".concat(cnf.chart.offsetX, \", \").concat(cnf.chart.offsetY, \")\")\n        });\n        gl.dom.Paper.node.style.background = cnf.theme.mode === 'dark' && cnf.chart.background === 'transparent' ? 'rgba(0, 0, 0, 0.8)' : cnf.chart.background;\n        this.setSVGDimensions(); // append foreignElement (legend's parent)\n        // legend is kept in foreignElement to be included while exporting\n        // removing foreignElement and creating legend through HTML will not render legend in export\n\n        gl.dom.elLegendForeign = document.createElementNS(gl.SVGNS, 'foreignObject');\n        Graphics.setAttrs(gl.dom.elLegendForeign, {\n          x: 0,\n          y: 0,\n          width: gl.svgWidth,\n          height: gl.svgHeight\n        });\n        gl.dom.elLegendWrap = document.createElement('div');\n        gl.dom.elLegendWrap.classList.add('apexcharts-legend');\n        gl.dom.elLegendWrap.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n        gl.dom.elLegendForeign.appendChild(gl.dom.elLegendWrap);\n        gl.dom.Paper.node.appendChild(gl.dom.elLegendForeign); // the elGraphical is the parent of all primary visuals\n\n        gl.dom.elGraphical = gl.dom.Paper.group().attr({\n          class: 'apexcharts-inner apexcharts-graphical'\n        });\n        gl.dom.elDefs = gl.dom.Paper.defs();\n        gl.dom.Paper.add(gl.dom.elGraphical);\n        gl.dom.elGraphical.add(gl.dom.elDefs);\n      }\n    }, {\n      key: \"plotChartType\",\n      value: function plotChartType(ser, xyRatios) {\n        var w = this.w;\n        var cnf = w.config;\n        var gl = w.globals;\n        var lineSeries = {\n          series: [],\n          i: []\n        };\n        var areaSeries = {\n          series: [],\n          i: []\n        };\n        var scatterSeries = {\n          series: [],\n          i: []\n        };\n        var bubbleSeries = {\n          series: [],\n          i: []\n        };\n        var columnSeries = {\n          series: [],\n          i: []\n        };\n        var candlestickSeries = {\n          series: [],\n          i: []\n        };\n        var boxplotSeries = {\n          series: [],\n          i: []\n        };\n        var rangeBarSeries = {\n          series: [],\n          i: []\n        };\n        var rangeAreaSeries = {\n          series: [],\n          seriesRangeEnd: [],\n          i: []\n        };\n        gl.series.map(function (serie, st) {\n          var comboCount = 0; // if user has specified a particular type for particular series\n\n          if (typeof ser[st].type !== 'undefined') {\n            if (ser[st].type === 'column' || ser[st].type === 'bar') {\n              if (gl.series.length > 1 && cnf.plotOptions.bar.horizontal) {\n                // horizontal bars not supported in mixed charts, hence show a warning\n                console.warn('Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`');\n              }\n\n              columnSeries.series.push(serie);\n              columnSeries.i.push(st);\n              comboCount++;\n              w.globals.columnSeries = columnSeries.series;\n            } else if (ser[st].type === 'area') {\n              areaSeries.series.push(serie);\n              areaSeries.i.push(st);\n              comboCount++;\n            } else if (ser[st].type === 'line') {\n              lineSeries.series.push(serie);\n              lineSeries.i.push(st);\n              comboCount++;\n            } else if (ser[st].type === 'scatter') {\n              scatterSeries.series.push(serie);\n              scatterSeries.i.push(st);\n            } else if (ser[st].type === 'bubble') {\n              bubbleSeries.series.push(serie);\n              bubbleSeries.i.push(st);\n              comboCount++;\n            } else if (ser[st].type === 'candlestick') {\n              candlestickSeries.series.push(serie);\n              candlestickSeries.i.push(st);\n              comboCount++;\n            } else if (ser[st].type === 'boxPlot') {\n              boxplotSeries.series.push(serie);\n              boxplotSeries.i.push(st);\n              comboCount++;\n            } else if (ser[st].type === 'rangeBar') {\n              rangeBarSeries.series.push(serie);\n              rangeBarSeries.i.push(st);\n              comboCount++;\n            } else if (ser[st].type === 'rangeArea') {\n              rangeAreaSeries.series.push(gl.seriesRangeStart[st]);\n              rangeAreaSeries.seriesRangeEnd.push(gl.seriesRangeEnd[st]);\n              rangeAreaSeries.i.push(st);\n              comboCount++;\n            } else {\n              // user has specified type, but it is not valid (other than line/area/column)\n              console.warn('You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea');\n            }\n\n            if (comboCount > 1) {\n              gl.comboCharts = true;\n            }\n          } else {\n            lineSeries.series.push(serie);\n            lineSeries.i.push(st);\n          }\n        });\n        var line = new Line(this.ctx, xyRatios);\n        var boxCandlestick = new BoxCandleStick(this.ctx, xyRatios);\n        this.ctx.pie = new Pie(this.ctx);\n        var radialBar = new Radial(this.ctx);\n        this.ctx.rangeBar = new RangeBar(this.ctx, xyRatios);\n        var radar = new Radar(this.ctx);\n        var elGraph = [];\n\n        if (gl.comboCharts) {\n          if (areaSeries.series.length > 0) {\n            elGraph.push(line.draw(areaSeries.series, 'area', areaSeries.i));\n          }\n\n          if (columnSeries.series.length > 0) {\n            if (w.config.chart.stacked) {\n              var barStacked = new BarStacked(this.ctx, xyRatios);\n              elGraph.push(barStacked.draw(columnSeries.series, columnSeries.i));\n            } else {\n              this.ctx.bar = new Bar(this.ctx, xyRatios);\n              elGraph.push(this.ctx.bar.draw(columnSeries.series, columnSeries.i));\n            }\n          }\n\n          if (rangeAreaSeries.series.length > 0) {\n            elGraph.push(line.draw(rangeAreaSeries.series, 'rangeArea', rangeAreaSeries.i, rangeAreaSeries.seriesRangeEnd));\n          }\n\n          if (lineSeries.series.length > 0) {\n            elGraph.push(line.draw(lineSeries.series, 'line', lineSeries.i));\n          }\n\n          if (candlestickSeries.series.length > 0) {\n            elGraph.push(boxCandlestick.draw(candlestickSeries.series, 'candlestick', candlestickSeries.i));\n          }\n\n          if (boxplotSeries.series.length > 0) {\n            elGraph.push(boxCandlestick.draw(boxplotSeries.series, 'boxPlot', boxplotSeries.i));\n          }\n\n          if (rangeBarSeries.series.length > 0) {\n            elGraph.push(this.ctx.rangeBar.draw(rangeBarSeries.series, rangeBarSeries.i));\n          }\n\n          if (scatterSeries.series.length > 0) {\n            var scatterLine = new Line(this.ctx, xyRatios, true);\n            elGraph.push(scatterLine.draw(scatterSeries.series, 'scatter', scatterSeries.i));\n          }\n\n          if (bubbleSeries.series.length > 0) {\n            var bubbleLine = new Line(this.ctx, xyRatios, true);\n            elGraph.push(bubbleLine.draw(bubbleSeries.series, 'bubble', bubbleSeries.i));\n          }\n        } else {\n          switch (cnf.chart.type) {\n            case 'line':\n              elGraph = line.draw(gl.series, 'line');\n              break;\n\n            case 'area':\n              elGraph = line.draw(gl.series, 'area');\n              break;\n\n            case 'bar':\n              if (cnf.chart.stacked) {\n                var _barStacked = new BarStacked(this.ctx, xyRatios);\n\n                elGraph = _barStacked.draw(gl.series);\n              } else {\n                this.ctx.bar = new Bar(this.ctx, xyRatios);\n                elGraph = this.ctx.bar.draw(gl.series);\n              }\n\n              break;\n\n            case 'candlestick':\n              var candleStick = new BoxCandleStick(this.ctx, xyRatios);\n              elGraph = candleStick.draw(gl.series, 'candlestick');\n              break;\n\n            case 'boxPlot':\n              var boxPlot = new BoxCandleStick(this.ctx, xyRatios);\n              elGraph = boxPlot.draw(gl.series, cnf.chart.type);\n              break;\n\n            case 'rangeBar':\n              elGraph = this.ctx.rangeBar.draw(gl.series);\n              break;\n\n            case 'rangeArea':\n              elGraph = line.draw(gl.seriesRangeStart, 'rangeArea', undefined, gl.seriesRangeEnd);\n              break;\n\n            case 'heatmap':\n              var heatmap = new HeatMap(this.ctx, xyRatios);\n              elGraph = heatmap.draw(gl.series);\n              break;\n\n            case 'treemap':\n              var treemap = new TreemapChart(this.ctx, xyRatios);\n              elGraph = treemap.draw(gl.series);\n              break;\n\n            case 'pie':\n            case 'donut':\n            case 'polarArea':\n              elGraph = this.ctx.pie.draw(gl.series);\n              break;\n\n            case 'radialBar':\n              elGraph = radialBar.draw(gl.series);\n              break;\n\n            case 'radar':\n              elGraph = radar.draw(gl.series);\n              break;\n\n            default:\n              elGraph = line.draw(gl.series);\n          }\n        }\n\n        return elGraph;\n      }\n    }, {\n      key: \"setSVGDimensions\",\n      value: function setSVGDimensions() {\n        var gl = this.w.globals;\n        var cnf = this.w.config;\n        gl.svgWidth = cnf.chart.width;\n        gl.svgHeight = cnf.chart.height;\n        var elDim = Utils$1.getDimensions(this.el);\n        var widthUnit = cnf.chart.width.toString().split(/[0-9]+/g).pop();\n\n        if (widthUnit === '%') {\n          if (Utils$1.isNumber(elDim[0])) {\n            if (elDim[0].width === 0) {\n              elDim = Utils$1.getDimensions(this.el.parentNode);\n            }\n\n            gl.svgWidth = elDim[0] * parseInt(cnf.chart.width, 10) / 100;\n          }\n        } else if (widthUnit === 'px' || widthUnit === '') {\n          gl.svgWidth = parseInt(cnf.chart.width, 10);\n        }\n\n        var heightUnit = cnf.chart.height.toString().split(/[0-9]+/g).pop();\n\n        if (gl.svgHeight !== 'auto' && gl.svgHeight !== '') {\n          if (heightUnit === '%') {\n            var elParentDim = Utils$1.getDimensions(this.el.parentNode);\n            gl.svgHeight = elParentDim[1] * parseInt(cnf.chart.height, 10) / 100;\n          } else {\n            gl.svgHeight = parseInt(cnf.chart.height, 10);\n          }\n        } else {\n          if (gl.axisCharts) {\n            gl.svgHeight = gl.svgWidth / 1.61;\n          } else {\n            gl.svgHeight = gl.svgWidth / 1.2;\n          }\n        }\n\n        if (gl.svgWidth < 0) gl.svgWidth = 0;\n        if (gl.svgHeight < 0) gl.svgHeight = 0;\n        Graphics.setAttrs(gl.dom.Paper.node, {\n          width: gl.svgWidth,\n          height: gl.svgHeight\n        });\n\n        if (heightUnit !== '%') {\n          // fixes https://github.com/apexcharts/apexcharts.js/issues/2059\n          var offsetY = cnf.chart.sparkline.enabled ? 0 : gl.axisCharts ? cnf.chart.parentHeightOffset : 0;\n          gl.dom.Paper.node.parentNode.parentNode.style.minHeight = gl.svgHeight + offsetY + 'px';\n        }\n\n        gl.dom.elWrap.style.width = gl.svgWidth + 'px';\n        gl.dom.elWrap.style.height = gl.svgHeight + 'px';\n      }\n    }, {\n      key: \"shiftGraphPosition\",\n      value: function shiftGraphPosition() {\n        var gl = this.w.globals;\n        var tY = gl.translateY;\n        var tX = gl.translateX;\n        var scalingAttrs = {\n          transform: 'translate(' + tX + ', ' + tY + ')'\n        };\n        Graphics.setAttrs(gl.dom.elGraphical.node, scalingAttrs);\n      } // To prevent extra spacings in the bottom of the chart, we need to recalculate the height for pie/donut/radialbar charts\n\n    }, {\n      key: \"resizeNonAxisCharts\",\n      value: function resizeNonAxisCharts() {\n        var w = this.w;\n        var gl = w.globals;\n        var legendHeight = 0;\n        var offY = w.config.chart.sparkline.enabled ? 1 : 15;\n        offY = offY + w.config.grid.padding.bottom;\n\n        if ((w.config.legend.position === 'top' || w.config.legend.position === 'bottom') && w.config.legend.show && !w.config.legend.floating) {\n          legendHeight = new Legend(this.ctx).legendHelpers.getLegendBBox().clwh + 10;\n        }\n\n        var el = w.globals.dom.baseEl.querySelector('.apexcharts-radialbar, .apexcharts-pie');\n        var chartInnerDimensions = w.globals.radialSize * 2.05;\n\n        if (el && !w.config.chart.sparkline.enabled && w.config.plotOptions.radialBar.startAngle !== 0) {\n          var elRadialRect = Utils$1.getBoundingClientRect(el);\n          chartInnerDimensions = elRadialRect.bottom;\n          var maxHeight = elRadialRect.bottom - elRadialRect.top;\n          chartInnerDimensions = Math.max(w.globals.radialSize * 2.05, maxHeight);\n        }\n\n        var newHeight = chartInnerDimensions + gl.translateY + legendHeight + offY;\n\n        if (gl.dom.elLegendForeign) {\n          gl.dom.elLegendForeign.setAttribute('height', newHeight);\n        } // fix apexcharts/apexcharts.js/issues/3105 (when % is provided in height, it keeps increasing)\n\n\n        if (w.config.chart.height && String(w.config.chart.height).indexOf('%') > 0) return;\n        gl.dom.elWrap.style.height = newHeight + 'px';\n        Graphics.setAttrs(gl.dom.Paper.node, {\n          height: newHeight\n        });\n        gl.dom.Paper.node.parentNode.parentNode.style.minHeight = newHeight + 'px';\n      }\n      /*\n       ** All the calculations for setting range in charts will be done here\n       */\n\n    }, {\n      key: \"coreCalculations\",\n      value: function coreCalculations() {\n        var range = new Range(this.ctx);\n        range.init();\n      }\n    }, {\n      key: \"resetGlobals\",\n      value: function resetGlobals() {\n        var _this = this;\n\n        var resetxyValues = function resetxyValues() {\n          return _this.w.config.series.map(function (s) {\n            return [];\n          });\n        };\n\n        var globalObj = new Globals();\n        var gl = this.w.globals;\n        globalObj.initGlobalVars(gl);\n        gl.seriesXvalues = resetxyValues();\n        gl.seriesYvalues = resetxyValues();\n      }\n    }, {\n      key: \"isMultipleY\",\n      value: function isMultipleY() {\n        // user has supplied an array in yaxis property. So, turn on multipleYAxis flag\n        if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) {\n          this.w.globals.isMultipleYAxis = true;\n          return true;\n        }\n      }\n    }, {\n      key: \"xySettings\",\n      value: function xySettings() {\n        var xyRatios = null;\n        var w = this.w;\n\n        if (w.globals.axisCharts) {\n          if (w.config.xaxis.crosshairs.position === 'back') {\n            var crosshairs = new Crosshairs(this.ctx);\n            crosshairs.drawXCrosshairs();\n          }\n\n          if (w.config.yaxis[0].crosshairs.position === 'back') {\n            var _crosshairs = new Crosshairs(this.ctx);\n\n            _crosshairs.drawYCrosshairs();\n          }\n\n          if (w.config.xaxis.type === 'datetime' && w.config.xaxis.labels.formatter === undefined) {\n            this.ctx.timeScale = new TimeScale(this.ctx);\n            var formattedTimeScale = [];\n\n            if (isFinite(w.globals.minX) && isFinite(w.globals.maxX) && !w.globals.isBarHorizontal) {\n              formattedTimeScale = this.ctx.timeScale.calculateTimeScaleTicks(w.globals.minX, w.globals.maxX);\n            } else if (w.globals.isBarHorizontal) {\n              formattedTimeScale = this.ctx.timeScale.calculateTimeScaleTicks(w.globals.minY, w.globals.maxY);\n            }\n\n            this.ctx.timeScale.recalcDimensionsBasedOnFormat(formattedTimeScale);\n          }\n\n          var coreUtils = new CoreUtils(this.ctx);\n          xyRatios = coreUtils.getCalculatedRatios();\n        }\n\n        return xyRatios;\n      }\n    }, {\n      key: \"updateSourceChart\",\n      value: function updateSourceChart(targetChart) {\n        this.ctx.w.globals.selection = undefined;\n\n        this.ctx.updateHelpers._updateOptions({\n          chart: {\n            selection: {\n              xaxis: {\n                min: targetChart.w.globals.minX,\n                max: targetChart.w.globals.maxX\n              }\n            }\n          }\n        }, false, false);\n      }\n    }, {\n      key: \"setupBrushHandler\",\n      value: function setupBrushHandler() {\n        var _this2 = this;\n\n        var w = this.w; // only for brush charts\n\n        if (!w.config.chart.brush.enabled) {\n          return;\n        } // if user has not defined a custom function for selection - we handle the brush chart\n        // otherwise we leave it to the user to define the functionality for selection\n\n\n        if (typeof w.config.chart.events.selection !== 'function') {\n          var targets = Array.isArray(w.config.chart.brush.targets) || [w.config.chart.brush.target]; // retro compatibility with single target option\n\n          targets.forEach(function (target) {\n            var targetChart = ApexCharts.getChartByID(target);\n            targetChart.w.globals.brushSource = _this2.ctx;\n\n            if (typeof targetChart.w.config.chart.events.zoomed !== 'function') {\n              targetChart.w.config.chart.events.zoomed = function () {\n                _this2.updateSourceChart(targetChart);\n              };\n            }\n\n            if (typeof targetChart.w.config.chart.events.scrolled !== 'function') {\n              targetChart.w.config.chart.events.scrolled = function () {\n                _this2.updateSourceChart(targetChart);\n              };\n            }\n          });\n\n          w.config.chart.events.selection = function (chart, e) {\n            targets.forEach(function (target) {\n              var targetChart = ApexCharts.getChartByID(target);\n              var yaxis = Utils$1.clone(w.config.yaxis);\n\n              if (w.config.chart.brush.autoScaleYaxis && targetChart.w.globals.series.length === 1) {\n                var scale = new Range$1(targetChart);\n                yaxis = scale.autoScaleY(targetChart, yaxis, e);\n              }\n\n              var multipleYaxis = targetChart.w.config.yaxis.reduce(function (acc, curr, index) {\n                return [].concat(_toConsumableArray(acc), [_objectSpread2(_objectSpread2({}, targetChart.w.config.yaxis[index]), {}, {\n                  min: yaxis[0].min,\n                  max: yaxis[0].max\n                })]);\n              }, []);\n\n              targetChart.ctx.updateHelpers._updateOptions({\n                xaxis: {\n                  min: e.xaxis.min,\n                  max: e.xaxis.max\n                },\n                yaxis: multipleYaxis\n              }, false, false, false, false);\n            });\n          };\n        }\n      }\n    }]);\n\n    return Core;\n  }();\n\n  var UpdateHelpers = /*#__PURE__*/function () {\n    function UpdateHelpers(ctx) {\n      _classCallCheck(this, UpdateHelpers);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n    /**\n     * private method to update Options.\n     *\n     * @param {object} options - A new config object can be passed which will be merged with the existing config object\n     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there\n     * @param {boolean} animate - should animate or not on updating Options\n     * @param {boolean} overwriteInitialConfig - should update the initial config or not\n     */\n\n\n    _createClass(UpdateHelpers, [{\n      key: \"_updateOptions\",\n      value: function _updateOptions(options) {\n        var _this = this;\n\n        var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var updateSyncedCharts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var overwriteInitialConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n        return new Promise(function (resolve) {\n          var charts = [_this.ctx];\n\n          if (updateSyncedCharts) {\n            charts = _this.ctx.getSyncedCharts();\n          }\n\n          if (_this.ctx.w.globals.isExecCalled) {\n            // If the user called exec method, we don't want to get grouped charts as user specifically provided a chartID to update\n            charts = [_this.ctx];\n            _this.ctx.w.globals.isExecCalled = false;\n          }\n\n          charts.forEach(function (ch, chartIndex) {\n            var w = ch.w;\n            w.globals.shouldAnimate = animate;\n\n            if (!redraw) {\n              w.globals.resized = true;\n              w.globals.dataChanged = true;\n\n              if (animate) {\n                ch.series.getPreviousPaths();\n              }\n            }\n\n            if (options && _typeof(options) === 'object') {\n              ch.config = new Config(options);\n              options = CoreUtils.extendArrayProps(ch.config, options, w); // fixes #914, #623\n\n              if (ch.w.globals.chartID !== _this.ctx.w.globals.chartID) {\n                // don't overwrite series of synchronized charts\n                delete options.series;\n              }\n\n              w.config = Utils$1.extend(w.config, options);\n\n              if (overwriteInitialConfig) {\n                // we need to forget the lastXAxis and lastYAxis as user forcefully overwriteInitialConfig. If we do not do this, and next time when user zooms the chart after setting yaxis.min/max or xaxis.min/max - the stored lastXAxis will never allow the chart to use the updated min/max by user.\n                w.globals.lastXAxis = options.xaxis ? Utils$1.clone(options.xaxis) : [];\n                w.globals.lastYAxis = options.yaxis ? Utils$1.clone(options.yaxis) : []; // After forgetting lastAxes, we need to restore the new config in initialConfig/initialSeries\n\n                w.globals.initialConfig = Utils$1.extend({}, w.config);\n                w.globals.initialSeries = Utils$1.clone(w.config.series);\n\n                if (options.series) {\n                  // Replace the collapsed series data\n                  for (var i = 0; i < w.globals.collapsedSeriesIndices.length; i++) {\n                    var series = w.config.series[w.globals.collapsedSeriesIndices[i]];\n                    w.globals.collapsedSeries[i].data = w.globals.axisCharts ? series.data.slice() : series;\n                  }\n\n                  for (var _i = 0; _i < w.globals.ancillaryCollapsedSeriesIndices.length; _i++) {\n                    var _series = w.config.series[w.globals.ancillaryCollapsedSeriesIndices[_i]];\n                    w.globals.ancillaryCollapsedSeries[_i].data = w.globals.axisCharts ? _series.data.slice() : _series;\n                  } // Ensure that auto-generated axes are scaled to the visible data\n\n\n                  ch.series.emptyCollapsedSeries(w.config.series);\n                }\n              }\n            }\n\n            return ch.update(options).then(function () {\n              if (chartIndex === charts.length - 1) {\n                resolve(ch);\n              }\n            });\n          });\n        });\n      }\n      /**\n       * Private method to update Series.\n       *\n       * @param {array} series - New series which will override the existing\n       */\n\n    }, {\n      key: \"_updateSeries\",\n      value: function _updateSeries(newSeries, animate) {\n        var _this2 = this;\n\n        var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        return new Promise(function (resolve) {\n          var w = _this2.w;\n          w.globals.shouldAnimate = animate;\n          w.globals.dataChanged = true;\n\n          if (animate) {\n            _this2.ctx.series.getPreviousPaths();\n          }\n\n          var existingSeries; // axis charts\n\n          if (w.globals.axisCharts) {\n            existingSeries = newSeries.map(function (s, i) {\n              return _this2._extendSeries(s, i);\n            });\n\n            if (existingSeries.length === 0) {\n              existingSeries = [{\n                data: []\n              }];\n            }\n\n            w.config.series = existingSeries;\n          } else {\n            // non-axis chart (pie/radialbar)\n            w.config.series = newSeries.slice();\n          }\n\n          if (overwriteInitialSeries) {\n            w.globals.initialConfig.series = Utils$1.clone(w.config.series);\n            w.globals.initialSeries = Utils$1.clone(w.config.series);\n          }\n\n          return _this2.ctx.update().then(function () {\n            resolve(_this2.ctx);\n          });\n        });\n      }\n    }, {\n      key: \"_extendSeries\",\n      value: function _extendSeries(s, i) {\n        var w = this.w;\n        var ser = w.config.series[i];\n        return _objectSpread2(_objectSpread2({}, w.config.series[i]), {}, {\n          name: s.name ? s.name : ser && ser.name,\n          color: s.color ? s.color : ser && ser.color,\n          type: s.type ? s.type : ser && ser.type,\n          group: s.group ? s.group : ser && ser.group,\n          data: s.data ? s.data : ser && ser.data\n        });\n      }\n    }, {\n      key: \"toggleDataPointSelection\",\n      value: function toggleDataPointSelection(seriesIndex, dataPointIndex) {\n        var w = this.w;\n        var elPath = null;\n        var parent = \".apexcharts-series[data\\\\:realIndex='\".concat(seriesIndex, \"']\");\n\n        if (w.globals.axisCharts) {\n          elPath = w.globals.dom.Paper.select(\"\".concat(parent, \" path[j='\").concat(dataPointIndex, \"'], \").concat(parent, \" circle[j='\").concat(dataPointIndex, \"'], \").concat(parent, \" rect[j='\").concat(dataPointIndex, \"']\")).members[0];\n        } else {\n          // dataPointIndex will be undefined here, hence using seriesIndex\n          if (typeof dataPointIndex === 'undefined') {\n            elPath = w.globals.dom.Paper.select(\"\".concat(parent, \" path[j='\").concat(seriesIndex, \"']\")).members[0];\n\n            if (w.config.chart.type === 'pie' || w.config.chart.type === 'polarArea' || w.config.chart.type === 'donut') {\n              this.ctx.pie.pieClicked(seriesIndex);\n            }\n          }\n        }\n\n        if (elPath) {\n          var graphics = new Graphics(this.ctx);\n          graphics.pathMouseDown(elPath, null);\n        } else {\n          console.warn('toggleDataPointSelection: Element not found');\n          return null;\n        }\n\n        return elPath.node ? elPath.node : null;\n      }\n    }, {\n      key: \"forceXAxisUpdate\",\n      value: function forceXAxisUpdate(options) {\n        var w = this.w;\n        var minmax = ['min', 'max'];\n        minmax.forEach(function (a) {\n          if (typeof options.xaxis[a] !== 'undefined') {\n            w.config.xaxis[a] = options.xaxis[a];\n            w.globals.lastXAxis[a] = options.xaxis[a];\n          }\n        });\n\n        if (options.xaxis.categories && options.xaxis.categories.length) {\n          w.config.xaxis.categories = options.xaxis.categories;\n        }\n\n        if (w.config.xaxis.convertedCatToNumeric) {\n          var defaults = new Defaults(options);\n          options = defaults.convertCatToNumericXaxis(options, this.ctx);\n        }\n\n        return options;\n      }\n    }, {\n      key: \"forceYAxisUpdate\",\n      value: function forceYAxisUpdate(options) {\n        if (options.chart && options.chart.stacked && options.chart.stackType === '100%') {\n          if (Array.isArray(options.yaxis)) {\n            options.yaxis.forEach(function (yaxe, index) {\n              options.yaxis[index].min = 0;\n              options.yaxis[index].max = 100;\n            });\n          } else {\n            options.yaxis.min = 0;\n            options.yaxis.max = 100;\n          }\n        }\n\n        return options;\n      }\n      /**\n       * This function reverts the yaxis and xaxis min/max values to what it was when the chart was defined.\n       * This function fixes an important bug where a user might load a new series after zooming in/out of previous series which resulted in wrong min/max\n       * Also, this should never be called internally on zoom/pan - the reset should only happen when user calls the updateSeries() function externally\n       * The function also accepts an object {xaxis, yaxis} which when present is set as the new xaxis/yaxis\n       */\n\n    }, {\n      key: \"revertDefaultAxisMinMax\",\n      value: function revertDefaultAxisMinMax(opts) {\n        var _this3 = this;\n\n        var w = this.w;\n        var xaxis = w.globals.lastXAxis;\n        var yaxis = w.globals.lastYAxis;\n\n        if (opts && opts.xaxis) {\n          xaxis = opts.xaxis;\n        }\n\n        if (opts && opts.yaxis) {\n          yaxis = opts.yaxis;\n        }\n\n        w.config.xaxis.min = xaxis.min;\n        w.config.xaxis.max = xaxis.max;\n\n        var getLastYAxis = function getLastYAxis(index) {\n          if (typeof yaxis[index] !== 'undefined') {\n            w.config.yaxis[index].min = yaxis[index].min;\n            w.config.yaxis[index].max = yaxis[index].max;\n          }\n        };\n\n        w.config.yaxis.map(function (yaxe, index) {\n          if (w.globals.zoomed) {\n            // user has zoomed, check the last yaxis\n            getLastYAxis(index);\n          } else {\n            // user hasn't zoomed, check the last yaxis first\n            if (typeof yaxis[index] !== 'undefined') {\n              getLastYAxis(index);\n            } else {\n              // if last y-axis don't exist, check the original yaxis\n              if (typeof _this3.ctx.opts.yaxis[index] !== 'undefined') {\n                yaxe.min = _this3.ctx.opts.yaxis[index].min;\n                yaxe.max = _this3.ctx.opts.yaxis[index].max;\n              }\n            }\n          }\n        });\n      }\n    }]);\n\n    return UpdateHelpers;\n  }();\n\n  (function (root, factory) {\n    /* istanbul ignore next */\n    if (true) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return factory(root, root.document);\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      /* below check fixes #412 */\n    } else {}\n  })(typeof window !== 'undefined' ? window : undefined, function (window, document) {\n    // Find global reference - uses 'this' by default when available,\n    // falls back to 'window' otherwise (for bundlers like Webpack)\n    var globalRef = typeof this !== 'undefined' ? this : window; // The main wrapping element\n\n    var SVG = globalRef.SVG = function (element) {\n      if (SVG.supported) {\n        element = new SVG.Doc(element);\n\n        if (!SVG.parser.draw) {\n          SVG.prepare();\n        }\n\n        return element;\n      }\n    }; // Default namespaces\n\n\n    SVG.ns = 'http://www.w3.org/2000/svg';\n    SVG.xmlns = 'http://www.w3.org/2000/xmlns/';\n    SVG.xlink = 'http://www.w3.org/1999/xlink';\n    SVG.svgjs = 'http://svgjs.dev'; // Svg support test\n\n    SVG.supported = function () {\n      return true; // !!document.createElementNS &&\n      //     !! document.createElementNS(SVG.ns,'svg').createSVGRect\n    }(); // Don't bother to continue if SVG is not supported\n\n\n    if (!SVG.supported) return false; // Element id sequence\n\n    SVG.did = 1000; // Get next named element id\n\n    SVG.eid = function (name) {\n      return 'Svgjs' + capitalize(name) + SVG.did++;\n    }; // Method for element creation\n\n\n    SVG.create = function (name) {\n      // create element\n      var element = document.createElementNS(this.ns, name); // apply unique id\n\n      element.setAttribute('id', this.eid(name));\n      return element;\n    }; // Method for extending objects\n\n\n    SVG.extend = function () {\n      var modules, methods; // Get list of modules\n\n      modules = [].slice.call(arguments); // Get object with extensions\n\n      methods = modules.pop();\n\n      for (var i = modules.length - 1; i >= 0; i--) {\n        if (modules[i]) {\n          for (var key in methods) {\n            modules[i].prototype[key] = methods[key];\n          }\n        }\n      } // Make sure SVG.Set inherits any newly added methods\n\n\n      if (SVG.Set && SVG.Set.inherit) {\n        SVG.Set.inherit();\n      }\n    }; // Invent new element\n\n\n    SVG.invent = function (config) {\n      // Create element initializer\n      var initializer = typeof config.create === 'function' ? config.create : function () {\n        this.constructor.call(this, SVG.create(config.create));\n      }; // Inherit prototype\n\n      if (config.inherit) {\n        initializer.prototype = new config.inherit();\n      } // Extend with methods\n\n\n      if (config.extend) {\n        SVG.extend(initializer, config.extend);\n      } // Attach construct method to parent\n\n\n      if (config.construct) {\n        SVG.extend(config.parent || SVG.Container, config.construct);\n      }\n\n      return initializer;\n    }; // Adopt existing svg elements\n\n\n    SVG.adopt = function (node) {\n      // check for presence of node\n      if (!node) return null; // make sure a node isn't already adopted\n\n      if (node.instance) return node.instance; // initialize variables\n\n      var element; // adopt with element-specific settings\n\n      if (node.nodeName == 'svg') {\n        element = node.parentNode instanceof window.SVGElement ? new SVG.Nested() : new SVG.Doc();\n      } else if (node.nodeName == 'linearGradient') {\n        element = new SVG.Gradient('linear');\n      } else if (node.nodeName == 'radialGradient') {\n        element = new SVG.Gradient('radial');\n      } else if (SVG[capitalize(node.nodeName)]) {\n        element = new SVG[capitalize(node.nodeName)]();\n      } else {\n        element = new SVG.Element(node);\n      } // ensure references\n\n\n      element.type = node.nodeName;\n      element.node = node;\n      node.instance = element; // SVG.Class specific preparations\n\n      if (element instanceof SVG.Doc) {\n        element.namespace().defs();\n      } // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n\n\n      element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});\n      return element;\n    }; // Initialize parsing element\n\n\n    SVG.prepare = function () {\n      // Select document body and create invisible svg element\n      var body = document.getElementsByTagName('body')[0],\n          draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0); // Create parser object\n\n      SVG.parser = {\n        body: body || document.documentElement,\n        draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node,\n        poly: draw.polyline().node,\n        path: draw.path().node,\n        native: SVG.create('svg')\n      };\n    };\n\n    SVG.parser = {\n      native: SVG.create('svg')\n    };\n    document.addEventListener('DOMContentLoaded', function () {\n      if (!SVG.parser.draw) {\n        SVG.prepare();\n      }\n    }, false); // Storage for regular expressions\n\n    SVG.regex = {\n      // Parse unit value\n      numberAndUnit: /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i,\n      // Parse hex value\n      hex: /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\n      // Parse rgb value\n      rgb: /rgb\\((\\d+),(\\d+),(\\d+)\\)/,\n      // Parse reference id\n      reference: /#([a-z0-9\\-_]+)/i,\n      // splits a transformation chain\n      transforms: /\\)\\s*,?\\s*/,\n      // Whitespace\n      whitespace: /\\s/g,\n      // Test hex value\n      isHex: /^#[a-f0-9]{3,6}$/i,\n      // Test rgb value\n      isRgb: /^rgb\\(/,\n      // Test css declaration\n      isCss: /[^:]+:[^;]+;?/,\n      // Test for blank string\n      isBlank: /^(\\s+)?$/,\n      // Test for numeric string\n      isNumber: /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\n      // Test for percent value\n      isPercent: /^-?[\\d\\.]+%$/,\n      // Test for image url\n      isImage: /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i,\n      // split at whitespace and comma\n      delimiter: /[\\s,]+/,\n      // The following regex are used to parse the d attribute of a path\n      // Matches all hyphens which are not after an exponent\n      hyphen: /([^e])\\-/gi,\n      // Replaces and tests for all path letters\n      pathLetters: /[MLHVCSQTAZ]/gi,\n      // yes we need this one, too\n      isPathLetter: /[MLHVCSQTAZ]/i,\n      // matches 0.154.23.45\n      numbersWithDots: /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi,\n      // matches .\n      dots: /\\./g\n    };\n    SVG.utils = {\n      // Map function\n      map: function map(array, block) {\n        var il = array.length,\n            result = [];\n\n        for (var i = 0; i < il; i++) {\n          result.push(block(array[i]));\n        }\n\n        return result;\n      },\n      // Filter function\n      filter: function filter(array, block) {\n        var il = array.length,\n            result = [];\n\n        for (var i = 0; i < il; i++) {\n          if (block(array[i])) {\n            result.push(array[i]);\n          }\n        }\n\n        return result;\n      },\n      filterSVGElements: function filterSVGElements(nodes) {\n        return this.filter(nodes, function (el) {\n          return el instanceof window.SVGElement;\n        });\n      }\n    };\n    SVG.defaults = {\n      // Default attribute values\n      attrs: {\n        // fill and stroke\n        'fill-opacity': 1,\n        'stroke-opacity': 1,\n        'stroke-width': 0,\n        'stroke-linejoin': 'miter',\n        'stroke-linecap': 'butt',\n        fill: '#000000',\n        stroke: '#000000',\n        opacity: 1,\n        // position\n        x: 0,\n        y: 0,\n        cx: 0,\n        cy: 0,\n        // size\n        width: 0,\n        height: 0,\n        // radius\n        r: 0,\n        rx: 0,\n        ry: 0,\n        // gradient\n        offset: 0,\n        'stop-opacity': 1,\n        'stop-color': '#000000',\n        // text\n        'font-size': 16,\n        'font-family': 'Helvetica, Arial, sans-serif',\n        'text-anchor': 'start'\n      }\n    }; // Module for color convertions\n\n    SVG.Color = function (color) {\n      var match; // initialize defaults\n\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      if (!color) return; // parse color\n\n      if (typeof color === 'string') {\n        if (SVG.regex.isRgb.test(color)) {\n          // get rgb values\n          match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace, '')); // parse numeric values\n\n          this.r = parseInt(match[1]);\n          this.g = parseInt(match[2]);\n          this.b = parseInt(match[3]);\n        } else if (SVG.regex.isHex.test(color)) {\n          // get hex values\n          match = SVG.regex.hex.exec(fullHex(color)); // parse numeric values\n\n          this.r = parseInt(match[1], 16);\n          this.g = parseInt(match[2], 16);\n          this.b = parseInt(match[3], 16);\n        }\n      } else if (_typeof(color) === 'object') {\n        this.r = color.r;\n        this.g = color.g;\n        this.b = color.b;\n      }\n    };\n\n    SVG.extend(SVG.Color, {\n      // Default to hex conversion\n      toString: function toString() {\n        return this.toHex();\n      },\n      // Build hex value\n      toHex: function toHex() {\n        return '#' + compToHex(this.r) + compToHex(this.g) + compToHex(this.b);\n      },\n      // Build rgb value\n      toRgb: function toRgb() {\n        return 'rgb(' + [this.r, this.g, this.b].join() + ')';\n      },\n      // Calculate true brightness\n      brightness: function brightness() {\n        return this.r / 255 * 0.30 + this.g / 255 * 0.59 + this.b / 255 * 0.11;\n      },\n      // Make color morphable\n      morph: function morph(color) {\n        this.destination = new SVG.Color(color);\n        return this;\n      },\n      // Get morphed color at given position\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this; // normalise pos\n\n        pos = pos < 0 ? 0 : pos > 1 ? 1 : pos; // generate morphed color\n\n        return new SVG.Color({\n          r: ~~(this.r + (this.destination.r - this.r) * pos),\n          g: ~~(this.g + (this.destination.g - this.g) * pos),\n          b: ~~(this.b + (this.destination.b - this.b) * pos)\n        });\n      }\n    }); // Testers\n    // Test if given value is a color string\n\n    SVG.Color.test = function (color) {\n      color += '';\n      return SVG.regex.isHex.test(color) || SVG.regex.isRgb.test(color);\n    }; // Test if given value is a rgb object\n\n\n    SVG.Color.isRgb = function (color) {\n      return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';\n    }; // Test if given value is a color\n\n\n    SVG.Color.isColor = function (color) {\n      return SVG.Color.isRgb(color) || SVG.Color.test(color);\n    }; // Module for array conversion\n\n\n    SVG.Array = function (array, fallback) {\n      array = (array || []).valueOf(); // if array is empty and fallback is provided, use fallback\n\n      if (array.length == 0 && fallback) {\n        array = fallback.valueOf();\n      } // parse array\n\n\n      this.value = this.parse(array);\n    };\n\n    SVG.extend(SVG.Array, {\n      // Convert array to string\n      toString: function toString() {\n        return this.value.join(' ');\n      },\n      // Real value\n      valueOf: function valueOf() {\n        return this.value;\n      },\n      // Parse whitespace separated string\n      parse: function parse(array) {\n        array = array.valueOf(); // if already is an array, no need to parse it\n\n        if (Array.isArray(array)) return array;\n        return this.split(array);\n      }\n    }); // Poly points array\n\n    SVG.PointArray = function (array, fallback) {\n      SVG.Array.call(this, array, fallback || [[0, 0]]);\n    }; // Inherit from SVG.Array\n\n\n    SVG.PointArray.prototype = new SVG.Array();\n    SVG.PointArray.prototype.constructor = SVG.PointArray;\n    var pathHandlers = {\n      M: function M(c, p, p0) {\n        p.x = p0.x = c[0];\n        p.y = p0.y = c[1];\n        return ['M', p.x, p.y];\n      },\n      L: function L(c, p) {\n        p.x = c[0];\n        p.y = c[1];\n        return ['L', c[0], c[1]];\n      },\n      H: function H(c, p) {\n        p.x = c[0];\n        return ['H', c[0]];\n      },\n      V: function V(c, p) {\n        p.y = c[0];\n        return ['V', c[0]];\n      },\n      C: function C(c, p) {\n        p.x = c[4];\n        p.y = c[5];\n        return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n      },\n      Q: function Q(c, p) {\n        p.x = c[2];\n        p.y = c[3];\n        return ['Q', c[0], c[1], c[2], c[3]];\n      },\n      S: function S(c, p) {\n        p.x = c[2];\n        p.y = c[3];\n        return ['S', c[0], c[1], c[2], c[3]];\n      },\n      Z: function Z(c, p, p0) {\n        p.x = p0.x;\n        p.y = p0.y;\n        return ['Z'];\n      }\n    };\n    var mlhvqtcsa = 'mlhvqtcsaz'.split('');\n\n    for (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {\n      pathHandlers[mlhvqtcsa[i]] = function (i) {\n        return function (c, p, p0) {\n          if (i == 'H') c[0] = c[0] + p.x;else if (i == 'V') c[0] = c[0] + p.y;else if (i == 'A') {\n            c[5] = c[5] + p.x, c[6] = c[6] + p.y;\n          } else {\n            for (var j = 0, jl = c.length; j < jl; ++j) {\n              c[j] = c[j] + (j % 2 ? p.y : p.x);\n            }\n          }\n\n          if (pathHandlers && typeof pathHandlers[i] === 'function') {\n            // this check fixes jest unit tests\n            return pathHandlers[i](c, p, p0);\n          }\n        };\n      }(mlhvqtcsa[i].toUpperCase());\n    } // Path points array\n\n\n    SVG.PathArray = function (array, fallback) {\n      SVG.Array.call(this, array, fallback || [['M', 0, 0]]);\n    }; // Inherit from SVG.Array\n\n\n    SVG.PathArray.prototype = new SVG.Array();\n    SVG.PathArray.prototype.constructor = SVG.PathArray;\n    SVG.extend(SVG.PathArray, {\n      // Convert array to string\n      toString: function toString() {\n        return arrayToString(this.value);\n      },\n      // Move path string\n      move: function move(x, y) {\n        // get bounding box of current situation\n        var box = this.bbox(); // get relative offset\n\n        x -= box.x;\n        y -= box.y;\n        return this;\n      },\n      // Get morphed path array at given position\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this;\n        var sourceArray = this.value,\n            destinationArray = this.destination.value,\n            array = [],\n            pathArray = new SVG.PathArray(),\n            il,\n            jl; // Animate has specified in the SVG spec\n        // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\n\n        for (var i = 0, il = sourceArray.length; i < il; i++) {\n          array[i] = [sourceArray[i][0]];\n\n          for (var j = 1, jl = sourceArray[i].length; j < jl; j++) {\n            array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;\n          } // For the two flags of the elliptical arc command, the SVG spec say:\n          // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\n          // Elliptical arc command as an array followed by corresponding indexes:\n          // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n          //   0    1   2        3                 4             5      6  7\n\n\n          if (array[i][0] === 'A') {\n            array[i][4] = +(array[i][4] != 0);\n            array[i][5] = +(array[i][5] != 0);\n          }\n        } // Directly modify the value of a path array, this is done this way for performance\n\n\n        pathArray.value = array;\n        return pathArray;\n      },\n      // Absolutize and parse path to array\n      parse: function parse(array) {\n        // if it's already a patharray, no need to parse it\n        if (array instanceof SVG.PathArray) return array.valueOf(); // prepare for parsing\n\n        var s,\n            arr,\n            paramCnt = {\n          'M': 2,\n          'L': 2,\n          'H': 1,\n          'V': 1,\n          'C': 6,\n          'S': 4,\n          'Q': 4,\n          'T': 2,\n          'A': 7,\n          'Z': 0\n        };\n\n        if (typeof array === 'string') {\n          array = array.replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\n          .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\n          .replace(SVG.regex.hyphen, '$1 -') // add space before hyphen\n          .trim() // trim\n          .split(SVG.regex.delimiter); // split into array\n        } else {\n          array = array.reduce(function (prev, curr) {\n            return [].concat.call(prev, curr);\n          }, []);\n        } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\n\n\n        var arr = [],\n            p = new SVG.Point(),\n            p0 = new SVG.Point(),\n            index = 0,\n            len = array.length;\n\n        do {\n          // Test if we have a path letter\n          if (SVG.regex.isPathLetter.test(array[index])) {\n            s = array[index];\n            ++index; // If last letter was a move command and we got no new, it defaults to [L]ine\n          } else if (s == 'M') {\n            s = 'L';\n          } else if (s == 'm') {\n            s = 'l';\n          }\n\n          arr.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));\n        } while (len > index);\n\n        return arr;\n      },\n      // Get bounding box of path\n      bbox: function bbox() {\n        if (!SVG.parser.draw) {\n          SVG.prepare();\n        }\n\n        SVG.parser.path.setAttribute('d', this.toString());\n        return SVG.parser.path.getBBox();\n      }\n    }); // Module for unit convertions\n\n    SVG.Number = SVG.invent({\n      // Initialize\n      create: function create(value, unit) {\n        // initialize defaults\n        this.value = 0;\n        this.unit = unit || ''; // parse value\n\n        if (typeof value === 'number') {\n          // ensure a valid numeric value\n          this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;\n        } else if (typeof value === 'string') {\n          unit = value.match(SVG.regex.numberAndUnit);\n\n          if (unit) {\n            // make value numeric\n            this.value = parseFloat(unit[1]); // normalize\n\n            if (unit[5] == '%') {\n              this.value /= 100;\n            } else if (unit[5] == 's') {\n              this.value *= 1000;\n            } // store unit\n\n\n            this.unit = unit[5];\n          }\n        } else {\n          if (value instanceof SVG.Number) {\n            this.value = value.valueOf();\n            this.unit = value.unit;\n          }\n        }\n      },\n      // Add methods\n      extend: {\n        // Stringalize\n        toString: function toString() {\n          return (this.unit == '%' ? ~~(this.value * 1e8) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit;\n        },\n        toJSON: function toJSON() {\n          return this.toString();\n        },\n        // Convert to primitive\n        valueOf: function valueOf() {\n          return this.value;\n        },\n        // Add number\n        plus: function plus(number) {\n          number = new SVG.Number(number);\n          return new SVG.Number(this + number, this.unit || number.unit);\n        },\n        // Subtract number\n        minus: function minus(number) {\n          number = new SVG.Number(number);\n          return new SVG.Number(this - number, this.unit || number.unit);\n        },\n        // Multiply number\n        times: function times(number) {\n          number = new SVG.Number(number);\n          return new SVG.Number(this * number, this.unit || number.unit);\n        },\n        // Divide number\n        divide: function divide(number) {\n          number = new SVG.Number(number);\n          return new SVG.Number(this / number, this.unit || number.unit);\n        },\n        // Convert to different unit\n        to: function to(unit) {\n          var number = new SVG.Number(this);\n\n          if (typeof unit === 'string') {\n            number.unit = unit;\n          }\n\n          return number;\n        },\n        // Make number morphable\n        morph: function morph(number) {\n          this.destination = new SVG.Number(number);\n\n          if (number.relative) {\n            this.destination.value += this.value;\n          }\n\n          return this;\n        },\n        // Get morphed number at given position\n        at: function at(pos) {\n          // Make sure a destination is defined\n          if (!this.destination) return this; // Generate new morphed number\n\n          return new SVG.Number(this.destination).minus(this).times(pos).plus(this);\n        }\n      }\n    });\n    SVG.Element = SVG.invent({\n      // Initialize node\n      create: function create(node) {\n        // make stroke value accessible dynamically\n        this._stroke = SVG.defaults.attrs.stroke;\n        this._event = null; // initialize data object\n\n        this.dom = {}; // create circular reference\n\n        if (this.node = node) {\n          this.type = node.nodeName;\n          this.node.instance = this; // store current attribute value\n\n          this._stroke = node.getAttribute('stroke') || this._stroke;\n        }\n      },\n      // Add class methods\n      extend: {\n        // Move over x-axis\n        x: function x(_x) {\n          return this.attr('x', _x);\n        },\n        // Move over y-axis\n        y: function y(_y) {\n          return this.attr('y', _y);\n        },\n        // Move by center over x-axis\n        cx: function cx(x) {\n          return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n        },\n        // Move by center over y-axis\n        cy: function cy(y) {\n          return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n        },\n        // Move element to given x and y values\n        move: function move(x, y) {\n          return this.x(x).y(y);\n        },\n        // Move element by its center\n        center: function center(x, y) {\n          return this.cx(x).cy(y);\n        },\n        // Set width of element\n        width: function width(_width) {\n          return this.attr('width', _width);\n        },\n        // Set height of element\n        height: function height(_height) {\n          return this.attr('height', _height);\n        },\n        // Set element size to given width and height\n        size: function size(width, height) {\n          var p = proportionalSize(this, width, height);\n          return this.width(new SVG.Number(p.width)).height(new SVG.Number(p.height));\n        },\n        // Clone element\n        clone: function clone(parent) {\n          // write dom data to the dom so the clone can pickup the data\n          this.writeDataToDom(); // clone element and assign new id\n\n          var clone = assignNewId(this.node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n          if (parent) parent.add(clone);else this.after(clone);\n          return clone;\n        },\n        // Remove element\n        remove: function remove() {\n          if (this.parent()) {\n            this.parent().removeElement(this);\n          }\n\n          return this;\n        },\n        // Replace element\n        replace: function replace(element) {\n          this.after(element).remove();\n          return element;\n        },\n        // Add element to given container and return self\n        addTo: function addTo(parent) {\n          return parent.put(this);\n        },\n        // Add element to given container and return container\n        putIn: function putIn(parent) {\n          return parent.add(this);\n        },\n        // Get / set id\n        id: function id(_id) {\n          return this.attr('id', _id);\n        },\n        // Show element\n        show: function show() {\n          return this.style('display', '');\n        },\n        // Hide element\n        hide: function hide() {\n          return this.style('display', 'none');\n        },\n        // Is element visible?\n        visible: function visible() {\n          return this.style('display') != 'none';\n        },\n        // Return id on string conversion\n        toString: function toString() {\n          return this.attr('id');\n        },\n        // Return array of classes on the node\n        classes: function classes() {\n          var attr = this.attr('class');\n          return attr == null ? [] : attr.trim().split(SVG.regex.delimiter);\n        },\n        // Return true if class exists on the node, false otherwise\n        hasClass: function hasClass(name) {\n          return this.classes().indexOf(name) != -1;\n        },\n        // Add class to the node\n        addClass: function addClass(name) {\n          if (!this.hasClass(name)) {\n            var array = this.classes();\n            array.push(name);\n            this.attr('class', array.join(' '));\n          }\n\n          return this;\n        },\n        // Remove class from the node\n        removeClass: function removeClass(name) {\n          if (this.hasClass(name)) {\n            this.attr('class', this.classes().filter(function (c) {\n              return c != name;\n            }).join(' '));\n          }\n\n          return this;\n        },\n        // Toggle the presence of a class on the node\n        toggleClass: function toggleClass(name) {\n          return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n        },\n        // Get referenced element form attribute value\n        reference: function reference(attr) {\n          return SVG.get(this.attr(attr));\n        },\n        // Returns the parent element instance\n        parent: function parent(type) {\n          var parent = this; // check for parent\n\n          if (!parent.node.parentNode) return null; // get parent element\n\n          parent = SVG.adopt(parent.node.parentNode);\n          if (!type) return parent; // loop trough ancestors if type is given\n\n          while (parent && parent.node instanceof window.SVGElement) {\n            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n            if (!parent.node.parentNode || parent.node.parentNode.nodeName == '#document') return null; // #759, #720\n\n            parent = SVG.adopt(parent.node.parentNode);\n          }\n        },\n        // Get parent document\n        doc: function doc() {\n          return this instanceof SVG.Doc ? this : this.parent(SVG.Doc);\n        },\n        // return array of all ancestors of given type up to the root svg\n        parents: function parents(type) {\n          var parents = [],\n              parent = this;\n\n          do {\n            parent = parent.parent(type);\n            if (!parent || !parent.node) break;\n            parents.push(parent);\n          } while (parent.parent);\n\n          return parents;\n        },\n        // matches the element vs a css selector\n        matches: function matches(selector) {\n          return _matches(this.node, selector);\n        },\n        // Returns the svg node to call native svg methods on it\n        native: function native() {\n          return this.node;\n        },\n        // Import raw svg\n        svg: function svg(_svg) {\n          // create temporary holder\n          var well = document.createElement('svg'); // act as a setter if svg is given\n\n          if (_svg && this instanceof SVG.Parent) {\n            // dump raw svg\n            well.innerHTML = '<svg>' + _svg.replace(/\\n/, '').replace(/<([\\w:-]+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'; // transplant nodes\n\n            for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {\n              this.node.appendChild(well.firstChild.firstChild);\n            } // otherwise act as a getter\n\n          } else {\n            // create a wrapping svg element in case of partial content\n            well.appendChild(_svg = document.createElement('svg')); // write svgjs data to the dom\n\n            this.writeDataToDom(); // insert a copy of this node\n\n            _svg.appendChild(this.node.cloneNode(true)); // return target element\n\n\n            return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '');\n          }\n\n          return this;\n        },\n        // write svgjs data to the dom\n        writeDataToDom: function writeDataToDom() {\n          // dump variables recursively\n          if (this.each || this.lines) {\n            var fn = this.each ? this : this.lines();\n            fn.each(function () {\n              this.writeDataToDom();\n            });\n          } // remove previously set data\n\n\n          this.node.removeAttribute('svgjs:data');\n\n          if (Object.keys(this.dom).length) {\n            this.node.setAttribute('svgjs:data', JSON.stringify(this.dom));\n          } // see #428\n\n\n          return this;\n        },\n        // set given data to the elements data property\n        setData: function setData(o) {\n          this.dom = o;\n          return this;\n        },\n        is: function is(obj) {\n          return _is(this, obj);\n        }\n      }\n    });\n    SVG.easing = {\n      '-': function _(pos) {\n        return pos;\n      },\n      '<>': function _(pos) {\n        return -Math.cos(pos * Math.PI) / 2 + 0.5;\n      },\n      '>': function _(pos) {\n        return Math.sin(pos * Math.PI / 2);\n      },\n      '<': function _(pos) {\n        return -Math.cos(pos * Math.PI / 2) + 1;\n      }\n    };\n\n    SVG.morph = function (pos) {\n      return function (from, to) {\n        return new SVG.MorphObj(from, to).at(pos);\n      };\n    };\n\n    SVG.Situation = SVG.invent({\n      create: function create(o) {\n        this.init = false;\n        this.reversed = false;\n        this.reversing = false;\n        this.duration = new SVG.Number(o.duration).valueOf();\n        this.delay = new SVG.Number(o.delay).valueOf();\n        this.start = +new Date() + this.delay;\n        this.finish = this.start + this.duration;\n        this.ease = o.ease; // this.loop is incremented from 0 to this.loops\n        // it is also incremented when in an infinite loop (when this.loops is true)\n\n        this.loop = 0;\n        this.loops = false;\n        this.animations = {// functionToCall: [list of morphable objects]\n          // e.g. move: [SVG.Number, SVG.Number]\n        };\n        this.attrs = {// holds all attributes which are not represented from a function svg.js provides\n          // e.g. someAttr: SVG.Number\n        };\n        this.styles = {// holds all styles which should be animated\n          // e.g. fill-color: SVG.Color\n        };\n        this.transforms = [// holds all transformations as transformation objects\n          // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\n        ];\n        this.once = {// functions to fire at a specific position\n          // e.g. \"0.5\": function foo(){}\n        };\n      }\n    });\n    SVG.FX = SVG.invent({\n      create: function create(element) {\n        this._target = element;\n        this.situations = [];\n        this.active = false;\n        this.situation = null;\n        this.paused = false;\n        this.lastPos = 0;\n        this.pos = 0; // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\n        // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\n\n        this.absPos = 0;\n        this._speed = 1;\n      },\n      extend: {\n        /**\n         * sets or returns the target of this animation\n         * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\n         * @param ease function || string Function which should be used for easing or easing keyword\n         * @param delay Number indicating the delay before the animation starts\n         * @return target || this\n         */\n        animate: function animate(o, ease, delay) {\n          if (_typeof(o) === 'object') {\n            ease = o.ease;\n            delay = o.delay;\n            o = o.duration;\n          }\n\n          var situation = new SVG.Situation({\n            duration: o || 1000,\n            delay: delay || 0,\n            ease: SVG.easing[ease || '-'] || ease\n          });\n          this.queue(situation);\n          return this;\n        },\n\n        /**\n        * sets a delay before the next element of the queue is called\n        * @param delay Duration of delay in milliseconds\n        * @return this.target()\n        */\n\n        /**\n        * sets or returns the target of this animation\n        * @param null || target SVG.Element which should be set as new target\n        * @return target || this\n        */\n        target: function target(_target) {\n          if (_target && _target instanceof SVG.Element) {\n            this._target = _target;\n            return this;\n          }\n\n          return this._target;\n        },\n        // returns the absolute position at a given time\n        timeToAbsPos: function timeToAbsPos(timestamp) {\n          return (timestamp - this.situation.start) / (this.situation.duration / this._speed);\n        },\n        // returns the timestamp from a given absolute positon\n        absPosToTime: function absPosToTime(absPos) {\n          return this.situation.duration / this._speed * absPos + this.situation.start;\n        },\n        // starts the animationloop\n        startAnimFrame: function startAnimFrame() {\n          this.stopAnimFrame();\n          this.animationFrame = window.requestAnimationFrame(function () {\n            this.step();\n          }.bind(this));\n        },\n        // cancels the animationframe\n        stopAnimFrame: function stopAnimFrame() {\n          window.cancelAnimationFrame(this.animationFrame);\n        },\n        // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\n        start: function start() {\n          // dont start if already started\n          if (!this.active && this.situation) {\n            this.active = true;\n            this.startCurrent();\n          }\n\n          return this;\n        },\n        // start the current situation\n        startCurrent: function startCurrent() {\n          this.situation.start = +new Date() + this.situation.delay / this._speed;\n          this.situation.finish = this.situation.start + this.situation.duration / this._speed;\n          return this.initAnimations().step();\n        },\n\n        /**\n        * adds a function / Situation to the animation queue\n        * @param fn function / situation to add\n        * @return this\n        */\n        queue: function queue(fn) {\n          if (typeof fn === 'function' || fn instanceof SVG.Situation) {\n            this.situations.push(fn);\n          }\n\n          if (!this.situation) this.situation = this.situations.shift();\n          return this;\n        },\n\n        /**\n        * pulls next element from the queue and execute it\n        * @return this\n        */\n        dequeue: function dequeue() {\n          // stop current animation\n          this.stop(); // get next animation from queue\n\n          this.situation = this.situations.shift();\n\n          if (this.situation) {\n            if (this.situation instanceof SVG.Situation) {\n              this.start();\n            } else {\n              // If it is not a SVG.Situation, then it is a function, we execute it\n              this.situation.call(this);\n            }\n          }\n\n          return this;\n        },\n        // updates all animations to the current state of the element\n        // this is important when one property could be changed from another property\n        initAnimations: function initAnimations() {\n          var source;\n          var s = this.situation;\n          if (s.init) return this;\n\n          for (var i in s.animations) {\n            source = this.target()[i]();\n\n            if (!Array.isArray(source)) {\n              source = [source];\n            }\n\n            if (!Array.isArray(s.animations[i])) {\n              s.animations[i] = [s.animations[i]];\n            } // if(s.animations[i].length > source.length) {\n            //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))\n            // }\n\n\n            for (var j = source.length; j--;) {\n              // The condition is because some methods return a normal number instead\n              // of a SVG.Number\n              if (s.animations[i][j] instanceof SVG.Number) {\n                source[j] = new SVG.Number(source[j]);\n              }\n\n              s.animations[i][j] = source[j].morph(s.animations[i][j]);\n            }\n          }\n\n          for (var i in s.attrs) {\n            s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i]);\n          }\n\n          for (var i in s.styles) {\n            s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i]);\n          }\n\n          s.initialTransformation = this.target().matrixify();\n          s.init = true;\n          return this;\n        },\n        clearQueue: function clearQueue() {\n          this.situations = [];\n          return this;\n        },\n        clearCurrent: function clearCurrent() {\n          this.situation = null;\n          return this;\n        },\n\n        /** stops the animation immediately\n        * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\n        * @param clearQueue A Boolean indicating whether to remove queued animation as well.\n        * @return this\n        */\n        stop: function stop(jumpToEnd, clearQueue) {\n          var active = this.active;\n          this.active = false;\n\n          if (clearQueue) {\n            this.clearQueue();\n          }\n\n          if (jumpToEnd && this.situation) {\n            // initialize the situation if it was not\n            !active && this.startCurrent();\n            this.atEnd();\n          }\n\n          this.stopAnimFrame();\n          return this.clearCurrent();\n        },\n        after: function after(fn) {\n          var c = this.last(),\n              wrapper = function wrapper(e) {\n            if (e.detail.situation == c) {\n              fn.call(this, c);\n              this.off('finished.fx', wrapper); // prevent memory leak\n            }\n          };\n\n          this.target().on('finished.fx', wrapper);\n          return this._callStart();\n        },\n        // adds a callback which is called whenever one animation step is performed\n        during: function during(fn) {\n          var c = this.last(),\n              wrapper = function wrapper(e) {\n            if (e.detail.situation == c) {\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c);\n            }\n          }; // see above\n\n\n          this.target().off('during.fx', wrapper).on('during.fx', wrapper);\n          this.after(function () {\n            this.off('during.fx', wrapper);\n          });\n          return this._callStart();\n        },\n        // calls after ALL animations in the queue are finished\n        afterAll: function afterAll(fn) {\n          var wrapper = function wrapper(e) {\n            fn.call(this);\n            this.off('allfinished.fx', wrapper);\n          }; // see above\n\n\n          this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper);\n          return this._callStart();\n        },\n        last: function last() {\n          return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;\n        },\n        // adds one property to the animations\n        add: function add(method, args, type) {\n          this.last()[type || 'animations'][method] = args;\n          return this._callStart();\n        },\n\n        /** perform one step of the animation\n        *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\n        *  @return this\n        */\n        step: function step(ignoreTime) {\n          // convert current time to an absolute position\n          if (!ignoreTime) this.absPos = this.timeToAbsPos(+new Date()); // This part convert an absolute position to a position\n\n          if (this.situation.loops !== false) {\n            var absPos, absPosInt, lastLoop; // If the absolute position is below 0, we just treat it as if it was 0\n\n            absPos = Math.max(this.absPos, 0);\n            absPosInt = Math.floor(absPos);\n\n            if (this.situation.loops === true || absPosInt < this.situation.loops) {\n              this.pos = absPos - absPosInt;\n              lastLoop = this.situation.loop;\n              this.situation.loop = absPosInt;\n            } else {\n              this.absPos = this.situation.loops;\n              this.pos = 1; // The -1 here is because we don't want to toggle reversed when all the loops have been completed\n\n              lastLoop = this.situation.loop - 1;\n              this.situation.loop = this.situation.loops;\n            }\n\n            if (this.situation.reversing) {\n              // Toggle reversed if an odd number of loops as occured since the last call of step\n              this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2);\n            }\n          } else {\n            // If there are no loop, the absolute position must not be above 1\n            this.absPos = Math.min(this.absPos, 1);\n            this.pos = this.absPos;\n          } // while the absolute position can be below 0, the position must not be below 0\n\n\n          if (this.pos < 0) this.pos = 0;\n          if (this.situation.reversed) this.pos = 1 - this.pos; // apply easing\n\n          var eased = this.situation.ease(this.pos); // call once-callbacks\n\n          for (var i in this.situation.once) {\n            if (i > this.lastPos && i <= eased) {\n              this.situation.once[i].call(this.target(), this.pos, eased);\n              delete this.situation.once[i];\n            }\n          } // fire during callback with position, eased position and current situation as parameter\n\n\n          if (this.active) this.target().fire('during', {\n            pos: this.pos,\n            eased: eased,\n            fx: this,\n            situation: this.situation\n          }); // the user may call stop or finish in the during callback\n          // so make sure that we still have a valid situation\n\n          if (!this.situation) {\n            return this;\n          } // apply the actual animation to every property\n\n\n          this.eachAt(); // do final code when situation is finished\n\n          if (this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0) {\n            // stop animation callback\n            this.stopAnimFrame(); // fire finished callback with current situation as parameter\n\n            this.target().fire('finished', {\n              fx: this,\n              situation: this.situation\n            });\n\n            if (!this.situations.length) {\n              this.target().fire('allfinished'); // Recheck the length since the user may call animate in the afterAll callback\n\n              if (!this.situations.length) {\n                this.target().off('.fx'); // there shouldnt be any binding left, but to make sure...\n\n                this.active = false;\n              }\n            } // start next animation\n\n\n            if (this.active) this.dequeue();else this.clearCurrent();\n          } else if (!this.paused && this.active) {\n            // we continue animating when we are not at the end\n            this.startAnimFrame();\n          } // save last eased position for once callback triggering\n\n\n          this.lastPos = eased;\n          return this;\n        },\n        // calculates the step for every property and calls block with it\n        eachAt: function eachAt() {\n          var len,\n              at,\n              self = this,\n              target = this.target(),\n              s = this.situation; // apply animations which can be called trough a method\n\n          for (var i in s.animations) {\n            at = [].concat(s.animations[i]).map(function (el) {\n              return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n            });\n            target[i].apply(target, at);\n          } // apply animation which has to be applied with attr()\n\n\n          for (var i in s.attrs) {\n            at = [i].concat(s.attrs[i]).map(function (el) {\n              return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n            });\n            target.attr.apply(target, at);\n          } // apply animation which has to be applied with style()\n\n\n          for (var i in s.styles) {\n            at = [i].concat(s.styles[i]).map(function (el) {\n              return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n            });\n            target.style.apply(target, at);\n          } // animate initialTransformation which has to be chained\n\n\n          if (s.transforms.length) {\n            // get initial initialTransformation\n            at = s.initialTransformation;\n\n            for (var i = 0, len = s.transforms.length; i < len; i++) {\n              // get next transformation in chain\n              var a = s.transforms[i]; // multiply matrix directly\n\n              if (a instanceof SVG.Matrix) {\n                if (a.relative) {\n                  at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)));\n                } else {\n                  at = at.morph(a).at(s.ease(this.pos));\n                }\n\n                continue;\n              } // when transformation is absolute we have to reset the needed transformation first\n\n\n              if (!a.relative) {\n                a.undo(at.extract());\n              } // and reapply it after\n\n\n              at = at.multiply(a.at(s.ease(this.pos)));\n            } // set new matrix on element\n\n\n            target.matrix(at);\n          }\n\n          return this;\n        },\n        // adds an once-callback which is called at a specific position and never again\n        once: function once(pos, fn, isEased) {\n          var c = this.last();\n          if (!isEased) pos = c.ease(pos);\n          c.once[pos] = fn;\n          return this;\n        },\n        _callStart: function _callStart() {\n          setTimeout(function () {\n            this.start();\n          }.bind(this), 0);\n          return this;\n        }\n      },\n      parent: SVG.Element,\n      // Add method to parent elements\n      construct: {\n        // Get fx module or create a new one, then animate with given duration and ease\n        animate: function animate(o, ease, delay) {\n          return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay);\n        },\n        delay: function delay(_delay) {\n          return (this.fx || (this.fx = new SVG.FX(this))).delay(_delay);\n        },\n        stop: function stop(jumpToEnd, clearQueue) {\n          if (this.fx) {\n            this.fx.stop(jumpToEnd, clearQueue);\n          }\n\n          return this;\n        },\n        finish: function finish() {\n          if (this.fx) {\n            this.fx.finish();\n          }\n\n          return this;\n        }\n      }\n    }); // MorphObj is used whenever no morphable object is given\n\n    SVG.MorphObj = SVG.invent({\n      create: function create(from, to) {\n        // prepare color for morphing\n        if (SVG.Color.isColor(to)) return new SVG.Color(from).morph(to); // check if we have a list of values\n\n        if (SVG.regex.delimiter.test(from)) {\n          // prepare path for morphing\n          if (SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to); // prepare value list for morphing\n          else return new SVG.Array(from).morph(to);\n        } // prepare number for morphing\n\n\n        if (SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to); // prepare for plain morphing\n\n        this.value = from;\n        this.destination = to;\n      },\n      extend: {\n        at: function at(pos, real) {\n          return real < 1 ? this.value : this.destination;\n        },\n        valueOf: function valueOf() {\n          return this.value;\n        }\n      }\n    });\n    SVG.extend(SVG.FX, {\n      // Add animatable attributes\n      attr: function attr(a, v, relative) {\n        // apply attributes individually\n        if (_typeof(a) === 'object') {\n          for (var key in a) {\n            this.attr(key, a[key]);\n          }\n        } else {\n          this.add(a, v, 'attrs');\n        }\n\n        return this;\n      },\n      // Add animatable plot\n      plot: function plot(a, b, c, d) {\n        // Lines can be plotted with 4 arguments\n        if (arguments.length == 4) {\n          return this.plot([a, b, c, d]);\n        }\n\n        return this.add('plot', new (this.target().morphArray)(a));\n      }\n    });\n    SVG.Box = SVG.invent({\n      create: function create(x, y, width, height) {\n        if (_typeof(x) === 'object' && !(x instanceof SVG.Element)) {\n          // chromes getBoundingClientRect has no x and y property\n          return SVG.Box.call(this, x.left != null ? x.left : x.x, x.top != null ? x.top : x.y, x.width, x.height);\n        } else if (arguments.length == 4) {\n          this.x = x;\n          this.y = y;\n          this.width = width;\n          this.height = height;\n        } // add center, right, bottom...\n\n\n        fullBox(this);\n      }\n    });\n    SVG.BBox = SVG.invent({\n      // Initialize\n      create: function create(element) {\n        SVG.Box.apply(this, [].slice.call(arguments)); // get values if element is given\n\n        if (element instanceof SVG.Element) {\n          var box; // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered\n\n          try {\n            if (!document.documentElement.contains) {\n              // This is IE - it does not support contains() for top-level SVGs\n              var topParent = element.node;\n\n              while (topParent.parentNode) {\n                topParent = topParent.parentNode;\n              }\n\n              if (topParent != document) throw new Error('Element not in the dom');\n            } else {// the element is NOT in the dom, throw error\n              // disabling the check below which fixes issue #76\n              // if (!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\n            } // find native bbox\n\n\n            box = element.node.getBBox();\n          } catch (e) {\n            if (element instanceof SVG.Shape) {\n              if (!SVG.parser.draw) {\n                // fixes apexcharts/vue-apexcharts #14\n                SVG.prepare();\n              }\n\n              var clone = element.clone(SVG.parser.draw.instance).show();\n\n              if (clone && clone.node && typeof clone.node.getBBox === 'function') {\n                // this check fixes jest unit tests\n                box = clone.node.getBBox();\n              }\n\n              if (clone && typeof clone.remove === 'function') {\n                clone.remove();\n              }\n            } else {\n              box = {\n                x: element.node.clientLeft,\n                y: element.node.clientTop,\n                width: element.node.clientWidth,\n                height: element.node.clientHeight\n              };\n            }\n          }\n\n          SVG.Box.call(this, box);\n        }\n      },\n      // Define ancestor\n      inherit: SVG.Box,\n      // Define Parent\n      parent: SVG.Element,\n      // Constructor\n      construct: {\n        // Get bounding box\n        bbox: function bbox() {\n          return new SVG.BBox(this);\n        }\n      }\n    });\n    SVG.BBox.prototype.constructor = SVG.BBox;\n    SVG.Matrix = SVG.invent({\n      // Initialize\n      create: function create(source) {\n        var base = arrayToMatrix([1, 0, 0, 1, 0, 0]); // ensure source as object\n\n        source = source === null ? base : source instanceof SVG.Element ? source.matrixify() : typeof source === 'string' ? arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? arrayToMatrix([].slice.call(arguments)) : Array.isArray(source) ? arrayToMatrix(source) : source && _typeof(source) === 'object' ? source : base; // merge source\n\n        for (var i = abcdef.length - 1; i >= 0; --i) {\n          this[abcdef[i]] = source[abcdef[i]] != null ? source[abcdef[i]] : base[abcdef[i]];\n        }\n      },\n      // Add methods\n      extend: {\n        // Extract individual transformations\n        extract: function extract() {\n          // find delta transform points\n          var px = deltaTransformPoint(this, 0, 1);\n              deltaTransformPoint(this, 1, 0);\n              var skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;\n          return {\n            // translation\n            x: this.e,\n            y: this.f,\n            transformedX: (this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),\n            transformedY: (this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),\n            // rotation\n            rotation: skewX,\n            a: this.a,\n            b: this.b,\n            c: this.c,\n            d: this.d,\n            e: this.e,\n            f: this.f,\n            matrix: new SVG.Matrix(this)\n          };\n        },\n        // Clone matrix\n        clone: function clone() {\n          return new SVG.Matrix(this);\n        },\n        // Morph one matrix into another\n        morph: function morph(matrix) {\n          // store new destination\n          this.destination = new SVG.Matrix(matrix);\n          return this;\n        },\n        // Multiplies by given matrix\n        multiply: function multiply(matrix) {\n          return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()));\n        },\n        // Inverses matrix\n        inverse: function inverse() {\n          return new SVG.Matrix(this.native().inverse());\n        },\n        // Translate matrix\n        translate: function translate(x, y) {\n          return new SVG.Matrix(this.native().translate(x || 0, y || 0));\n        },\n        // Convert to native SVGMatrix\n        native: function native() {\n          // create new matrix\n          var matrix = SVG.parser.native.createSVGMatrix(); // update with current values\n\n          for (var i = abcdef.length - 1; i >= 0; i--) {\n            matrix[abcdef[i]] = this[abcdef[i]];\n          }\n\n          return matrix;\n        },\n        // Convert matrix to string\n        toString: function toString() {\n          // Construct the matrix directly, avoid values that are too small\n          return 'matrix(' + float32String(this.a) + ',' + float32String(this.b) + ',' + float32String(this.c) + ',' + float32String(this.d) + ',' + float32String(this.e) + ',' + float32String(this.f) + ')';\n        }\n      },\n      // Define parent\n      parent: SVG.Element,\n      // Add parent method\n      construct: {\n        // Get current matrix\n        ctm: function ctm() {\n          return new SVG.Matrix(this.node.getCTM());\n        },\n        // Get current screen matrix\n        screenCTM: function screenCTM() {\n          /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n             This is needed because FF does not return the transformation matrix\n             for the inner coordinate system when getScreenCTM() is called on nested svgs.\n             However all other Browsers do that */\n          if (this instanceof SVG.Nested) {\n            var rect = this.rect(1, 1);\n            var m = rect.node.getScreenCTM();\n            rect.remove();\n            return new SVG.Matrix(m);\n          }\n\n          return new SVG.Matrix(this.node.getScreenCTM());\n        }\n      }\n    });\n    SVG.Point = SVG.invent({\n      // Initialize\n      create: function create(x, y) {\n        var source,\n            base = {\n          x: 0,\n          y: 0\n        }; // ensure source as object\n\n        source = Array.isArray(x) ? {\n          x: x[0],\n          y: x[1]\n        } : _typeof(x) === 'object' ? {\n          x: x.x,\n          y: x.y\n        } : x != null ? {\n          x: x,\n          y: y != null ? y : x\n        } : base; // If y has no value, then x is used has its value\n        // merge source\n\n        this.x = source.x;\n        this.y = source.y;\n      },\n      // Add methods\n      extend: {\n        // Clone point\n        clone: function clone() {\n          return new SVG.Point(this);\n        },\n        // Morph one point into another\n        morph: function morph(x, y) {\n          // store new destination\n          this.destination = new SVG.Point(x, y);\n          return this;\n        }\n      }\n    });\n    SVG.extend(SVG.Element, {\n      // Get point\n      point: function point(x, y) {\n        return new SVG.Point(x, y).transform(this.screenCTM().inverse());\n      }\n    });\n    SVG.extend(SVG.Element, {\n      // Set svg element attribute\n      attr: function attr(a, v, n) {\n        // act as full getter\n        if (a == null) {\n          // get an object of attributes\n          a = {};\n          v = this.node.attributes;\n\n          for (var n = v.length - 1; n >= 0; n--) {\n            a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue;\n          }\n\n          return a;\n        } else if (_typeof(a) === 'object') {\n          // apply every attribute individually if an object is passed\n          for (var v_ in a) {\n            this.attr(v_, a[v_]);\n          }\n        } else if (v === null) {\n          // remove value\n          this.node.removeAttribute(a);\n        } else if (v == null) {\n          // act as a getter if the first and only argument is not an object\n          v = this.node.getAttribute(a);\n          return v == null ? SVG.defaults.attrs[a] : SVG.regex.isNumber.test(v) ? parseFloat(v) : v;\n        } else {\n          // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\n          if (a == 'stroke-width') {\n            this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null);\n          } else if (a == 'stroke') {\n            this._stroke = v;\n          } // convert image fill and stroke to patterns\n\n\n          if (a == 'fill' || a == 'stroke') {\n            if (SVG.regex.isImage.test(v)) {\n              v = this.doc().defs().image(v, 0, 0);\n            }\n\n            if (v instanceof SVG.Image) {\n              v = this.doc().defs().pattern(0, 0, function () {\n                this.add(v);\n              });\n            }\n          } // ensure correct numeric values (also accepts NaN and Infinity)\n\n\n          if (typeof v === 'number') {\n            v = new SVG.Number(v);\n          } // ensure full hex color\n          else if (SVG.Color.isColor(v)) {\n            v = new SVG.Color(v);\n          } // parse array values\n          else if (Array.isArray(v)) {\n            v = new SVG.Array(v);\n          } // if the passed attribute is leading...\n\n\n          if (a == 'leading') {\n            // ... call the leading method instead\n            if (this.leading) {\n              this.leading(v);\n            }\n          } else {\n            // set given attribute on node\n            typeof n === 'string' ? this.node.setAttributeNS(n, a, v.toString()) : this.node.setAttribute(a, v.toString());\n          } // rebuild if required\n\n\n          if (this.rebuild && (a == 'font-size' || a == 'x')) {\n            this.rebuild(a, v);\n          }\n        }\n\n        return this;\n      }\n    });\n    SVG.extend(SVG.Element, {\n      // Add transformations\n      transform: function transform(o, relative) {\n        // get target in case of the fx module, otherwise reference this\n        var target = this,\n            matrix;\n   // act as a getter\n\n        if (_typeof(o) !== 'object') {\n          // get current matrix\n          matrix = new SVG.Matrix(target).extract();\n          return typeof o === 'string' ? matrix[o] : matrix;\n        } // get current matrix\n\n\n        matrix = new SVG.Matrix(target); // ensure relative flag\n\n        relative = !!relative || !!o.relative; // act on matrix\n\n        if (o.a != null) {\n          matrix = relative // relative\n          ? matrix.multiply(new SVG.Matrix(o)) // absolute\n          : new SVG.Matrix(o);\n        }\n\n        return this.attr('transform', matrix);\n      }\n    });\n    SVG.extend(SVG.Element, {\n      // Reset all transformations\n      untransform: function untransform() {\n        return this.attr('transform', null);\n      },\n      // merge the whole transformation chain into one matrix and returns it\n      matrixify: function matrixify() {\n        var matrix = (this.attr('transform') || '').split(SVG.regex.transforms).slice(0, -1).map(function (str) {\n          // generate key => value pairs\n          var kv = str.trim().split('(');\n          return [kv[0], kv[1].split(SVG.regex.delimiter).map(function (str) {\n            return parseFloat(str);\n          })];\n        }) // merge every transformation into one matrix\n        .reduce(function (matrix, transform) {\n          if (transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]));\n          return matrix[transform[0]].apply(matrix, transform[1]);\n        }, new SVG.Matrix());\n        return matrix;\n      },\n      // add an element to another parent without changing the visual representation on the screen\n      toParent: function toParent(parent) {\n        if (this == parent) return this;\n        var ctm = this.screenCTM();\n        var pCtm = parent.screenCTM().inverse();\n        this.addTo(parent).untransform().transform(pCtm.multiply(ctm));\n        return this;\n      },\n      // same as above with parent equals root-svg\n      toDoc: function toDoc() {\n        return this.toParent(this.doc());\n      }\n    });\n    SVG.Transformation = SVG.invent({\n      create: function create(source, inversed) {\n        if (arguments.length > 1 && typeof inversed !== 'boolean') {\n          return this.constructor.call(this, [].slice.call(arguments));\n        }\n\n        if (Array.isArray(source)) {\n          for (var i = 0, len = this.arguments.length; i < len; ++i) {\n            this[this.arguments[i]] = source[i];\n          }\n        } else if (source && _typeof(source) === 'object') {\n          for (var i = 0, len = this.arguments.length; i < len; ++i) {\n            this[this.arguments[i]] = source[this.arguments[i]];\n          }\n        }\n\n        this.inversed = false;\n\n        if (inversed === true) {\n          this.inversed = true;\n        }\n      }\n    });\n    SVG.Translate = SVG.invent({\n      parent: SVG.Matrix,\n      inherit: SVG.Transformation,\n      create: function create(source, inversed) {\n        this.constructor.apply(this, [].slice.call(arguments));\n      },\n      extend: {\n        arguments: ['transformedX', 'transformedY'],\n        method: 'translate'\n      }\n    });\n    SVG.extend(SVG.Element, {\n      // Dynamic style generator\n      style: function style(s, v) {\n        if (arguments.length == 0) {\n          // get full style\n          return this.node.style.cssText || '';\n        } else if (arguments.length < 2) {\n          // apply every style individually if an object is passed\n          if (_typeof(s) === 'object') {\n            for (var v_ in s) {\n              this.style(v_, s[v_]);\n            }\n          } else if (SVG.regex.isCss.test(s)) {\n            // parse css string\n            s = s.split(/\\s*;\\s*/) // filter out suffix ; and stuff like ;;\n            .filter(function (e) {\n              return !!e;\n            }).map(function (e) {\n              return e.split(/\\s*:\\s*/);\n            }); // apply every definition individually\n\n            while (v = s.pop()) {\n              this.style(v[0], v[1]);\n            }\n          } else {\n            // act as a getter if the first and only argument is not an object\n            return this.node.style[camelCase(s)];\n          }\n        } else {\n          this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v;\n        }\n\n        return this;\n      }\n    });\n    SVG.Parent = SVG.invent({\n      // Initialize node\n      create: function create(element) {\n        this.constructor.call(this, element);\n      },\n      // Inherit from\n      inherit: SVG.Element,\n      // Add class methods\n      extend: {\n        // Returns all child elements\n        children: function children() {\n          return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function (node) {\n            return SVG.adopt(node);\n          });\n        },\n        // Add given element at a position\n        add: function add(element, i) {\n          if (i == null) {\n            this.node.appendChild(element.node);\n          } else if (element.node != this.node.childNodes[i]) {\n            this.node.insertBefore(element.node, this.node.childNodes[i]);\n          }\n\n          return this;\n        },\n        // Basically does the same as `add()` but returns the added element instead\n        put: function put(element, i) {\n          this.add(element, i);\n          return element;\n        },\n        // Checks if the given element is a child\n        has: function has(element) {\n          return this.index(element) >= 0;\n        },\n        // Gets index of given element\n        index: function index(element) {\n          return [].slice.call(this.node.childNodes).indexOf(element.node);\n        },\n        // Get a element at the given index\n        get: function get(i) {\n          return SVG.adopt(this.node.childNodes[i]);\n        },\n        // Get first child\n        first: function first() {\n          return this.get(0);\n        },\n        // Get the last child\n        last: function last() {\n          return this.get(this.node.childNodes.length - 1);\n        },\n        // Iterates over all children and invokes a given block\n        each: function each(block, deep) {\n          var il,\n              children = this.children();\n\n          for (var i = 0, il = children.length; i < il; i++) {\n            if (children[i] instanceof SVG.Element) {\n              block.apply(children[i], [i, children]);\n            }\n\n            if (deep && children[i] instanceof SVG.Container) {\n              children[i].each(block, deep);\n            }\n          }\n\n          return this;\n        },\n        // Remove a given child\n        removeElement: function removeElement(element) {\n          this.node.removeChild(element.node);\n          return this;\n        },\n        // Remove all elements in this container\n        clear: function clear() {\n          // remove children\n          while (this.node.hasChildNodes()) {\n            this.node.removeChild(this.node.lastChild);\n          } // remove defs reference\n\n\n          delete this._defs;\n          return this;\n        },\n        // Get defs\n        defs: function defs() {\n          return this.doc().defs();\n        }\n      }\n    });\n    SVG.extend(SVG.Parent, {\n      ungroup: function ungroup(parent, depth) {\n        if (depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this;\n        parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent));\n        depth = depth || Infinity;\n        this.each(function () {\n          if (this instanceof SVG.Defs) return this;\n          if (this instanceof SVG.Parent) return this.ungroup(parent, depth - 1);\n          return this.toParent(parent);\n        });\n        this.node.firstChild || this.remove();\n        return this;\n      },\n      flatten: function flatten(parent, depth) {\n        return this.ungroup(parent, depth);\n      }\n    });\n    SVG.Container = SVG.invent({\n      // Initialize node\n      create: function create(element) {\n        this.constructor.call(this, element);\n      },\n      // Inherit from\n      inherit: SVG.Parent\n    });\n    SVG.ViewBox = SVG.invent({\n      // Define parent\n      parent: SVG.Container,\n      // Add parent method\n      construct: {}\n    }) // Add events to elements\n    ;\n    ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', // , 'mouseenter' -> not supported by IE\n    // , 'mouseleave' -> not supported by IE\n    'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(function (event) {\n      // add event to SVG.Element\n      SVG.Element.prototype[event] = function (f) {\n        // bind event to element rather than element node\n        SVG.on(this.node, event, f);\n        return this;\n      };\n    }); // Initialize listeners stack\n\n    SVG.listeners = [];\n    SVG.handlerMap = [];\n    SVG.listenerId = 0; // Add event binder in the SVG namespace\n\n    SVG.on = function (node, event, listener, binding, options) {\n      // create listener, get object-index\n      var l = listener.bind(binding || node.instance || node),\n          index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1,\n          ev = event.split('.')[0],\n          ns = event.split('.')[1] || '*'; // ensure valid object\n\n      SVG.listeners[index] = SVG.listeners[index] || {};\n      SVG.listeners[index][ev] = SVG.listeners[index][ev] || {};\n      SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {};\n\n      if (!listener._svgjsListenerId) {\n        listener._svgjsListenerId = ++SVG.listenerId;\n      } // reference listener\n\n\n      SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l; // add listener\n\n      node.addEventListener(ev, l, options || {\n        passive: true\n      });\n    }; // Add event unbinder in the SVG namespace\n\n\n    SVG.off = function (node, event, listener) {\n      var index = SVG.handlerMap.indexOf(node),\n          ev = event && event.split('.')[0],\n          ns = event && event.split('.')[1],\n          namespace = '';\n      if (index == -1) return;\n\n      if (listener) {\n        if (typeof listener === 'function') listener = listener._svgjsListenerId;\n        if (!listener) return; // remove listener reference\n\n        if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\n          // remove listener\n          node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false);\n          delete SVG.listeners[index][ev][ns || '*'][listener];\n        }\n      } else if (ns && ev) {\n        // remove all listeners for a namespaced event\n        if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\n          for (var listener_ in SVG.listeners[index][ev][ns]) {\n            SVG.off(node, [ev, ns].join('.'), listener_);\n          }\n\n          delete SVG.listeners[index][ev][ns];\n        }\n      } else if (ns) {\n        // remove all listeners for a specific namespace\n        for (var event_ in SVG.listeners[index]) {\n          for (var namespace in SVG.listeners[index][event_]) {\n            if (ns === namespace) {\n              SVG.off(node, [event_, ns].join('.'));\n            }\n          }\n        }\n      } else if (ev) {\n        // remove all listeners for the event\n        if (SVG.listeners[index][ev]) {\n          for (var namespace in SVG.listeners[index][ev]) {\n            SVG.off(node, [ev, namespace].join('.'));\n          }\n\n          delete SVG.listeners[index][ev];\n        }\n      } else {\n        // remove all listeners on a given node\n        for (var event_ in SVG.listeners[index]) {\n          SVG.off(node, event_);\n        }\n\n        delete SVG.listeners[index];\n        delete SVG.handlerMap[index];\n      }\n    }; //\n\n\n    SVG.extend(SVG.Element, {\n      // Bind given event to listener\n      on: function on(event, listener, binding, options) {\n        SVG.on(this.node, event, listener, binding, options);\n        return this;\n      },\n      // Unbind event from listener\n      off: function off(event, listener) {\n        SVG.off(this.node, event, listener);\n        return this;\n      },\n      // Fire given event\n      fire: function fire(event, data) {\n        // Dispatch event\n        if (event instanceof window.Event) {\n          this.node.dispatchEvent(event);\n        } else {\n          this.node.dispatchEvent(event = new SVG.CustomEvent(event, {\n            detail: data,\n            cancelable: true\n          }));\n        }\n\n        this._event = event;\n        return this;\n      },\n      event: function event() {\n        return this._event;\n      }\n    });\n    SVG.Defs = SVG.invent({\n      // Initialize node\n      create: 'defs',\n      // Inherit from\n      inherit: SVG.Container\n    });\n    SVG.G = SVG.invent({\n      // Initialize node\n      create: 'g',\n      // Inherit from\n      inherit: SVG.Container,\n      // Add class methods\n      extend: {\n        // Move over x-axis\n        x: function x(_x2) {\n          return _x2 == null ? this.transform('x') : this.transform({\n            x: _x2 - this.x()\n          }, true);\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create a group element\n        group: function group() {\n          return this.put(new SVG.G());\n        }\n      }\n    });\n    SVG.Doc = SVG.invent({\n      // Initialize node\n      create: function create(element) {\n        if (element) {\n          // ensure the presence of a dom element\n          element = typeof element === 'string' ? document.getElementById(element) : element; // If the target is an svg element, use that element as the main wrapper.\n          // This allows svg.js to work with svg documents as well.\n\n          if (element.nodeName == 'svg') {\n            this.constructor.call(this, element);\n          } else {\n            this.constructor.call(this, SVG.create('svg'));\n            element.appendChild(this.node);\n            this.size('100%', '100%');\n          } // set svg element attributes and ensure defs node\n\n\n          this.namespace().defs();\n        }\n      },\n      // Inherit from\n      inherit: SVG.Container,\n      // Add class methods\n      extend: {\n        // Add namespaces\n        namespace: function namespace() {\n          return this.attr({\n            xmlns: SVG.ns,\n            version: '1.1'\n          }).attr('xmlns:xlink', SVG.xlink, SVG.xmlns).attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns);\n        },\n        // Creates and returns defs element\n        defs: function defs() {\n          if (!this._defs) {\n            var defs; // Find or create a defs element in this instance\n\n            if (defs = this.node.getElementsByTagName('defs')[0]) {\n              this._defs = SVG.adopt(defs);\n            } else {\n              this._defs = new SVG.Defs();\n            } // Make sure the defs node is at the end of the stack\n\n\n            this.node.appendChild(this._defs.node);\n          }\n\n          return this._defs;\n        },\n        // custom parent method\n        parent: function parent() {\n          if (!this.node.parentNode || this.node.parentNode.nodeName == '#document') return null;\n          return this.node.parentNode;\n        },\n        // Removes the doc from the DOM\n        remove: function remove() {\n          if (this.parent()) {\n            this.parent().removeChild(this.node);\n          }\n\n          return this;\n        },\n        clear: function clear() {\n          // remove children\n          while (this.node.hasChildNodes()) {\n            this.node.removeChild(this.node.lastChild);\n          } // remove defs reference\n\n\n          delete this._defs; // add back parser\n\n          if (SVG.parser.draw && !SVG.parser.draw.parentNode) {\n            this.node.appendChild(SVG.parser.draw);\n          }\n\n          return this;\n        },\n        clone: function clone(parent) {\n          // write dom data to the dom so the clone can pickup the data\n          this.writeDataToDom(); // get reference to node\n\n          var node = this.node; // clone element and assign new id\n\n          var clone = assignNewId(node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n          if (parent) {\n            (parent.node || parent).appendChild(clone.node);\n          } else {\n            node.parentNode.insertBefore(clone.node, node.nextSibling);\n          }\n\n          return clone;\n        }\n      }\n    }); // ### This module adds backward / forward functionality to elements.\n    //\n\n    SVG.extend(SVG.Element, {// Get all siblings, including myself\n    });\n    SVG.Gradient = SVG.invent({\n      // Initialize node\n      create: function create(type) {\n        this.constructor.call(this, SVG.create(type + 'Gradient')); // store type\n\n        this.type = type;\n      },\n      // Inherit from\n      inherit: SVG.Container,\n      // Add class methods\n      extend: {\n        // Add a color stop\n        at: function at(offset, color, opacity) {\n          return this.put(new SVG.Stop()).update(offset, color, opacity);\n        },\n        // Update gradient\n        update: function update(block) {\n          // remove all stops\n          this.clear(); // invoke passed block\n\n          if (typeof block === 'function') {\n            block.call(this, this);\n          }\n\n          return this;\n        },\n        // Return the fill id\n        fill: function fill() {\n          return 'url(#' + this.id() + ')';\n        },\n        // Alias string convertion to fill\n        toString: function toString() {\n          return this.fill();\n        },\n        // custom attr to handle transform\n        attr: function attr(a, b, c) {\n          if (a == 'transform') a = 'gradientTransform';\n          return SVG.Container.prototype.attr.call(this, a, b, c);\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create gradient element in defs\n        gradient: function gradient(type, block) {\n          return this.defs().gradient(type, block);\n        }\n      }\n    }); // Add animatable methods to both gradient and fx module\n\n    SVG.extend(SVG.Gradient, SVG.FX, {\n      // From position\n      from: function from(x, y) {\n        return (this._target || this).type == 'radial' ? this.attr({\n          fx: new SVG.Number(x),\n          fy: new SVG.Number(y)\n        }) : this.attr({\n          x1: new SVG.Number(x),\n          y1: new SVG.Number(y)\n        });\n      },\n      // To position\n      to: function to(x, y) {\n        return (this._target || this).type == 'radial' ? this.attr({\n          cx: new SVG.Number(x),\n          cy: new SVG.Number(y)\n        }) : this.attr({\n          x2: new SVG.Number(x),\n          y2: new SVG.Number(y)\n        });\n      }\n    }); // Base gradient generation\n\n    SVG.extend(SVG.Defs, {\n      // define gradient\n      gradient: function gradient(type, block) {\n        return this.put(new SVG.Gradient(type)).update(block);\n      }\n    });\n    SVG.Stop = SVG.invent({\n      // Initialize node\n      create: 'stop',\n      // Inherit from\n      inherit: SVG.Element,\n      // Add class methods\n      extend: {\n        // add color stops\n        update: function update(o) {\n          if (typeof o === 'number' || o instanceof SVG.Number) {\n            o = {\n              offset: arguments[0],\n              color: arguments[1],\n              opacity: arguments[2]\n            };\n          } // set attributes\n\n\n          if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n          if (o.color != null) this.attr('stop-color', o.color);\n          if (o.offset != null) this.attr('offset', new SVG.Number(o.offset));\n          return this;\n        }\n      }\n    });\n    SVG.Pattern = SVG.invent({\n      // Initialize node\n      create: 'pattern',\n      // Inherit from\n      inherit: SVG.Container,\n      // Add class methods\n      extend: {\n        // Return the fill id\n        fill: function fill() {\n          return 'url(#' + this.id() + ')';\n        },\n        // Update pattern by rebuilding\n        update: function update(block) {\n          // remove content\n          this.clear(); // invoke passed block\n\n          if (typeof block === 'function') {\n            block.call(this, this);\n          }\n\n          return this;\n        },\n        // Alias string convertion to fill\n        toString: function toString() {\n          return this.fill();\n        },\n        // custom attr to handle transform\n        attr: function attr(a, b, c) {\n          if (a == 'transform') a = 'patternTransform';\n          return SVG.Container.prototype.attr.call(this, a, b, c);\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create pattern element in defs\n        pattern: function pattern(width, height, block) {\n          return this.defs().pattern(width, height, block);\n        }\n      }\n    });\n    SVG.extend(SVG.Defs, {\n      // Define gradient\n      pattern: function pattern(width, height, block) {\n        return this.put(new SVG.Pattern()).update(block).attr({\n          x: 0,\n          y: 0,\n          width: width,\n          height: height,\n          patternUnits: 'userSpaceOnUse'\n        });\n      }\n    });\n    SVG.Shape = SVG.invent({\n      // Initialize node\n      create: function create(element) {\n        this.constructor.call(this, element);\n      },\n      // Inherit from\n      inherit: SVG.Element\n    });\n    SVG.Symbol = SVG.invent({\n      // Initialize node\n      create: 'symbol',\n      // Inherit from\n      inherit: SVG.Container,\n      construct: {\n        // create symbol\n        symbol: function symbol() {\n          return this.put(new SVG.Symbol());\n        }\n      }\n    });\n    SVG.Use = SVG.invent({\n      // Initialize node\n      create: 'use',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add class methods\n      extend: {\n        // Use element as a reference\n        element: function element(_element, file) {\n          // Set lined element\n          return this.attr('href', (file || '') + '#' + _element, SVG.xlink);\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create a use element\n        use: function use(element, file) {\n          return this.put(new SVG.Use()).element(element, file);\n        }\n      }\n    });\n    SVG.Rect = SVG.invent({\n      // Initialize node\n      create: 'rect',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add parent method\n      construct: {\n        // Create a rect element\n        rect: function rect(width, height) {\n          return this.put(new SVG.Rect()).size(width, height);\n        }\n      }\n    });\n    SVG.Circle = SVG.invent({\n      // Initialize node\n      create: 'circle',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add parent method\n      construct: {\n        // Create circle element, based on ellipse\n        circle: function circle(size) {\n          return this.put(new SVG.Circle()).rx(new SVG.Number(size).divide(2)).move(0, 0);\n        }\n      }\n    });\n    SVG.extend(SVG.Circle, SVG.FX, {\n      // Radius x value\n      rx: function rx(_rx) {\n        return this.attr('r', _rx);\n      },\n      // Alias radius x value\n      ry: function ry(_ry) {\n        return this.rx(_ry);\n      }\n    });\n    SVG.Ellipse = SVG.invent({\n      // Initialize node\n      create: 'ellipse',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add parent method\n      construct: {\n        // Create an ellipse\n        ellipse: function ellipse(width, height) {\n          return this.put(new SVG.Ellipse()).size(width, height).move(0, 0);\n        }\n      }\n    });\n    SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\n      // Radius x value\n      rx: function rx(_rx2) {\n        return this.attr('rx', _rx2);\n      },\n      // Radius y value\n      ry: function ry(_ry2) {\n        return this.attr('ry', _ry2);\n      }\n    }); // Add common method\n\n    SVG.extend(SVG.Circle, SVG.Ellipse, {\n      // Move over x-axis\n      x: function x(_x3) {\n        return _x3 == null ? this.cx() - this.rx() : this.cx(_x3 + this.rx());\n      },\n      // Move over y-axis\n      y: function y(_y2) {\n        return _y2 == null ? this.cy() - this.ry() : this.cy(_y2 + this.ry());\n      },\n      // Move by center over x-axis\n      cx: function cx(x) {\n        return x == null ? this.attr('cx') : this.attr('cx', x);\n      },\n      // Move by center over y-axis\n      cy: function cy(y) {\n        return y == null ? this.attr('cy') : this.attr('cy', y);\n      },\n      // Set width of element\n      width: function width(_width2) {\n        return _width2 == null ? this.rx() * 2 : this.rx(new SVG.Number(_width2).divide(2));\n      },\n      // Set height of element\n      height: function height(_height2) {\n        return _height2 == null ? this.ry() * 2 : this.ry(new SVG.Number(_height2).divide(2));\n      },\n      // Custom size function\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.rx(new SVG.Number(p.width).divide(2)).ry(new SVG.Number(p.height).divide(2));\n      }\n    });\n    SVG.Line = SVG.invent({\n      // Initialize node\n      create: 'line',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add class methods\n      extend: {\n        // Get array\n        array: function array() {\n          return new SVG.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n        },\n        // Overwrite native plot() method\n        plot: function plot(x1, y1, x2, y2) {\n          if (x1 == null) {\n            return this.array();\n          } else if (typeof y1 !== 'undefined') {\n            x1 = {\n              x1: x1,\n              y1: y1,\n              x2: x2,\n              y2: y2\n            };\n          } else {\n            x1 = new SVG.PointArray(x1).toLine();\n          }\n\n          return this.attr(x1);\n        },\n        // Move by left top corner\n        move: function move(x, y) {\n          return this.attr(this.array().move(x, y).toLine());\n        },\n        // Set element size to given width and height\n        size: function size(width, height) {\n          var p = proportionalSize(this, width, height);\n          return this.attr(this.array().size(p.width, p.height).toLine());\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create a line element\n        line: function line(x1, y1, x2, y2) {\n          // make sure plot is called as a setter\n          // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\n          return SVG.Line.prototype.plot.apply(this.put(new SVG.Line()), x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]);\n        }\n      }\n    });\n    SVG.Polyline = SVG.invent({\n      // Initialize node\n      create: 'polyline',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add parent method\n      construct: {\n        // Create a wrapped polyline element\n        polyline: function polyline(p) {\n          // make sure plot is called as a setter\n          return this.put(new SVG.Polyline()).plot(p || new SVG.PointArray());\n        }\n      }\n    });\n    SVG.Polygon = SVG.invent({\n      // Initialize node\n      create: 'polygon',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add parent method\n      construct: {\n        // Create a wrapped polygon element\n        polygon: function polygon(p) {\n          // make sure plot is called as a setter\n          return this.put(new SVG.Polygon()).plot(p || new SVG.PointArray());\n        }\n      }\n    }); // Add polygon-specific functions\n\n    SVG.extend(SVG.Polyline, SVG.Polygon, {\n      // Get array\n      array: function array() {\n        return this._array || (this._array = new SVG.PointArray(this.attr('points')));\n      },\n      // Plot new path\n      plot: function plot(p) {\n        return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new SVG.PointArray(p));\n      },\n      // Clear array cache\n      clear: function clear() {\n        delete this._array;\n        return this;\n      },\n      // Move by left top corner\n      move: function move(x, y) {\n        return this.attr('points', this.array().move(x, y));\n      },\n      // Set element size to given width and height\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.attr('points', this.array().size(p.width, p.height));\n      }\n    }); // unify all point to point elements\n\n    SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\n      // Define morphable array\n      morphArray: SVG.PointArray,\n      // Move by left top corner over x-axis\n      x: function x(_x4) {\n        return _x4 == null ? this.bbox().x : this.move(_x4, this.bbox().y);\n      },\n      // Move by left top corner over y-axis\n      y: function y(_y3) {\n        return _y3 == null ? this.bbox().y : this.move(this.bbox().x, _y3);\n      },\n      // Set width of element\n      width: function width(_width3) {\n        var b = this.bbox();\n        return _width3 == null ? b.width : this.size(_width3, b.height);\n      },\n      // Set height of element\n      height: function height(_height3) {\n        var b = this.bbox();\n        return _height3 == null ? b.height : this.size(b.width, _height3);\n      }\n    });\n    SVG.Path = SVG.invent({\n      // Initialize node\n      create: 'path',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add class methods\n      extend: {\n        // Define morphable array\n        morphArray: SVG.PathArray,\n        // Get array\n        array: function array() {\n          return this._array || (this._array = new SVG.PathArray(this.attr('d')));\n        },\n        // Plot new path\n        plot: function plot(d) {\n          return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new SVG.PathArray(d));\n        },\n        // Clear array cache\n        clear: function clear() {\n          delete this._array;\n          return this;\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create a wrapped path element\n        path: function path(d) {\n          // make sure plot is called as a setter\n          return this.put(new SVG.Path()).plot(d || new SVG.PathArray());\n        }\n      }\n    });\n    SVG.Image = SVG.invent({\n      // Initialize node\n      create: 'image',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add class methods\n      extend: {\n        // (re)load image\n        load: function load(url) {\n          if (!url) return this;\n          var self = this,\n              img = new window.Image(); // preload image\n\n          SVG.on(img, 'load', function () {\n            SVG.off(img);\n            var p = self.parent(SVG.Pattern);\n            if (p === null) return; // ensure image size\n\n            if (self.width() == 0 && self.height() == 0) {\n              self.size(img.width, img.height);\n            } // ensure pattern size if not set\n\n\n            if (p && p.width() == 0 && p.height() == 0) {\n              p.size(self.width(), self.height());\n            } // callback\n\n\n            if (typeof self._loaded === 'function') {\n              self._loaded.call(self, {\n                width: img.width,\n                height: img.height,\n                ratio: img.width / img.height,\n                url: url\n              });\n            }\n          });\n          SVG.on(img, 'error', function (e) {\n            SVG.off(img);\n\n            if (typeof self._error === 'function') {\n              self._error.call(self, e);\n            }\n          });\n          return this.attr('href', img.src = this.src = url, SVG.xlink);\n        },\n        // Add loaded callback\n        loaded: function loaded(_loaded) {\n          this._loaded = _loaded;\n          return this;\n        },\n        error: function error(_error) {\n          this._error = _error;\n          return this;\n        }\n      },\n      // Add parent method\n      construct: {\n        // create image element, load image and set its size\n        image: function image(source, width, height) {\n          return this.put(new SVG.Image()).load(source).size(width || 0, height || width || 0);\n        }\n      }\n    });\n    SVG.Text = SVG.invent({\n      // Initialize node\n      create: function create() {\n        this.constructor.call(this, SVG.create('text'));\n        this.dom.leading = new SVG.Number(1.3); // store leading value for rebuilding\n\n        this._rebuild = true; // enable automatic updating of dy values\n\n        this._build = false; // disable build mode for adding multiple lines\n        // set default font\n\n        this.attr('font-family', SVG.defaults.attrs['font-family']);\n      },\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add class methods\n      extend: {\n        // Move over x-axis\n        x: function x(_x5) {\n          // act as getter\n          if (_x5 == null) {\n            return this.attr('x');\n          }\n\n          return this.attr('x', _x5);\n        },\n        // Set the text content\n        text: function text(_text) {\n          // act as getter\n          if (typeof _text === 'undefined') {\n            var _text = '';\n            var children = this.node.childNodes;\n\n            for (var i = 0, len = children.length; i < len; ++i) {\n              // add newline if its not the first child and newLined is set to true\n              if (i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true) {\n                _text += '\\n';\n              } // add content of this node\n\n\n              _text += children[i].textContent;\n            }\n\n            return _text;\n          } // remove existing content\n\n\n          this.clear().build(true);\n\n          if (typeof _text === 'function') {\n            // call block\n            _text.call(this, this);\n          } else {\n            // store text and make sure text is not blank\n            _text = _text.split('\\n'); // build new lines\n\n            for (var i = 0, il = _text.length; i < il; i++) {\n              this.tspan(_text[i]).newLine();\n            }\n          } // disable build mode and rebuild lines\n\n\n          return this.build(false).rebuild();\n        },\n        // Set font size\n        size: function size(_size) {\n          return this.attr('font-size', _size).rebuild();\n        },\n        // Set / get leading\n        leading: function leading(value) {\n          // act as getter\n          if (value == null) {\n            return this.dom.leading;\n          } // act as setter\n\n\n          this.dom.leading = new SVG.Number(value);\n          return this.rebuild();\n        },\n        // Get all the first level lines\n        lines: function lines() {\n          var node = (this.textPath && this.textPath() || this).node; // filter tspans and map them to SVG.js instances\n\n          var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function (el) {\n            return SVG.adopt(el);\n          }); // return an instance of SVG.set\n\n          return new SVG.Set(lines);\n        },\n        // Rebuild appearance type\n        rebuild: function rebuild(_rebuild) {\n          // store new rebuild flag if given\n          if (typeof _rebuild === 'boolean') {\n            this._rebuild = _rebuild;\n          } // define position of all lines\n\n\n          if (this._rebuild) {\n            var self = this,\n                blankLineOffset = 0,\n                dy = this.dom.leading * new SVG.Number(this.attr('font-size'));\n            this.lines().each(function () {\n              if (this.dom.newLined) {\n                if (!self.textPath()) {\n                  this.attr('x', self.attr('x'));\n                }\n\n                if (this.text() == '\\n') {\n                  blankLineOffset += dy;\n                } else {\n                  this.attr('dy', dy + blankLineOffset);\n                  blankLineOffset = 0;\n                }\n              }\n            });\n            this.fire('rebuild');\n          }\n\n          return this;\n        },\n        // Enable / disable build mode\n        build: function build(_build) {\n          this._build = !!_build;\n          return this;\n        },\n        // overwrite method from parent to set data properly\n        setData: function setData(o) {\n          this.dom = o;\n          this.dom.leading = new SVG.Number(o.leading || 1.3);\n          return this;\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create text element\n        text: function text(_text2) {\n          return this.put(new SVG.Text()).text(_text2);\n        },\n        // Create plain text element\n        plain: function plain(text) {\n          return this.put(new SVG.Text()).plain(text);\n        }\n      }\n    });\n    SVG.Tspan = SVG.invent({\n      // Initialize node\n      create: 'tspan',\n      // Inherit from\n      inherit: SVG.Shape,\n      // Add class methods\n      extend: {\n        // Set text content\n        text: function text(_text3) {\n          if (_text3 == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n          typeof _text3 === 'function' ? _text3.call(this, this) : this.plain(_text3);\n          return this;\n        },\n        // Shortcut dx\n        dx: function dx(_dx) {\n          return this.attr('dx', _dx);\n        },\n        // Shortcut dy\n        dy: function dy(_dy) {\n          return this.attr('dy', _dy);\n        },\n        // Create new line\n        newLine: function newLine() {\n          // fetch text parent\n          var t = this.parent(SVG.Text); // mark new line\n\n          this.dom.newLined = true; // apply new hy¡n\n\n          return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x());\n        }\n      }\n    });\n    SVG.extend(SVG.Text, SVG.Tspan, {\n      // Create plain text node\n      plain: function plain(text) {\n        // clear if build mode is disabled\n        if (this._build === false) {\n          this.clear();\n        } // create text node\n\n\n        this.node.appendChild(document.createTextNode(text));\n        return this;\n      },\n      // Create a tspan\n      tspan: function tspan(text) {\n        var node = (this.textPath && this.textPath() || this).node,\n            tspan = new SVG.Tspan(); // clear if build mode is disabled\n\n        if (this._build === false) {\n          this.clear();\n        } // add new tspan\n\n\n        node.appendChild(tspan.node);\n        return tspan.text(text);\n      },\n      // Clear all lines\n      clear: function clear() {\n        var node = (this.textPath && this.textPath() || this).node; // remove existing child nodes\n\n        while (node.hasChildNodes()) {\n          node.removeChild(node.lastChild);\n        }\n\n        return this;\n      },\n      // Get length of text element\n      length: function length() {\n        return this.node.getComputedTextLength();\n      }\n    });\n    SVG.TextPath = SVG.invent({\n      // Initialize node\n      create: 'textPath',\n      // Inherit from\n      inherit: SVG.Parent,\n      // Define parent class\n      parent: SVG.Text,\n      // Add parent method\n      construct: {\n        morphArray: SVG.PathArray,\n        // return the array of the path track element\n        array: function array() {\n          var track = this.track();\n          return track ? track.array() : null;\n        },\n        // Plot path if any\n        plot: function plot(d) {\n          var track = this.track(),\n              pathArray = null;\n\n          if (track) {\n            pathArray = track.plot(d);\n          }\n\n          return d == null ? pathArray : this;\n        },\n        // Get the path track element\n        track: function track() {\n          var path = this.textPath();\n\n          if (path) {\n            return path.reference('href');\n          }\n        },\n        // Get the textPath child\n        textPath: function textPath() {\n          if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') {\n            return SVG.adopt(this.node.firstChild);\n          }\n        }\n      }\n    });\n    SVG.Nested = SVG.invent({\n      // Initialize node\n      create: function create() {\n        this.constructor.call(this, SVG.create('svg'));\n        this.style('overflow', 'visible');\n      },\n      // Inherit from\n      inherit: SVG.Container,\n      // Add parent method\n      construct: {\n        // Create nested svg document\n        nested: function nested() {\n          return this.put(new SVG.Nested());\n        }\n      }\n    }); // Define list of available attributes for stroke and fill\n\n    var sugar = {\n      stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n      fill: ['color', 'opacity', 'rule'],\n      prefix: function prefix(t, a) {\n        return a == 'color' ? t : t + '-' + a;\n      }\n    } // Add sugar for fill and stroke\n    ;\n    ['fill', 'stroke'].forEach(function (m) {\n      var extension = {};\n\n      extension[m] = function (o) {\n        if (typeof o === 'undefined') {\n          return this;\n        }\n\n        if (typeof o === 'string' || SVG.Color.isRgb(o) || o && typeof o.fill === 'function') {\n          this.attr(m, o);\n        } else // set all attributes from sugar.fill and sugar.stroke list\n          {\n            for (var i = sugar[m].length - 1; i >= 0; i--) {\n              if (o[sugar[m][i]] != null) {\n                this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n              }\n            }\n          }\n\n        return this;\n      };\n\n      SVG.extend(SVG.Element, SVG.FX, extension);\n    });\n    SVG.extend(SVG.Element, SVG.FX, {\n      // Map translate to transform\n      translate: function translate(x, y) {\n        return this.transform({\n          x: x,\n          y: y\n        });\n      },\n      // Map matrix to transform\n      matrix: function matrix(m) {\n        return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m));\n      },\n      // Opacity\n      opacity: function opacity(value) {\n        return this.attr('opacity', value);\n      },\n      // Relative move over x axis\n      dx: function dx(x) {\n        return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true);\n      },\n      // Relative move over y axis\n      dy: function dy(y) {\n        return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true);\n      }\n    });\n    SVG.extend(SVG.Path, {\n      // Get path length\n      length: function length() {\n        return this.node.getTotalLength();\n      },\n      // Get point at length\n      pointAt: function pointAt(length) {\n        return this.node.getPointAtLength(length);\n      }\n    });\n    SVG.Set = SVG.invent({\n      // Initialize\n      create: function create(members) {\n        // Set initial state\n        Array.isArray(members) ? this.members = members : this.clear();\n      },\n      // Add class methods\n      extend: {\n        // Add element to set\n        add: function add() {\n          var il,\n              elements = [].slice.call(arguments);\n\n          for (var i = 0, il = elements.length; i < il; i++) {\n            this.members.push(elements[i]);\n          }\n\n          return this;\n        },\n        // Remove element from set\n        remove: function remove(element) {\n          var i = this.index(element); // remove given child\n\n          if (i > -1) {\n            this.members.splice(i, 1);\n          }\n\n          return this;\n        },\n        // Iterate over all members\n        each: function each(block) {\n          for (var i = 0, il = this.members.length; i < il; i++) {\n            block.apply(this.members[i], [i, this.members]);\n          }\n\n          return this;\n        },\n        // Restore to defaults\n        clear: function clear() {\n          // initialize store\n          this.members = [];\n          return this;\n        },\n        // Get the length of a set\n        length: function length() {\n          return this.members.length;\n        },\n        // Checks if a given element is present in set\n        has: function has(element) {\n          return this.index(element) >= 0;\n        },\n        // retuns index of given element in set\n        index: function index(element) {\n          return this.members.indexOf(element);\n        },\n        // Get member at given index\n        get: function get(i) {\n          return this.members[i];\n        },\n        // Get first member\n        first: function first() {\n          return this.get(0);\n        },\n        // Get last member\n        last: function last() {\n          return this.get(this.members.length - 1);\n        },\n        // Default value\n        valueOf: function valueOf() {\n          return this.members;\n        }\n      },\n      // Add parent method\n      construct: {\n        // Create a new set\n        set: function set(members) {\n          return new SVG.Set(members);\n        }\n      }\n    });\n    SVG.FX.Set = SVG.invent({\n      // Initialize node\n      create: function create(set) {\n        // store reference to set\n        this.set = set;\n      }\n    }); // Alias methods\n\n    SVG.Set.inherit = function () {\n      var methods = []; // gather shape methods\n\n      for (var m in SVG.Shape.prototype) {\n        if (typeof SVG.Shape.prototype[m] === 'function' && typeof SVG.Set.prototype[m] !== 'function') {\n          methods.push(m);\n        }\n      } // apply shape aliasses\n\n\n      methods.forEach(function (method) {\n        SVG.Set.prototype[method] = function () {\n          for (var i = 0, il = this.members.length; i < il; i++) {\n            if (this.members[i] && typeof this.members[i][method] === 'function') {\n              this.members[i][method].apply(this.members[i], arguments);\n            }\n          }\n\n          return method == 'animate' ? this.fx || (this.fx = new SVG.FX.Set(this)) : this;\n        };\n      }); // clear methods for the next round\n\n      methods = []; // gather fx methods\n\n      for (var m in SVG.FX.prototype) {\n        if (typeof SVG.FX.prototype[m] === 'function' && typeof SVG.FX.Set.prototype[m] !== 'function') {\n          methods.push(m);\n        }\n      } // apply fx aliasses\n\n\n      methods.forEach(function (method) {\n        SVG.FX.Set.prototype[method] = function () {\n          for (var i = 0, il = this.set.members.length; i < il; i++) {\n            this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments);\n          }\n\n          return this;\n        };\n      });\n    };\n\n    SVG.extend(SVG.Element, {});\n    SVG.extend(SVG.Element, {\n      // Remember arbitrary data\n      remember: function remember(k, v) {\n        // remember every item in an object individually\n        if (_typeof(arguments[0]) === 'object') {\n          for (var v_ in k) {\n            this.remember(v_, k[v_]);\n          }\n        } // retrieve memory\n        else if (arguments.length == 1) {\n          return this.memory()[k];\n        } // store memory\n        else {\n          this.memory()[k] = v;\n        }\n\n        return this;\n      },\n      // Erase a given memory\n      forget: function forget() {\n        if (arguments.length == 0) {\n          this._memory = {};\n        } else {\n          for (var i = arguments.length - 1; i >= 0; i--) {\n            delete this.memory()[arguments[i]];\n          }\n        }\n\n        return this;\n      },\n      // Initialize or return local memory object\n      memory: function memory() {\n        return this._memory || (this._memory = {});\n      }\n    }); // Method for getting an element by id\n\n    SVG.get = function (id) {\n      var node = document.getElementById(idFromReference(id) || id);\n      return SVG.adopt(node);\n    }; // Select elements by query string\n\n\n    SVG.select = function (query, parent) {\n      return new SVG.Set(SVG.utils.map((parent || document).querySelectorAll(query), function (node) {\n        return SVG.adopt(node);\n      }));\n    };\n\n    SVG.extend(SVG.Parent, {\n      // Scoped select method\n      select: function select(query) {\n        return SVG.select(query, this.node);\n      }\n    });\n\n    function pathRegReplace(a, b, c, d) {\n      return c + d.replace(SVG.regex.dots, ' .');\n    } // creates deep clone of array\n\n\n    function _is(el, obj) {\n      return el instanceof obj;\n    } // tests if a given selector matches an element\n\n\n    function _matches(el, selector) {\n      return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n    } // Convert dash-separated-string to camelCase\n\n\n    function camelCase(s) {\n      return s.toLowerCase().replace(/-(.)/g, function (m, g) {\n        return g.toUpperCase();\n      });\n    } // Capitalize first letter of a string\n\n\n    function capitalize(s) {\n      return s.charAt(0).toUpperCase() + s.slice(1);\n    } // Ensure to six-based hex\n\n\n    function fullHex(hex) {\n      return hex.length == 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n    } // Component to hex value\n\n\n    function compToHex(comp) {\n      var hex = comp.toString(16);\n      return hex.length == 1 ? '0' + hex : hex;\n    } // Calculate proportional width and height values when necessary\n\n\n    function proportionalSize(element, width, height) {\n      if (width == null || height == null) {\n        var box = element.bbox();\n\n        if (width == null) {\n          width = box.width / box.height * height;\n        } else if (height == null) {\n          height = box.height / box.width * width;\n        }\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    } // Delta transform point\n\n\n    function deltaTransformPoint(matrix, x, y) {\n      return {\n        x: x * matrix.a + y * matrix.c + 0,\n        y: x * matrix.b + y * matrix.d + 0\n      };\n    } // Map matrix array to object\n\n\n    function arrayToMatrix(a) {\n      return {\n        a: a[0],\n        b: a[1],\n        c: a[2],\n        d: a[3],\n        e: a[4],\n        f: a[5]\n      };\n    } // Parse matrix if required\n\n\n    function parseMatrix(matrix) {\n      if (!(matrix instanceof SVG.Matrix)) {\n        matrix = new SVG.Matrix(matrix);\n      }\n\n      return matrix;\n    } // Add centre point to transform object\n\n\n    function arrayToString(a) {\n      for (var i = 0, il = a.length, s = ''; i < il; i++) {\n        s += a[i][0];\n\n        if (a[i][1] != null) {\n          s += a[i][1];\n\n          if (a[i][2] != null) {\n            s += ' ';\n            s += a[i][2];\n\n            if (a[i][3] != null) {\n              s += ' ';\n              s += a[i][3];\n              s += ' ';\n              s += a[i][4];\n\n              if (a[i][5] != null) {\n                s += ' ';\n                s += a[i][5];\n                s += ' ';\n                s += a[i][6];\n\n                if (a[i][7] != null) {\n                  s += ' ';\n                  s += a[i][7];\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s + ' ';\n    } // Deep new id assignment\n\n\n    function assignNewId(node) {\n      // do the same for SVG child nodes as well\n      for (var i = node.childNodes.length - 1; i >= 0; i--) {\n        if (node.childNodes[i] instanceof window.SVGElement) {\n          assignNewId(node.childNodes[i]);\n        }\n      }\n\n      return SVG.adopt(node).id(SVG.eid(node.nodeName));\n    } // Add more bounding box properties\n\n\n    function fullBox(b) {\n      if (b.x == null) {\n        b.x = 0;\n        b.y = 0;\n        b.width = 0;\n        b.height = 0;\n      }\n\n      b.w = b.width;\n      b.h = b.height;\n      b.x2 = b.x + b.width;\n      b.y2 = b.y + b.height;\n      b.cx = b.x + b.width / 2;\n      b.cy = b.y + b.height / 2;\n      return b;\n    } // Get id from reference string\n\n\n    function idFromReference(url) {\n      var m = (url || '').toString().match(SVG.regex.reference);\n      if (m) return m[1];\n    } // If values like 1e-88 are passed, this is not a valid 32 bit float,\n    // but in those cases, we are so close to 0 that 0 works well!\n\n\n    function float32String(v) {\n      return Math.abs(v) > 1e-37 ? v : 0;\n    } // Create matrix array for looping\n\n\n    var abcdef = 'abcdef'.split(''); // Add CustomEvent to IE9 and IE10\n\n    if (typeof window.CustomEvent !== 'function') {\n      // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n      var CustomEventPoly = function CustomEventPoly(event, options) {\n        options = options || {\n          bubbles: false,\n          cancelable: false,\n          detail: undefined\n        };\n        var e = document.createEvent('CustomEvent');\n        e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail);\n        return e;\n      };\n\n      CustomEventPoly.prototype = window.Event.prototype;\n      SVG.CustomEvent = CustomEventPoly;\n    } else {\n      SVG.CustomEvent = window.CustomEvent;\n    }\n\n    return SVG;\n  });\n\n  /*! svg.filter.js - v2.0.2 - 2016-02-24\r\n  * https://github.com/wout/svg.filter.js\r\n  * Copyright (c) 2016 Wout Fierens; Licensed MIT */\r\n  (function() {\r\n\r\n    // Main filter class\r\n    SVG.Filter = SVG.invent({\r\n      create: 'filter',\r\n      inherit: SVG.Parent,\r\n      extend: {\r\n        // Static strings\r\n        source:           'SourceGraphic',\r\n        sourceAlpha:      'SourceAlpha',\r\n        background:       'BackgroundImage',\r\n        backgroundAlpha:  'BackgroundAlpha',\r\n        fill:             'FillPaint',\r\n        stroke:           'StrokePaint',\r\n\r\n        autoSetIn: true,\r\n        // Custom put method for leaner code\r\n        put: function(element, i) {\r\n          this.add(element, i);\r\n\r\n          if(!element.attr('in') && this.autoSetIn){\r\n            element.attr('in',this.source);\r\n          }\r\n          if(!element.attr('result')){\r\n            element.attr('result',element);\r\n          }\r\n\r\n          return element\r\n        },\r\n        // Blend effect\r\n        blend: function(in1, in2, mode) {\r\n          return this.put(new SVG.BlendEffect(in1, in2, mode))\r\n        },\r\n        // ColorMatrix effect\r\n        colorMatrix: function(type, values) {\r\n          return this.put(new SVG.ColorMatrixEffect(type, values))\r\n        },\r\n        // ConvolveMatrix effect\r\n        convolveMatrix: function(matrix) {\r\n          return this.put(new SVG.ConvolveMatrixEffect(matrix))\r\n        },\r\n        // ComponentTransfer effect\r\n        componentTransfer: function(components) {\r\n          return this.put(new SVG.ComponentTransferEffect(components))\r\n        },\r\n        // Composite effect\r\n        composite: function(in1, in2, operator) {\r\n          return this.put(new SVG.CompositeEffect(in1, in2, operator))\r\n        },\r\n        // Flood effect\r\n        flood: function(color, opacity) {\r\n          return this.put(new SVG.FloodEffect(color, opacity))\r\n        },\r\n        // Offset effect\r\n        offset: function(x, y) {\r\n          return this.put(new SVG.OffsetEffect(x,y))\r\n        },\r\n        // Image effect\r\n        image: function(src) {\r\n          return this.put(new SVG.ImageEffect(src))\r\n        },\r\n        // Merge effect\r\n        merge: function() {\r\n          //pass the array of arguments to the constructor because we dont know if the user gave us an array as the first arguemnt or wether they listed the effects in the arguments\r\n          var args = [undefined];\r\n          for(var i in arguments) args.push(arguments[i]);\r\n          return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect,args)))\r\n        },\r\n        // Gaussian Blur effect\r\n        gaussianBlur: function(x,y) {\r\n          return this.put(new SVG.GaussianBlurEffect(x,y))\r\n        },\r\n        // Morphology effect\r\n        morphology: function(operator,radius){\r\n          return this.put(new SVG.MorphologyEffect(operator,radius))\r\n        },\r\n        // DiffuseLighting effect\r\n        diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n          return this.put(new SVG.DiffuseLightingEffect(surfaceScale,diffuseConstant,kernelUnitLength))\r\n        },\r\n        // DisplacementMap effect\r\n        displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){\r\n          return this.put(new SVG.DisplacementMapEffect(in1,in2,scale,xChannelSelector,yChannelSelector))\r\n        },\r\n        // SpecularLighting effect\r\n        specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n          return this.put(new SVG.SpecularLightingEffect(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength))\r\n        },\r\n        // Tile effect\r\n        tile: function(){\r\n          return this.put(new SVG.TileEffect());\r\n        },\r\n        // Turbulence effect\r\n        turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n          return this.put(new SVG.TurbulenceEffect(baseFrequency,numOctaves,seed,stitchTiles,type))\r\n        },\r\n        // Default string value\r\n        toString: function() {\r\n          return 'url(#' + this.attr('id') + ')'\r\n        }\r\n      }\r\n    });\r\n\r\n    //add .filter function\r\n    SVG.extend(SVG.Defs, {\r\n      // Define filter\r\n      filter: function(block) {\r\n        var filter = this.put(new SVG.Filter);\r\n\r\n        /* invoke passed block */\r\n        if (typeof block === 'function')\r\n          block.call(filter, filter);\r\n\r\n        return filter\r\n      }\r\n    });\r\n    SVG.extend(SVG.Container, {\r\n      // Define filter on defs\r\n      filter: function(block) {\r\n        return this.defs().filter(block)\r\n      }\r\n    });\r\n    SVG.extend(SVG.Element, SVG.G, SVG.Nested, {\r\n      // Create filter element in defs and store reference\r\n      filter: function(block) {\r\n        this.filterer = block instanceof SVG.Element ?\r\n          block : this.doc().filter(block);\r\n\r\n        if(this.doc() && this.filterer.doc() !== this.doc()){\r\n          this.doc().defs().add(this.filterer);\r\n        }\r\n\r\n        this.attr('filter', this.filterer);\r\n\r\n        return this.filterer\r\n      },\r\n      // Remove filter\r\n      unfilter: function(remove) {\r\n        /* also remove the filter node */\r\n        if (this.filterer && remove === true)\r\n          this.filterer.remove();\r\n\r\n        /* delete reference to filterer */\r\n        delete this.filterer;\r\n\r\n        /* remove filter attribute */\r\n        return this.attr('filter', null)\r\n      }\r\n    });\r\n\r\n    // Create SVG.Effect class\r\n    SVG.Effect = SVG.invent({\r\n      create: function(){\r\n        this.constructor.call(this);\r\n      },\r\n      inherit: SVG.Element,\r\n      extend: {\r\n        // Set in attribute\r\n        in: function(effect) {\r\n          return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in')+'\"]').get(0) || this.attr('in') : this.attr('in', effect)\r\n        },\r\n        // Named result\r\n        result: function(result) {\r\n          return result == null? this.attr('result') : this.attr('result',result)\r\n        },\r\n        // Stringification\r\n        toString: function() {\r\n          return this.result()\r\n        }\r\n      }\r\n    });\r\n\r\n    // create class for parent effects like merge\r\n    // Inherit from SVG.Parent\r\n    SVG.ParentEffect = SVG.invent({\r\n      create: function(){\r\n        this.constructor.call(this);\r\n      },\r\n      inherit: SVG.Parent,\r\n      extend: {\r\n        // Set in attribute\r\n        in: function(effect) {\r\n          return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in')+'\"]').get(0) || this.attr('in') : this.attr('in', effect)\r\n        },\r\n        // Named result\r\n        result: function(result) {\r\n          return result == null? this.attr('result') : this.attr('result',result)\r\n        },\r\n        // Stringification\r\n        toString: function() {\r\n          return this.result()\r\n        }\r\n      }\r\n    });\r\n\r\n    //chaining\r\n    var chainingEffects = {\r\n      // Blend effect\r\n      blend: function(in2, mode) {\r\n        return this.parent() && this.parent().blend(this, in2, mode) //pass this as the first input\r\n      },\r\n      // ColorMatrix effect\r\n      colorMatrix: function(type, values) {\r\n        return this.parent() && this.parent().colorMatrix(type, values).in(this)\r\n      },\r\n      // ConvolveMatrix effect\r\n      convolveMatrix: function(matrix) {\r\n        return this.parent() && this.parent().convolveMatrix(matrix).in(this)\r\n      },\r\n      // ComponentTransfer effect\r\n      componentTransfer: function(components) {\r\n        return this.parent() && this.parent().componentTransfer(components).in(this)\r\n      },\r\n      // Composite effect\r\n      composite: function(in2, operator) {\r\n        return this.parent() && this.parent().composite(this, in2, operator) //pass this as the first input\r\n      },\r\n      // Flood effect\r\n      flood: function(color, opacity) {\r\n        return this.parent() && this.parent().flood(color, opacity) //this effect dont have inputs\r\n      },\r\n      // Offset effect\r\n      offset: function(x, y) {\r\n        return this.parent() && this.parent().offset(x,y).in(this)\r\n      },\r\n      // Image effect\r\n      image: function(src) {\r\n        return this.parent() && this.parent().image(src) //this effect dont have inputs\r\n      },\r\n      // Merge effect\r\n      merge: function() {\r\n        return this.parent() && this.parent().merge.apply(this.parent(),[this].concat(arguments)) //pass this as the first argument\r\n      },\r\n      // Gaussian Blur effect\r\n      gaussianBlur: function(x,y) {\r\n        return this.parent() && this.parent().gaussianBlur(x,y).in(this)\r\n      },\r\n      // Morphology effect\r\n      morphology: function(operator,radius){\r\n        return this.parent() && this.parent().morphology(operator,radius).in(this)\r\n      },\r\n      // DiffuseLighting effect\r\n      diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n        return this.parent() && this.parent().diffuseLighting(surfaceScale,diffuseConstant,kernelUnitLength).in(this)\r\n      },\r\n      // DisplacementMap effect\r\n      displacementMap: function(in2,scale,xChannelSelector,yChannelSelector){\r\n        return this.parent() && this.parent().displacementMap(this,in2,scale,xChannelSelector,yChannelSelector) //pass this as the first input\r\n      },\r\n      // SpecularLighting effect\r\n      specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n        return this.parent() && this.parent().specularLighting(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength).in(this)\r\n      },\r\n      // Tile effect\r\n      tile: function(){\r\n        return this.parent() && this.parent().tile().in(this)\r\n      },\r\n      // Turbulence effect\r\n      turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n        return this.parent() && this.parent().turbulence(baseFrequency,numOctaves,seed,stitchTiles,type).in(this)\r\n      }\r\n    };\r\n    SVG.extend(SVG.Effect,chainingEffects);\r\n    SVG.extend(SVG.ParentEffect,chainingEffects);\r\n\r\n    //crea class for child effects, like MergeNode, FuncR and lights\r\n    SVG.ChildEffect = SVG.invent({\r\n      create: function(){\r\n        this.constructor.call(this);\r\n      },\r\n      inherit: SVG.Element,\r\n      extend: {\r\n      in: function(effect){\r\n        this.attr('in',effect);\r\n      }\r\n      //dont include any \"result\" functions because these types of nodes dont have them\r\n      }\r\n    });\r\n\r\n    // Create all different effects\r\n    var effects = {\r\n      blend: function(in1,in2,mode){\r\n        this.attr({\r\n          in: in1,\r\n          in2: in2,\r\n          mode: mode || 'normal'\r\n        });\r\n      },\r\n      colorMatrix: function(type,values){\r\n        if (type == 'matrix')\r\n          values = normaliseMatrix(values);\r\n\r\n        this.attr({\r\n          type:   type\r\n        , values: typeof values == 'undefined' ? null : values\r\n        });\r\n      },\r\n      convolveMatrix: function(matrix){\r\n        matrix = normaliseMatrix(matrix);\r\n\r\n        this.attr({\r\n          order:        Math.sqrt(matrix.split(' ').length)\r\n        , kernelMatrix: matrix\r\n        });\r\n      },\r\n      composite: function(in1, in2, operator){\r\n        this.attr({\r\n          in: in1,\r\n          in2: in2,\r\n          operator: operator\r\n        });\r\n      },\r\n      flood: function(color,opacity){\r\n        this.attr('flood-color',color);\r\n        if(opacity != null) this.attr('flood-opacity',opacity);\r\n      },\r\n      offset: function(x,y){\r\n        this.attr({\r\n          dx: x,\r\n          dy: y\r\n        });\r\n      },\r\n      image: function(src){\r\n        this.attr('href', src, SVG.xlink);\r\n      },\r\n      displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){\r\n        this.attr({\r\n          in: in1,\r\n          in2: in2,\r\n          scale: scale,\r\n          xChannelSelector: xChannelSelector,\r\n          yChannelSelector: yChannelSelector\r\n        });\r\n      },\r\n      gaussianBlur: function(x,y){\r\n        if(x != null || y != null)\r\n          this.attr('stdDeviation', listString(Array.prototype.slice.call(arguments)));\r\n        else\r\n          this.attr('stdDeviation', '0 0');\r\n      },\r\n      morphology: function(operator,radius){\r\n        this.attr({\r\n          operator: operator,\r\n          radius: radius\r\n        });\r\n      },\r\n      tile: function(){\r\n\r\n      },\r\n      turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n        this.attr({\r\n          numOctaves: numOctaves,\r\n          seed: seed,\r\n          stitchTiles: stitchTiles,\r\n          baseFrequency: baseFrequency,\r\n          type: type\r\n        });\r\n      }\r\n    };\r\n\r\n    // Create all parent effects\r\n    var parentEffects = {\r\n      merge: function(){\r\n        var children;\r\n\r\n        //test to see if we have a set\r\n        if(arguments[0] instanceof SVG.Set){\r\n          var that = this;\r\n          arguments[0].each(function(i){\r\n            if(this instanceof SVG.MergeNode)\r\n              that.put(this);\r\n            else if(this instanceof SVG.Effect || this instanceof SVG.ParentEffect)\r\n              that.put(new SVG.MergeNode(this));\r\n          });\r\n        }\r\n        else {\r\n          //if the first argument is an array use it\r\n          if(Array.isArray(arguments[0]))\r\n            children = arguments[0];\r\n          else\r\n            children = arguments;\r\n\r\n          for(var i = 0; i < children.length; i++){\r\n            if(children[i] instanceof SVG.MergeNode){\r\n              this.put(children[i]);\r\n            }\r\n            else this.put(new SVG.MergeNode(children[i]));\r\n          }\r\n        }\r\n      },\r\n      componentTransfer: function(compontents){\r\n        /* create rgb set */\r\n        this.rgb = new SVG.Set\r\n\r\n        /* create components */\r\n        ;(['r', 'g', 'b', 'a']).forEach(function(c) {\r\n          /* create component */\r\n          this[c] = new SVG['Func' + c.toUpperCase()]('identity');\r\n\r\n          /* store component in set */\r\n          this.rgb.add(this[c]);\r\n\r\n          /* add component node */\r\n          this.node.appendChild(this[c].node);\r\n        }.bind(this)); //lost context in foreach\r\n\r\n        /* set components */\r\n        if (compontents) {\r\n          if (compontents.rgb) {\r\n  (['r', 'g', 'b']).forEach(function(c) {\r\n              this[c].attr(compontents.rgb);\r\n            }.bind(this));\r\n\r\n            delete compontents.rgb;\r\n          }\r\n\r\n          /* set individual components */\r\n          for (var c in compontents)\r\n            this[c].attr(compontents[c]);\r\n        }\r\n      },\r\n      diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n        this.attr({\r\n          surfaceScale: surfaceScale,\r\n          diffuseConstant: diffuseConstant,\r\n          kernelUnitLength: kernelUnitLength\r\n        });\r\n      },\r\n      specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n        this.attr({\r\n          surfaceScale: surfaceScale,\r\n          diffuseConstant: diffuseConstant,\r\n          specularExponent: specularExponent,\r\n          kernelUnitLength: kernelUnitLength\r\n        });\r\n      },\r\n    };\r\n\r\n    // Create child effects like PointLight and MergeNode\r\n    var childEffects = {\r\n      distantLight: function(azimuth, elevation){\r\n        this.attr({\r\n          azimuth: azimuth,\r\n          elevation: elevation\r\n        });\r\n      },\r\n      pointLight: function(x,y,z){\r\n        this.attr({\r\n          x: x,\r\n          y: y,\r\n          z: z\r\n        });\r\n      },\r\n      spotLight: function(x,y,z,pointsAtX,pointsAtY,pointsAtZ){\r\n        this.attr({\r\n          x: x,\r\n          y: y,\r\n          z: z,\r\n          pointsAtX: pointsAtX,\r\n          pointsAtY: pointsAtY,\r\n          pointsAtZ: pointsAtZ\r\n        });\r\n      },\r\n      mergeNode: function(in1){\r\n        this.attr('in',in1);\r\n      }\r\n    }\r\n\r\n    // Create compontent functions\r\n    ;(['r', 'g', 'b', 'a']).forEach(function(c) {\r\n      /* create class */\r\n      childEffects['Func' + c.toUpperCase()] = function(type) {\r\n        this.attr('type',type);\r\n\r\n        // take diffent arguments based on the type\r\n        switch(type){\r\n          case 'table':\r\n            this.attr('tableValues',arguments[1]);\r\n            break\r\n          case 'linear':\r\n            this.attr('slope',arguments[1]);\r\n            this.attr('intercept',arguments[2]);\r\n            break\r\n          case 'gamma':\r\n            this.attr('amplitude',arguments[1]);\r\n            this.attr('exponent',arguments[2]);\r\n            this.attr('offset',arguments[2]);\r\n            break\r\n        }\r\n      };\r\n    });\r\n\r\n    //create effects\r\n    foreach(effects,function(effect,i){\r\n\r\n      /* capitalize name */\r\n      var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n      var proto = {};\r\n\r\n      /* create class */\r\n      SVG[name + 'Effect'] = SVG.invent({\r\n        create: function() {\r\n          //call super\r\n          this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n          //call constructor for this effect\r\n          effect.apply(this,arguments);\r\n\r\n          //set the result\r\n          this.result(this.attr('id') + 'Out');\r\n        },\r\n        inherit: SVG.Effect,\r\n        extend: proto\r\n      });\r\n    });\r\n\r\n    //create parent effects\r\n    foreach(parentEffects,function(effect,i){\r\n\r\n      /* capitalize name */\r\n      var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n      var proto = {};\r\n\r\n      /* create class */\r\n      SVG[name + 'Effect'] = SVG.invent({\r\n        create: function() {\r\n          //call super\r\n          this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n          //call constructor for this effect\r\n          effect.apply(this,arguments);\r\n\r\n          //set the result\r\n          this.result(this.attr('id') + 'Out');\r\n        },\r\n        inherit: SVG.ParentEffect,\r\n        extend: proto\r\n      });\r\n    });\r\n\r\n    //create child effects\r\n    foreach(childEffects,function(effect,i){\r\n\r\n      /* capitalize name */\r\n      var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n      var proto = {};\r\n\r\n      /* create class */\r\n      SVG[name] = SVG.invent({\r\n        create: function() {\r\n          //call super\r\n          this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n          //call constructor for this effect\r\n          effect.apply(this,arguments);\r\n        },\r\n        inherit: SVG.ChildEffect,\r\n        extend: proto\r\n      });\r\n    });\r\n\r\n    // Effect-specific extensions\r\n    SVG.extend(SVG.MergeEffect,{\r\n      in: function(effect){\r\n        if(effect instanceof SVG.MergeNode)\r\n          this.add(effect,0);\r\n        else\r\n          this.add(new SVG.MergeNode(effect),0);\r\n\r\n        return this\r\n      }\r\n    });\r\n    SVG.extend(SVG.CompositeEffect,SVG.BlendEffect,SVG.DisplacementMapEffect,{\r\n      in2: function(effect){\r\n          return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in2')+'\"]').get(0) || this.attr('in2') : this.attr('in2', effect)\r\n      }\r\n    });\r\n\r\n    // Presets\r\n    SVG.filter = {\r\n      sepiatone:  [ .343, .669, .119, 0, 0\r\n                  , .249, .626, .130, 0, 0\r\n                  , .172, .334, .111, 0, 0\r\n                  , .000, .000, .000, 1, 0 ]\r\n    };\r\n\r\n    // Helpers\r\n    function normaliseMatrix(matrix) {\r\n      /* convert possible array value to string */\r\n      if (Array.isArray(matrix))\r\n        matrix = new SVG.Array(matrix);\r\n\r\n      /* ensure there are no leading, tailing or double spaces */\r\n      return matrix.toString().replace(/^\\s+/, '').replace(/\\s+$/, '').replace(/\\s+/g, ' ')\r\n    }\r\n\r\n    function listString(list) {\r\n      if (!Array.isArray(list))\r\n        return list\r\n\r\n      for (var i = 0, l = list.length, s = []; i < l; i++)\r\n        s.push(list[i]);\r\n\r\n      return s.join(' ')\r\n    }\r\n\r\n    function foreach(){ //loops through mutiple objects\r\n      var fn = function(){};\r\n      if(typeof arguments[arguments.length-1] == 'function'){\r\n        fn = arguments[arguments.length-1];\r\n        Array.prototype.splice.call(arguments,arguments.length-1,1);\r\n      }\r\n      for(var k in arguments){\r\n        for(var i in arguments[k]){\r\n          fn(arguments[k][i],i,arguments[k]);\r\n        }\r\n      }\r\n    }\r\n\r\n  }).call(undefined);\n\n  (function() {\r\n\r\n  SVG.extend(SVG.PathArray, {\r\n    morph: function(array) {\r\n\r\n      var startArr = this.value\r\n        ,  destArr = this.parse(array);\r\n\r\n      var startOffsetM = 0\r\n        ,  destOffsetM = 0;\r\n\r\n      var startOffsetNextM = false\r\n        ,  destOffsetNextM = false;\r\n\r\n      while(true){\r\n        // stop if there is no M anymore\r\n        if(startOffsetM === false && destOffsetM === false) break\r\n\r\n        // find the next M in path array\r\n        startOffsetNextM = findNextM(startArr, startOffsetM === false ? false : startOffsetM+1);\r\n         destOffsetNextM = findNextM( destArr,  destOffsetM === false ? false :  destOffsetM+1);\r\n\r\n        // We have to add one M to the startArray\r\n        if(startOffsetM === false){\r\n          var bbox = new SVG.PathArray(result.start).bbox();\r\n\r\n          // when the last block had no bounding box we simply take the first M we got\r\n          if(bbox.height == 0 || bbox.width == 0){\r\n            startOffsetM =  startArr.push(startArr[0]) - 1;\r\n          }else {\r\n            // we take the middle of the bbox instead when we got one\r\n            startOffsetM = startArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;\r\n          }\r\n        }\r\n\r\n        // We have to add one M to the destArray\r\n        if( destOffsetM === false){\r\n          var bbox = new SVG.PathArray(result.dest).bbox();\r\n\r\n          if(bbox.height == 0 || bbox.width == 0){\r\n            destOffsetM =  destArr.push(destArr[0]) - 1;\r\n          }else {\r\n            destOffsetM =  destArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;\r\n          }\r\n        }\r\n\r\n        // handle block from M to next M\r\n        var result = handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM);\r\n\r\n        // update the arrays to their new values\r\n        startArr = startArr.slice(0, startOffsetM).concat(result.start, startOffsetNextM === false ? [] : startArr.slice(startOffsetNextM));\r\n         destArr =  destArr.slice(0,  destOffsetM).concat(result.dest ,  destOffsetNextM === false ? [] :  destArr.slice( destOffsetNextM));\r\n\r\n        // update offsets\r\n        startOffsetM = startOffsetNextM === false ? false : startOffsetM + result.start.length;\r\n         destOffsetM =  destOffsetNextM === false ? false :  destOffsetM + result.dest.length;\r\n\r\n      }\r\n\r\n      // copy back arrays\r\n      this.value = startArr;\r\n      this.destination = new SVG.PathArray();\r\n      this.destination.value = destArr;\r\n\r\n      return this\r\n    }\r\n  });\r\n\r\n\r\n\r\n  // sorry for the long declaration\r\n  // slices out one block (from M to M) and syncronize it so the types and length match\r\n  function handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM, undefined$1){\r\n\r\n    // slice out the block we need\r\n    var startArrTemp = startArr.slice(startOffsetM, startOffsetNextM || undefined$1)\r\n      ,  destArrTemp =  destArr.slice( destOffsetM,  destOffsetNextM || undefined$1);\r\n\r\n    var i = 0\r\n      , posStart = {pos:[0,0], start:[0,0]}\r\n      , posDest  = {pos:[0,0], start:[0,0]};\r\n\r\n    do{\r\n\r\n      // convert shorthand types to long form\r\n      startArrTemp[i] = simplyfy.call(posStart, startArrTemp[i]);\r\n       destArrTemp[i] = simplyfy.call(posDest ,  destArrTemp[i]);\r\n\r\n      // check if both shape types match\r\n      // 2 elliptical arc curve commands ('A'), are considered different if the\r\n      // flags (large-arc-flag, sweep-flag) don't match\r\n      if(startArrTemp[i][0] != destArrTemp[i][0] || startArrTemp[i][0] == 'M' ||\r\n          (startArrTemp[i][0] == 'A' &&\r\n            (startArrTemp[i][4] != destArrTemp[i][4] || startArrTemp[i][5] != destArrTemp[i][5])\r\n          )\r\n        ) {\r\n\r\n        // if not, convert shapes to beziere\r\n        Array.prototype.splice.apply(startArrTemp, [i, 1].concat(toBeziere.call(posStart, startArrTemp[i])));\r\n         Array.prototype.splice.apply(destArrTemp, [i, 1].concat(toBeziere.call(posDest, destArrTemp[i])));\r\n\r\n      } else {\r\n\r\n        // only update positions otherwise\r\n        startArrTemp[i] = setPosAndReflection.call(posStart, startArrTemp[i]);\r\n         destArrTemp[i] = setPosAndReflection.call(posDest ,  destArrTemp[i]);\r\n\r\n      }\r\n\r\n      // we are at the end at both arrays. stop here\r\n      if(++i == startArrTemp.length && i == destArrTemp.length) break\r\n\r\n      // destArray is longer. Add one element\r\n      if(i == startArrTemp.length){\r\n        startArrTemp.push([\r\n          'C',\r\n          posStart.pos[0],\r\n          posStart.pos[1],\r\n          posStart.pos[0],\r\n          posStart.pos[1],\r\n          posStart.pos[0],\r\n          posStart.pos[1],\r\n        ]);\r\n      }\r\n\r\n      // startArr is longer. Add one element\r\n      if(i == destArrTemp.length){\r\n        destArrTemp.push([\r\n          'C',\r\n          posDest.pos[0],\r\n          posDest.pos[1],\r\n          posDest.pos[0],\r\n          posDest.pos[1],\r\n          posDest.pos[0],\r\n          posDest.pos[1]\r\n        ]);\r\n      }\r\n\r\n\r\n    }while(true)\r\n\r\n    // return the updated block\r\n    return {start:startArrTemp, dest:destArrTemp}\r\n  }\r\n\r\n  // converts shorthand types to long form\r\n  function simplyfy(val){\r\n\r\n    switch(val[0]){\r\n      case 'z': // shorthand line to start\r\n      case 'Z':\r\n        val[0] = 'L';\r\n        val[1] = this.start[0];\r\n        val[2] = this.start[1];\r\n        break\r\n      case 'H': // shorthand horizontal line\r\n        val[0] = 'L';\r\n        val[2] = this.pos[1];\r\n        break\r\n      case 'V': // shorthand vertical line\r\n        val[0] = 'L';\r\n        val[2] = val[1];\r\n        val[1] = this.pos[0];\r\n        break\r\n      case 'T': // shorthand quadratic beziere\r\n        val[0] = 'Q';\r\n        val[3] = val[1];\r\n        val[4] = val[2];\r\n        val[1] = this.reflection[1];\r\n        val[2] = this.reflection[0];\r\n        break\r\n      case 'S': // shorthand cubic beziere\r\n        val[0] = 'C';\r\n        val[6] = val[4];\r\n        val[5] = val[3];\r\n        val[4] = val[2];\r\n        val[3] = val[1];\r\n        val[2] = this.reflection[1];\r\n        val[1] = this.reflection[0];\r\n        break\r\n    }\r\n\r\n    return val\r\n\r\n  }\r\n\r\n  // updates reflection point and current position\r\n  function setPosAndReflection(val){\r\n\r\n    var len = val.length;\r\n\r\n    this.pos = [ val[len-2], val[len-1] ];\r\n\r\n    if('SCQT'.indexOf(val[0]) != -1)\r\n      this.reflection = [ 2 * this.pos[0] - val[len-4], 2 * this.pos[1] - val[len-3] ];\r\n\r\n    return val\r\n  }\r\n\r\n  // converts all types to cubic beziere\r\n  function toBeziere(val){\r\n    var retVal = [val];\r\n\r\n    switch(val[0]){\r\n      case 'M': // special handling for M\r\n        this.pos = this.start = [val[1], val[2]];\r\n        return retVal\r\n      case 'L':\r\n        val[5] = val[3] = val[1];\r\n        val[6] = val[4] = val[2];\r\n        val[1] = this.pos[0];\r\n        val[2] = this.pos[1];\r\n        break\r\n      case 'Q':\r\n        val[6] = val[4];\r\n        val[5] = val[3];\r\n        val[4] = val[4] * 1/3 + val[2] * 2/3;\r\n        val[3] = val[3] * 1/3 + val[1] * 2/3;\r\n        val[2] = this.pos[1] * 1/3 + val[2] * 2/3;\r\n        val[1] = this.pos[0] * 1/3 + val[1] * 2/3;\r\n        break\r\n      case 'A':\r\n        retVal = arcToBeziere(this.pos, val);\r\n        val = retVal[0];\r\n        break\r\n    }\r\n\r\n    val[0] = 'C';\r\n    this.pos = [val[5], val[6]];\r\n    this.reflection = [2 * val[5] - val[3], 2 * val[6] - val[4]];\r\n\r\n    return retVal\r\n\r\n  }\r\n\r\n  // finds the next position of type M\r\n  function findNextM(arr, offset){\r\n\r\n    if(offset === false) return false\r\n\r\n    for(var i = offset, len = arr.length;i < len;++i){\r\n\r\n      if(arr[i][0] == 'M') return i\r\n\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n\r\n\r\n  // Convert an arc segment into equivalent cubic Bezier curves\r\n  // Depending on the arc, up to 4 curves might be used to represent it since a\r\n  // curve gives a good approximation for only a quarter of an ellipse\r\n  // The curves are returned as an array of SVG curve commands:\r\n  // [ ['C', x1, y1, x2, y2, x, y] ... ]\r\n  function arcToBeziere(pos, val) {\r\n      // Parameters extraction, handle out-of-range parameters as specified in the SVG spec\r\n      // See: https://www.w3.org/TR/SVG11/implnote.html#ArcOutOfRangeParameters\r\n      var rx = Math.abs(val[1]), ry = Math.abs(val[2]), xAxisRotation = val[3] % 360\r\n        , largeArcFlag = val[4], sweepFlag = val[5], x = val[6], y = val[7]\r\n        , A = new SVG.Point(pos), B = new SVG.Point(x, y)\r\n        , primedCoord, lambda, mat, k, c, cSquare, t, O, OA, OB, tetaStart, tetaEnd\r\n        , deltaTeta, nbSectors, f, arcSegPoints, angle, sinAngle, cosAngle, pt, i, il\r\n        , retVal = [], x1, y1, x2, y2;\r\n\r\n      // Ensure radii are non-zero\r\n      if(rx === 0 || ry === 0 || (A.x === B.x && A.y === B.y)) {\r\n        // treat this arc as a straight line segment\r\n        return [['C', A.x, A.y, B.x, B.y, B.x, B.y]]\r\n      }\r\n\r\n      // Ensure radii are large enough using the algorithm provided in the SVG spec\r\n      // See: https://www.w3.org/TR/SVG11/implnote.html#ArcCorrectionOutOfRangeRadii\r\n      primedCoord = new SVG.Point((A.x-B.x)/2, (A.y-B.y)/2).transform(new SVG.Matrix().rotate(xAxisRotation));\r\n      lambda = (primedCoord.x * primedCoord.x) / (rx * rx) + (primedCoord.y * primedCoord.y) / (ry * ry);\r\n      if(lambda > 1) {\r\n        lambda = Math.sqrt(lambda);\r\n        rx = lambda*rx;\r\n        ry = lambda*ry;\r\n      }\r\n\r\n      // To simplify calculations, we make the arc part of a unit circle (rayon is 1) instead of an ellipse\r\n      mat = new SVG.Matrix().rotate(xAxisRotation).scale(1/rx, 1/ry).rotate(-xAxisRotation);\r\n      A = A.transform(mat);\r\n      B = B.transform(mat);\r\n\r\n      // Calculate the horizontal and vertical distance between the initial and final point of the arc\r\n      k = [B.x-A.x, B.y-A.y];\r\n\r\n      // Find the length of the chord formed by A and B\r\n      cSquare = k[0]*k[0] + k[1]*k[1];\r\n      c = Math.sqrt(cSquare);\r\n\r\n      // Calculate the ratios of the horizontal and vertical distance on the length of the chord\r\n      k[0] /= c;\r\n      k[1] /= c;\r\n\r\n      // Calculate the distance between the circle center and the chord midpoint\r\n      // using this formula: t = sqrt(r^2 - c^2 / 4)\r\n      // where t is the distance between the cirle center and the chord midpoint,\r\n      //       r is the rayon of the circle and c is the chord length\r\n      // From: http://www.ajdesigner.com/phpcircle/circle_segment_chord_t.php\r\n      // Because of the imprecision of floating point numbers, cSquare might end\r\n      // up being slightly above 4 which would result in a negative radicand\r\n      // To prevent that, a test is made before computing the square root\r\n      t = (cSquare < 4) ? Math.sqrt(1 - cSquare/4) : 0;\r\n\r\n      // For most situations, there are actually two different ellipses that\r\n      // satisfy the constraints imposed by the points A and B, the radii rx and ry,\r\n      // and the xAxisRotation\r\n      // When the flags largeArcFlag and sweepFlag are equal, it means that the\r\n      // second ellipse is used as a solution\r\n      // See: https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\r\n      if(largeArcFlag === sweepFlag) {\r\n          t *= -1;\r\n      }\r\n\r\n      // Calculate the coordinates of the center of the circle from the midpoint of the chord\r\n      // This is done by multiplying the ratios calculated previously by the distance between\r\n      // the circle center and the chord midpoint and using these values to go from the midpoint\r\n      // to the center of the circle\r\n      // The negative of the vertical distance ratio is used to modify the x coordinate while\r\n      // the horizontal distance ratio is used to modify the y coordinate\r\n      // That is because the center of the circle is perpendicular to the chord and perpendicular\r\n      // lines are negative reciprocals\r\n      O = new SVG.Point((B.x+A.x)/2 + t*-k[1], (B.y+A.y)/2 + t*k[0]);\r\n      // Move the center of the circle at the origin\r\n      OA = new SVG.Point(A.x-O.x, A.y-O.y);\r\n      OB = new SVG.Point(B.x-O.x, B.y-O.y);\r\n\r\n      // Calculate the start and end angle\r\n      tetaStart = Math.acos(OA.x/Math.sqrt(OA.x*OA.x + OA.y*OA.y));\r\n      if (OA.y < 0) {\r\n        tetaStart *= -1;\r\n      }\r\n      tetaEnd = Math.acos(OB.x/Math.sqrt(OB.x*OB.x + OB.y*OB.y));\r\n      if (OB.y < 0) {\r\n        tetaEnd *= -1;\r\n      }\r\n\r\n      // If sweep-flag is '1', then the arc will be drawn in a \"positive-angle\" direction,\r\n      // make sure that the end angle is above the start angle\r\n      if (sweepFlag && tetaStart > tetaEnd) {\r\n        tetaEnd += 2*Math.PI;\r\n      }\r\n      // If sweep-flag is '0', then the arc will be drawn in a \"negative-angle\" direction,\r\n      // make sure that the end angle is below the start angle\r\n      if (!sweepFlag && tetaStart < tetaEnd) {\r\n        tetaEnd -= 2*Math.PI;\r\n      }\r\n\r\n      // Find the number of Bezier curves that are required to represent the arc\r\n      // A cubic Bezier curve gives a good enough approximation when representing at most a quarter of a circle\r\n      nbSectors = Math.ceil(Math.abs(tetaStart-tetaEnd) * 2/Math.PI);\r\n\r\n      // Calculate the coordinates of the points of all the Bezier curves required to represent the arc\r\n      // For an in-depth explanation of this part see: http://pomax.github.io/bezierinfo/#circles_cubic\r\n      arcSegPoints = [];\r\n      angle = tetaStart;\r\n      deltaTeta = (tetaEnd-tetaStart)/nbSectors;\r\n      f = 4*Math.tan(deltaTeta/4)/3;\r\n      for (i = 0; i <= nbSectors; i++) { // The <= is because a Bezier curve have a start and a endpoint\r\n        cosAngle = Math.cos(angle);\r\n        sinAngle = Math.sin(angle);\r\n\r\n        pt = new SVG.Point(O.x+cosAngle, O.y+sinAngle);\r\n        arcSegPoints[i] = [new SVG.Point(pt.x+f*sinAngle, pt.y-f*cosAngle), pt, new SVG.Point(pt.x-f*sinAngle, pt.y+f*cosAngle)];\r\n\r\n        angle += deltaTeta;\r\n      }\r\n\r\n      // Remove the first control point of the first segment point and remove the second control point of the last segment point\r\n      // These two control points are not used in the approximation of the arc, that is why they are removed\r\n      arcSegPoints[0][0] = arcSegPoints[0][1].clone();\r\n      arcSegPoints[arcSegPoints.length-1][2] = arcSegPoints[arcSegPoints.length-1][1].clone();\r\n\r\n      // Revert the transformation that was applied to make the arc part of a unit circle instead of an ellipse\r\n      mat = new SVG.Matrix().rotate(xAxisRotation).scale(rx, ry).rotate(-xAxisRotation);\r\n      for (i = 0, il = arcSegPoints.length; i < il; i++) {\r\n        arcSegPoints[i][0] = arcSegPoints[i][0].transform(mat);\r\n        arcSegPoints[i][1] = arcSegPoints[i][1].transform(mat);\r\n        arcSegPoints[i][2] = arcSegPoints[i][2].transform(mat);\r\n      }\r\n\r\n\r\n      // Convert the segments points to SVG curve commands\r\n      for (i = 1, il = arcSegPoints.length; i < il; i++) {\r\n        pt = arcSegPoints[i-1][2];\r\n        x1 = pt.x;\r\n        y1 = pt.y;\r\n\r\n        pt = arcSegPoints[i][0];\r\n        x2 = pt.x;\r\n        y2 = pt.y;\r\n\r\n        pt = arcSegPoints[i][1];\r\n        x = pt.x;\r\n        y = pt.y;\r\n\r\n        retVal.push(['C', x1, y1, x2, y2, x, y]);\r\n      }\r\n\r\n      return retVal\r\n  }\r\n  }());\n\n  /*! svg.draggable.js - v2.2.2 - 2019-01-08\r\n  * https://github.com/svgdotjs/svg.draggable.js\r\n  * Copyright (c) 2019 Wout Fierens; Licensed MIT */\r\n  (function() {\r\n\r\n    // creates handler, saves it\r\n    function DragHandler(el){\r\n      el.remember('_draggable', this);\r\n      this.el = el;\r\n    }\r\n\r\n\r\n    // Sets new parameter, starts dragging\r\n    DragHandler.prototype.init = function(constraint, val){\r\n      var _this = this;\r\n      this.constraint = constraint;\r\n      this.value = val;\r\n      this.el.on('mousedown.drag', function(e){ _this.start(e); });\r\n      this.el.on('touchstart.drag', function(e){ _this.start(e); });\r\n    };\r\n\r\n    // transforms one point from screen to user coords\r\n    DragHandler.prototype.transformPoint = function(event, offset){\r\n        event = event || window.event;\r\n        var touches = event.changedTouches && event.changedTouches[0] || event;\r\n        this.p.x = touches.clientX - (offset || 0);\r\n        this.p.y = touches.clientY;\r\n        return this.p.matrixTransform(this.m)\r\n    };\r\n\r\n    // gets elements bounding box with special handling of groups, nested and use\r\n    DragHandler.prototype.getBBox = function(){\r\n\r\n      var box = this.el.bbox();\r\n\r\n      if(this.el instanceof SVG.Nested) box = this.el.rbox();\r\n\r\n      if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {\r\n        box.x = this.el.x();\r\n        box.y = this.el.y();\r\n      }\r\n\r\n      return box\r\n    };\r\n\r\n    // start dragging\r\n    DragHandler.prototype.start = function(e){\r\n\r\n      // check for left button\r\n      if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){\r\n        if((e.which || e.buttons) != 1){\r\n            return\r\n        }\r\n      }\r\n\r\n      var _this = this;\r\n\r\n      // fire beforedrag event\r\n      this.el.fire('beforedrag', { event: e, handler: this });\r\n      if(this.el.event().defaultPrevented) return;\r\n\r\n      // prevent browser drag behavior as soon as possible\r\n      e.preventDefault();\r\n\r\n      // prevent propagation to a parent that might also have dragging enabled\r\n      e.stopPropagation();\r\n\r\n      // search for parent on the fly to make sure we can call\r\n      // draggable() even when element is not in the dom currently\r\n      this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc);\r\n      this.p = this.parent.node.createSVGPoint();\r\n\r\n      // save current transformation matrix\r\n      this.m = this.el.node.getScreenCTM().inverse();\r\n\r\n      var box = this.getBBox();\r\n\r\n      var anchorOffset;\r\n\r\n      // fix text-anchor in text-element (#37)\r\n      if(this.el instanceof SVG.Text){\r\n        anchorOffset = this.el.node.getComputedTextLength();\r\n\r\n        switch(this.el.attr('text-anchor')){\r\n          case 'middle':\r\n            anchorOffset /= 2;\r\n            break\r\n          case 'start':\r\n            anchorOffset = 0;\r\n            break;\r\n        }\r\n      }\r\n\r\n      this.startPoints = {\r\n        // We take absolute coordinates since we are just using a delta here\r\n        point: this.transformPoint(e, anchorOffset),\r\n        box:   box,\r\n        transform: this.el.transform()\r\n      };\r\n\r\n      // add drag and end events to window\r\n      SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e); });\r\n      SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e); });\r\n      SVG.on(window, 'mouseup.drag', function(e){ _this.end(e); });\r\n      SVG.on(window, 'touchend.drag', function(e){ _this.end(e); });\r\n\r\n      // fire dragstart event\r\n      this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this});\r\n    };\r\n\r\n    // while dragging\r\n    DragHandler.prototype.drag = function(e){\r\n\r\n      var box = this.getBBox()\r\n        , p   = this.transformPoint(e)\r\n        , x   = this.startPoints.box.x + p.x - this.startPoints.point.x\r\n        , y   = this.startPoints.box.y + p.y - this.startPoints.point.y\r\n        , c   = this.constraint\r\n        , gx  = p.x - this.startPoints.point.x\r\n        , gy  = p.y - this.startPoints.point.y;\r\n\r\n      this.el.fire('dragmove', {\r\n          event: e\r\n        , p: p\r\n        , m: this.m\r\n        , handler: this\r\n      });\r\n\r\n      if(this.el.event().defaultPrevented) return p\r\n\r\n      // move the element to its new position, if possible by constraint\r\n      if (typeof c == 'function') {\r\n\r\n        var coord = c.call(this.el, x, y, this.m);\r\n\r\n        // bool, just show us if movement is allowed or not\r\n        if (typeof coord == 'boolean') {\r\n          coord = {\r\n            x: coord,\r\n            y: coord\r\n          };\r\n        }\r\n\r\n        // if true, we just move. If !false its a number and we move it there\r\n        if (coord.x === true) {\r\n          this.el.x(x);\r\n        } else if (coord.x !== false) {\r\n          this.el.x(coord.x);\r\n        }\r\n\r\n        if (coord.y === true) {\r\n          this.el.y(y);\r\n        } else if (coord.y !== false) {\r\n          this.el.y(coord.y);\r\n        }\r\n\r\n      } else if (typeof c == 'object') {\r\n\r\n        // keep element within constrained box\r\n        if (c.minX != null && x < c.minX) {\r\n          x = c.minX;\r\n          gx = x - this.startPoints.box.x;\r\n        } else if (c.maxX != null && x > c.maxX - box.width) {\r\n          x = c.maxX - box.width;\r\n          gx = x - this.startPoints.box.x;\r\n        } if (c.minY != null && y < c.minY) {\r\n          y = c.minY;\r\n          gy = y - this.startPoints.box.y;\r\n        } else if (c.maxY != null && y > c.maxY - box.height) {\r\n          y = c.maxY - box.height;\r\n          gy = y - this.startPoints.box.y;\r\n        }\r\n\r\n        if (c.snapToGrid != null) {\r\n          x = x - (x % c.snapToGrid);\r\n          y = y - (y % c.snapToGrid);\r\n          gx = gx - (gx % c.snapToGrid);\r\n          gy = gy - (gy % c.snapToGrid);\r\n        }\r\n\r\n        if(this.el instanceof SVG.G)\r\n          this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true);\r\n        else\r\n          this.el.move(x, y);\r\n      }\r\n\r\n      // so we can use it in the end-method, too\r\n      return p\r\n    };\r\n\r\n    DragHandler.prototype.end = function(e){\r\n\r\n      // final drag\r\n      var p = this.drag(e);\r\n\r\n      // fire dragend event\r\n      this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this });\r\n\r\n      // unbind events\r\n      SVG.off(window, 'mousemove.drag');\r\n      SVG.off(window, 'touchmove.drag');\r\n      SVG.off(window, 'mouseup.drag');\r\n      SVG.off(window, 'touchend.drag');\r\n\r\n    };\r\n\r\n    SVG.extend(SVG.Element, {\r\n      // Make element draggable\r\n      // Constraint might be an object (as described in readme.md) or a function in the form \"function (x, y)\" that gets called before every move.\r\n      // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. \"False\" skips moving, true moves to raw x, y.\r\n      draggable: function(value, constraint) {\r\n\r\n        // Check the parameters and reassign if needed\r\n        if (typeof value == 'function' || typeof value == 'object') {\r\n          constraint = value;\r\n          value = true;\r\n        }\r\n\r\n        var dragHandler = this.remember('_draggable') || new DragHandler(this);\r\n\r\n        // When no parameter is given, value is true\r\n        value = typeof value === 'undefined' ? true : value;\r\n\r\n        if(value) dragHandler.init(constraint || {}, value);\r\n        else {\r\n          this.off('mousedown.drag');\r\n          this.off('touchstart.drag');\r\n        }\r\n\r\n        return this\r\n      }\r\n\r\n    });\r\n\r\n  }).call(undefined);\n\n  (function() {\n\n  function SelectHandler(el) {\r\n\r\n      this.el = el;\r\n      el.remember('_selectHandler', this);\r\n      this.pointSelection = {isSelected: false};\r\n      this.rectSelection = {isSelected: false};\r\n\r\n      // helper list with position settings of each type of point\r\n      this.pointsList = {\r\n        lt: [ 0, 0 ],\r\n        rt: [ 'width', 0 ],\r\n        rb: [ 'width', 'height' ],\r\n        lb: [ 0, 'height' ],\r\n        t: [ 'width', 0 ],\r\n        r: [ 'width', 'height' ],\r\n        b: [ 'width', 'height' ],\r\n        l: [ 0, 'height' ]\r\n      };\r\n\r\n      // helper function to get point coordinates based on settings above and an object (bbox in our case)\r\n      this.pointCoord = function (setting, object, isPointCentered) {\r\n        var coord = typeof setting !== 'string' ? setting : object[setting];\r\n        // Top, bottom, right and left points are placed in the center of element width/height\r\n        return isPointCentered ? coord / 2 : coord\r\n      };\r\n\r\n      this.pointCoords = function (point, object) {\r\n        var settings = this.pointsList[point];\r\n\r\n        return {\r\n          x: this.pointCoord(settings[0], object, (point === 't' || point === 'b')),\r\n          y: this.pointCoord(settings[1], object, (point === 'r' || point === 'l'))\r\n        }\r\n      };\r\n  }\r\n\r\n  SelectHandler.prototype.init = function (value, options) {\r\n\r\n      var bbox = this.el.bbox();\r\n      this.options = {};\r\n\r\n      // store defaults list of points in order to verify users config\r\n      var points = this.el.selectize.defaults.points;\r\n\r\n      // Merging the defaults and the options-object together\r\n      for (var i in this.el.selectize.defaults) {\r\n          this.options[i] = this.el.selectize.defaults[i];\r\n          if (options[i] !== undefined) {\r\n              this.options[i] = options[i];\r\n          }\r\n      }\r\n\r\n      // prepare & validate list of points to be added (or excluded)\r\n      var pointsLists = ['points', 'pointsExclude'];\r\n\r\n      for (var i in pointsLists) {\r\n        var option = this.options[pointsLists[i]];\r\n\r\n        if (typeof option === 'string') {\r\n          if (option.length > 0) {\r\n            // if set as comma separated string list => convert it into an array\r\n            option = option.split(/\\s*,\\s*/i);\r\n          } else {\r\n            option = [];\r\n          }\r\n        } else if (typeof option === 'boolean' && pointsLists[i] === 'points') {\r\n          // this is not needed, but let's have it for legacy support\r\n          option = option ? points : [];\r\n        }\r\n\r\n        this.options[pointsLists[i]] = option;\r\n      }\r\n\r\n      // intersect correct all points options with users config (exclude unwanted points)\r\n      // ES5 -> NO arrow functions nor Array.includes()\r\n      this.options.points = [ points, this.options.points ].reduce(\r\n        function (a, b) {\r\n          return a.filter(\r\n            function (c) {\r\n              return b.indexOf(c) > -1;\r\n            }\r\n          )\r\n        }\r\n      );\r\n\r\n      // exclude pointsExclude, if wanted\r\n      this.options.points = [ this.options.points, this.options.pointsExclude ].reduce(\r\n        function (a, b) {\r\n          return a.filter(\r\n            function (c) {\r\n              return b.indexOf(c) < 0;\r\n            }\r\n          )\r\n        }\r\n      );\r\n\r\n      this.parent = this.el.parent();\r\n      this.nested = (this.nested || this.parent.group());\r\n      this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));\r\n\r\n      // When deepSelect is enabled and the element is a line/polyline/polygon, draw only points for moving\r\n      if (this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1) {\r\n          this.selectPoints(value);\r\n      } else {\r\n          this.selectRect(value);\r\n      }\r\n\r\n      this.observe();\r\n      this.cleanup();\r\n\r\n  };\r\n\r\n  SelectHandler.prototype.selectPoints = function (value) {\r\n\r\n      this.pointSelection.isSelected = value;\r\n\r\n      // When set is already there we dont have to create one\r\n      if (this.pointSelection.set) {\r\n          return this;\r\n      }\r\n\r\n      // Create our set of elements\r\n      this.pointSelection.set = this.parent.set();\r\n      // draw the points and mark the element as selected\r\n      this.drawPoints();\r\n\r\n      return this;\r\n\r\n  };\r\n\r\n  // create the point-array which contains the 2 points of a line or simply the points-array of polyline/polygon\r\n  SelectHandler.prototype.getPointArray = function () {\r\n      var bbox = this.el.bbox();\r\n\r\n      return this.el.array().valueOf().map(function (el) {\r\n          return [el[0] - bbox.x, el[1] - bbox.y];\r\n      });\r\n  };\r\n\r\n  // Draws a points\r\n  SelectHandler.prototype.drawPoints = function () {\r\n\r\n      var _this = this, array = this.getPointArray();\r\n\r\n      // go through the array of points\r\n      for (var i = 0, len = array.length; i < len; ++i) {\r\n\r\n          var curriedEvent = (function (k) {\r\n              return function (ev) {\r\n                  ev = ev || window.event;\r\n                  ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n                  ev.stopPropagation();\r\n\r\n                  var x = ev.pageX || ev.touches[0].pageX;\r\n                  var y = ev.pageY || ev.touches[0].pageY;\r\n                  _this.el.fire('point', {x: x, y: y, i: k, event: ev});\r\n              };\r\n          })(i);\r\n\r\n          // add every point to the set\r\n          // add css-classes and a touchstart-event which fires our event for moving points\r\n          var point = this.drawPoint(array[i][0], array[i][1])\r\n                          .addClass(this.options.classPoints)\r\n                          .addClass(this.options.classPoints + '_point')\r\n                          .on('touchstart', curriedEvent)\r\n                          .on('mousedown', curriedEvent);\r\n          this.pointSelection.set.add(point);\r\n      }\r\n  };\r\n\r\n  // The function to draw single point\r\n  SelectHandler.prototype.drawPoint = function (cx, cy) {\r\n      var pointType = this.options.pointType;\r\n\r\n      switch (pointType) {\r\n          case 'circle':\r\n              return this.drawCircle(cx, cy);\r\n          case 'rect':\r\n              return this.drawRect(cx, cy);\r\n          default:\r\n              if (typeof pointType === 'function') {\r\n                  return pointType.call(this, cx, cy);\r\n              }\r\n\r\n              throw new Error('Unknown ' + pointType + ' point type!');\r\n      }\r\n  };\r\n\r\n  // The function to draw the circle point\r\n  SelectHandler.prototype.drawCircle = function (cx, cy) {\r\n      return this.nested.circle(this.options.pointSize)\r\n                        .center(cx, cy);\r\n  };\r\n\r\n  // The function to draw the rect point\r\n  SelectHandler.prototype.drawRect = function (cx, cy) {\r\n      return this.nested.rect(this.options.pointSize, this.options.pointSize)\r\n                        .center(cx, cy);\r\n  };\r\n\r\n  // every time a point is moved, we have to update the positions of our point\r\n  SelectHandler.prototype.updatePointSelection = function () {\r\n      var array = this.getPointArray();\r\n\r\n      this.pointSelection.set.each(function (i) {\r\n          if (this.cx() === array[i][0] && this.cy() === array[i][1]) {\r\n              return;\r\n          }\r\n          this.center(array[i][0], array[i][1]);\r\n      });\r\n  };\r\n\r\n  SelectHandler.prototype.updateRectSelection = function () {\r\n      var _this = this, bbox = this.el.bbox();\r\n\r\n      this.rectSelection.set.get(0).attr({\r\n          width: bbox.width,\r\n          height: bbox.height\r\n      });\r\n\r\n      // set.get(1) is always in the upper left corner. no need to move it\r\n      if (this.options.points.length) {\r\n        this.options.points.map(function (point, index) {\r\n          var coords = _this.pointCoords(point, bbox);\r\n\r\n          _this.rectSelection.set.get(index + 1).center(coords.x, coords.y);\r\n        });\r\n      }\r\n\r\n      if (this.options.rotationPoint) {\r\n          var length = this.rectSelection.set.length();\r\n\r\n          this.rectSelection.set.get(length - 1).center(bbox.width / 2, 20);\r\n      }\r\n  };\r\n\r\n  SelectHandler.prototype.selectRect = function (value) {\r\n\r\n      var _this = this, bbox = this.el.bbox();\r\n\r\n      this.rectSelection.isSelected = value;\r\n\r\n      // when set is already p\r\n      this.rectSelection.set = this.rectSelection.set || this.parent.set();\r\n\r\n      // helperFunction to create a mouse-down function which triggers the event specified in `eventName`\r\n      function getMoseDownFunc(eventName) {\r\n          return function (ev) {\r\n              ev = ev || window.event;\r\n              ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n              ev.stopPropagation();\r\n\r\n              var x = ev.pageX || ev.touches[0].pageX;\r\n              var y = ev.pageY || ev.touches[0].pageY;\r\n              _this.el.fire(eventName, {x: x, y: y, event: ev});\r\n          };\r\n      }\r\n\r\n      // create the selection-rectangle and add the css-class\r\n      if (!this.rectSelection.set.get(0)) {\r\n          this.rectSelection.set.add(this.nested.rect(bbox.width, bbox.height).addClass(this.options.classRect));\r\n      }\r\n\r\n      // Draw Points at the edges, if enabled\r\n      if (this.options.points.length && this.rectSelection.set.length() < 2) {\r\n          var ename =\"touchstart\", mname = \"mousedown\";\r\n\r\n          this.options.points.map(function (point, index) {\r\n              var coords = _this.pointCoords(point, bbox);\r\n\r\n              var pointElement = _this.drawPoint(coords.x, coords.y)\r\n                                      .attr('class', _this.options.classPoints + '_' + point)\r\n                                      .on(mname, getMoseDownFunc(point))\r\n                                      .on(ename, getMoseDownFunc(point));\r\n              _this.rectSelection.set.add(pointElement);\r\n          });\r\n\r\n          this.rectSelection.set.each(function () {\r\n              this.addClass(_this.options.classPoints);\r\n          });\r\n      }\r\n\r\n      // draw rotationPint, if enabled\r\n      if (this.options.rotationPoint && ((this.options.points && !this.rectSelection.set.get(9)) || (!this.options.points && !this.rectSelection.set.get(1)))) {\r\n\r\n          var curriedEvent = function (ev) {\r\n              ev = ev || window.event;\r\n              ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n              ev.stopPropagation();\r\n\r\n              var x = ev.pageX || ev.touches[0].pageX;\r\n              var y = ev.pageY || ev.touches[0].pageY;\r\n              _this.el.fire('rot', {x: x, y: y, event: ev});\r\n          };\r\n\r\n          var pointElement = this.drawPoint(bbox.width / 2, 20)\r\n                                .attr('class', this.options.classPoints + '_rot')\r\n                                .on(\"touchstart\", curriedEvent)\r\n                                .on(\"mousedown\", curriedEvent);\r\n          this.rectSelection.set.add(pointElement);\r\n      }\r\n\r\n  };\r\n\r\n  SelectHandler.prototype.handler = function () {\r\n\r\n      var bbox = this.el.bbox();\r\n      this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));\r\n\r\n      if (this.rectSelection.isSelected) {\r\n          this.updateRectSelection();\r\n      }\r\n\r\n      if (this.pointSelection.isSelected) {\r\n          this.updatePointSelection();\r\n      }\r\n\r\n  };\r\n\r\n  SelectHandler.prototype.observe = function () {\r\n      var _this = this;\r\n\r\n      if (MutationObserver) {\r\n          if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\r\n              this.observerInst = this.observerInst || new MutationObserver(function () {\r\n                  _this.handler();\r\n              });\r\n              this.observerInst.observe(this.el.node, {attributes: true});\r\n          } else {\r\n              try {\r\n                  this.observerInst.disconnect();\r\n                  delete this.observerInst;\r\n              } catch (e) {\r\n              }\r\n          }\r\n      } else {\r\n          this.el.off('DOMAttrModified.select');\r\n\r\n          if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\r\n              this.el.on('DOMAttrModified.select', function () {\r\n                  _this.handler();\r\n              });\r\n          }\r\n      }\r\n  };\r\n\r\n  SelectHandler.prototype.cleanup = function () {\r\n\r\n      //var _this = this;\r\n\r\n      if (!this.rectSelection.isSelected && this.rectSelection.set) {\r\n          // stop watching the element, remove the selection\r\n          this.rectSelection.set.each(function () {\r\n              this.remove();\r\n          });\r\n\r\n          this.rectSelection.set.clear();\r\n          delete this.rectSelection.set;\r\n      }\r\n\r\n      if (!this.pointSelection.isSelected && this.pointSelection.set) {\r\n          // Remove all points, clear the set, stop watching the element\r\n          this.pointSelection.set.each(function () {\r\n              this.remove();\r\n          });\r\n\r\n          this.pointSelection.set.clear();\r\n          delete this.pointSelection.set;\r\n      }\r\n\r\n      if (!this.pointSelection.isSelected && !this.rectSelection.isSelected) {\r\n          this.nested.remove();\r\n          delete this.nested;\r\n\r\n      }\r\n  };\r\n\r\n\r\n  SVG.extend(SVG.Element, {\r\n      // Select element with mouse\r\n      selectize: function (value, options) {\r\n\r\n          // Check the parameters and reassign if needed\r\n          if (typeof value === 'object') {\r\n              options = value;\r\n              value = true;\r\n          }\r\n\r\n          var selectHandler = this.remember('_selectHandler') || new SelectHandler(this);\r\n\r\n          selectHandler.init(value === undefined ? true : value, options || {});\r\n\r\n          return this;\r\n\r\n      }\r\n  });\r\n\r\n  SVG.Element.prototype.selectize.defaults = {\r\n      points: ['lt', 'rt', 'rb', 'lb', 't', 'r', 'b', 'l'],    // which points to draw, default all\r\n      pointsExclude: [],                       // easier option if to exclude few than rewrite all\r\n      classRect: 'svg_select_boundingRect',    // Css-class added to the rect\r\n      classPoints: 'svg_select_points',        // Css-class added to the points\r\n      pointSize: 7,                            // size of point\r\n      rotationPoint: true,                     // If true, rotation point is drawn. Needed for rotation!\r\n      deepSelect: false,                       // If true, moving of single points is possible (only line, polyline, polyon)\r\n      pointType: 'circle'                      // Point type: circle or rect, default circle\r\n  };\n  }());\n\n  (function() {\n  (function () {\r\n\r\n      function ResizeHandler(el) {\r\n\r\n          el.remember('_resizeHandler', this);\r\n\r\n          this.el = el;\r\n          this.parameters = {};\r\n          this.lastUpdateCall = null;\r\n          this.p = el.doc().node.createSVGPoint();\r\n      }\r\n\r\n      ResizeHandler.prototype.transformPoint = function(x, y, m){\r\n\r\n          this.p.x = x - (this.offset.x - window.pageXOffset);\r\n          this.p.y = y - (this.offset.y - window.pageYOffset);\r\n\r\n          return this.p.matrixTransform(m || this.m);\r\n\r\n      };\r\n\r\n      ResizeHandler.prototype._extractPosition = function(event) {\r\n          // Extract a position from a mouse/touch event.\r\n          // Returns { x: .., y: .. }\r\n          return {\r\n              x: event.clientX != null ? event.clientX : event.touches[0].clientX,\r\n              y: event.clientY != null ? event.clientY : event.touches[0].clientY\r\n          }\r\n      };\r\n\r\n      ResizeHandler.prototype.init = function (options) {\r\n\r\n          var _this = this;\r\n\r\n          this.stop();\r\n\r\n          if (options === 'stop') {\r\n              return;\r\n          }\r\n\r\n          this.options = {};\r\n\r\n          // Merge options and defaults\r\n          for (var i in this.el.resize.defaults) {\r\n              this.options[i] = this.el.resize.defaults[i];\r\n              if (typeof options[i] !== 'undefined') {\r\n                  this.options[i] = options[i];\r\n              }\r\n          }\r\n\r\n          // We listen to all these events which are specifying different edges\r\n          this.el.on('lt.resize', function(e){ _this.resize(e || window.event); });  // Left-Top\r\n          this.el.on('rt.resize', function(e){ _this.resize(e || window.event); });  // Right-Top\r\n          this.el.on('rb.resize', function(e){ _this.resize(e || window.event); });  // Right-Bottom\r\n          this.el.on('lb.resize', function(e){ _this.resize(e || window.event); });  // Left-Bottom\r\n\r\n          this.el.on('t.resize', function(e){ _this.resize(e || window.event); });   // Top\r\n          this.el.on('r.resize', function(e){ _this.resize(e || window.event); });   // Right\r\n          this.el.on('b.resize', function(e){ _this.resize(e || window.event); });   // Bottom\r\n          this.el.on('l.resize', function(e){ _this.resize(e || window.event); });   // Left\r\n\r\n          this.el.on('rot.resize', function(e){ _this.resize(e || window.event); }); // Rotation\r\n\r\n          this.el.on('point.resize', function(e){ _this.resize(e || window.event); }); // Point-Moving\r\n\r\n          // This call ensures, that the plugin reacts to a change of snapToGrid immediately\r\n          this.update();\r\n\r\n      };\r\n\r\n      ResizeHandler.prototype.stop = function(){\r\n          this.el.off('lt.resize');\r\n          this.el.off('rt.resize');\r\n          this.el.off('rb.resize');\r\n          this.el.off('lb.resize');\r\n\r\n          this.el.off('t.resize');\r\n          this.el.off('r.resize');\r\n          this.el.off('b.resize');\r\n          this.el.off('l.resize');\r\n\r\n          this.el.off('rot.resize');\r\n\r\n          this.el.off('point.resize');\r\n\r\n          return this;\r\n      };\r\n\r\n      ResizeHandler.prototype.resize = function (event) {\r\n\r\n          var _this = this;\r\n\r\n          this.m = this.el.node.getScreenCTM().inverse();\r\n          this.offset = { x: window.pageXOffset, y: window.pageYOffset };\r\n\r\n          var txPt = this._extractPosition(event.detail.event);\r\n          this.parameters = {\r\n              type: this.el.type, // the type of element\r\n              p: this.transformPoint(txPt.x, txPt.y),\r\n              x: event.detail.x,      // x-position of the mouse when resizing started\r\n              y: event.detail.y,      // y-position of the mouse when resizing started\r\n              box: this.el.bbox(),    // The bounding-box of the element\r\n              rotation: this.el.transform().rotation  // The current rotation of the element\r\n          };\r\n\r\n          // Add font-size parameter if the element type is text\r\n          if (this.el.type === \"text\") {\r\n              this.parameters.fontSize = this.el.attr()[\"font-size\"];\r\n          }\r\n\r\n          // the i-param in the event holds the index of the point which is moved, when using `deepSelect`\r\n          if (event.detail.i !== undefined) {\r\n\r\n              // get the point array\r\n              var array = this.el.array().valueOf();\r\n\r\n              // Save the index and the point which is moved\r\n              this.parameters.i = event.detail.i;\r\n              this.parameters.pointCoords = [array[event.detail.i][0], array[event.detail.i][1]];\r\n          }\r\n\r\n          // Lets check which edge of the bounding-box was clicked and resize the this.el according to this\r\n          switch (event.type) {\r\n\r\n              // Left-Top-Edge\r\n              case 'lt':\r\n                  // We build a calculating function for every case which gives us the new position of the this.el\r\n                  this.calc = function (diffX, diffY) {\r\n                      // The procedure is always the same\r\n                      // First we snap the edge to the given grid (snapping to 1px grid is normal resizing)\r\n                      var snap = this.snapToGrid(diffX, diffY);\r\n\r\n                      // Now we check if the new height and width still valid (> 0)\r\n                      if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {\r\n                          // ...if valid, we resize the this.el (which can include moving because the coord-system starts at the left-top and this edge is moving sometimes when resized)\r\n\r\n                          /*\r\n                           * but first check if the element is text box, so we can change the font size instead of\r\n                           * the width and height\r\n                           */\r\n\r\n                          if (this.parameters.type === \"text\") {\r\n                              this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\r\n                              this.el.attr(\"font-size\", this.parameters.fontSize - snap[0]);\r\n                              return;\r\n                          }\r\n\r\n                          snap = this.checkAspectRatio(snap);\r\n\r\n                          this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y + snap[1]).size(this.parameters.box.width - snap[0], this.parameters.box.height - snap[1]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Right-Top\r\n              case 'rt':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n                      var snap = this.snapToGrid(diffX, diffY, 1 << 1);\r\n                      if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {\r\n                          if (this.parameters.type === \"text\") {\r\n                              this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);\r\n                              this.el.attr(\"font-size\", this.parameters.fontSize + snap[0]);\r\n                              return;\r\n                          }\r\n\r\n                          snap = this.checkAspectRatio(snap, true);\r\n\r\n                          this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).size(this.parameters.box.width + snap[0], this.parameters.box.height - snap[1]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Right-Bottom\r\n              case 'rb':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n                      var snap = this.snapToGrid(diffX, diffY, 0);\r\n                      if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {\r\n                          if (this.parameters.type === \"text\") {\r\n                              this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);\r\n                              this.el.attr(\"font-size\", this.parameters.fontSize + snap[0]);\r\n                              return;\r\n                          }\r\n\r\n                          snap = this.checkAspectRatio(snap);\r\n\r\n                          this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + snap[0], this.parameters.box.height + snap[1]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Left-Bottom\r\n              case 'lb':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n                      var snap = this.snapToGrid(diffX, diffY, 1);\r\n                      if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {\r\n                          if (this.parameters.type === \"text\") {\r\n                              this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\r\n                              this.el.attr(\"font-size\", this.parameters.fontSize - snap[0]);\r\n                              return;\r\n                          }\r\n\r\n                          snap = this.checkAspectRatio(snap, true);\r\n\r\n                          this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).size(this.parameters.box.width - snap[0], this.parameters.box.height + snap[1]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Top\r\n              case 't':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n                      var snap = this.snapToGrid(diffX, diffY, 1 << 1);\r\n                      if (this.parameters.box.height - snap[1] > 0) {\r\n                          // Disable the font-resizing if it is not from the corner of bounding-box\r\n                          if (this.parameters.type === \"text\") {\r\n                              return;\r\n                          }\r\n\r\n                          this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).height(this.parameters.box.height - snap[1]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Right\r\n              case 'r':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n                      var snap = this.snapToGrid(diffX, diffY, 0);\r\n                      if (this.parameters.box.width + snap[0] > 0) {\r\n                          if (this.parameters.type === \"text\") {\r\n                              return;\r\n                          }\r\n\r\n                          this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + snap[0]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Bottom\r\n              case 'b':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n                      var snap = this.snapToGrid(diffX, diffY, 0);\r\n                      if (this.parameters.box.height + snap[1] > 0) {\r\n                          if (this.parameters.type === \"text\") {\r\n                              return;\r\n                          }\r\n\r\n                          this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + snap[1]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Left\r\n              case 'l':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n                      var snap = this.snapToGrid(diffX, diffY, 1);\r\n                      if (this.parameters.box.width - snap[0] > 0) {\r\n                          if (this.parameters.type === \"text\") {\r\n                              return;\r\n                          }\r\n\r\n                          this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).width(this.parameters.box.width - snap[0]);\r\n                      }\r\n                  };\r\n                  break;\r\n\r\n              // Rotation\r\n              case 'rot':\r\n                  // s.a.\r\n                  this.calc = function (diffX, diffY) {\r\n\r\n                      // yes this is kinda stupid but we need the mouse coords back...\r\n                      var current = {x: diffX + this.parameters.p.x, y: diffY + this.parameters.p.y};\r\n\r\n                      // start minus middle\r\n                      var sAngle = Math.atan2((this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2), (this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2));\r\n\r\n                      // end minus middle\r\n                      var pAngle = Math.atan2((current.y - this.parameters.box.y - this.parameters.box.height / 2), (current.x - this.parameters.box.x - this.parameters.box.width / 2));\r\n\r\n                      var angle = this.parameters.rotation + (pAngle - sAngle) * 180 / Math.PI + this.options.snapToAngle / 2;\r\n\r\n                      // We have to move the element to the center of the box first and change the rotation afterwards\r\n                      // because rotation always works around a rotation-center, which is changed when moving the element\r\n                      // We also set the new rotation center to the center of the box.\r\n                      this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(angle - (angle % this.options.snapToAngle), this.parameters.box.cx, this.parameters.box.cy);\r\n                  };\r\n                  break;\r\n\r\n              // Moving one single Point (needed when an element is deepSelected which means you can move every single point of the object)\r\n              case 'point':\r\n                  this.calc = function (diffX, diffY) {\r\n\r\n                      // Snapping the point to the grid\r\n                      var snap = this.snapToGrid(diffX, diffY, this.parameters.pointCoords[0], this.parameters.pointCoords[1]);\r\n\r\n                      // Get the point array\r\n                      var array = this.el.array().valueOf();\r\n\r\n                      // Changing the moved point in the array\r\n                      array[this.parameters.i][0] = this.parameters.pointCoords[0] + snap[0];\r\n                      array[this.parameters.i][1] = this.parameters.pointCoords[1] + snap[1];\r\n\r\n                      // And plot the new this.el\r\n                      this.el.plot(array);\r\n                  };\r\n          }\r\n\r\n          this.el.fire('resizestart', {dx: this.parameters.x, dy: this.parameters.y, event: event});\r\n          // When resizing started, we have to register events for...\r\n          // Touches.\r\n          SVG.on(window, 'touchmove.resize', function(e) {\r\n              _this.update(e || window.event);\r\n          });\r\n          SVG.on(window, 'touchend.resize', function() {\r\n              _this.done();\r\n          });\r\n          // Mouse.\r\n          SVG.on(window, 'mousemove.resize', function (e) {\r\n              _this.update(e || window.event);\r\n          });\r\n          SVG.on(window, 'mouseup.resize', function () {\r\n              _this.done();\r\n          });\r\n\r\n      };\r\n\r\n      // The update-function redraws the element every time the mouse is moving\r\n      ResizeHandler.prototype.update = function (event) {\r\n\r\n          if (!event) {\r\n              if (this.lastUpdateCall) {\r\n                  this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);\r\n              }\r\n              return;\r\n          }\r\n\r\n          // Calculate the difference between the mouseposition at start and now\r\n          var txPt = this._extractPosition(event);\r\n          var p = this.transformPoint(txPt.x, txPt.y);\r\n\r\n          var diffX = p.x - this.parameters.p.x,\r\n              diffY = p.y - this.parameters.p.y;\r\n\r\n          this.lastUpdateCall = [diffX, diffY];\r\n\r\n          // Calculate the new position and height / width of the element\r\n          this.calc(diffX, diffY);\r\n\r\n         // Emit an event to say we have changed.\r\n          this.el.fire('resizing', {dx: diffX, dy: diffY, event: event});\r\n      };\r\n\r\n      // Is called on mouseup.\r\n      // Removes the update-function from the mousemove event\r\n      ResizeHandler.prototype.done = function () {\r\n          this.lastUpdateCall = null;\r\n          SVG.off(window, 'mousemove.resize');\r\n          SVG.off(window, 'mouseup.resize');\r\n          SVG.off(window, 'touchmove.resize');\r\n          SVG.off(window, 'touchend.resize');\r\n          this.el.fire('resizedone');\r\n      };\r\n\r\n      // The flag is used to determine whether the resizing is used with a left-Point (first bit) and top-point (second bit)\r\n      // In this cases the temp-values are calculated differently\r\n      ResizeHandler.prototype.snapToGrid = function (diffX, diffY, flag, pointCoordsY) {\r\n\r\n          var temp;\r\n\r\n          // If `pointCoordsY` is given, a single Point has to be snapped (deepSelect). That's why we need a different temp-value\r\n          if (typeof pointCoordsY !== 'undefined') {\r\n              // Note that flag = pointCoordsX in this case\r\n              temp = [(flag + diffX) % this.options.snapToGrid, (pointCoordsY + diffY) % this.options.snapToGrid];\r\n          } else {\r\n              // We check if the flag is set and if not we set a default-value (both bits set - which means upper-left-edge)\r\n              flag = flag == null ? 1 | 1 << 1 : flag;\r\n              temp = [(this.parameters.box.x + diffX + (flag & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + diffY + (flag & (1 << 1) ? 0 : this.parameters.box.height)) % this.options.snapToGrid];\r\n          }\r\n\r\n          if(diffX < 0) {\r\n              temp[0] -= this.options.snapToGrid;\r\n          }\r\n          if(diffY < 0) {\r\n              temp[1] -= this.options.snapToGrid;\r\n          }\r\n\r\n          diffX -= (Math.abs(temp[0]) < this.options.snapToGrid / 2 ?\r\n                    temp[0] :\r\n                    temp[0] - (diffX < 0 ? -this.options.snapToGrid : this.options.snapToGrid));\r\n          diffY -= (Math.abs(temp[1]) < this.options.snapToGrid / 2 ?\r\n                    temp[1] :\r\n                    temp[1] - (diffY < 0 ? -this.options.snapToGrid : this.options.snapToGrid));\r\n\r\n          return this.constraintToBox(diffX, diffY, flag, pointCoordsY);\r\n\r\n      };\r\n\r\n      // keep element within constrained box\r\n      ResizeHandler.prototype.constraintToBox = function (diffX, diffY, flag, pointCoordsY) {\r\n          //return [diffX, diffY]\r\n          var c = this.options.constraint || {};\r\n          var orgX, orgY;\r\n\r\n          if (typeof pointCoordsY !== 'undefined') {\r\n            orgX = flag;\r\n            orgY = pointCoordsY;\r\n          } else {\r\n            orgX = this.parameters.box.x + (flag & 1 ? 0 : this.parameters.box.width);\r\n            orgY = this.parameters.box.y + (flag & (1<<1) ? 0 : this.parameters.box.height);\r\n          }\r\n\r\n          if (typeof c.minX !== 'undefined' && orgX + diffX < c.minX) {\r\n            diffX = c.minX - orgX;\r\n          }\r\n\r\n          if (typeof c.maxX !== 'undefined' && orgX + diffX > c.maxX) {\r\n            diffX = c.maxX - orgX;\r\n          }\r\n\r\n          if (typeof c.minY !== 'undefined' && orgY + diffY < c.minY) {\r\n            diffY = c.minY - orgY;\r\n          }\r\n\r\n          if (typeof c.maxY !== 'undefined' && orgY + diffY > c.maxY) {\r\n            diffY = c.maxY - orgY;\r\n          }\r\n\r\n          return [diffX, diffY];\r\n      };\r\n\r\n      ResizeHandler.prototype.checkAspectRatio = function (snap, isReverse) {\r\n          if (!this.options.saveAspectRatio) {\r\n              return snap;\r\n          }\r\n\r\n          var updatedSnap = snap.slice();\r\n          var aspectRatio = this.parameters.box.width / this.parameters.box.height;\r\n          var newW = this.parameters.box.width + snap[0];\r\n          var newH = this.parameters.box.height - snap[1];\r\n          var newAspectRatio = newW / newH;\r\n\r\n          if (newAspectRatio < aspectRatio) {\r\n              // Height is too big. Adapt it\r\n              updatedSnap[1] = newW / aspectRatio - this.parameters.box.height;\r\n              isReverse && (updatedSnap[1] = -updatedSnap[1]);\r\n          } else if (newAspectRatio > aspectRatio) {\r\n              // Width is too big. Adapt it\r\n              updatedSnap[0] = this.parameters.box.width - newH * aspectRatio;\r\n              isReverse && (updatedSnap[0] = -updatedSnap[0]);\r\n          }\r\n\r\n          return updatedSnap;\r\n      };\r\n\r\n      SVG.extend(SVG.Element, {\r\n          // Resize element with mouse\r\n          resize: function (options) {\r\n\r\n              (this.remember('_resizeHandler') || new ResizeHandler(this)).init(options || {});\r\n\r\n              return this;\r\n\r\n          }\r\n\r\n      });\r\n\r\n      SVG.Element.prototype.resize.defaults = {\r\n          snapToAngle: 0.1,       // Specifies the speed the rotation is happening when moving the mouse\r\n          snapToGrid: 1,          // Snaps to a grid of `snapToGrid` Pixels\r\n          constraint: {},         // keep element within constrained box\r\n          saveAspectRatio: false  // Save aspect ratio when resizing using lt, rt, rb or lb points\r\n      };\r\n\r\n  }).call(this);\n  }());\n\n  if (typeof window.Apex === 'undefined') {\n    window.Apex = {};\n  }\n\n  var InitCtxVariables = /*#__PURE__*/function () {\n    function InitCtxVariables(ctx) {\n      _classCallCheck(this, InitCtxVariables);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(InitCtxVariables, [{\n      key: \"initModules\",\n      value: function initModules() {\n        this.ctx.publicMethods = ['updateOptions', 'updateSeries', 'appendData', 'replaceData' , 'appendSeries', 'isSeriesHidden', 'toggleSeries', 'showSeries', 'hideSeries', 'setLocale', 'resetSeries', 'zoomX', 'toggleDataPointSelection', 'dataURI', 'exportToCSV', 'addXaxisAnnotation', 'addYaxisAnnotation', 'addPointAnnotation', 'clearAnnotations', 'removeAnnotation', 'paper', 'destroy'];\n        this.ctx.eventList = ['click', 'mousedown', 'mousemove', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'mouseup', 'touchend'];\n        this.ctx.animations = new Animations(this.ctx);\n        this.ctx.axes = new Axes(this.ctx);\n        this.ctx.core = new Core(this.ctx.el, this.ctx);\n        this.ctx.config = new Config({});\n        this.ctx.data = new Data(this.ctx);\n        this.ctx.grid = new Grid(this.ctx);\n        this.ctx.graphics = new Graphics(this.ctx);\n        this.ctx.coreUtils = new CoreUtils(this.ctx);\n        this.ctx.crosshairs = new Crosshairs(this.ctx);\n        this.ctx.events = new Events(this.ctx);\n        this.ctx.exports = new Exports(this.ctx);\n        this.ctx.localization = new Localization(this.ctx);\n        this.ctx.options = new Options();\n        this.ctx.responsive = new Responsive(this.ctx);\n        this.ctx.series = new Series(this.ctx);\n        this.ctx.theme = new Theme(this.ctx);\n        this.ctx.formatters = new Formatters(this.ctx);\n        this.ctx.titleSubtitle = new TitleSubtitle(this.ctx);\n        this.ctx.legend = new Legend(this.ctx);\n        this.ctx.toolbar = new Toolbar(this.ctx);\n        this.ctx.tooltip = new Tooltip(this.ctx);\n        this.ctx.dimensions = new Dimensions(this.ctx);\n        this.ctx.updateHelpers = new UpdateHelpers(this.ctx);\n        this.ctx.zoomPanSelection = new ZoomPanSelection(this.ctx);\n        this.ctx.w.globals.tooltip = new Tooltip(this.ctx);\n      }\n    }]);\n\n    return InitCtxVariables;\n  }();\n\n  var Destroy = /*#__PURE__*/function () {\n    function Destroy(ctx) {\n      _classCallCheck(this, Destroy);\n\n      this.ctx = ctx;\n      this.w = ctx.w;\n    }\n\n    _createClass(Destroy, [{\n      key: \"clear\",\n      value: function clear(_ref) {\n        var isUpdating = _ref.isUpdating;\n\n        if (this.ctx.zoomPanSelection) {\n          this.ctx.zoomPanSelection.destroy();\n        }\n\n        if (this.ctx.toolbar) {\n          this.ctx.toolbar.destroy();\n        }\n\n        this.ctx.animations = null;\n        this.ctx.axes = null;\n        this.ctx.annotations = null;\n        this.ctx.core = null;\n        this.ctx.data = null;\n        this.ctx.grid = null;\n        this.ctx.series = null;\n        this.ctx.responsive = null;\n        this.ctx.theme = null;\n        this.ctx.formatters = null;\n        this.ctx.titleSubtitle = null;\n        this.ctx.legend = null;\n        this.ctx.dimensions = null;\n        this.ctx.options = null;\n        this.ctx.crosshairs = null;\n        this.ctx.zoomPanSelection = null;\n        this.ctx.updateHelpers = null;\n        this.ctx.toolbar = null;\n        this.ctx.localization = null;\n        this.ctx.w.globals.tooltip = null;\n        this.clearDomElements({\n          isUpdating: isUpdating\n        });\n      }\n    }, {\n      key: \"killSVG\",\n      value: function killSVG(draw) {\n        draw.each(function (i, children) {\n          this.removeClass('*');\n          this.off();\n          this.stop();\n        }, true);\n        draw.ungroup();\n        draw.clear();\n      }\n    }, {\n      key: \"clearDomElements\",\n      value: function clearDomElements(_ref2) {\n        var _this = this;\n\n        var isUpdating = _ref2.isUpdating;\n        var elSVG = this.w.globals.dom.Paper.node; // fixes apexcharts.js#1654 & vue-apexcharts#256\n\n        if (elSVG.parentNode && elSVG.parentNode.parentNode && !isUpdating) {\n          elSVG.parentNode.parentNode.style.minHeight = 'unset';\n        } // detach root event\n\n\n        var baseEl = this.w.globals.dom.baseEl;\n\n        if (baseEl) {\n          // see https://github.com/apexcharts/vue-apexcharts/issues/275\n          this.ctx.eventList.forEach(function (event) {\n            baseEl.removeEventListener(event, _this.ctx.events.documentEvent);\n          });\n        }\n\n        var domEls = this.w.globals.dom;\n\n        if (this.ctx.el !== null) {\n          // remove all child elements - resetting the whole chart\n          while (this.ctx.el.firstChild) {\n            this.ctx.el.removeChild(this.ctx.el.firstChild);\n          }\n        }\n\n        this.killSVG(domEls.Paper);\n        domEls.Paper.remove();\n        domEls.elWrap = null;\n        domEls.elGraphical = null;\n        domEls.elLegendWrap = null;\n        domEls.elLegendForeign = null;\n        domEls.baseEl = null;\n        domEls.elGridRect = null;\n        domEls.elGridRectMask = null;\n        domEls.elGridRectMarkerMask = null;\n        domEls.elForecastMask = null;\n        domEls.elNonForecastMask = null;\n        domEls.elDefs = null;\n      }\n    }]);\n\n    return Destroy;\n  }();\n\n  // Helpers to react to element resizes, regardless of what caused them\n  // TODO Currently this creates a new ResizeObserver every time we want to observe an element for resizes\n  // Ideally, we should be able to use a single observer for all elements\n  var ros = new WeakMap(); // Map callbacks to ResizeObserver instances for easy removal\n\n  function addResizeListener(el, fn) {\n    var called = false;\n\n    if (el.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n      var elRect = el.getBoundingClientRect();\n\n      if (el.style.display === 'none' || elRect.width === 0) {\n        // if elRect.width=0, the chart is not rendered at all\n        // (it has either display none or hidden in a different tab)\n        // fixes https://github.com/apexcharts/apexcharts.js/issues/2825\n        // fixes https://github.com/apexcharts/apexcharts.js/issues/2991\n        // fixes https://github.com/apexcharts/apexcharts.js/issues/2992\n        called = true;\n      }\n    }\n\n    var ro = new ResizeObserver(function (r) {\n      // ROs fire immediately after being created,\n      // per spec: https://drafts.csswg.org/resize-observer/#ref-for-element%E2%91%A3\n      // we don't want that so we just discard the first run\n      if (called) {\n        fn.call(el, r);\n      }\n\n      called = true;\n    });\n\n    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      // Document fragment, observe children instead (needed for Shadow DOM, see #1332)\n      Array.from(el.children).forEach(function (c) {\n        return ro.observe(c);\n      });\n    } else {\n      ro.observe(el);\n    }\n\n    ros.set(fn, ro);\n  }\n  function removeResizeListener(el, fn) {\n    var ro = ros.get(fn);\n\n    if (ro) {\n      ro.disconnect();\n      ros.delete(fn);\n    }\n  }\n\n  var css_248z = \"@keyframes opaque {\\n  0% {\\n      opacity: 0\\n  }\\n\\n  to {\\n      opacity: 1\\n  }\\n}\\n\\n@keyframes resizeanim {\\n  0%,to {\\n      opacity: 0\\n  }\\n}\\n\\n.apexcharts-canvas {\\n  position: relative;\\n  user-select: none\\n}\\n\\n.apexcharts-canvas ::-webkit-scrollbar {\\n  -webkit-appearance: none;\\n  width: 6px\\n}\\n\\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\\n  border-radius: 4px;\\n  background-color: rgba(0,0,0,.5);\\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\\n}\\n\\n.apexcharts-inner {\\n  position: relative\\n}\\n\\n.apexcharts-text tspan {\\n  font-family: inherit\\n}\\n\\n.legend-mouseover-inactive {\\n  transition: .15s ease all;\\n  opacity: .2\\n}\\n\\n.apexcharts-legend-text {\\n  padding-left: 15px;\\n  margin-left: -15px;\\n}\\n\\n.apexcharts-series-collapsed {\\n  opacity: 0\\n}\\n\\n.apexcharts-tooltip {\\n  border-radius: 5px;\\n  box-shadow: 2px 2px 6px -4px #999;\\n  cursor: default;\\n  font-size: 14px;\\n  left: 62px;\\n  opacity: 0;\\n  pointer-events: none;\\n  position: absolute;\\n  top: 20px;\\n  display: flex;\\n  flex-direction: column;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  z-index: 12;\\n  transition: .15s ease all\\n}\\n\\n.apexcharts-tooltip.apexcharts-active {\\n  opacity: 1;\\n  transition: .15s ease all\\n}\\n\\n.apexcharts-tooltip.apexcharts-theme-light {\\n  border: 1px solid #e3e3e3;\\n  background: rgba(255,255,255,.96)\\n}\\n\\n.apexcharts-tooltip.apexcharts-theme-dark {\\n  color: #fff;\\n  background: rgba(30,30,30,.8)\\n}\\n\\n.apexcharts-tooltip * {\\n  font-family: inherit\\n}\\n\\n.apexcharts-tooltip-title {\\n  padding: 6px;\\n  font-size: 15px;\\n  margin-bottom: 4px\\n}\\n\\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\\n  background: #eceff1;\\n  border-bottom: 1px solid #ddd\\n}\\n\\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\\n  background: rgba(0,0,0,.7);\\n  border-bottom: 1px solid #333\\n}\\n\\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\\n  display: inline-block;\\n  margin-left: 5px;\\n  font-weight: 600\\n}\\n\\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\\n  display: none\\n}\\n\\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\\n  padding: 6px 0 5px\\n}\\n\\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\\n  display: flex\\n}\\n\\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\\n  margin-top: -6px\\n}\\n\\n.apexcharts-tooltip-marker {\\n  width: 12px;\\n  height: 12px;\\n  position: relative;\\n  top: 0;\\n  margin-right: 10px;\\n  border-radius: 50%\\n}\\n\\n.apexcharts-tooltip-series-group {\\n  padding: 0 10px;\\n  display: none;\\n  text-align: left;\\n  justify-content: left;\\n  align-items: center\\n}\\n\\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\\n  opacity: 1\\n}\\n\\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\\n  padding-bottom: 4px\\n}\\n\\n.apexcharts-tooltip-series-group-hidden {\\n  opacity: 0;\\n  height: 0;\\n  line-height: 0;\\n  padding: 0!important\\n}\\n\\n.apexcharts-tooltip-y-group {\\n  padding: 6px 0 5px\\n}\\n\\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\\n  padding: 4px 8px\\n}\\n\\n.apexcharts-tooltip-boxPlot {\\n  display: flex;\\n  flex-direction: column-reverse\\n}\\n\\n.apexcharts-tooltip-box>div {\\n  margin: 4px 0\\n}\\n\\n.apexcharts-tooltip-box span.value {\\n  font-weight: 700\\n}\\n\\n.apexcharts-tooltip-rangebar {\\n  padding: 5px 8px\\n}\\n\\n.apexcharts-tooltip-rangebar .category {\\n  font-weight: 600;\\n  color: #777\\n}\\n\\n.apexcharts-tooltip-rangebar .series-name {\\n  font-weight: 700;\\n  display: block;\\n  margin-bottom: 5px\\n}\\n\\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\\n  opacity: 0;\\n  pointer-events: none;\\n  color: #373d3f;\\n  font-size: 13px;\\n  text-align: center;\\n  border-radius: 2px;\\n  position: absolute;\\n  z-index: 10;\\n  background: #eceff1;\\n  border: 1px solid #90a4ae\\n}\\n\\n.apexcharts-xaxistooltip {\\n  padding: 9px 10px;\\n  transition: .15s ease all\\n}\\n\\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\\n  background: rgba(0,0,0,.7);\\n  border: 1px solid rgba(0,0,0,.5);\\n  color: #fff\\n}\\n\\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\\n  left: 50%;\\n  border: solid transparent;\\n  content: \\\" \\\";\\n  height: 0;\\n  width: 0;\\n  position: absolute;\\n  pointer-events: none\\n}\\n\\n.apexcharts-xaxistooltip:after {\\n  border-color: transparent;\\n  border-width: 6px;\\n  margin-left: -6px\\n}\\n\\n.apexcharts-xaxistooltip:before {\\n  border-color: transparent;\\n  border-width: 7px;\\n  margin-left: -7px\\n}\\n\\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\\n  bottom: 100%\\n}\\n\\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\\n  top: 100%\\n}\\n\\n.apexcharts-xaxistooltip-bottom:after {\\n  border-bottom-color: #eceff1\\n}\\n\\n.apexcharts-xaxistooltip-bottom:before {\\n  border-bottom-color: #90a4ae\\n}\\n\\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\\n  border-bottom-color: rgba(0,0,0,.5)\\n}\\n\\n.apexcharts-xaxistooltip-top:after {\\n  border-top-color: #eceff1\\n}\\n\\n.apexcharts-xaxistooltip-top:before {\\n  border-top-color: #90a4ae\\n}\\n\\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\\n  border-top-color: rgba(0,0,0,.5)\\n}\\n\\n.apexcharts-xaxistooltip.apexcharts-active {\\n  opacity: 1;\\n  transition: .15s ease all\\n}\\n\\n.apexcharts-yaxistooltip {\\n  padding: 4px 10px\\n}\\n\\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\\n  background: rgba(0,0,0,.7);\\n  border: 1px solid rgba(0,0,0,.5);\\n  color: #fff\\n}\\n\\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\\n  top: 50%;\\n  border: solid transparent;\\n  content: \\\" \\\";\\n  height: 0;\\n  width: 0;\\n  position: absolute;\\n  pointer-events: none\\n}\\n\\n.apexcharts-yaxistooltip:after {\\n  border-color: transparent;\\n  border-width: 6px;\\n  margin-top: -6px\\n}\\n\\n.apexcharts-yaxistooltip:before {\\n  border-color: transparent;\\n  border-width: 7px;\\n  margin-top: -7px\\n}\\n\\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\\n  left: 100%\\n}\\n\\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\\n  right: 100%\\n}\\n\\n.apexcharts-yaxistooltip-left:after {\\n  border-left-color: #eceff1\\n}\\n\\n.apexcharts-yaxistooltip-left:before {\\n  border-left-color: #90a4ae\\n}\\n\\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\\n  border-left-color: rgba(0,0,0,.5)\\n}\\n\\n.apexcharts-yaxistooltip-right:after {\\n  border-right-color: #eceff1\\n}\\n\\n.apexcharts-yaxistooltip-right:before {\\n  border-right-color: #90a4ae\\n}\\n\\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\\n  border-right-color: rgba(0,0,0,.5)\\n}\\n\\n.apexcharts-yaxistooltip.apexcharts-active {\\n  opacity: 1\\n}\\n\\n.apexcharts-yaxistooltip-hidden {\\n  display: none\\n}\\n\\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\\n  pointer-events: none;\\n  opacity: 0;\\n  transition: .15s ease all\\n}\\n\\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\\n  opacity: 1;\\n  transition: .15s ease all\\n}\\n\\n.apexcharts-ycrosshairs-hidden {\\n  opacity: 0\\n}\\n\\n.apexcharts-selection-rect {\\n  cursor: move\\n}\\n\\n.svg_select_boundingRect,.svg_select_points_rot {\\n  pointer-events: none;\\n  opacity: 0;\\n  visibility: hidden\\n}\\n\\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\\n  opacity: 0;\\n  visibility: hidden\\n}\\n\\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\\n  cursor: ew-resize;\\n  opacity: 1;\\n  visibility: visible\\n}\\n\\n.svg_select_points {\\n  fill: #efefef;\\n  stroke: #333;\\n  rx: 2\\n}\\n\\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\\n  cursor: crosshair\\n}\\n\\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\\n  cursor: move\\n}\\n\\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\\n  cursor: pointer;\\n  width: 20px;\\n  height: 20px;\\n  line-height: 24px;\\n  color: #6e8192;\\n  text-align: center\\n}\\n\\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\\n  fill: #6e8192\\n}\\n\\n.apexcharts-selection-icon svg {\\n  fill: #444;\\n  transform: scale(.76)\\n}\\n\\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\\n  fill: #f3f4f5\\n}\\n\\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\\n  fill: #008ffb\\n}\\n\\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\\n  fill: #333\\n}\\n\\n.apexcharts-menu-icon,.apexcharts-selection-icon {\\n  position: relative\\n}\\n\\n.apexcharts-reset-icon {\\n  margin-left: 5px\\n}\\n\\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\\n  transform: scale(.85)\\n}\\n\\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\\n  transform: scale(.7)\\n}\\n\\n.apexcharts-zoomout-icon {\\n  margin-right: 3px\\n}\\n\\n.apexcharts-pan-icon {\\n  transform: scale(.62);\\n  position: relative;\\n  left: 1px;\\n  top: 0\\n}\\n\\n.apexcharts-pan-icon svg {\\n  fill: #fff;\\n  stroke: #6e8192;\\n  stroke-width: 2\\n}\\n\\n.apexcharts-pan-icon.apexcharts-selected svg {\\n  stroke: #008ffb\\n}\\n\\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\\n  stroke: #333\\n}\\n\\n.apexcharts-toolbar {\\n  position: absolute;\\n  z-index: 11;\\n  max-width: 176px;\\n  text-align: right;\\n  border-radius: 3px;\\n  padding: 0 6px 2px;\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center\\n}\\n\\n.apexcharts-menu {\\n  background: #fff;\\n  position: absolute;\\n  top: 100%;\\n  border: 1px solid #ddd;\\n  border-radius: 3px;\\n  padding: 3px;\\n  right: 10px;\\n  opacity: 0;\\n  min-width: 110px;\\n  transition: .15s ease all;\\n  pointer-events: none\\n}\\n\\n.apexcharts-menu.apexcharts-menu-open {\\n  opacity: 1;\\n  pointer-events: all;\\n  transition: .15s ease all\\n}\\n\\n.apexcharts-menu-item {\\n  padding: 6px 7px;\\n  font-size: 12px;\\n  cursor: pointer\\n}\\n\\n.apexcharts-theme-light .apexcharts-menu-item:hover {\\n  background: #eee\\n}\\n\\n.apexcharts-theme-dark .apexcharts-menu {\\n  background: rgba(0,0,0,.7);\\n  color: #fff\\n}\\n\\n@media screen and (min-width:768px) {\\n  .apexcharts-canvas:hover .apexcharts-toolbar {\\n      opacity: 1\\n  }\\n}\\n\\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\\n  opacity: 0\\n}\\n\\n.apexcharts-hidden-element-shown {\\n  opacity: 1;\\n  transition: 0.25s ease all;\\n}\\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\\n  cursor: default;\\n  pointer-events: none\\n}\\n\\n.apexcharts-pie-label-delay {\\n  opacity: 0;\\n  animation-name: opaque;\\n  animation-duration: .3s;\\n  animation-fill-mode: forwards;\\n  animation-timing-function: ease\\n}\\n\\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\\n  pointer-events: none\\n}\\n\\n.apexcharts-marker {\\n  transition: .15s ease all\\n}\\n\\n.resize-triggers {\\n  animation: 1ms resizeanim;\\n  visibility: hidden;\\n  opacity: 0;\\n  height: 100%;\\n  width: 100%;\\n  overflow: hidden\\n}\\n\\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\\n  content: \\\" \\\";\\n  display: block;\\n  position: absolute;\\n  top: 0;\\n  left: 0\\n}\\n\\n.resize-triggers>div {\\n  height: 100%;\\n  width: 100%;\\n  background: #eee;\\n  overflow: auto\\n}\\n\\n.contract-trigger:before {\\n  overflow: hidden;\\n  width: 200%;\\n  height: 200%\\n}\\n\\n.apexcharts-bar-goals-markers{\\n  pointer-events: none\\n}\\n\\n.apexcharts-bar-shadows{\\n  pointer-events: none\\n}\\n\\n.apexcharts-rangebar-goals-markers{\\n  pointer-events: none\\n}\";\n\n  /**\n   *\n   * @module ApexCharts\n   **/\n\n  var ApexCharts$1 = /*#__PURE__*/function () {\n    function ApexCharts(el, opts) {\n      _classCallCheck(this, ApexCharts);\n\n      this.opts = opts;\n      this.ctx = this; // Pass the user supplied options to the Base Class where these options will be extended with defaults. The returned object from Base Class will become the config object in the entire codebase.\n\n      this.w = new Base(opts).init();\n      this.el = el;\n      this.w.globals.cuid = Utils$1.randomId();\n      this.w.globals.chartID = this.w.config.chart.id ? Utils$1.escapeString(this.w.config.chart.id) : this.w.globals.cuid;\n      var initCtx = new InitCtxVariables(this);\n      initCtx.initModules();\n      this.create = Utils$1.bind(this.create, this);\n      this.windowResizeHandler = this._windowResizeHandler.bind(this);\n      this.parentResizeHandler = this._parentResizeCallback.bind(this);\n    }\n    /**\n     * The primary method user will call to render the chart.\n     */\n\n\n    _createClass(ApexCharts, [{\n      key: \"render\",\n      value: function render() {\n        var _this = this;\n\n        // main method\n        return new Promise(function (resolve, reject) {\n          // only draw chart, if element found\n          if (_this.el !== null) {\n            if (typeof Apex._chartInstances === 'undefined') {\n              Apex._chartInstances = [];\n            }\n\n            if (_this.w.config.chart.id) {\n              Apex._chartInstances.push({\n                id: _this.w.globals.chartID,\n                group: _this.w.config.chart.group,\n                chart: _this\n              });\n            } // set the locale here\n\n\n            _this.setLocale(_this.w.config.chart.defaultLocale);\n\n            var beforeMount = _this.w.config.chart.events.beforeMount;\n\n            if (typeof beforeMount === 'function') {\n              beforeMount(_this, _this.w);\n            }\n\n            _this.events.fireEvent('beforeMount', [_this, _this.w]);\n\n            window.addEventListener('resize', _this.windowResizeHandler);\n            addResizeListener(_this.el.parentNode, _this.parentResizeHandler); // Add CSS if not already added\n\n            if (!_this.css) {\n              var rootNode = _this.el.getRootNode && _this.el.getRootNode();\n\n              var inShadowRoot = Utils$1.is('ShadowRoot', rootNode);\n              var doc = _this.el.ownerDocument;\n              var globalCSS = doc.getElementById('apexcharts-css');\n\n              if (inShadowRoot || !globalCSS) {\n                _this.css = document.createElement('style');\n                _this.css.id = 'apexcharts-css';\n                _this.css.textContent = css_248z;\n\n                if (inShadowRoot) {\n                  // We are in Shadow DOM, add to shadow root\n                  rootNode.prepend(_this.css);\n                } else {\n                  // Add to <head> of element's document\n                  doc.head.appendChild(_this.css);\n                }\n              }\n            }\n\n            var graphData = _this.create(_this.w.config.series, {});\n\n            if (!graphData) return resolve(_this);\n\n            _this.mount(graphData).then(function () {\n              if (typeof _this.w.config.chart.events.mounted === 'function') {\n                _this.w.config.chart.events.mounted(_this, _this.w);\n              }\n\n              _this.events.fireEvent('mounted', [_this, _this.w]);\n\n              resolve(graphData);\n            }).catch(function (e) {\n              reject(e); // handle error in case no data or element not found\n            });\n          } else {\n            reject(new Error('Element not found'));\n          }\n        });\n      }\n    }, {\n      key: \"create\",\n      value: function create(ser, opts) {\n        var w = this.w;\n        var initCtx = new InitCtxVariables(this);\n        initCtx.initModules();\n        var gl = this.w.globals;\n        gl.noData = false;\n        gl.animationEnded = false;\n        this.responsive.checkResponsiveConfig(opts);\n\n        if (w.config.xaxis.convertedCatToNumeric) {\n          var defaults = new Defaults(w.config);\n          defaults.convertCatToNumericXaxis(w.config, this.ctx);\n        }\n\n        if (this.el === null) {\n          gl.animationEnded = true;\n          return null;\n        }\n\n        this.core.setupElements();\n\n        if (w.config.chart.type === 'treemap') {\n          w.config.grid.show = false;\n          w.config.yaxis[0].show = false;\n        }\n\n        if (gl.svgWidth === 0) {\n          // if the element is hidden, skip drawing\n          gl.animationEnded = true;\n          return null;\n        }\n\n        var combo = CoreUtils.checkComboSeries(ser);\n        gl.comboCharts = combo.comboCharts;\n        gl.comboBarCount = combo.comboBarCount;\n        var allSeriesAreEmpty = ser.every(function (s) {\n          return s.data && s.data.length === 0;\n        });\n\n        if (ser.length === 0 || allSeriesAreEmpty) {\n          this.series.handleNoData();\n        }\n\n        this.events.setupEventHandlers(); // Handle the data inputted by user and set some of the global variables (for eg, if data is datetime / numeric / category). Don't calculate the range / min / max at this time\n\n        this.data.parseData(ser); // this is a good time to set theme colors first\n\n        this.theme.init(); // as markers accepts array, we need to setup global markers for easier access\n\n        var markers = new Markers(this);\n        markers.setGlobalMarkerSize(); // labelFormatters should be called before dimensions as in dimensions we need text labels width\n\n        this.formatters.setLabelFormatters();\n        this.titleSubtitle.draw(); // legend is calculated here before coreCalculations because it affects the plottable area\n        // if there is some data to show or user collapsed all series, then proceed drawing legend\n\n        if (!gl.noData || gl.collapsedSeries.length === gl.series.length || w.config.legend.showForSingleSeries) {\n          this.legend.init();\n        } // check whether in multiple series, all series share the same X\n\n\n        this.series.hasAllSeriesEqualX(); // coreCalculations will give the min/max range and yaxis/axis values. It should be called here to set series variable from config to globals\n\n        if (gl.axisCharts) {\n          this.core.coreCalculations();\n\n          if (w.config.xaxis.type !== 'category') {\n            // as we have minX and maxX values, determine the default DateTimeFormat for time series\n            this.formatters.setLabelFormatters();\n          }\n\n          this.ctx.toolbar.minX = w.globals.minX;\n          this.ctx.toolbar.maxX = w.globals.maxX;\n        } // we need to generate yaxis for heatmap separately as we are not showing numerics there, but seriesNames. There are some tweaks which are required for heatmap to align labels correctly which are done in below function\n        // Also we need to do this before calculating Dimensions plotCoords() method of Dimensions\n\n\n        this.formatters.heatmapLabelFormatters(); // get the largest marker size which will be needed in dimensions calc\n\n        var coreUtils = new CoreUtils(this);\n        coreUtils.getLargestMarkerSize(); // We got plottable area here, next task would be to calculate axis areas\n\n        this.dimensions.plotCoords();\n        var xyRatios = this.core.xySettings();\n        this.grid.createGridMask();\n        var elGraph = this.core.plotChartType(ser, xyRatios);\n        var dataLabels = new DataLabels(this);\n        dataLabels.bringForward();\n\n        if (w.config.dataLabels.background.enabled) {\n          dataLabels.dataLabelsBackground();\n        } // after all the drawing calculations, shift the graphical area (actual charts/bars) excluding legends\n\n\n        this.core.shiftGraphPosition();\n        var dim = {\n          plot: {\n            left: w.globals.translateX,\n            top: w.globals.translateY,\n            width: w.globals.gridWidth,\n            height: w.globals.gridHeight\n          }\n        };\n        return {\n          elGraph: elGraph,\n          xyRatios: xyRatios,\n          dimensions: dim\n        };\n      }\n    }, {\n      key: \"mount\",\n      value: function mount() {\n        var _this2 = this;\n\n        var graphData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var me = this;\n        var w = me.w;\n        return new Promise(function (resolve, reject) {\n          // no data to display\n          if (me.el === null) {\n            return reject(new Error('Not enough data to display or target element not found'));\n          } else if (graphData === null || w.globals.allSeriesCollapsed) {\n            me.series.handleNoData();\n          }\n\n          me.grid = new Grid(me);\n          var elgrid = me.grid.drawGrid();\n          me.annotations = new Annotations(me);\n          me.annotations.drawImageAnnos();\n          me.annotations.drawTextAnnos();\n\n          if (w.config.grid.position === 'back') {\n            var _elgrid$elGridBorders;\n\n            if (elgrid) {\n              w.globals.dom.elGraphical.add(elgrid.el);\n            }\n\n            if (elgrid !== null && elgrid !== void 0 && (_elgrid$elGridBorders = elgrid.elGridBorders) !== null && _elgrid$elGridBorders !== void 0 && _elgrid$elGridBorders.node) {\n              w.globals.dom.elGraphical.add(elgrid.elGridBorders);\n            }\n          }\n\n          if (Array.isArray(graphData.elGraph)) {\n            for (var g = 0; g < graphData.elGraph.length; g++) {\n              w.globals.dom.elGraphical.add(graphData.elGraph[g]);\n            }\n          } else {\n            w.globals.dom.elGraphical.add(graphData.elGraph);\n          }\n\n          if (w.config.grid.position === 'front') {\n            var _elgrid$elGridBorders2;\n\n            if (elgrid) {\n              w.globals.dom.elGraphical.add(elgrid.el);\n            }\n\n            if (elgrid !== null && elgrid !== void 0 && (_elgrid$elGridBorders2 = elgrid.elGridBorders) !== null && _elgrid$elGridBorders2 !== void 0 && _elgrid$elGridBorders2.node) {\n              w.globals.dom.elGraphical.add(elgrid.elGridBorders);\n            }\n          }\n\n          if (w.config.xaxis.crosshairs.position === 'front') {\n            me.crosshairs.drawXCrosshairs();\n          }\n\n          if (w.config.yaxis[0].crosshairs.position === 'front') {\n            me.crosshairs.drawYCrosshairs();\n          }\n\n          if (w.config.chart.type !== 'treemap') {\n            me.axes.drawAxis(w.config.chart.type, elgrid);\n          }\n\n          var xAxis = new XAxis(_this2.ctx, elgrid);\n          var yaxis = new YAxis(_this2.ctx, elgrid);\n\n          if (elgrid !== null) {\n            xAxis.xAxisLabelCorrections(elgrid.xAxisTickWidth);\n            yaxis.setYAxisTextAlignments();\n            w.config.yaxis.map(function (yaxe, index) {\n              if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1) {\n                yaxis.yAxisTitleRotate(index, yaxe.opposite);\n              }\n            });\n          }\n\n          me.annotations.drawAxesAnnotations();\n\n          if (!w.globals.noData) {\n            // draw tooltips at the end\n            if (w.config.tooltip.enabled && !w.globals.noData) {\n              me.w.globals.tooltip.drawTooltip(graphData.xyRatios);\n            }\n\n            if (w.globals.axisCharts && (w.globals.isXNumeric || w.config.xaxis.convertedCatToNumeric || w.globals.isRangeBar)) {\n              if (w.config.chart.zoom.enabled || w.config.chart.selection && w.config.chart.selection.enabled || w.config.chart.pan && w.config.chart.pan.enabled) {\n                me.zoomPanSelection.init({\n                  xyRatios: graphData.xyRatios\n                });\n              }\n            } else {\n              var tools = w.config.chart.toolbar.tools;\n              var toolsArr = ['zoom', 'zoomin', 'zoomout', 'selection', 'pan', 'reset'];\n              toolsArr.forEach(function (t) {\n                tools[t] = false;\n              });\n            }\n\n            if (w.config.chart.toolbar.show && !w.globals.allSeriesCollapsed) {\n              me.toolbar.createToolbar();\n            }\n          }\n\n          if (w.globals.memory.methodsToExec.length > 0) {\n            w.globals.memory.methodsToExec.forEach(function (fn) {\n              fn.method(fn.params, false, fn.context);\n            });\n          }\n\n          if (!w.globals.axisCharts && !w.globals.noData) {\n            me.core.resizeNonAxisCharts();\n          }\n\n          resolve(me);\n        });\n      }\n      /**\n       * Destroy the chart instance by removing all elements which also clean up event listeners on those elements.\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        window.removeEventListener('resize', this.windowResizeHandler);\n        removeResizeListener(this.el.parentNode, this.parentResizeHandler); // remove the chart's instance from the global Apex._chartInstances\n\n        var chartID = this.w.config.chart.id;\n\n        if (chartID) {\n          Apex._chartInstances.forEach(function (c, i) {\n            if (c.id === Utils$1.escapeString(chartID)) {\n              Apex._chartInstances.splice(i, 1);\n            }\n          });\n        }\n\n        new Destroy(this.ctx).clear({\n          isUpdating: false\n        });\n      }\n      /**\n       * Allows users to update Options after the chart has rendered.\n       *\n       * @param {object} options - A new config object can be passed which will be merged with the existing config object\n       * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there\n       * @param {boolean} animate - should animate or not on updating Options\n       */\n\n    }, {\n      key: \"updateOptions\",\n      value: function updateOptions(options) {\n        var _this3 = this;\n\n        var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var updateSyncedCharts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        var overwriteInitialConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var w = this.w; // when called externally, clear some global variables\n        // fixes apexcharts.js#1488\n\n        w.globals.selection = undefined;\n\n        if (options.series) {\n          this.series.resetSeries(false, true, false);\n\n          if (options.series.length && options.series[0].data) {\n            options.series = options.series.map(function (s, i) {\n              return _this3.updateHelpers._extendSeries(s, i);\n            });\n          } // user updated the series via updateOptions() function.\n          // Hence, we need to reset axis min/max to avoid zooming issues\n\n\n          this.updateHelpers.revertDefaultAxisMinMax();\n        } // user has set x-axis min/max externally - hence we need to forcefully set the xaxis min/max\n\n\n        if (options.xaxis) {\n          options = this.updateHelpers.forceXAxisUpdate(options);\n        }\n\n        if (options.yaxis) {\n          options = this.updateHelpers.forceYAxisUpdate(options);\n        }\n\n        if (w.globals.collapsedSeriesIndices.length > 0) {\n          this.series.clearPreviousPaths();\n        }\n        /* update theme mode#459 */\n\n\n        if (options.theme) {\n          options = this.theme.updateThemeOptions(options);\n        }\n\n        return this.updateHelpers._updateOptions(options, redraw, animate, updateSyncedCharts, overwriteInitialConfig);\n      }\n      /**\n       * Allows users to update Series after the chart has rendered.\n       *\n       * @param {array} series - New series which will override the existing\n       */\n\n    }, {\n      key: \"updateSeries\",\n      value: function updateSeries() {\n        var newSeries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        this.series.resetSeries(false);\n        this.updateHelpers.revertDefaultAxisMinMax();\n        return this.updateHelpers._updateSeries(newSeries, animate, overwriteInitialSeries);\n      }\n      /**\n       * Allows users to append a new series after the chart has rendered.\n       *\n       * @param {array} newSerie - New serie which will be appended to the existing series\n       */\n\n    }, {\n      key: \"appendSeries\",\n      value: function appendSeries(newSerie) {\n        var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var newSeries = this.w.config.series.slice();\n        newSeries.push(newSerie);\n        this.series.resetSeries(false);\n        this.updateHelpers.revertDefaultAxisMinMax();\n        return this.updateHelpers._updateSeries(newSeries, animate, overwriteInitialSeries);\n      }\n      /**\n       * Allows users to append Data to series.\n       *\n       * @param {array} newData - New data in the same format as series\n       */\n\n    }, {\n      key: \"appendData\",\n      value: function appendData(newData) {\n        var overwriteInitialSeries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var me = this;\n        me.w.globals.dataChanged = true;\n        me.series.getPreviousPaths();\n        var newSeries = me.w.config.series.slice();\n\n        for (var i = 0; i < newSeries.length; i++) {\n          if (newData[i] !== null && typeof newData[i] !== 'undefined') {\n            for (var j = 0; j < newData[i].data.length; j++) {\n              newSeries[i].data.push(newData[i].data[j]);\n            }\n          }\n        }\n\n        me.w.config.series = newSeries;\n\n        if (overwriteInitialSeries) {\n          me.w.globals.initialSeries = Utils$1.clone(me.w.config.series);\n        }\n\n        return this.update();\n      }\n    },\n    {\n      key: \"replaceData\",\n      value: function replaceData(newData) {\n        var overwriteInitialSeries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var me = this;\n        me.w.globals.dataChanged = true;\n        me.series.getPreviousPaths();\n        var newSeries = me.w.config.series.slice();\n\n        for (var i = 0; i < newSeries.length; i++) {\n          if (newData[i] !== null && typeof newData[i] !== 'undefined') {\n            for (var j = 0; j < newData[i].data.length; j++) {\n                let length = newSeries[i].data.length;\n\n                newSeries[i].data[length-1] = newData[i].data[j];\n                //newSeries[i].data.splice(length-1, 1, newData[i].data[j]);\n            }\n          }\n        }\n\n        me.w.config.series = newSeries;\n\n        if (overwriteInitialSeries) {\n          me.w.globals.initialSeries = Utils$1.clone(me.w.config.series);\n        }\n\n        return this.update();\n      }\n    },\n     {\n      key: \"update\",\n      value: function update(options) {\n        var _this4 = this;\n\n        return new Promise(function (resolve, reject) {\n          new Destroy(_this4.ctx).clear({\n            isUpdating: true\n          });\n\n          var graphData = _this4.create(_this4.w.config.series, options);\n\n          if (!graphData) return resolve(_this4);\n\n          _this4.mount(graphData).then(function () {\n            if (typeof _this4.w.config.chart.events.updated === 'function') {\n              _this4.w.config.chart.events.updated(_this4, _this4.w);\n            }\n\n            _this4.events.fireEvent('updated', [_this4, _this4.w]);\n\n            _this4.w.globals.isDirty = true;\n            resolve(_this4);\n          }).catch(function (e) {\n            reject(e);\n          });\n        });\n      }\n      /**\n       * Get all charts in the same \"group\" (including the instance which is called upon) to sync them when user zooms in/out or pan.\n       */\n\n    }, {\n      key: \"getSyncedCharts\",\n      value: function getSyncedCharts() {\n        var chartGroups = this.getGroupedCharts();\n        var allCharts = [this];\n\n        if (chartGroups.length) {\n          allCharts = [];\n          chartGroups.forEach(function (ch) {\n            allCharts.push(ch);\n          });\n        }\n\n        return allCharts;\n      }\n      /**\n       * Get charts in the same \"group\" (excluding the instance which is called upon) to perform operations on the other charts of the same group (eg., tooltip hovering)\n       */\n\n    }, {\n      key: \"getGroupedCharts\",\n      value: function getGroupedCharts() {\n        var _this5 = this;\n\n        return Apex._chartInstances.filter(function (ch) {\n          if (ch.group) {\n            return true;\n          }\n        }).map(function (ch) {\n          return _this5.w.config.chart.group === ch.group ? ch.chart : _this5;\n        });\n      }\n    }, {\n      key: \"toggleSeries\",\n      value: function toggleSeries(seriesName) {\n        return this.series.toggleSeries(seriesName);\n      }\n    }, {\n      key: \"highlightSeriesOnLegendHover\",\n      value: function highlightSeriesOnLegendHover(e, targetElement) {\n        return this.series.toggleSeriesOnHover(e, targetElement);\n      }\n    }, {\n      key: \"showSeries\",\n      value: function showSeries(seriesName) {\n        this.series.showSeries(seriesName);\n      }\n    }, {\n      key: \"hideSeries\",\n      value: function hideSeries(seriesName) {\n        this.series.hideSeries(seriesName);\n      }\n    }, {\n      key: \"isSeriesHidden\",\n      value: function isSeriesHidden(seriesName) {\n        this.series.isSeriesHidden(seriesName);\n      }\n    }, {\n      key: \"resetSeries\",\n      value: function resetSeries() {\n        var shouldUpdateChart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var shouldResetZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        this.series.resetSeries(shouldUpdateChart, shouldResetZoom);\n      } // Public method to add event listener on chart context\n\n    }, {\n      key: \"addEventListener\",\n      value: function addEventListener(name, handler) {\n        this.events.addEventListener(name, handler);\n      } // Public method to remove event listener on chart context\n\n    }, {\n      key: \"removeEventListener\",\n      value: function removeEventListener(name, handler) {\n        this.events.removeEventListener(name, handler);\n      }\n    }, {\n      key: \"addXaxisAnnotation\",\n      value: function addXaxisAnnotation(opts) {\n        var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n        var me = this;\n\n        if (context) {\n          me = context;\n        }\n\n        me.annotations.addXaxisAnnotationExternal(opts, pushToMemory, me);\n      }\n    }, {\n      key: \"addYaxisAnnotation\",\n      value: function addYaxisAnnotation(opts) {\n        var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n        var me = this;\n\n        if (context) {\n          me = context;\n        }\n\n        me.annotations.addYaxisAnnotationExternal(opts, pushToMemory, me);\n      }\n    }, {\n      key: \"addPointAnnotation\",\n      value: function addPointAnnotation(opts) {\n        var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n        var me = this;\n\n        if (context) {\n          me = context;\n        }\n\n        me.annotations.addPointAnnotationExternal(opts, pushToMemory, me);\n      }\n    }, {\n      key: \"clearAnnotations\",\n      value: function clearAnnotations() {\n        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        var me = this;\n\n        if (context) {\n          me = context;\n        }\n\n        me.annotations.clearAnnotations(me);\n      }\n    }, {\n      key: \"removeAnnotation\",\n      value: function removeAnnotation(id) {\n        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        var me = this;\n\n        if (context) {\n          me = context;\n        }\n\n        me.annotations.removeAnnotation(me, id);\n      }\n    }, {\n      key: \"getChartArea\",\n      value: function getChartArea() {\n        var el = this.w.globals.dom.baseEl.querySelector('.apexcharts-inner');\n        return el;\n      }\n    }, {\n      key: \"getSeriesTotalXRange\",\n      value: function getSeriesTotalXRange(minX, maxX) {\n        return this.coreUtils.getSeriesTotalsXRange(minX, maxX);\n      }\n    }, {\n      key: \"getHighestValueInSeries\",\n      value: function getHighestValueInSeries() {\n        var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var range = new Range(this.ctx);\n        return range.getMinYMaxY(seriesIndex).highestY;\n      }\n    }, {\n      key: \"getLowestValueInSeries\",\n      value: function getLowestValueInSeries() {\n        var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var range = new Range(this.ctx);\n        return range.getMinYMaxY(seriesIndex).lowestY;\n      }\n    }, {\n      key: \"getSeriesTotal\",\n      value: function getSeriesTotal() {\n        return this.w.globals.seriesTotals;\n      }\n    }, {\n      key: \"toggleDataPointSelection\",\n      value: function toggleDataPointSelection(seriesIndex, dataPointIndex) {\n        return this.updateHelpers.toggleDataPointSelection(seriesIndex, dataPointIndex);\n      }\n    }, {\n      key: \"zoomX\",\n      value: function zoomX(min, max) {\n        this.ctx.toolbar.zoomUpdateOptions(min, max);\n      }\n    }, {\n      key: \"setLocale\",\n      value: function setLocale(localeName) {\n        this.localization.setCurrentLocaleValues(localeName);\n      }\n    }, {\n      key: \"dataURI\",\n      value: function dataURI(options) {\n        var exp = new Exports(this.ctx);\n        return exp.dataURI(options);\n      }\n    }, {\n      key: \"exportToCSV\",\n      value: function exportToCSV() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var exp = new Exports(this.ctx);\n        return exp.exportToCSV(options);\n      }\n    }, {\n      key: \"paper\",\n      value: function paper() {\n        return this.w.globals.dom.Paper;\n      }\n    }, {\n      key: \"_parentResizeCallback\",\n      value: function _parentResizeCallback() {\n        if (this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize) {\n          this._windowResize();\n        }\n      }\n      /**\n       * Handle window resize and re-draw the whole chart.\n       */\n\n    }, {\n      key: \"_windowResize\",\n      value: function _windowResize() {\n        var _this6 = this;\n\n        clearTimeout(this.w.globals.resizeTimer);\n        this.w.globals.resizeTimer = window.setTimeout(function () {\n          _this6.w.globals.resized = true;\n          _this6.w.globals.dataChanged = false; // we need to redraw the whole chart on window resize (with a small delay).\n\n          _this6.ctx.update();\n        }, 150);\n      }\n    }, {\n      key: \"_windowResizeHandler\",\n      value: function _windowResizeHandler() {\n        var redraw = this.w.config.chart.redrawOnWindowResize;\n\n        if (typeof redraw === 'function') {\n          redraw = redraw();\n        }\n\n        redraw && this._windowResize();\n      }\n    }], [{\n      key: \"getChartByID\",\n      value: function getChartByID(id) {\n        var chartId = Utils$1.escapeString(id);\n        if (!Apex._chartInstances) return undefined;\n\n        var c = Apex._chartInstances.filter(function (ch) {\n          return ch.id === chartId;\n        })[0];\n\n        return c && c.chart;\n      }\n      /**\n       * Allows the user to provide data attrs in the element and the chart will render automatically when this method is called by searching for the elements containing 'data-apexcharts' attribute\n       */\n\n    }, {\n      key: \"initOnLoad\",\n      value: function initOnLoad() {\n        var els = document.querySelectorAll('[data-apexcharts]');\n\n        for (var i = 0; i < els.length; i++) {\n          var el = els[i];\n          var options = JSON.parse(els[i].getAttribute('data-options'));\n          var apexChart = new ApexCharts(el, options);\n          apexChart.render();\n        }\n      }\n      /**\n       * This static method allows users to call chart methods without necessarily from the\n       * instance of the chart in case user has assigned chartID to the targeted chart.\n       * The chartID is used for mapping the instance stored in Apex._chartInstances global variable\n       *\n       * This is helpful in cases when you don't have reference of the chart instance\n       * easily and need to call the method from anywhere.\n       * For eg, in React/Vue applications when you have many parent/child components,\n       * and need easy reference to other charts for performing dynamic operations\n       *\n       * @param {string} chartID - The unique identifier which will be used to call methods\n       * on that chart instance\n       * @param {function} fn - The method name to call\n       * @param {object} opts - The parameters which are accepted in the original method will be passed here in the same order.\n       */\n\n    }, {\n      key: \"exec\",\n      value: function exec(chartID, fn) {\n        var chart = this.getChartByID(chartID);\n        if (!chart) return; // turn on the global exec flag to indicate this method was called\n\n        chart.w.globals.isExecCalled = true;\n        var ret = null;\n\n        if (chart.publicMethods.indexOf(fn) !== -1) {\n          for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n            opts[_key - 2] = arguments[_key];\n          }\n\n          ret = chart[fn].apply(chart, opts);\n        }\n\n        return ret;\n      }\n    }, {\n      key: \"merge\",\n      value: function merge(target, source) {\n        return Utils$1.extend(target, source);\n      }\n    }]);\n\n    return ApexCharts;\n  }();\n\n  return ApexCharts$1;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBleGNoYXJ0cy9kaXN0L2FwZXhjaGFydHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ3lHO0FBQzNHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxTQUFTOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTs7QUFFUixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhLE1BQU07OztBQUc3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFNBQVMsT0FBTzs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLE9BQU87O0FBRWhCOztBQUVBO0FBQ0EseURBQXlEOztBQUV6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjs7QUFFQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0EsNkNBQTZDOztBQUU3Qyw2RkFBNkY7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0EsK0VBQStFOztBQUUvRSx3SEFBd0g7O0FBRXhIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUE0RDtBQUNwRjs7QUFFQSwwQkFBMEIsNkJBQTZCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsaURBQWlEOztBQUVqRCx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsT0FBTztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELENBQUU7QUFDakUsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwSkFBMEo7O0FBRTFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsV0FBVztBQUMxRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFQUF1RSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUVBQXVFLFdBQVc7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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L0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQyxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNB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QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEVBQTRFOztBQUU1RSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBNQUEwTTs7QUFFMU07QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHFMQUFxTDs7QUFFckwsd0RBQXdEOztBQUV4RDtBQUNBLDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixtREFBbUQ7O0FBRW5ELDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFOztBQUU5RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTOztBQUVULHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztB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c0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTLEdBQUc7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHdCQUF3QixtQ0FBbUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQSxzRkFBc0YsUUFBUTtBQUM5RjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLGdFQUFnRSw2QkFBNkI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnS0FBZ0ssYUFBYSxrQkFBa0IsU0FBUztBQUN4TTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG9FQUFvRTs7QUFFcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QixpQkFBaUIsS0FBSztBQUN0QixpQkFBaUIsS0FBSztBQUN0Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSx3QkFBd0Isc0JBQXNCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtB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QUNBLGdCQUFnQixRQUFRO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQyxzQ0FBc0M7O0FBRXRDLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWLDBCQUEwQjs7QUFFMUIsMEJBQTBCOztBQUUxQiwyQkFBMkI7O0FBRTNCLDJCQUEyQjs7QUFFM0IsNkJBQTZCOztBQUU3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDViwwQkFBMEI7O0FBRTFCLDJCQUEyQjs7QUFFM0IsNkJBQTZCOztBQUU3QiwwQkFBMEI7O0FBRTFCLDJCQUEyQjs7QUFFM0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2TUFBNk07QUFDN007O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Qsc0NBQXNDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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WUFBWTtBQUNaO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtEQUErRCwrQ0FBK0M7QUFDOUc7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXOztBQUVYLDBCQUEwQiwwQkFBMEI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHFDQUFxQztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNIQUFzSDs7QUFFdEgsdUdBQXVHOztBQUV2RztBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREOztBQUU1RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUMsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1Qzs7QUFFdkMsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBLHNHQUFzRzs7QUFFdEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkYsd0NBQXdDO0FBQ25JO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUZBQXlGOztBQUV6RiwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBNkM7QUFDL0U7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx1REFBdUQ7QUFDMUY7QUFDQTtBQUNBLG9CQUFvQjs7O0FBR3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxNQUFNLG1DQUFPO0FBQ2I7QUFDQSxPQUFPO0FBQUEsa0dBQUM7QUFDUjtBQUNBLE1BQU0sS0FBSyxFQU1OO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxLQUFLLElBQUk7OztBQUdULHNDQUFzQzs7QUFFdEMsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsNEJBQTRCOztBQUU1QiwwQ0FBMEM7O0FBRTFDOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QiwrQ0FBK0M7O0FBRS9DLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQSxRQUFROzs7QUFHUix1RUFBdUU7QUFDdkU7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7O0FBRXZHO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCLFdBQVcsVUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QywrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0EsMENBQTBDLHFDQUFxQztBQUMvRTtBQUNBLFlBQVk7QUFDWiwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSxpREFBaUQsUUFBUTtBQUN6RDs7QUFFQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDLDhEQUE4RDs7QUFFOUQsd0NBQXdDO0FBQ3hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0Isb0RBQW9EOztBQUVwRDtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLHdHQUF3Rzs7QUFFeEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0EsMkhBQTJIOztBQUUzSCxvRUFBb0UsUUFBUTtBQUM1RTtBQUNBLGNBQWM7O0FBRWQsWUFBWTtBQUNaO0FBQ0Esb0VBQW9FOztBQUVwRSxtQ0FBbUM7O0FBRW5DLHlEQUF5RDs7O0FBR3pEO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTs7O0FBR1o7O0FBRUE7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0Esd0NBQXdDLElBQUk7QUFD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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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O0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVYsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04scUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFLG9EQUFvRCxnQkFBZ0I7QUFDcEUsa0RBQWtELGVBQWU7QUFDakUsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBLGlDQUFpQyw4REFBOEQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyREFBMkQ7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1DQUFtQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBLGlHQUFpRyxhQUFhO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcGV4Y2hhcnRzL2Rpc3QvYXBleGNoYXJ0cy5qcz9jNzQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBcGV4Q2hhcnRzIHYzLjQzLjJcbiAqIChjKSAyMDE4LTIwMjMgQXBleENoYXJ0c1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5BcGV4Q2hhcnRzID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgICBpZiAoaSAlIDIpIHtcbiAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuXG4gICAgdmFyIF9zLCBfZTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICAvKlxuICAgKiogR2VuZXJpYyBmdW5jdGlvbnMgd2hpY2ggYXJlIG5vdCBkZXBlbmRlbnQgb24gQXBleENoYXJ0c1xuICAgKi9cbiAgdmFyIFV0aWxzJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFV0aWxzKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWxzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVXRpbHMsIFt7XG4gICAgICBrZXk6IFwic2hhZGVSR0JDb2xvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNoYWRlUkdCQ29sb3IocGVyY2VudCwgY29sb3IpIHtcbiAgICAgICAgdmFyIGYgPSBjb2xvci5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgdCA9IHBlcmNlbnQgPCAwID8gMCA6IDI1NSxcbiAgICAgICAgICAgIHAgPSBwZXJjZW50IDwgMCA/IHBlcmNlbnQgKiAtMSA6IHBlcmNlbnQsXG4gICAgICAgICAgICBSID0gcGFyc2VJbnQoZlswXS5zbGljZSg0KSwgMTApLFxuICAgICAgICAgICAgRyA9IHBhcnNlSW50KGZbMV0sIDEwKSxcbiAgICAgICAgICAgIEIgPSBwYXJzZUludChmWzJdLCAxMCk7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyAoTWF0aC5yb3VuZCgodCAtIFIpICogcCkgKyBSKSArICcsJyArIChNYXRoLnJvdW5kKCh0IC0gRykgKiBwKSArIEcpICsgJywnICsgKE1hdGgucm91bmQoKHQgLSBCKSAqIHApICsgQikgKyAnKSc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNoYWRlSGV4Q29sb3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFkZUhleENvbG9yKHBlcmNlbnQsIGNvbG9yKSB7XG4gICAgICAgIHZhciBmID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksIDE2KSxcbiAgICAgICAgICAgIHQgPSBwZXJjZW50IDwgMCA/IDAgOiAyNTUsXG4gICAgICAgICAgICBwID0gcGVyY2VudCA8IDAgPyBwZXJjZW50ICogLTEgOiBwZXJjZW50LFxuICAgICAgICAgICAgUiA9IGYgPj4gMTYsXG4gICAgICAgICAgICBHID0gZiA+PiA4ICYgMHgwMGZmLFxuICAgICAgICAgICAgQiA9IGYgJiAweDAwMDBmZjtcbiAgICAgICAgcmV0dXJuICcjJyArICgweDEwMDAwMDAgKyAoTWF0aC5yb3VuZCgodCAtIFIpICogcCkgKyBSKSAqIDB4MTAwMDAgKyAoTWF0aC5yb3VuZCgodCAtIEcpICogcCkgKyBHKSAqIDB4MTAwICsgKE1hdGgucm91bmQoKHQgLSBCKSAqIHApICsgQikpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgIH0gLy8gYmVhdXRpZnVsIGNvbG9yIHNoYWRpbmcgYmxlbmRpbmcgY29kZVxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTYwMjQ4L3Byb2dyYW1tYXRpY2FsbHktbGlnaHRlbi1vci1kYXJrZW4tYS1oZXgtY29sb3Itb3ItcmdiLWFuZC1ibGVuZC1jb2xvcnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaGFkZUNvbG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hhZGVDb2xvcihwLCBjb2xvcikge1xuICAgICAgICBpZiAoVXRpbHMuaXNDb2xvckhleChjb2xvcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZUhleENvbG9yKHAsIGNvbG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZVJHQkNvbG9yKHAsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImJpbmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kKGZuLCBtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNPYmplY3RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc09iamVjdChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICYmIF90eXBlb2YoaXRlbSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGl0ZW0pICYmIGl0ZW0gIT0gbnVsbDtcbiAgICAgIH0gLy8gVHlwZSBjaGVja2luZyB0aGF0IHdvcmtzIGFjcm9zcyBkaWZmZXJlbnQgd2luZG93IG9iamVjdHNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzKHR5cGUsIHZhbCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0ICcgKyB0eXBlICsgJ10nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsaXN0VG9BcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RUb0FycmF5KGxpc3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBhcnJheSA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJyYXlbaV0gPSBsaXN0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSAvLyB0byBleHRlbmQgZGVmYXVsdHMgd2l0aCB1c2VyIG9wdGlvbnNcbiAgICAgIC8vIGNyZWRpdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzkzNjc3Mi9kZWVwLW9iamVjdC1tZXJnaW5nLWluLWVzNi1lczcjYW5zd2VyLTM0NzQ5ODczXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZXh0ZW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblxuICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAoX3NvdXJjZSAhPT0gdW5kZWZpbmVkICYmIF9zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gX3NvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3NvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IF9zb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNPYmplY3QodGFyZ2V0KSAmJiB0aGlzLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgc291cmNlW2tleV0pKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IF90aGlzLmV4dGVuZCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHNvdXJjZVtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJleHRlbmRBcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZEFycmF5KGFyclRvRXh0ZW5kLCByZXN1bHRBcnIpIHtcbiAgICAgICAgdmFyIGV4dGVuZGVkQXJyID0gW107XG4gICAgICAgIGFyclRvRXh0ZW5kLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGV4dGVuZGVkQXJyLnB1c2goVXRpbHMuZXh0ZW5kKHJlc3VsdEFyciwgaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyVG9FeHRlbmQgPSBleHRlbmRlZEFycjtcbiAgICAgICAgcmV0dXJuIGFyclRvRXh0ZW5kO1xuICAgICAgfSAvLyBJZiBtb250aCBjb3VudGVyIGV4Y2VlZHMgMTIsIGl0IHN0YXJ0cyBhZ2FpbiBmcm9tIDFcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb250aE1vZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoTW9kKG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBtb250aCAlIDEyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICAgICAgICBpZiAoVXRpbHMuaXMoJ0FycmF5Jywgc291cmNlKSkge1xuICAgICAgICAgIHZhciBjbG9uZVJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lUmVzdWx0W2ldID0gdGhpcy5jbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjbG9uZVJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pcygnTnVsbCcsIHNvdXJjZSkpIHtcbiAgICAgICAgICAvLyBmaXhlcyBhbiBpc3N1ZSB3aGVyZSBudWxsIHZhbHVlcyB3ZXJlIGNvbnZlcnRlZCB0byB7fVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzKCdEYXRlJywgc291cmNlKSkge1xuICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihzb3VyY2UpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBfY2xvbmVSZXN1bHQgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgIF9jbG9uZVJlc3VsdFtwcm9wXSA9IHRoaXMuY2xvbmUoc291cmNlW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2Nsb25lUmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibG9nMTBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicm91bmRUb0Jhc2UxMFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kVG9CYXNlMTAoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2cxMCh4KSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyb3VuZFRvQmFzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kVG9CYXNlKHgsIGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KGJhc2UsIE1hdGguZmxvb3IoTWF0aC5sb2coeCkgLyBNYXRoLmxvZyhiYXNlKSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXJzZU51bWJlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlTnVtYmVyKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gdmFsO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdHJpcE51bWJlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmlwTnVtYmVyKG51bSkge1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyO1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihudW0pID8gbnVtIDogcGFyc2VGbG9hdChudW0udG9QcmVjaXNpb24ocHJlY2lzaW9uKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJhbmRvbUlkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZG9tSWQoKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm5vRXhwb25lbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbm9FeHBvbmVudHModmFsKSB7XG4gICAgICAgIHZhciBkYXRhID0gU3RyaW5nKHZhbCkuc3BsaXQoL1tlRV0vKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAxKSByZXR1cm4gZGF0YVswXTtcbiAgICAgICAgdmFyIHogPSAnJyxcbiAgICAgICAgICAgIHNpZ24gPSB2YWwgPCAwID8gJy0nIDogJycsXG4gICAgICAgICAgICBzdHIgPSBkYXRhWzBdLnJlcGxhY2UoJy4nLCAnJyksXG4gICAgICAgICAgICBtYWcgPSBOdW1iZXIoZGF0YVsxXSkgKyAxO1xuXG4gICAgICAgIGlmIChtYWcgPCAwKSB7XG4gICAgICAgICAgeiA9IHNpZ24gKyAnMC4nO1xuXG4gICAgICAgICAgd2hpbGUgKG1hZysrKSB7XG4gICAgICAgICAgICB6ICs9ICcwJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geiArIHN0ci5yZXBsYWNlKC9eLS8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hZyAtPSBzdHIubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChtYWctLSkge1xuICAgICAgICAgIHogKz0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ciArIHo7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldERpbWVuc2lvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsKSB7XG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gICAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZWxlbWVudFdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIGVsZW1lbnRIZWlnaHQgLT0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICAgICAgICBlbGVtZW50V2lkdGggLT0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgICByZXR1cm4gW2VsZW1lbnRXaWR0aCwgZWxlbWVudEhlaWdodF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gICAgICAgIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxuICAgICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20sXG4gICAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICAgIHdpZHRoOiBlbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogZWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgeDogcmVjdC5sZWZ0LFxuICAgICAgICAgIHk6IHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldExhcmdlc3RTdHJpbmdGcm9tQXJyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFyZ2VzdFN0cmluZ0Zyb21BcnIoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIGIgPSBiLnJlZHVjZShmdW5jdGlvbiAoYWEsIGJiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhYS5sZW5ndGggPiBiYi5sZW5ndGggPyBhYSA6IGJiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYjtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiI2Fuc3dlci0xMjM0MjI3NVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImhleFRvUmdiYVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhleFRvUmdiYSgpIHtcbiAgICAgICAgdmFyIGhleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyM5OTk5OTknO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC42O1xuXG4gICAgICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDEpICE9PSAnIycpIHtcbiAgICAgICAgICBoZXggPSAnIzk5OTk5OSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaCA9IGhleC5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgICBoID0gaC5tYXRjaChuZXcgUmVnRXhwKCcoLnsnICsgaC5sZW5ndGggLyAzICsgJ30pJywgJ2cnKSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaFtpXSA9IHBhcnNlSW50KGhbaV0ubGVuZ3RoID09PSAxID8gaFtpXSArIGhbaV0gOiBoW2ldLCAxNik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSBoLnB1c2gob3BhY2l0eSk7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgaC5qb2luKCcsJykgKyAnKSc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE9wYWNpdHlGcm9tUkdCQVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wYWNpdHlGcm9tUkdCQShyZ2JhKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHJnYmEucmVwbGFjZSgvXi4qLCguKylcXCkvLCAnJDEnKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJnYjJoZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZ2IyaGV4KHJnYikge1xuICAgICAgICByZ2IgPSByZ2IubWF0Y2goL15yZ2JhP1tcXHMrXT9cXChbXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPy9pKTtcbiAgICAgICAgcmV0dXJuIHJnYiAmJiByZ2IubGVuZ3RoID09PSA0ID8gJyMnICsgKCcwJyArIHBhcnNlSW50KHJnYlsxXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICsgKCcwJyArIHBhcnNlSW50KHJnYlsyXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICsgKCcwJyArIHBhcnNlSW50KHJnYlszXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpIDogJyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzQ29sb3JIZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NvbG9ySGV4KGNvbG9yKSB7XG4gICAgICAgIHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpfCheI1swLTlBLUZdezh9JCkvaS50ZXN0KGNvbG9yKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0UG9seWdvblBvc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvbHlnb25Qb3Moc2l6ZSwgZGF0YVBvaW50c0xlbikge1xuICAgICAgICB2YXIgZG90c0FycmF5ID0gW107XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyIC8gZGF0YVBvaW50c0xlbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFQb2ludHNMZW47IGkrKykge1xuICAgICAgICAgIHZhciBjdXJQb3MgPSB7fTtcbiAgICAgICAgICBjdXJQb3MueCA9IHNpemUgKiBNYXRoLnNpbihpICogYW5nbGUpO1xuICAgICAgICAgIGN1clBvcy55ID0gLXNpemUgKiBNYXRoLmNvcyhpICogYW5nbGUpO1xuICAgICAgICAgIGRvdHNBcnJheS5wdXNoKGN1clBvcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZG90c0FycmF5O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwb2xhclRvQ2FydGVzaWFuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgICAgIHZhciBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcyAtIDkwKSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpLFxuICAgICAgICAgIHk6IGNlbnRlclkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZXNjYXBlU3RyaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgZXNjYXBlV2l0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gnO1xuICAgICAgICB2YXIgbmV3U3RyID0gc3RyLnRvU3RyaW5nKCkuc2xpY2UoKTtcbiAgICAgICAgbmV3U3RyID0gbmV3U3RyLnJlcGxhY2UoL1tgIH4hQCMkJV4mKigpfCtcXD0/OzonXCIsLjw+e31bXFxdXFxcXC9dL2dpLCBlc2NhcGVXaXRoKTtcbiAgICAgICAgcmV0dXJuIG5ld1N0cjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibmVnVG9aZXJvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmVnVG9aZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsIDwgMCA/IDAgOiB2YWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1vdmVJbmRleEluQXJyYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlSW5kZXhJbkFycmF5KGFyciwgb2xkX2luZGV4LCBuZXdfaW5kZXgpIHtcbiAgICAgICAgaWYgKG5ld19pbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGsgPSBuZXdfaW5kZXggLSBhcnIubGVuZ3RoICsgMTtcblxuICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyLnNwbGljZShuZXdfaW5kZXgsIDAsIGFyci5zcGxpY2Uob2xkX2luZGV4LCAxKVswXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4dHJhY3ROdW1iZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0TnVtYmVyKHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocy5yZXBsYWNlKC9bXlxcZC5dKi9nLCAnJykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaW5kQW5jZXN0b3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQW5jZXN0b3IoZWwsIGNscykge1xuICAgICAgICB3aGlsZSAoKGVsID0gZWwucGFyZW50RWxlbWVudCkgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhjbHMpKSB7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEVMc3R5bGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RUxzdHlsZXMoZWwsIHN0eWxlcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5rZXkgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNOdW1iZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiBwYXJzZUZsb2F0KE51bWJlcih2YWx1ZSkpID09PSB2YWx1ZSAmJiAhaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzRmxvYXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zsb2F0KG4pIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihuKSA9PT0gbiAmJiBuICUgMSAhPT0gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNTYWZhcmlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICAgICAgcmV0dXJuIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzRmlyZWZveFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRmlyZWZveCgpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAtMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNJRTExXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJRTExKCkge1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpICE9PSAtMSB8fCB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZignVHJpZGVudC8nKSA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNJRVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICB2YXIgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJyk7XG5cbiAgICAgICAgaWYgKG1zaWUgPiAwKSB7XG4gICAgICAgICAgLy8gSUUgMTAgb3Igb2xkZXIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyaWRlbnQgPSB1YS5pbmRleE9mKCdUcmlkZW50LycpO1xuXG4gICAgICAgIGlmICh0cmlkZW50ID4gMCkge1xuICAgICAgICAgIC8vIElFIDExID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgICAgICAgIHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcocnYgKyAzLCB1YS5pbmRleE9mKCcuJywgcnYpKSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdFZGdlLycpO1xuXG4gICAgICAgIGlmIChlZGdlID4gMCkge1xuICAgICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhlZGdlICsgNSwgdWEuaW5kZXhPZignLicsIGVkZ2UpKSwgMTApO1xuICAgICAgICB9IC8vIG90aGVyIGJyb3dzZXJcblxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVXRpbHM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBBbmltYXRpb24gQ2xhc3MuXG4gICAqXG4gICAqIEBtb2R1bGUgQW5pbWF0aW9uc1xuICAgKiovXG5cbiAgdmFyIEFuaW1hdGlvbnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbnMoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5pbWF0aW9ucyk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgICB0aGlzLnNldEVhc2luZ0Z1bmN0aW9ucygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBbmltYXRpb25zLCBbe1xuICAgICAga2V5OiBcInNldEVhc2luZ0Z1bmN0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVhc2luZ0Z1bmN0aW9ucygpIHtcbiAgICAgICAgdmFyIGVhc2luZztcbiAgICAgICAgaWYgKHRoaXMudy5nbG9iYWxzLmVhc2luZykgcmV0dXJuO1xuICAgICAgICB2YXIgdXNlckRlZmluZWRFYXNpbmcgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZWFzaW5nO1xuXG4gICAgICAgIHN3aXRjaCAodXNlckRlZmluZWRFYXNpbmcpIHtcbiAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlYXNpbmcgPSAnLSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZWFzZWluJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZWFzaW5nID0gJzwnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Vhc2VvdXQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlYXNpbmcgPSAnPic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZWFzZWlub3V0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZWFzaW5nID0gJzw+JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdzd2luZyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVhc2luZyA9IGZ1bmN0aW9uIGVhc2luZyhwb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IChwb3MgLT0gMSkgKiBwb3MgKiAoKHMgKyAxKSAqIHBvcyArIHMpICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYm91bmNlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZWFzaW5nID0gZnVuY3Rpb24gZWFzaW5nKHBvcykge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChwb3MgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gNy41NjI1ICogcG9zICogcG9zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zIDwgMiAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IDcuNTYyNSAqIChwb3MgLT0gMS41IC8gMi43NSkgKiBwb3MgKyAwLjc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zIDwgMi41IC8gMi43NSkge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gNy41NjI1ICogKHBvcyAtPSAyLjI1IC8gMi43NSkgKiBwb3MgKyAwLjkzNzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IDcuNTYyNSAqIChwb3MgLT0gMi42MjUgLyAyLjc1KSAqIHBvcyArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlbGFzdGljJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZWFzaW5nID0gZnVuY3Rpb24gZWFzaW5nKHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09ICEhcG9zKSByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBwb3MpICogTWF0aC5zaW4oKHBvcyAtIDAuMDc1KSAqICgyICogTWF0aC5QSSkgLyAwLjMpICsgMTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVhc2luZyA9ICc8Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLncuZ2xvYmFscy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFuaW1hdGVMaW5lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUxpbmUoZWwsIGZyb20sIHRvLCBzcGVlZCkge1xuICAgICAgICBlbC5hdHRyKGZyb20pLmFuaW1hdGUoc3BlZWQpLmF0dHIodG8pO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqKiBBbmltYXRlIHJhZGl1cyBvZiBhIGNpcmNsZSBlbGVtZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbmltYXRlTWFya2VyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZU1hcmtlcihlbCwgZnJvbSwgdG8sIHNwZWVkLCBlYXNpbmcsIGNiKSB7XG4gICAgICAgIGlmICghZnJvbSkgZnJvbSA9IDA7XG4gICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgIHI6IGZyb20sXG4gICAgICAgICAgd2lkdGg6IGZyb20sXG4gICAgICAgICAgaGVpZ2h0OiBmcm9tXG4gICAgICAgIH0pLmFuaW1hdGUoc3BlZWQsIGVhc2luZykuYXR0cih7XG4gICAgICAgICAgcjogdG8sXG4gICAgICAgICAgd2lkdGg6IHRvLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdG8uaGVpZ2h0XG4gICAgICAgIH0pLmFmdGVyQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgKiogQW5pbWF0ZSByYWRpdXMgYW5kIHBvc2l0aW9uIG9mIGEgY2lyY2xlIGVsZW1lbnRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFuaW1hdGVDaXJjbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlQ2lyY2xlKGVsLCBmcm9tLCB0bywgc3BlZWQsIGVhc2luZykge1xuICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICByOiBmcm9tLnIsXG4gICAgICAgICAgY3g6IGZyb20uY3gsXG4gICAgICAgICAgY3k6IGZyb20uY3lcbiAgICAgICAgfSkuYW5pbWF0ZShzcGVlZCwgZWFzaW5nKS5hdHRyKHtcbiAgICAgICAgICByOiB0by5yLFxuICAgICAgICAgIGN4OiB0by5jeCxcbiAgICAgICAgICBjeTogdG8uY3lcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICoqIEFuaW1hdGUgcmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbmltYXRlUmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVSZWN0KGVsLCBmcm9tLCB0bywgc3BlZWQsIGZuKSB7XG4gICAgICAgIGVsLmF0dHIoZnJvbSkuYW5pbWF0ZShzcGVlZCkuYXR0cih0bykuYWZ0ZXJBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYW5pbWF0ZVBhdGhzR3JhZHVhbGx5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVBhdGhzR3JhZHVhbGx5KHBhcmFtcykge1xuICAgICAgICB2YXIgZWwgPSBwYXJhbXMuZWwsXG4gICAgICAgICAgICByZWFsSW5kZXggPSBwYXJhbXMucmVhbEluZGV4LFxuICAgICAgICAgICAgaiA9IHBhcmFtcy5qLFxuICAgICAgICAgICAgZmlsbCA9IHBhcmFtcy5maWxsLFxuICAgICAgICAgICAgcGF0aEZyb20gPSBwYXJhbXMucGF0aEZyb20sXG4gICAgICAgICAgICBwYXRoVG8gPSBwYXJhbXMucGF0aFRvLFxuICAgICAgICAgICAgc3BlZWQgPSBwYXJhbXMuc3BlZWQsXG4gICAgICAgICAgICBkZWxheSA9IHBhcmFtcy5kZWxheTtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBkZWxheUZhY3RvciA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuYW5pbWF0ZUdyYWR1YWxseS5lbmFibGVkKSB7XG4gICAgICAgICAgZGVsYXlGYWN0b3IgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGVHcmFkdWFsbHkuZGVsYXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQgJiYgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkICYmIHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdiYXInKSB7XG4gICAgICAgICAgLy8gZGlzYWJsZWQgZHVlIHRvIHRoaXMgYnVnIC0gaHR0cHM6Ly9naXRodWIuY29tL2FwZXhjaGFydHMvdnVlLWFwZXhjaGFydHMvaXNzdWVzLzc1XG4gICAgICAgICAgZGVsYXlGYWN0b3IgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUubW9ycGhTVkcoZWwsIHJlYWxJbmRleCwgaiwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2xpbmUnICYmICF3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyAnc3Ryb2tlJyA6IGZpbGwsIHBhdGhGcm9tLCBwYXRoVG8sIHNwZWVkLCBkZWxheSAqIGRlbGF5RmFjdG9yKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2hvd0RlbGF5ZWRFbGVtZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dEZWxheWVkRWxlbWVudHMoKSB7XG4gICAgICAgIHRoaXMudy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGQuZWw7XG4gICAgICAgICAgZWxlLmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtZWxlbWVudC1oaWRkZW4nKTtcbiAgICAgICAgICBlbGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1oaWRkZW4tZWxlbWVudC1zaG93bicpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYW5pbWF0aW9uQ29tcGxldGVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0aW9uQ29tcGxldGVkKGVsKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICBpZiAody5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkKSByZXR1cm47XG4gICAgICAgIHcuZ2xvYmFscy5hbmltYXRpb25FbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0RlbGF5ZWRFbGVtZW50cygpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmFuaW1hdGlvbkVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5hbmltYXRpb25FbmQodGhpcy5jdHgsIHtcbiAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBTVkcuanMgYW5pbWF0aW9uIGZvciBtb3JwaGluZyBvbmUgcGF0aCB0byBhbm90aGVyXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibW9ycGhTVkdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3JwaFNWRyhlbCwgcmVhbEluZGV4LCBqLCBmaWxsLCBwYXRoRnJvbSwgcGF0aFRvLCBzcGVlZCwgZGVsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAoIXBhdGhGcm9tKSB7XG4gICAgICAgICAgcGF0aEZyb20gPSBlbC5hdHRyKCdwYXRoRnJvbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXRoVG8pIHtcbiAgICAgICAgICBwYXRoVG8gPSBlbC5hdHRyKCdwYXRoVG8nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXNhYmxlQW5pbWF0aW9uRm9yQ29ycnVwUGF0aCA9IGZ1bmN0aW9uIGRpc2FibGVBbmltYXRpb25Gb3JDb3JydXBQYXRoKHBhdGgpIHtcbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGFyJykge1xuICAgICAgICAgICAgLy8gcmFkYXIgY2hhcnQgZHJvcHMgdGhlIHBhdGggdG8gYm90dG9tIGFuZCBoZW5jZSBhIGNvcnJ1cCBwYXRoIGxvb2tzIHVnbHlcbiAgICAgICAgICAgIC8vIHRoZXJlZm9yZSwgZGlzYWJsZSBhbmltYXRpb24gZm9yIHN1Y2ggYSBjYXNlXG4gICAgICAgICAgICBzcGVlZCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFwiTSAwIFwiLmNvbmNhdCh3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFwYXRoRnJvbSB8fCBwYXRoRnJvbS5pbmRleE9mKCd1bmRlZmluZWQnKSA+IC0xIHx8IHBhdGhGcm9tLmluZGV4T2YoJ05hTicpID4gLTEpIHtcbiAgICAgICAgICBwYXRoRnJvbSA9IGRpc2FibGVBbmltYXRpb25Gb3JDb3JydXBQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhdGhUbyB8fCBwYXRoVG8uaW5kZXhPZigndW5kZWZpbmVkJykgPiAtMSB8fCBwYXRoVG8uaW5kZXhPZignTmFOJykgPiAtMSkge1xuICAgICAgICAgIHBhdGhUbyA9IGRpc2FibGVBbmltYXRpb25Gb3JDb3JydXBQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5zaG91bGRBbmltYXRlKSB7XG4gICAgICAgICAgc3BlZWQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwucGxvdChwYXRoRnJvbSkuYW5pbWF0ZSgxLCB3Lmdsb2JhbHMuZWFzaW5nLCBkZWxheSkucGxvdChwYXRoRnJvbSkuYW5pbWF0ZShzcGVlZCwgdy5nbG9iYWxzLmVhc2luZywgZGVsYXkpLnBsb3QocGF0aFRvKS5hZnRlckFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIG9yaWdpbmFsIG1vdW50IGZ1bmN0aW9uIGNhbiByZXR1cm4gdHJ1ZSBub3cgYXMgYW5pbWF0aW9uIGZpbmlzaGVkIGhlcmVcbiAgICAgICAgICBpZiAoVXRpbHMkMS5pc051bWJlcihqKSkge1xuICAgICAgICAgICAgaWYgKGogPT09IHcuZ2xvYmFscy5zZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aCAtIDIgJiYgdy5nbG9iYWxzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uQ29tcGxldGVkKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbGwgIT09ICdub25lJyAmJiB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgICAgaWYgKCF3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgcmVhbEluZGV4ID09PSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCAtIDEgfHwgdy5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbkNvbXBsZXRlZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuc2hvd0RlbGF5ZWRFbGVtZW50cygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQW5pbWF0aW9ucztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIEZpbHRlcnMgQ2xhc3MgZm9yIHNldHRpbmcgaG92ZXIvYWN0aXZlIHN0YXRlcyBvbiB0aGUgcGF0aHMuXG4gICAqXG4gICAqIEBtb2R1bGUgRm9ybWF0dGVyc1xuICAgKiovXG5cbiAgdmFyIEZpbHRlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlcnMoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsdGVycyk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgfSAvLyBjcmVhdGUgYSByZS11c2FibGUgZmlsdGVyIHdoaWNoIGNhbiBiZSBhcHBlbmRlZCBvdGhlciBmaWx0ZXIgZWZmZWN0cyBhbmQgYXBwbGllZCB0byBtdWx0aXBsZSBlbGVtZW50c1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRmlsdGVycywgW3tcbiAgICAgIGtleTogXCJnZXREZWZhdWx0RmlsdGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdEZpbHRlcihlbCwgaSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgZWwudW5maWx0ZXIodHJ1ZSk7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBuZXcgd2luZG93LlNWRy5GaWx0ZXIoKTtcbiAgICAgICAgZmlsdGVyLnNpemUoJzEyMCUnLCAnMTgwJScsICctNSUnLCAnLTQwJScpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMubm9ybWFsLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgdGhpcy5hcHBseUZpbHRlcihlbCwgaSwgdy5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIudHlwZSwgdy5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJvcFNoYWRvdyhlbCwgdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdywgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZE5vcm1hbEZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vcm1hbEZpbHRlcihlbCwgaSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudzsgLy8gcmV2ZXJ0IHNoYWRvdyBpZiBpdCB3YXMgdGhlcmVcbiAgICAgICAgLy8gYnV0LCBpZ25vcmUgbWFya2VyIGFzIG1hcmtlciBkb24ndCBoYXZlIGRyb3BzaGFkb3cgeWV0XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCAmJiAhZWwubm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbWFya2VyJykpIHtcbiAgICAgICAgICB0aGlzLmRyb3BTaGFkb3coZWwsIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3csIGkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFwcGVuZHMgZHJvcFNoYWRvdyB0byB0aGUgZmlsdGVyIG9iamVjdCB3aGljaCBjYW4gYmUgY2hhaW5lZCB3aXRoIG90aGVyIGZpbHRlciBlZmZlY3RzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkTGlnaHRlbkZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZExpZ2h0ZW5GaWx0ZXIoZWwsIGksIGF0dHJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBpbnRlbnNpdHkgPSBhdHRycy5pbnRlbnNpdHk7XG4gICAgICAgIGVsLnVuZmlsdGVyKHRydWUpO1xuICAgICAgICB2YXIgZmlsdGVyID0gbmV3IHdpbmRvdy5TVkcuRmlsdGVyKCk7XG4gICAgICAgIGVsLmZpbHRlcihmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgICAgdmFyIHNoYWRvd0F0dHIgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuXG4gICAgICAgICAgaWYgKHNoYWRvd0F0dHIuZW5hYmxlZCkge1xuICAgICAgICAgICAgZmlsdGVyID0gX3RoaXMuYWRkU2hhZG93KGFkZCwgaSwgc2hhZG93QXR0cik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciA9IGFkZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWx0ZXIuY29tcG9uZW50VHJhbnNmZXIoe1xuICAgICAgICAgICAgcmdiOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICAgICAgICBzbG9wZTogMS41LFxuICAgICAgICAgICAgICBpbnRlcmNlcHQ6IGludGVuc2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuZmlsdGVyZXIubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG5cbiAgICAgICAgdGhpcy5fc2NhbGVGaWx0ZXJTaXplKGVsLmZpbHRlcmVyLm5vZGUpO1xuICAgICAgfSAvLyBhcHBlbmRzIGRyb3BTaGFkb3cgdG8gdGhlIGZpbHRlciBvYmplY3Qgd2hpY2ggY2FuIGJlIGNoYWluZWQgd2l0aCBvdGhlciBmaWx0ZXIgZWZmZWN0c1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZERhcmtlbkZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERhcmtlbkZpbHRlcihlbCwgaSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBpbnRlbnNpdHkgPSBhdHRycy5pbnRlbnNpdHk7XG4gICAgICAgIGVsLnVuZmlsdGVyKHRydWUpO1xuICAgICAgICB2YXIgZmlsdGVyID0gbmV3IHdpbmRvdy5TVkcuRmlsdGVyKCk7XG4gICAgICAgIGVsLmZpbHRlcihmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgICAgdmFyIHNoYWRvd0F0dHIgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuXG4gICAgICAgICAgaWYgKHNoYWRvd0F0dHIuZW5hYmxlZCkge1xuICAgICAgICAgICAgZmlsdGVyID0gX3RoaXMyLmFkZFNoYWRvdyhhZGQsIGksIHNoYWRvd0F0dHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBhZGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsdGVyLmNvbXBvbmVudFRyYW5zZmVyKHtcbiAgICAgICAgICAgIHJnYjoge1xuICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgc2xvcGU6IGludGVuc2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuZmlsdGVyZXIubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG5cbiAgICAgICAgdGhpcy5fc2NhbGVGaWx0ZXJTaXplKGVsLmZpbHRlcmVyLm5vZGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhcHBseUZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RmlsdGVyKGVsLCBpLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIGludGVuc2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC41O1xuXG4gICAgICAgIHN3aXRjaCAoZmlsdGVyKSB7XG4gICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkTm9ybWFsRmlsdGVyKGVsLCBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRMaWdodGVuRmlsdGVyKGVsLCBpLCB7XG4gICAgICAgICAgICAgICAgaW50ZW5zaXR5OiBpbnRlbnNpdHlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZGFya2VuJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGREYXJrZW5GaWx0ZXIoZWwsIGksIHtcbiAgICAgICAgICAgICAgICBpbnRlbnNpdHk6IGludGVuc2l0eVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYXBwZW5kcyBkcm9wU2hhZG93IHRvIHRoZSBmaWx0ZXIgb2JqZWN0IHdoaWNoIGNhbiBiZSBjaGFpbmVkIHdpdGggb3RoZXIgZmlsdGVyIGVmZmVjdHNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRTaGFkb3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTaGFkb3coYWRkLCBpLCBhdHRycykge1xuICAgICAgICB2YXIgYmx1ciA9IGF0dHJzLmJsdXIsXG4gICAgICAgICAgICB0b3AgPSBhdHRycy50b3AsXG4gICAgICAgICAgICBsZWZ0ID0gYXR0cnMubGVmdCxcbiAgICAgICAgICAgIGNvbG9yID0gYXR0cnMuY29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5ID0gYXR0cnMub3BhY2l0eTtcbiAgICAgICAgdmFyIHNoYWRvd0JsdXIgPSBhZGQuZmxvb2QoQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvcltpXSA6IGNvbG9yLCBvcGFjaXR5KS5jb21wb3NpdGUoYWRkLnNvdXJjZUFscGhhLCAnaW4nKS5vZmZzZXQobGVmdCwgdG9wKS5nYXVzc2lhbkJsdXIoYmx1cikubWVyZ2UoYWRkLnNvdXJjZSk7XG4gICAgICAgIHJldHVybiBhZGQuYmxlbmQoYWRkLnNvdXJjZSwgc2hhZG93Qmx1cik7XG4gICAgICB9IC8vIGRpcmVjdGx5IGFkZHMgZHJvcFNoYWRvdyB0byB0aGUgZWxlbWVudCBhbmQgcmV0dXJucyB0aGUgc2FtZSBlbGVtZW50LlxuICAgICAgLy8gdGhlIG9ubHkgd2F5IGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhZGRTaGFkb3coKSBmdW5jdGlvbiBpcyB0aGF0IGFkZFNoYWRvdyBpcyBjaGFpbmFibGUgdG8gb3RoZXIgZmlsdGVycywgd2hpbGUgdGhpcyBmdW5jdGlvbiBkaXNjYXJkcyBhbGwgZmlsdGVycyBhbmQgYWRkIGRyb3BTaGFkb3dcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcm9wU2hhZG93XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJvcFNoYWRvdyhlbCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciB0b3AgPSBhdHRycy50b3AsXG4gICAgICAgICAgICBsZWZ0ID0gYXR0cnMubGVmdCxcbiAgICAgICAgICAgIGJsdXIgPSBhdHRycy5ibHVyLFxuICAgICAgICAgICAgY29sb3IgPSBhdHRycy5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHkgPSBhdHRycy5vcGFjaXR5LFxuICAgICAgICAgICAgbm9Vc2VyU3BhY2VPblVzZSA9IGF0dHJzLm5vVXNlclNwYWNlT25Vc2U7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICBlbC51bmZpbHRlcih0cnVlKTtcblxuICAgICAgICBpZiAoVXRpbHMkMS5pc0lFKCkgJiYgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGlhbEJhcicpIHtcbiAgICAgICAgICAvLyBpbiByYWRpYWxiYXIgY2hhcnRzLCBkcm9wc2hhZG93IGlzIGNsaXBwaW5nIGFjdHVhbCBkcmF3aW5nIGluIElFXG4gICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yW2ldIDogY29sb3I7XG4gICAgICAgIGVsLmZpbHRlcihmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgICAgdmFyIHNoYWRvd0JsdXIgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKFV0aWxzJDEuaXNTYWZhcmkoKSB8fCBVdGlscyQxLmlzRmlyZWZveCgpIHx8IFV0aWxzJDEuaXNJRSgpKSB7XG4gICAgICAgICAgICAvLyBzYWZhcmkvZmlyZWZveC9JRSBoYXZlIHNvbWUgYWx0ZXJuYXRpdmUgd2F5IHRvIHVzZSB0aGlzIGZpbHRlclxuICAgICAgICAgICAgc2hhZG93Qmx1ciA9IGFkZC5mbG9vZChjb2xvciwgb3BhY2l0eSkuY29tcG9zaXRlKGFkZC5zb3VyY2VBbHBoYSwgJ2luJykub2Zmc2V0KGxlZnQsIHRvcCkuZ2F1c3NpYW5CbHVyKGJsdXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGFkb3dCbHVyID0gYWRkLmZsb29kKGNvbG9yLCBvcGFjaXR5KS5jb21wb3NpdGUoYWRkLnNvdXJjZUFscGhhLCAnaW4nKS5vZmZzZXQobGVmdCwgdG9wKS5nYXVzc2lhbkJsdXIoYmx1cikubWVyZ2UoYWRkLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkLmJsZW5kKGFkZC5zb3VyY2UsIHNoYWRvd0JsdXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW5vVXNlclNwYWNlT25Vc2UpIHtcbiAgICAgICAgICBlbC5maWx0ZXJlci5ub2RlLnNldEF0dHJpYnV0ZSgnZmlsdGVyVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NjYWxlRmlsdGVyU2l6ZShlbC5maWx0ZXJlci5ub2RlKTtcblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFNlbGVjdGlvbkZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbkZpbHRlcihlbCwgcmVhbEluZGV4LCBkYXRhUG9pbnRJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbcmVhbEluZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tyZWFsSW5kZXhdLmluZGV4T2YoZGF0YVBvaW50SW5kZXgpID4gLTEpIHtcbiAgICAgICAgICAgIGVsLm5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUZpbHRlciA9IHcuY29uZmlnLnN0YXRlcy5hY3RpdmUuZmlsdGVyO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBseUZpbHRlcihlbCwgcmVhbEluZGV4LCBhY3RpdmVGaWx0ZXIudHlwZSwgYWN0aXZlRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NjYWxlRmlsdGVyU2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zY2FsZUZpbHRlclNpemUoZWwpIHtcbiAgICAgICAgdmFyIHNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgd2lkdGg6ICcyMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcyMDAlJyxcbiAgICAgICAgICB4OiAnLTUwJScsXG4gICAgICAgICAgeTogJy01MCUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGaWx0ZXJzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgR3JhcGhpY3MgQ2xhc3MgZm9yIGFsbCBkcmF3aW5nIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBtb2R1bGUgR3JhcGhpY3NcbiAgICoqL1xuXG4gIHZhciBHcmFwaGljcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhpY3MoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhpY3MpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgIH1cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICogIFNWRyBQYXRoIFJvdW5kaW5nIEZ1bmN0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqICBDb3B5cmlnaHQgKEMpIDIwMTQgWW9uYSBBcHBsZXRyZWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7ICAgICAgICAgICAqXG4gICAgICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gICAgICAgICAgKlxuICAgICAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSAgICAgICAqXG4gICAgICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgICAgICAgICAqXG4gICAgICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgKlxuICAgICAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kICAgICAgICpcbiAgICAgKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFNWRyBQYXRoIHJvdW5kaW5nIGZ1bmN0aW9uLiBUYWtlcyBhbiBpbnB1dCBwYXRoIHN0cmluZyBhbmQgb3V0cHV0cyBhIHBhdGhcbiAgICAgKiBzdHJpbmcgd2hlcmUgYWxsIGxpbmUtbGluZSBjb3JuZXJzIGhhdmUgYmVlbiByb3VuZGVkLiBPbmx5IHN1cHBvcnRzIGFic29sdXRlXG4gICAgICogY29tbWFuZHMgYXQgdGhlIG1vbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoU3RyaW5nIFRoZSBTVkcgaW5wdXQgcGF0aFxuICAgICAqIEBwYXJhbSByYWRpdXMgVGhlIGFtb3VudCB0byByb3VuZCB0aGUgY29ybmVycywgZWl0aGVyIGEgdmFsdWUgaW4gdGhlIFNWR1xuICAgICAqICAgICAgICAgICAgICAgY29vcmRpbmF0ZSBzcGFjZSwgb3IsIGlmIHVzZUZyYWN0aW9uYWxSYWRpdXMgaXMgdHJ1ZSwgYSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgICAgZnJvbSAwIHRvIDEuXG4gICAgICogQHJldHVybnMgQSBuZXcgU1ZHIHBhdGggc3RyaW5nIHdpdGggdGhlIHJvdW5kaW5nXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhHcmFwaGljcywgW3tcbiAgICAgIGtleTogXCJyb3VuZFBhdGhDb3JuZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmRQYXRoQ29ybmVycyhwYXRoU3RyaW5nLCByYWRpdXMpIHtcbiAgICAgICAgaWYgKHBhdGhTdHJpbmcuaW5kZXhPZignTmFOJykgPiAtMSkgcGF0aFN0cmluZyA9ICcnO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1vdmVUb3dhcmRzTGVuZ3RoKG1vdmluZ1BvaW50LCB0YXJnZXRQb2ludCwgYW1vdW50KSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gdGFyZ2V0UG9pbnQueCAtIG1vdmluZ1BvaW50Lng7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHRhcmdldFBvaW50LnkgLSBtb3ZpbmdQb2ludC55O1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KTtcbiAgICAgICAgICByZXR1cm4gbW92ZVRvd2FyZHNGcmFjdGlvbmFsKG1vdmluZ1BvaW50LCB0YXJnZXRQb2ludCwgTWF0aC5taW4oMSwgYW1vdW50IC8gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdmVUb3dhcmRzRnJhY3Rpb25hbChtb3ZpbmdQb2ludCwgdGFyZ2V0UG9pbnQsIGZyYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IG1vdmluZ1BvaW50LnggKyAodGFyZ2V0UG9pbnQueCAtIG1vdmluZ1BvaW50LngpICogZnJhY3Rpb24sXG4gICAgICAgICAgICB5OiBtb3ZpbmdQb2ludC55ICsgKHRhcmdldFBvaW50LnkgLSBtb3ZpbmdQb2ludC55KSAqIGZyYWN0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBBZGp1c3RzIHRoZSBlbmRpbmcgcG9zaXRpb24gb2YgYSBjb21tYW5kXG5cblxuICAgICAgICBmdW5jdGlvbiBhZGp1c3RDb21tYW5kKGNtZCwgbmV3UG9pbnQpIHtcbiAgICAgICAgICBpZiAoY21kLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGNtZFtjbWQubGVuZ3RoIC0gMl0gPSBuZXdQb2ludC54O1xuICAgICAgICAgICAgY21kW2NtZC5sZW5ndGggLSAxXSA9IG5ld1BvaW50Lnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEdpdmVzIGFuIHt4LCB5fSBvYmplY3QgZm9yIGEgY29tbWFuZCdzIGVuZGluZyBwb3NpdGlvblxuXG5cbiAgICAgICAgZnVuY3Rpb24gcG9pbnRGb3JDb21tYW5kKGNtZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwYXJzZUZsb2F0KGNtZFtjbWQubGVuZ3RoIC0gMl0pLFxuICAgICAgICAgICAgeTogcGFyc2VGbG9hdChjbWRbY21kLmxlbmd0aCAtIDFdKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gU3BsaXQgYXBhcnQgdGhlIHBhdGgsIGhhbmRpbmcgY29uY2F0b25hdGVkIGxldHRlcnMgYW5kIG51bWJlcnNcblxuXG4gICAgICAgIHZhciBwYXRoUGFydHMgPSBwYXRoU3RyaW5nLnNwbGl0KC9bLFxcc10vKS5yZWR1Y2UoZnVuY3Rpb24gKHBhcnRzLCBwYXJ0KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gcGFydC5tYXRjaCgnKFthLXpBLVpdKSguKyknKTtcblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChtYXRjaFsxXSk7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG1hdGNoWzJdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgIH0sIFtdKTsgLy8gR3JvdXAgdGhlIGNvbW1hbmRzIHdpdGggdGhlaXIgYXJndW1lbnRzIGZvciBlYXNpZXIgaGFuZGxpbmdcblxuICAgICAgICB2YXIgY29tbWFuZHMgPSBwYXRoUGFydHMucmVkdWNlKGZ1bmN0aW9uIChjb21tYW5kcywgcGFydCkge1xuICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHBhcnQpID09IHBhcnQgJiYgY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21tYW5kc1tjb21tYW5kcy5sZW5ndGggLSAxXS5wdXNoKHBhcnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKFtwYXJ0XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgICB9LCBbXSk7IC8vIFRoZSByZXN1bHRpbmcgY29tbWFuZHMsIGFsc28gZ3JvdXBlZFxuXG4gICAgICAgIHZhciByZXN1bHRDb21tYW5kcyA9IFtdO1xuXG4gICAgICAgIGlmIChjb21tYW5kcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBwb2ludEZvckNvbW1hbmQoY29tbWFuZHNbMF0pOyAvLyBIYW5kbGUgdGhlIGNsb3NlIHBhdGggY2FzZSB3aXRoIGEgXCJ2aXJ0dWFsXCIgY2xvc2luZyBsaW5lXG5cbiAgICAgICAgICB2YXIgdmlydHVhbENsb3NlTGluZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoY29tbWFuZHNbY29tbWFuZHMubGVuZ3RoIC0gMV1bMF0gPT0gJ1onICYmIGNvbW1hbmRzWzBdLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZpcnR1YWxDbG9zZUxpbmUgPSBbJ0wnLCBzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueV07XG4gICAgICAgICAgICBjb21tYW5kc1tjb21tYW5kcy5sZW5ndGggLSAxXSA9IHZpcnR1YWxDbG9zZUxpbmU7XG4gICAgICAgICAgfSAvLyBXZSBhbHdheXMgdXNlIHRoZSBmaXJzdCBjb21tYW5kIChidXQgaXQgbWF5IGJlIG11dGF0ZWQpXG5cblxuICAgICAgICAgIHJlc3VsdENvbW1hbmRzLnB1c2goY29tbWFuZHNbMF0pO1xuXG4gICAgICAgICAgZm9yICh2YXIgY21kSW5kZXggPSAxOyBjbWRJbmRleCA8IGNvbW1hbmRzLmxlbmd0aDsgY21kSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHByZXZDbWQgPSByZXN1bHRDb21tYW5kc1tyZXN1bHRDb21tYW5kcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBjdXJDbWQgPSBjb21tYW5kc1tjbWRJbmRleF07IC8vIEhhbmRsZSBjbG9zaW5nIGNhc2VcblxuICAgICAgICAgICAgdmFyIG5leHRDbWQgPSBjdXJDbWQgPT0gdmlydHVhbENsb3NlTGluZSA/IGNvbW1hbmRzWzFdIDogY29tbWFuZHNbY21kSW5kZXggKyAxXTsgLy8gTmFzdHkgbG9naWMgdG8gZGVjaWRlIGlmIHRoaXMgcGF0aCBpcyBhIGNhbmRpZGl0ZS5cblxuICAgICAgICAgICAgaWYgKG5leHRDbWQgJiYgcHJldkNtZCAmJiBwcmV2Q21kLmxlbmd0aCA+IDIgJiYgY3VyQ21kWzBdID09ICdMJyAmJiBuZXh0Q21kLmxlbmd0aCA+IDIgJiYgbmV4dENtZFswXSA9PSAnTCcpIHtcbiAgICAgICAgICAgICAgLy8gQ2FsYyB0aGUgcG9pbnRzIHdlJ3JlIGRlYWxpbmcgd2l0aFxuICAgICAgICAgICAgICB2YXIgcHJldlBvaW50ID0gcG9pbnRGb3JDb21tYW5kKHByZXZDbWQpO1xuICAgICAgICAgICAgICB2YXIgY3VyUG9pbnQgPSBwb2ludEZvckNvbW1hbmQoY3VyQ21kKTtcbiAgICAgICAgICAgICAgdmFyIG5leHRQb2ludCA9IHBvaW50Rm9yQ29tbWFuZChuZXh0Q21kKTsgLy8gVGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGN1dmUgYXJlIGp1c3Qgb3VyIHBvaW50IG1vdmVkIHRvd2FyZHMgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHBvaW50cywgcmVzcGVjdGl2bHlcblxuICAgICAgICAgICAgICB2YXIgY3VydmVTdGFydCwgY3VydmVFbmQ7XG4gICAgICAgICAgICAgIGN1cnZlU3RhcnQgPSBtb3ZlVG93YXJkc0xlbmd0aChjdXJQb2ludCwgcHJldlBvaW50LCByYWRpdXMpO1xuICAgICAgICAgICAgICBjdXJ2ZUVuZCA9IG1vdmVUb3dhcmRzTGVuZ3RoKGN1clBvaW50LCBuZXh0UG9pbnQsIHJhZGl1cyk7IC8vIEFkanVzdCB0aGUgY3VycmVudCBjb21tYW5kIGFuZCBhZGQgaXRcblxuICAgICAgICAgICAgICBhZGp1c3RDb21tYW5kKGN1ckNtZCwgY3VydmVTdGFydCk7XG4gICAgICAgICAgICAgIGN1ckNtZC5vcmlnUG9pbnQgPSBjdXJQb2ludDtcbiAgICAgICAgICAgICAgcmVzdWx0Q29tbWFuZHMucHVzaChjdXJDbWQpOyAvLyBUaGUgY3VydmUgY29udHJvbCBwb2ludHMgYXJlIGhhbGZ3YXkgYmV0d2VlbiB0aGUgc3RhcnQvZW5kIG9mIHRoZSBjdXJ2ZSBhbmRcbiAgICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHBvaW50XG5cbiAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29udHJvbCA9IG1vdmVUb3dhcmRzRnJhY3Rpb25hbChjdXJ2ZVN0YXJ0LCBjdXJQb2ludCwgMC41KTtcbiAgICAgICAgICAgICAgdmFyIGVuZENvbnRyb2wgPSBtb3ZlVG93YXJkc0ZyYWN0aW9uYWwoY3VyUG9pbnQsIGN1cnZlRW5kLCAwLjUpOyAvLyBDcmVhdGUgdGhlIGN1cnZlXG5cbiAgICAgICAgICAgICAgdmFyIGN1cnZlQ21kID0gWydDJywgc3RhcnRDb250cm9sLngsIHN0YXJ0Q29udHJvbC55LCBlbmRDb250cm9sLngsIGVuZENvbnRyb2wueSwgY3VydmVFbmQueCwgY3VydmVFbmQueV07IC8vIFNhdmUgdGhlIG9yaWdpbmFsIHBvaW50IGZvciBmcmFjdGlvbmFsIGNhbGN1bGF0aW9uc1xuXG4gICAgICAgICAgICAgIGN1cnZlQ21kLm9yaWdQb2ludCA9IGN1clBvaW50O1xuICAgICAgICAgICAgICByZXN1bHRDb21tYW5kcy5wdXNoKGN1cnZlQ21kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCBjb21tYW5kcyB0aGF0IGRvbid0IHF1YWxpZnlcbiAgICAgICAgICAgICAgcmVzdWx0Q29tbWFuZHMucHVzaChjdXJDbWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gRml4IHVwIHRoZSBzdGFydGluZyBwb2ludCBhbmQgcmVzdG9yZSB0aGUgY2xvc2UgcGF0aCBpZiB0aGUgcGF0aCB3YXMgb3JpZ25hbGx5IGNsb3NlZFxuXG5cbiAgICAgICAgICBpZiAodmlydHVhbENsb3NlTGluZSkge1xuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0UG9pbnQgPSBwb2ludEZvckNvbW1hbmQocmVzdWx0Q29tbWFuZHNbcmVzdWx0Q29tbWFuZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgcmVzdWx0Q29tbWFuZHMucHVzaChbJ1onXSk7XG4gICAgICAgICAgICBhZGp1c3RDb21tYW5kKHJlc3VsdENvbW1hbmRzWzBdLCBuZXdTdGFydFBvaW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Q29tbWFuZHMgPSBjb21tYW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRDb21tYW5kcy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgYykge1xuICAgICAgICAgIHJldHVybiBzdHIgKyBjLmpvaW4oJyAnKSArICcgJztcbiAgICAgICAgfSwgJycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3TGluZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciBsaW5lQ29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6ICcjYThhOGE4JztcbiAgICAgICAgdmFyIGRhc2hBcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBudWxsO1xuICAgICAgICB2YXIgc3Ryb2tlTGluZUNhcCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogJ2J1dHQnO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGxpbmUgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmxpbmUoKS5hdHRyKHtcbiAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgc3Ryb2tlOiBsaW5lQ29sb3IsXG4gICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBkYXNoQXJyYXksXG4gICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICdzdHJva2UtbGluZWNhcCc6IHN0cm9rZUxpbmVDYXBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3UmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdSZWN0KCkge1xuICAgICAgICB2YXIgeDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciB5MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgdmFyIHgyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICB2YXIgeTIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICAgIHZhciBjb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogJyNmZWZlZmUnO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogMTtcbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBudWxsO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gOCAmJiBhcmd1bWVudHNbOF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s4XSA6IG51bGw7XG4gICAgICAgIHZhciBzdHJva2VEYXNoQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gOSAmJiBhcmd1bWVudHNbOV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s5XSA6IDA7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcmVjdCA9IHcuZ2xvYmFscy5kb20uUGFwZXIucmVjdCgpO1xuICAgICAgICByZWN0LmF0dHIoe1xuICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgIHk6IHkxLFxuICAgICAgICAgIHdpZHRoOiB4MiA+IDAgPyB4MiA6IDAsXG4gICAgICAgICAgaGVpZ2h0OiB5MiA+IDAgPyB5MiA6IDAsXG4gICAgICAgICAgcng6IHJhZGl1cyxcbiAgICAgICAgICByeTogcmFkaXVzLFxuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoICE9PSBudWxsID8gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlQ29sb3IgIT09IG51bGwgPyBzdHJva2VDb2xvciA6ICdub25lJyxcbiAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHN0cm9rZURhc2hBcnJheVxuICAgICAgICB9KTsgLy8gZml4IGFwZXhjaGFydHMuanMjMTQxMFxuXG4gICAgICAgIHJlY3Qubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBjb2xvcik7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3UG9seWdvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQb2x5Z29uKHBvbHlnb25TdHJpbmcpIHtcbiAgICAgICAgdmFyIHN0cm9rZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyNlMWUxZTEnO1xuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBmaWxsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnbm9uZSc7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcG9seWdvbiA9IHcuZ2xvYmFscy5kb20uUGFwZXIucG9seWdvbihwb2x5Z29uU3RyaW5nKS5hdHRyKHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdDaXJjbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q2lyY2xlKHJhZGl1cykge1xuICAgICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICBpZiAocmFkaXVzIDwgMCkgcmFkaXVzID0gMDtcbiAgICAgICAgdmFyIGMgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmNpcmNsZShyYWRpdXMgKiAyKTtcblxuICAgICAgICBpZiAoYXR0cnMgIT09IG51bGwpIHtcbiAgICAgICAgICBjLmF0dHIoYXR0cnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdQYXRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BhdGgoX3JlZikge1xuICAgICAgICB2YXIgX3JlZiRkID0gX3JlZi5kLFxuICAgICAgICAgICAgZCA9IF9yZWYkZCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGQsXG4gICAgICAgICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHZvaWQgMCA/ICcjYThhOGE4JyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHZvaWQgMCA/IDEgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgICAgICAgIF9yZWYkZmlsbE9wYWNpdHkgPSBfcmVmLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgZmlsbE9wYWNpdHkgPSBfcmVmJGZpbGxPcGFjaXR5ID09PSB2b2lkIDAgPyAxIDogX3JlZiRmaWxsT3BhY2l0eSxcbiAgICAgICAgICAgIF9yZWYkc3Ryb2tlT3BhY2l0eSA9IF9yZWYuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHkgPSBfcmVmJHN0cm9rZU9wYWNpdHkgPT09IHZvaWQgMCA/IDEgOiBfcmVmJHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICBjbGFzc2VzID0gX3JlZi5jbGFzc2VzLFxuICAgICAgICAgICAgX3JlZiRzdHJva2VMaW5lY2FwID0gX3JlZi5zdHJva2VMaW5lY2FwLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWNhcCA9IF9yZWYkc3Ryb2tlTGluZWNhcCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkc3Ryb2tlTGluZWNhcCxcbiAgICAgICAgICAgIF9yZWYkc3Ryb2tlRGFzaEFycmF5ID0gX3JlZi5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSBfcmVmJHN0cm9rZURhc2hBcnJheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAoc3Ryb2tlTGluZWNhcCA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0cm9rZUxpbmVjYXAgPSB3LmNvbmZpZy5zdHJva2UubGluZUNhcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkLmluZGV4T2YoJ3VuZGVmaW5lZCcpID4gLTEgfHwgZC5pbmRleE9mKCdOYU4nKSA+IC0xKSB7XG4gICAgICAgICAgZCA9IFwiTSAwIFwiLmNvbmNhdCh3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IHcuZ2xvYmFscy5kb20uUGFwZXIucGF0aChkKS5hdHRyKHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBmaWxsT3BhY2l0eSxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICdzdHJva2UtbGluZWNhcCc6IHN0cm9rZUxpbmVjYXAsXG4gICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5Jzogc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ3JvdXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGcgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmdyb3VwKCk7XG5cbiAgICAgICAgaWYgKGF0dHJzICE9PSBudWxsKSB7XG4gICAgICAgICAgZy5hdHRyKGF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAgIHZhciBtb3ZlID0gWydNJywgeCwgeV0uam9pbignICcpO1xuICAgICAgICByZXR1cm4gbW92ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGluZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmUoeCwgeSkge1xuICAgICAgICB2YXIgaE9SdiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgdmFyIGxpbmUgPSBudWxsO1xuXG4gICAgICAgIGlmIChoT1J2ID09PSBudWxsKSB7XG4gICAgICAgICAgbGluZSA9IFsnIEwnLCB4LCB5XS5qb2luKCcgJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaE9SdiA9PT0gJ0gnKSB7XG4gICAgICAgICAgbGluZSA9IFsnIEgnLCB4XS5qb2luKCcgJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaE9SdiA9PT0gJ1YnKSB7XG4gICAgICAgICAgbGluZSA9IFsnIFYnLCB5XS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3VydmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZSh4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICB2YXIgY3VydmUgPSBbJ0MnLCB4MSwgeTEsIHgyLCB5MiwgeCwgeV0uam9pbignICcpO1xuICAgICAgICByZXR1cm4gY3VydmU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInF1YWRyYXRpY0N1cnZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcXVhZHJhdGljQ3VydmUoeDEsIHkxLCB4LCB5KSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IFsnUScsIHgxLCB5MSwgeCwgeV0uam9pbignICcpO1xuICAgICAgICByZXR1cm4gY3VydmU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFyY1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFyYyhyeCwgcnksIGF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBmYWxzZTtcbiAgICAgICAgdmFyIGNvb3JkID0gJ0EnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIGNvb3JkID0gJ2EnO1xuICAgICAgICB2YXIgYXJjID0gW2Nvb3JkLCByeCwgcnksIGF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHldLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGFyYztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEdyYXBoaWNzXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH1cbiAgICAgICAqICBpID0gc2VyaWVzJ3MgaW5kZXhcbiAgICAgICAqICByZWFsSW5kZXggPSByZWFsSW5kZXggaXMgc2VyaWVzJ3MgYWN0dWFsIGluZGV4IHdoZW4gaXQgd2FzIGRyYXduIHRpbWUuIEFmdGVyIHNldmVyYWwgcmVkcmF3cywgdGhlIGl0ZXJhdGluZyBcImlcIiBtYXkgY2hhbmdlIGluIGxvb3BzLCBidXQgcmVhbEluZGV4IGRvZXNuJ3RcbiAgICAgICAqICBwYXRoRnJvbSA9IGV4aXN0aW5nIHBhdGhGcm9tIHRvIGFuaW1hdGVUb1xuICAgICAgICogIHBhdGhUbyA9IG5ldyBQYXRoIHRvIHdoaWNoIGQgYXR0ciB3aWxsIGJlIGFuaW1hdGVkIGZyb20gcGF0aEZyb20gdG8gcGF0aFRvXG4gICAgICAgKiAgc3Ryb2tlID0gbGluZSBDb2xvclxuICAgICAgICogIHN0cm9rZVdpZHRoID0gd2lkdGggb2YgcGF0aCBMaW5lXG4gICAgICAgKiAgZmlsbCA9IGl0IGNhbiBiZSBncmFkaWVudCwgc2luZ2xlIGNvbG9yLCBwYXR0ZXJuIG9yIGltYWdlXG4gICAgICAgKiAgYW5pbWF0aW9uRGVsYXkgPSBob3cgbXVjaCB0byBkZWxheSB3aGVuIHN0YXJ0aW5nIGFuaW1hdGlvbiAoaW4gbWlsbGlzZWNvbmRzKVxuICAgICAgICogIGRhdGFDaGFuZ2VTcGVlZCA9IGZvciBkeW5hbWljIGFuaW1hdGlvbnMsIHdoZW4gZGF0YSBjaGFuZ2VzXG4gICAgICAgKiAgY2xhc3NOYW1lID0gY2xhc3MgYXR0cmlidXRlIHRvIGFkZFxuICAgICAgICogQHJldHVybiB7b2JqZWN0fSBzdmcuanMgcGF0aCBvYmplY3RcbiAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJQYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclBhdGhzKF9yZWYyKSB7XG4gICAgICAgIHZhciBqID0gX3JlZjIuaixcbiAgICAgICAgICAgIHJlYWxJbmRleCA9IF9yZWYyLnJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGcm9tID0gX3JlZjIucGF0aEZyb20sXG4gICAgICAgICAgICBwYXRoVG8gPSBfcmVmMi5wYXRoVG8sXG4gICAgICAgICAgICBzdHJva2UgPSBfcmVmMi5zdHJva2UsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYyLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWNhcCA9IF9yZWYyLnN0cm9rZUxpbmVjYXAsXG4gICAgICAgICAgICBmaWxsID0gX3JlZjIuZmlsbCxcbiAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5ID0gX3JlZjIuYW5pbWF0aW9uRGVsYXksXG4gICAgICAgICAgICBpbml0aWFsU3BlZWQgPSBfcmVmMi5pbml0aWFsU3BlZWQsXG4gICAgICAgICAgICBkYXRhQ2hhbmdlU3BlZWQgPSBfcmVmMi5kYXRhQ2hhbmdlU3BlZWQsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICAgICAgICBfcmVmMiRzaG91bGRDbGlwVG9HcmkgPSBfcmVmMi5zaG91bGRDbGlwVG9HcmlkLFxuICAgICAgICAgICAgc2hvdWxkQ2xpcFRvR3JpZCA9IF9yZWYyJHNob3VsZENsaXBUb0dyaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyJHNob3VsZENsaXBUb0dyaSxcbiAgICAgICAgICAgIF9yZWYyJGJpbmRFdmVudHNPblBhdCA9IF9yZWYyLmJpbmRFdmVudHNPblBhdGhzLFxuICAgICAgICAgICAgYmluZEV2ZW50c09uUGF0aHMgPSBfcmVmMiRiaW5kRXZlbnRzT25QYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRiaW5kRXZlbnRzT25QYXQsXG4gICAgICAgICAgICBfcmVmMiRkcmF3U2hhZG93ID0gX3JlZjIuZHJhd1NoYWRvdyxcbiAgICAgICAgICAgIGRyYXdTaGFkb3cgPSBfcmVmMiRkcmF3U2hhZG93ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIkZHJhd1NoYWRvdztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICB2YXIgYW5pbSA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgICAgIHZhciBkeW5hbWljQW5pbSA9IGluaXRpYWxBbmltICYmIHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQ7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB2YXIgc2hvdWxkQW5pbWF0ZSA9ICEhKGluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCB8fCBkeW5hbWljQW5pbSAmJiB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgJiYgdy5nbG9iYWxzLnNob3VsZEFuaW1hdGUpO1xuXG4gICAgICAgIGlmIChzaG91bGRBbmltYXRlKSB7XG4gICAgICAgICAgZCA9IHBhdGhGcm9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGQgPSBwYXRoVG87XG4gICAgICAgICAgdy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJva2VEYXNoQXJyYXlPcHQgPSB3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5O1xuICAgICAgICB2YXIgc3Ryb2tlRGFzaEFycmF5ID0gMDtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHJva2VEYXNoQXJyYXlPcHQpKSB7XG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gc3Ryb2tlRGFzaEFycmF5T3B0W3JlYWxJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gdy5jb25maWcuc3Ryb2tlLmRhc2hBcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZHJhd1BhdGgoe1xuICAgICAgICAgIGQ6IGQsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgICAgY2xhc3NlczogY2xhc3NOYW1lLFxuICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IHN0cm9rZUxpbmVjYXAsXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiBzdHJva2VEYXNoQXJyYXlcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLmF0dHIoJ2luZGV4JywgcmVhbEluZGV4KTtcblxuICAgICAgICBpZiAoc2hvdWxkQ2xpcFRvR3JpZCkge1xuICAgICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgICAgJ2NsaXAtcGF0aCc6IFwidXJsKCNncmlkUmVjdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIGNvbnN0IGRlZmF1bHRGaWx0ZXIgPSBlbC5maWx0ZXJlclxuXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5ub3JtYWwuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgIGZpbHRlcnMuZ2V0RGVmYXVsdEZpbHRlcihlbCwgcmVhbEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkICYmIGRyYXdTaGFkb3cpIHtcbiAgICAgICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkT25TZXJpZXMgfHwgdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkT25TZXJpZXMgJiYgdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkT25TZXJpZXMuaW5kZXhPZihyZWFsSW5kZXgpICE9PSAtMSkge1xuICAgICAgICAgICAgICB2YXIgc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsLCBzaGFkb3csIHJlYWxJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpbmRFdmVudHNPblBhdGhzKSB7XG4gICAgICAgICAgZWwubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5wYXRoTW91c2VFbnRlci5iaW5kKHRoaXMsIGVsKSk7XG4gICAgICAgICAgZWwubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5wYXRoTW91c2VMZWF2ZS5iaW5kKHRoaXMsIGVsKSk7XG4gICAgICAgICAgZWwubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnBhdGhNb3VzZURvd24uYmluZCh0aGlzLCBlbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVmYXVsdEFuaW1hdGVPcHRzID0ge1xuICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICBkZWxheTogYW5pbWF0aW9uRGVsYXlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5yZXNpemVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICBhbmltLmFuaW1hdGVQYXRoc0dyYWR1YWxseShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdEFuaW1hdGVPcHRzKSwge30sIHtcbiAgICAgICAgICAgIHNwZWVkOiBpbml0aWFsU3BlZWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5yZXNpemVkIHx8ICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGFuaW0uc2hvd0RlbGF5ZWRFbGVtZW50cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgJiYgZHluYW1pY0FuaW0gJiYgc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgIGFuaW0uYW5pbWF0ZVBhdGhzR3JhZHVhbGx5KF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0QW5pbWF0ZU9wdHMpLCB7fSwge1xuICAgICAgICAgICAgc3BlZWQ6IGRhdGFDaGFuZ2VTcGVlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1BhdHRlcm5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGF0dGVybihzdHlsZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgc3Ryb2tlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnI2E4YThhOCc7XG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBwID0gdy5nbG9iYWxzLmRvbS5QYXBlci5wYXR0ZXJuKHdpZHRoLCBoZWlnaHQsIGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgICBpZiAoc3R5bGUgPT09ICdob3Jpem9udGFsTGluZXMnKSB7XG4gICAgICAgICAgICBhZGQubGluZSgwLCAwLCBoZWlnaHQsIDApLnN0cm9rZSh7XG4gICAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aCArIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICd2ZXJ0aWNhbExpbmVzJykge1xuICAgICAgICAgICAgYWRkLmxpbmUoMCwgMCwgMCwgd2lkdGgpLnN0cm9rZSh7XG4gICAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aCArIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdzbGFudGVkTGluZXMnKSB7XG4gICAgICAgICAgICBhZGQubGluZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5zdHJva2Uoe1xuICAgICAgICAgICAgICBjb2xvcjogc3Ryb2tlLFxuICAgICAgICAgICAgICB3aWR0aDogc3Ryb2tlV2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdzcXVhcmVzJykge1xuICAgICAgICAgICAgYWRkLnJlY3Qod2lkdGgsIGhlaWdodCkuZmlsbCgnbm9uZScpLnN0cm9rZSh7XG4gICAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ2NpcmNsZXMnKSB7XG4gICAgICAgICAgICBhZGQuY2lyY2xlKHdpZHRoKS5maWxsKCdub25lJykuc3Ryb2tlKHtcbiAgICAgICAgICAgICAgY29sb3I6IHN0cm9rZSxcbiAgICAgICAgICAgICAgd2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0dyYWRpZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0dyYWRpZW50KHN0eWxlLCBnZnJvbSwgZ3RvLCBvcGFjaXR5RnJvbSwgb3BhY2l0eVRvKSB7XG4gICAgICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuICAgICAgICB2YXIgc3RvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IG51bGw7XG4gICAgICAgIHZhciBjb2xvclN0b3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBudWxsO1xuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDogMDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBnO1xuXG4gICAgICAgIGlmIChnZnJvbS5sZW5ndGggPCA5ICYmIGdmcm9tLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZSBoZXggY29udGFpbnMgYWxwaGEgYW5kIGlzIG9mIDkgZGlnaXQsIHNraXAgdGhlIG9wYWNpdHlcbiAgICAgICAgICBnZnJvbSA9IFV0aWxzJDEuaGV4VG9SZ2JhKGdmcm9tLCBvcGFjaXR5RnJvbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3RvLmxlbmd0aCA8IDkgJiYgZ3RvLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgICAgIGd0byA9IFV0aWxzJDEuaGV4VG9SZ2JhKGd0bywgb3BhY2l0eVRvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdG9wMSA9IDA7XG4gICAgICAgIHZhciBzdG9wMiA9IDE7XG4gICAgICAgIHZhciBzdG9wMyA9IDE7XG4gICAgICAgIHZhciBzdG9wNCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHN0b3BzICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RvcDEgPSB0eXBlb2Ygc3RvcHNbMF0gIT09ICd1bmRlZmluZWQnID8gc3RvcHNbMF0gLyAxMDAgOiAwO1xuICAgICAgICAgIHN0b3AyID0gdHlwZW9mIHN0b3BzWzFdICE9PSAndW5kZWZpbmVkJyA/IHN0b3BzWzFdIC8gMTAwIDogMTtcbiAgICAgICAgICBzdG9wMyA9IHR5cGVvZiBzdG9wc1syXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdG9wc1syXSAvIDEwMCA6IDE7XG4gICAgICAgICAgc3RvcDQgPSB0eXBlb2Ygc3RvcHNbM10gIT09ICd1bmRlZmluZWQnID8gc3RvcHNbM10gLyAxMDAgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhZGlhbCA9ICEhKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BpZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BvbGFyQXJlYScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2J1YmJsZScpO1xuXG4gICAgICAgIGlmIChjb2xvclN0b3BzID09PSBudWxsIHx8IGNvbG9yU3RvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuZ3JhZGllbnQocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJywgZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICAgIHN0b3AuYXQoc3RvcDEsIGdmcm9tLCBvcGFjaXR5RnJvbSk7XG4gICAgICAgICAgICBzdG9wLmF0KHN0b3AyLCBndG8sIG9wYWNpdHlUbyk7XG4gICAgICAgICAgICBzdG9wLmF0KHN0b3AzLCBndG8sIG9wYWNpdHlUbyk7XG5cbiAgICAgICAgICAgIGlmIChzdG9wNCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdG9wLmF0KHN0b3A0LCBnZnJvbSwgb3BhY2l0eUZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGcgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmdyYWRpZW50KHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnRTdG9wcyA9IEFycmF5LmlzQXJyYXkoY29sb3JTdG9wc1tpXSkgPyBjb2xvclN0b3BzW2ldIDogY29sb3JTdG9wcztcbiAgICAgICAgICAgIGdyYWRpZW50U3RvcHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICBzdG9wLmF0KHMub2Zmc2V0IC8gMTAwLCBzLmNvbG9yLCBzLm9wYWNpdHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJhZGlhbCkge1xuICAgICAgICAgIGlmIChzdHlsZSA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgZy5mcm9tKDAsIDApLnRvKDAsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdkaWFnb25hbCcpIHtcbiAgICAgICAgICAgIGcuZnJvbSgwLCAwKS50bygxLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGcuZnJvbSgwLCAxKS50bygxLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnZGlhZ29uYWwyJykge1xuICAgICAgICAgICAgZy5mcm9tKDEsIDApLnRvKDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2ZmeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgICAgIHZhciBvZmZ5ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdidWJibGUnKSB7XG4gICAgICAgICAgICBnLmF0dHIoe1xuICAgICAgICAgICAgICBncmFkaWVudFVuaXRzOiAndXNlclNwYWNlT25Vc2UnLFxuICAgICAgICAgICAgICBjeDogb2ZmeCxcbiAgICAgICAgICAgICAgY3k6IG9mZnksXG4gICAgICAgICAgICAgIHI6IHNpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLmF0dHIoe1xuICAgICAgICAgICAgICBjeDogMC41LFxuICAgICAgICAgICAgICBjeTogMC41LFxuICAgICAgICAgICAgICByOiAwLjgsXG4gICAgICAgICAgICAgIGZ4OiAwLjIsXG4gICAgICAgICAgICAgIGZ5OiAwLjJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRUZXh0QmFzZWRPbk1heFdpZHRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dEJhc2VkT25NYXhXaWR0aChfcmVmMykge1xuICAgICAgICB2YXIgdGV4dCA9IF9yZWYzLnRleHQsXG4gICAgICAgICAgICBtYXhXaWR0aCA9IF9yZWYzLm1heFdpZHRoLFxuICAgICAgICAgICAgZm9udFNpemUgPSBfcmVmMy5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfcmVmMy5mb250RmFtaWx5O1xuICAgICAgICB2YXIgdFJlY3RzID0gdGhpcy5nZXRUZXh0UmVjdHModGV4dCwgZm9udFNpemUsIGZvbnRGYW1pbHkpO1xuICAgICAgICB2YXIgd29yZFdpZHRoID0gdFJlY3RzLndpZHRoIC8gdGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciB3b3Jkc0Jhc2VkT25XaWR0aCA9IE1hdGguZmxvb3IobWF4V2lkdGggLyB3b3JkV2lkdGgpO1xuXG4gICAgICAgIGlmIChtYXhXaWR0aCA8IHRSZWN0cy53aWR0aCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIHdvcmRzQmFzZWRPbldpZHRoIC0gMykgKyAnLi4uJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3VGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUZXh0KF9yZWY0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHggPSBfcmVmNC54LFxuICAgICAgICAgICAgeSA9IF9yZWY0LnksXG4gICAgICAgICAgICB0ZXh0ID0gX3JlZjQudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSBfcmVmNC50ZXh0QW5jaG9yLFxuICAgICAgICAgICAgZm9udFNpemUgPSBfcmVmNC5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfcmVmNC5mb250RmFtaWx5LFxuICAgICAgICAgICAgZm9udFdlaWdodCA9IF9yZWY0LmZvbnRXZWlnaHQsXG4gICAgICAgICAgICBmb3JlQ29sb3IgPSBfcmVmNC5mb3JlQ29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5ID0gX3JlZjQub3BhY2l0eSxcbiAgICAgICAgICAgIG1heFdpZHRoID0gX3JlZjQubWF4V2lkdGgsXG4gICAgICAgICAgICBfcmVmNCRjc3NDbGFzcyA9IF9yZWY0LmNzc0NsYXNzLFxuICAgICAgICAgICAgY3NzQ2xhc3MgPSBfcmVmNCRjc3NDbGFzcyA9PT0gdm9pZCAwID8gJycgOiBfcmVmNCRjc3NDbGFzcyxcbiAgICAgICAgICAgIF9yZWY0JGlzUGxhaW5UZXh0ID0gX3JlZjQuaXNQbGFpblRleHQsXG4gICAgICAgICAgICBpc1BsYWluVGV4dCA9IF9yZWY0JGlzUGxhaW5UZXh0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjQkaXNQbGFpblRleHQ7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciB0cnVuY2F0ZWRUZXh0ID0gdGV4dDtcblxuICAgICAgICBpZiAoIXRleHRBbmNob3IpIHtcbiAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm9yZUNvbG9yIHx8ICFmb3JlQ29sb3IubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yZUNvbG9yID0gdy5jb25maWcuY2hhcnQuZm9yZUNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgICAgZm9udFNpemUgPSBmb250U2l6ZSB8fCAnMTFweCc7XG4gICAgICAgIGZvbnRXZWlnaHQgPSBmb250V2VpZ2h0IHx8ICdyZWd1bGFyJztcbiAgICAgICAgdmFyIGNvbW1vblByb3BzID0ge1xuICAgICAgICAgIG1heFdpZHRoOiBtYXhXaWR0aCxcbiAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZWxUZXh0O1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHQpKSB7XG4gICAgICAgICAgZWxUZXh0ID0gdy5nbG9iYWxzLmRvbS5QYXBlci50ZXh0KGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0cnVuY2F0ZWRUZXh0ID0gdGV4dFtpXTtcblxuICAgICAgICAgICAgICBpZiAobWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0cnVuY2F0ZWRUZXh0ID0gX3RoaXMuZ2V0VGV4dEJhc2VkT25NYXhXaWR0aChfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0W2ldXG4gICAgICAgICAgICAgICAgfSwgY29tbW9uUHJvcHMpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGkgPT09IDAgPyBhZGQudHNwYW4odHJ1bmNhdGVkVGV4dCkgOiBhZGQudHNwYW4odHJ1bmNhdGVkVGV4dCkubmV3TGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICAgICAgdHJ1bmNhdGVkVGV4dCA9IHRoaXMuZ2V0VGV4dEJhc2VkT25NYXhXaWR0aChfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICAgIH0sIGNvbW1vblByb3BzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxUZXh0ID0gaXNQbGFpblRleHQgPyB3Lmdsb2JhbHMuZG9tLlBhcGVyLnBsYWluKHRleHQpIDogdy5nbG9iYWxzLmRvbS5QYXBlci50ZXh0KGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGQudHNwYW4odHJ1bmNhdGVkVGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbFRleHQuYXR0cih7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgICd0ZXh0LWFuY2hvcic6IHRleHRBbmNob3IsXG4gICAgICAgICAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2F1dG8nLFxuICAgICAgICAgICdmb250LXNpemUnOiBmb250U2l6ZSxcbiAgICAgICAgICAnZm9udC1mYW1pbHknOiBmb250RmFtaWx5LFxuICAgICAgICAgICdmb250LXdlaWdodCc6IGZvbnRXZWlnaHQsXG4gICAgICAgICAgZmlsbDogZm9yZUNvbG9yLFxuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy10ZXh0ICcgKyBjc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxUZXh0Lm5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIGVsVGV4dC5ub2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICByZXR1cm4gZWxUZXh0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3TWFya2VyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd01hcmtlcih4LCB5LCBvcHRzKSB7XG4gICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgIHZhciBzaXplID0gb3B0cy5wU2l6ZSB8fCAwO1xuICAgICAgICB2YXIgZWxQb2ludCA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9wdHMuc2hhcGUgPT09ICdzcXVhcmUnIHx8IG9wdHMuc2hhcGUgPT09ICdyZWN0Jykge1xuICAgICAgICAgIHZhciByYWRpdXMgPSBvcHRzLnBSYWRpdXMgPT09IHVuZGVmaW5lZCA/IHNpemUgLyAyIDogb3B0cy5wUmFkaXVzO1xuXG4gICAgICAgICAgaWYgKHkgPT09IG51bGwgfHwgIXNpemUpIHtcbiAgICAgICAgICAgIHNpemUgPSAwO1xuICAgICAgICAgICAgcmFkaXVzID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgblNpemUgPSBzaXplICogMS4yICsgcmFkaXVzO1xuICAgICAgICAgIHZhciBwID0gdGhpcy5kcmF3UmVjdChuU2l6ZSwgblNpemUsIG5TaXplLCBuU2l6ZSwgcmFkaXVzKTtcbiAgICAgICAgICBwLmF0dHIoe1xuICAgICAgICAgICAgeDogeCAtIG5TaXplIC8gMixcbiAgICAgICAgICAgIHk6IHkgLSBuU2l6ZSAvIDIsXG4gICAgICAgICAgICBjeDogeCxcbiAgICAgICAgICAgIGN5OiB5LFxuICAgICAgICAgICAgY2xhc3M6IG9wdHMuY2xhc3MgPyBvcHRzLmNsYXNzIDogJycsXG4gICAgICAgICAgICBmaWxsOiBvcHRzLnBvaW50RmlsbENvbG9yLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wdHMucG9pbnRGaWxsT3BhY2l0eSA/IG9wdHMucG9pbnRGaWxsT3BhY2l0eSA6IDEsXG4gICAgICAgICAgICBzdHJva2U6IG9wdHMucG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBvcHRzLnBvaW50U3Ryb2tlV2lkdGggPyBvcHRzLnBvaW50U3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogb3B0cy5wb2ludFN0cm9rZU9wYWNpdHkgPyBvcHRzLnBvaW50U3Ryb2tlT3BhY2l0eSA6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFBvaW50ID0gcDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLnNoYXBlID09PSAnY2lyY2xlJyB8fCAhb3B0cy5zaGFwZSkge1xuICAgICAgICAgIGlmICghVXRpbHMkMS5pc051bWJlcih5KSkge1xuICAgICAgICAgICAgc2l6ZSA9IDA7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICB9IC8vIGxldCBuU2l6ZSA9IHNpemUgLSBvcHRzLnBSYWRpdXMgLyAyIDwgMCA/IDAgOiBzaXplIC0gb3B0cy5wUmFkaXVzIC8gMlxuXG5cbiAgICAgICAgICBlbFBvaW50ID0gdGhpcy5kcmF3Q2lyY2xlKHNpemUsIHtcbiAgICAgICAgICAgIGN4OiB4LFxuICAgICAgICAgICAgY3k6IHksXG4gICAgICAgICAgICBjbGFzczogb3B0cy5jbGFzcyA/IG9wdHMuY2xhc3MgOiAnJyxcbiAgICAgICAgICAgIHN0cm9rZTogb3B0cy5wb2ludFN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgZmlsbDogb3B0cy5wb2ludEZpbGxDb2xvcixcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcHRzLnBvaW50RmlsbE9wYWNpdHkgPyBvcHRzLnBvaW50RmlsbE9wYWNpdHkgOiAxLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG9wdHMucG9pbnRTdHJva2VXaWR0aCA/IG9wdHMucG9pbnRTdHJva2VXaWR0aCA6IDAsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBvcHRzLnBvaW50U3Ryb2tlT3BhY2l0eSA/IG9wdHMucG9pbnRTdHJva2VPcGFjaXR5IDogMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsUG9pbnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdGhNb3VzZUVudGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aE1vdXNlRW50ZXIocGF0aCwgZSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBpID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaW5kZXgnKSwgMTApO1xuICAgICAgICB2YXIgaiA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2onKSwgMTApO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludE1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50TW91c2VFbnRlcihlLCB0aGlzLmN0eCwge1xuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LmV2ZW50cy5maXJlRXZlbnQoJ2RhdGFQb2ludE1vdXNlRW50ZXInLCBbZSwgdGhpcy5jdHgsIHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH1dKTtcblxuICAgICAgICBpZiAody5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgaWYgKHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuaG92ZXIuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgIGlmICghdy5nbG9iYWxzLmlzVG91Y2hEZXZpY2UpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckZpbHRlciA9IHcuY29uZmlnLnN0YXRlcy5ob3Zlci5maWx0ZXI7XG4gICAgICAgICAgICBmaWx0ZXJzLmFwcGx5RmlsdGVyKHBhdGgsIGksIGhvdmVyRmlsdGVyLnR5cGUsIGhvdmVyRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGF0aE1vdXNlTGVhdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTW91c2VMZWF2ZShwYXRoLCBlKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGkgPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdpbmRleCcpLCAxMCk7XG4gICAgICAgIHZhciBqID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaicpLCAxMCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50TW91c2VMZWF2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5kYXRhUG9pbnRNb3VzZUxlYXZlKGUsIHRoaXMuY3R4LCB7XG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguZXZlbnRzLmZpcmVFdmVudCgnZGF0YVBvaW50TW91c2VMZWF2ZScsIFtlLCB0aGlzLmN0eCwge1xuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfV0pO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBpZiAocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5ob3Zlci5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgZmlsdGVycy5nZXREZWZhdWx0RmlsdGVyKHBhdGgsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdGhNb3VzZURvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTW91c2VEb3duKHBhdGgsIGUpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICB2YXIgaSA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2luZGV4JyksIDEwKTtcbiAgICAgICAgdmFyIGogPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdqJyksIDEwKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gJ2ZhbHNlJztcblxuICAgICAgICBpZiAocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgcGF0aC5ub2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldLmluZGV4T2YoaikgPiAtMSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXS5pbmRleE9mKGopO1xuICAgICAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXcuY29uZmlnLnN0YXRlcy5hY3RpdmUuYWxsb3dNdWx0aXBsZURhdGFQb2ludHNTZWxlY3Rpb24gJiYgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgZWxQYXRocyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KCcuYXBleGNoYXJ0cy1zZXJpZXMgcGF0aCcpLm1lbWJlcnM7XG4gICAgICAgICAgICB2YXIgZWxDaXJjbGVzID0gdy5nbG9iYWxzLmRvbS5QYXBlci5zZWxlY3QoJy5hcGV4Y2hhcnRzLXNlcmllcyBjaXJjbGUsIC5hcGV4Y2hhcnRzLXNlcmllcyByZWN0JykubWVtYmVycztcblxuICAgICAgICAgICAgdmFyIGRlU2VsZWN0ID0gZnVuY3Rpb24gZGVTZWxlY3QoZWxzKSB7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWxzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5ub2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLmdldERlZmF1bHRGaWx0ZXIoZWwsIGkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRlU2VsZWN0KGVsUGF0aHMpO1xuICAgICAgICAgICAgZGVTZWxlY3QoZWxDaXJjbGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoLm5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgICAgc2VsZWN0ZWQgPSAndHJ1ZSc7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXS5wdXNoKGopO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkID09PSAndHJ1ZScpIHtcbiAgICAgICAgICB2YXIgYWN0aXZlRmlsdGVyID0gdy5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXI7XG5cbiAgICAgICAgICBpZiAoYWN0aXZlRmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGZpbHRlcnMuYXBwbHlGaWx0ZXIocGF0aCwgaSwgYWN0aXZlRmlsdGVyLnR5cGUsIGFjdGl2ZUZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYXBwbHkgdGhlIGhvdmVyIGZpbHRlciBpbiBjYXNlIGl0IHdhcyByZW1vdmVkIGJ5IGBkZXNlbGVjdGB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBmaWx0ZXIgYW5kIGl0IGlzIG5vdCBhIHRvdWNoIGRldmljZVxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5ob3Zlci5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgICAgICAgICBpZiAoIXcuZ2xvYmFscy5pc1RvdWNoRGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvdmVyRmlsdGVyID0gdy5jb25maWcuc3RhdGVzLmhvdmVyLmZpbHRlcjtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLmFwcGx5RmlsdGVyKHBhdGgsIGksIGhvdmVyRmlsdGVyLnR5cGUsIGhvdmVyRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGUgaXRlbSB3YXMgZGVzZWxlY3RlZCwgYXBwbHkgaG92ZXIgc3RhdGUgZmlsdGVyIGlmIGl0IGlzIG5vdCBhIHRvdWNoIGRldmljZVxuICAgICAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuaG92ZXIuZmlsdGVyLnR5cGUgIT09ICdub25lJyAmJiAhdy5nbG9iYWxzLmlzVG91Y2hEZXZpY2UpIHtcbiAgICAgICAgICAgICAgdmFyIGhvdmVyRmlsdGVyID0gdy5jb25maWcuc3RhdGVzLmhvdmVyLmZpbHRlcjtcbiAgICAgICAgICAgICAgZmlsdGVycy5hcHBseUZpbHRlcihwYXRoLCBpLCBob3ZlckZpbHRlci50eXBlLCBob3ZlckZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWx0ZXJzLmdldERlZmF1bHRGaWx0ZXIocGF0aCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludFNlbGVjdGlvbihlLCB0aGlzLmN0eCwge1xuICAgICAgICAgICAgc2VsZWN0ZWREYXRhUG9pbnRzOiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgdGhpcy5jdHguZXZlbnRzLmZpcmVFdmVudCgnZGF0YVBvaW50U2VsZWN0aW9uJywgW2UsIHRoaXMuY3R4LCB7XG4gICAgICAgICAgICBzZWxlY3RlZERhdGFQb2ludHM6IHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyb3RhdGVBcm91bmRDZW50ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVBcm91bmRDZW50ZXIoZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkID0ge307XG5cbiAgICAgICAgaWYgKGVsICYmIHR5cGVvZiBlbC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29vcmQgPSBlbC5nZXRCQm94KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IGNvb3JkLnggKyBjb29yZC53aWR0aCAvIDI7XG4gICAgICAgIHZhciB5ID0gY29vcmQueSArIGNvb3JkLmhlaWdodCAvIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFRleHRSZWN0c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRSZWN0cyh0ZXh0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB1c2VCQm94ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHZpcnR1YWxUZXh0ID0gdGhpcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogLTIwMCxcbiAgICAgICAgICB5OiAtMjAwLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0JyxcbiAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSxcbiAgICAgICAgICBmb3JlQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB2aXJ0dWFsVGV4dC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLmRvbS5QYXBlci5hZGQodmlydHVhbFRleHQpO1xuICAgICAgICB2YXIgcmVjdCA9IHZpcnR1YWxUZXh0LmJib3goKTtcblxuICAgICAgICBpZiAoIXVzZUJCb3gpIHtcbiAgICAgICAgICByZWN0ID0gdmlydHVhbFRleHQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpcnR1YWxUZXh0LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogYXBwZW5kIC4uLiB0byBsb25nIHRleHRcbiAgICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTI0MTMxNS90cmltbWluZy10ZXh0LXRvLWEtZ2l2ZW4tcGl4ZWwtd2lkdGgtaW4tc3ZnXG4gICAgICAgKiBAbWVtYmVyb2YgR3JhcGhpY3NcbiAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwbGFjZVRleHRXaXRoRWxsaXBzaXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGFjZVRleHRXaXRoRWxsaXBzaXModGV4dE9iaiwgdGV4dFN0cmluZywgd2lkdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0T2JqLmdldENvbXB1dGVkVGV4dExlbmd0aCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgICAgICB0ZXh0T2JqLnRleHRDb250ZW50ID0gdGV4dFN0cmluZztcblxuICAgICAgICBpZiAodGV4dFN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gZWxsaXBzaXMgaXMgbmVlZGVkXG4gICAgICAgICAgaWYgKHRleHRPYmouZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPj0gd2lkdGggLyAxLjEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSB0ZXh0U3RyaW5nLmxlbmd0aCAtIDM7IHggPiAwOyB4IC09IDMpIHtcbiAgICAgICAgICAgICAgaWYgKHRleHRPYmouZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsIHgpIDw9IHdpZHRoIC8gMS4xKSB7XG4gICAgICAgICAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudCA9IHRleHRTdHJpbmcuc3Vic3RyaW5nKDAsIHgpICsgJy4uLic7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRPYmoudGV4dENvbnRlbnQgPSAnLic7IC8vIGNhbid0IHBsYWNlIGF0IGFsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcInNldEF0dHJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cnMoZWwsIGF0dHJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gR3JhcGhpY3M7XG4gIH0oKTtcblxuICAvKlxuICAgKiogVXRpbCBmdW5jdGlvbnMgd2hpY2ggYXJlIGRlcGVuZGVudCBvbiBBcGV4Q2hhcnRzIGluc3RhbmNlXG4gICAqL1xuICB2YXIgQ29yZVV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3JlVXRpbHMoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29yZVV0aWxzKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29yZVV0aWxzLCBbe1xuICAgICAga2V5OiBcImdldFN0YWNrZWRTZXJpZXNUb3RhbHNcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQ29yZVV0aWxzXG4gICAgICAgKiByZXR1cm5zIHRoZSBzdW0gb2YgYWxsIGluZGl2aWR1YWwgdmFsdWVzIGluIGEgbXVsdGlwbGUgc3RhY2tlZCBzZXJpZXNcbiAgICAgICAqIEVnLiB3Lmdsb2JhbHMuc2VyaWVzID0gW1szMiwzMyw0MywxMl0sIFsyLDMsNSwxXV1cbiAgICAgICAqICBAcmV0dXJuIFszNCwzNiw0OCwxM11cbiAgICAgICAqKi9cbiAgICAgIGZ1bmN0aW9uIGdldFN0YWNrZWRTZXJpZXNUb3RhbHMoKSB7XG4gICAgICAgIHZhciBleGNsdWRlZFNlcmllc0luZGljZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHRvdGFsID0gW107XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRvdGFsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5nbG9iYWxzLnNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnNlcmllc1tqXVtpXSAhPT0gJ3VuZGVmaW5lZCcgJiYgZXhjbHVkZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaikgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHQgKz0gdy5nbG9iYWxzLnNlcmllc1tqXVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b3RhbC5wdXNoKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfSAvLyBnZXQgdG90YWwgb2YgdGhlIGFsbCB2YWx1ZXMgaW5zaWRlIGFsbCBzZXJpZXNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbEJ5SW5kZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNUb3RhbEJ5SW5kZXgoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBub24tcGxvdCBjaGFydCB0eXBlcyAtIHBpZSAvIGRvbnV0IC8gY2lyY2xlXG4gICAgICAgICAgcmV0dXJuIHRoaXMudy5jb25maWcuc2VyaWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYXhpcyBjaGFydHMgLSBzdXBwb3J0aW5nIG11bHRpcGxlIHNlcmllc1xuICAgICAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5zZXJpZXNbaW5kZXhdLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNTZXJpZXNOdWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZXJpZXNOdWxsKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICAgIHZhciByID0gW107XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gbm9uLXBsb3QgY2hhcnQgdHlwZXMgLSBwaWUgLyBkb251dCAvIGNpcmNsZVxuICAgICAgICAgIHIgPSB0aGlzLncuY29uZmlnLnNlcmllcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkICE9PSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGF4aXMgY2hhcnRzIC0gc3VwcG9ydGluZyBtdWx0aXBsZSBzZXJpZXNcbiAgICAgICAgICByID0gdGhpcy53LmNvbmZpZy5zZXJpZXNbaW5kZXhdLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZCAhPT0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2VyaWVzSGF2ZVNhbWVWYWx1ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpZXNIYXZlU2FtZVZhbHVlcyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuc2VyaWVzW2luZGV4XS5ldmVyeShmdW5jdGlvbiAodmFsLCBpLCBhcnIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsID09PSBhcnJbMF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRDYXRlZ29yeUxhYmVsc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhdGVnb3J5TGFiZWxzKGxhYmVscykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGNhdExhYmVscyA9IGxhYmVscy5zbGljZSgpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgICBjYXRMYWJlbHMgPSBsYWJlbHMubWFwKGZ1bmN0aW9uIChpLCBsaSkge1xuICAgICAgICAgICAgcmV0dXJuIHcuY29uZmlnLnhheGlzLmxhYmVscy5mb3JtYXR0ZXIoaSAtIHcuZ2xvYmFscy5taW5YICsgMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2F0TGFiZWxzO1xuICAgICAgfSAvLyBtYXhWYWxzSW5BcnJheUluZGV4IGlzIHRoZSBpbmRleCBvZiBzZXJpZXNbXSB3aGljaCBoYXMgdGhlIGxhcmdlc3QgbnVtYmVyIG9mIGl0ZW1zXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TGFyZ2VzdFNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhcmdlc3RTZXJpZXMoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleCA9IHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGEubGVuZ3RoO1xuICAgICAgICB9KS5pbmRleE9mKE1hdGgubWF4LmFwcGx5KE1hdGgsIHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGEubGVuZ3RoO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRMYXJnZXN0TWFya2VyU2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhcmdlc3RNYXJrZXJTaXplKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5tYXJrZXJzLmRpc2NyZXRlICYmIHcuY29uZmlnLm1hcmtlcnMuZGlzY3JldGUubGVuZ3RoKSB7XG4gICAgICAgICAgdy5jb25maWcubWFya2Vycy5kaXNjcmV0ZS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgbS5zaXplKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgIHNpemUgKz0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplT2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5tYXJrZXJzLmxhcmdlc3RTaXplID0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgKiByZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBpbiBhIHNlcmllc1xuICAgICAgICogRWcuIHcuZ2xvYmFscy5zZXJpZXMgPSBbWzMyLDMzLDQzLDEyXSwgWzIsMyw1LDFdXVxuICAgICAgICogIEByZXR1cm4gWzEyMCwgMTFdXG4gICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U2VyaWVzVG90YWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxzKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1RvdGFscyA9IHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXIsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlcikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHRvdGFsICs9IHNlcltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZm9yIHBpZS9kb251dHMvZ2F1Z2VzXG4gICAgICAgICAgICB0b3RhbCArPSBzZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U2VyaWVzVG90YWxzWFJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxzWFJhbmdlKG1pblgsIG1heFgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBzZXJpZXNUb3RhbHNYUmFuZ2UgPSB3Lmdsb2JhbHMuc2VyaWVzLm1hcChmdW5jdGlvbiAoc2VyLCBpbmRleCkge1xuICAgICAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXNYW2luZGV4XVtqXSA+IG1pblggJiYgdy5nbG9iYWxzLnNlcmllc1hbaW5kZXhdW2pdIDwgbWF4WCkge1xuICAgICAgICAgICAgICB0b3RhbCArPSBzZXJbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmllc1RvdGFsc1hSYW5nZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIENvcmVVdGlsc1xuICAgICAgICogcmV0dXJucyB0aGUgcGVyY2VudGFnZSB2YWx1ZSBvZiBhbGwgaW5kaXZpZHVhbCB2YWx1ZXMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYSAxMDAlIHN0YWNrZWQgc2VyaWVzXG4gICAgICAgKiBFZy4gdy5nbG9iYWxzLnNlcmllcyA9IFtbMzIsIDMzLCA0MywgMTJdLCBbMiwgMywgNSwgMV1dXG4gICAgICAgKiAgQHJldHVybiBbWzk0LjExLCA5MS42NiwgODkuNTgsIDkyLjMwXSwgWzUuODgsIDguMzMsIDEwLjQxLCA3LjddXVxuICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFBlcmNlbnRTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQZXJjZW50U2VyaWVzKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1BlcmNlbnQgPSB3Lmdsb2JhbHMuc2VyaWVzLm1hcChmdW5jdGlvbiAoc2VyLCBpbmRleCkge1xuICAgICAgICAgIHZhciBzZXJpZXNQZXJjZW50ID0gW107XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXIpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgdG90YWwgPSB3Lmdsb2JhbHMuc3RhY2tlZFNlcmllc1RvdGFsc1tqXTtcbiAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSAwO1xuXG4gICAgICAgICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAxMDAgKiBzZXJbal0gLyB0b3RhbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNlcmllc1BlcmNlbnQucHVzaChwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF90b3RhbCA9IHcuZ2xvYmFscy5zZXJpZXNUb3RhbHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWNjICsgdmFsO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIHZhciBfcGVyY2VudCA9IDEwMCAqIHNlciAvIF90b3RhbDtcblxuICAgICAgICAgICAgc2VyaWVzUGVyY2VudC5wdXNoKF9wZXJjZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VyaWVzUGVyY2VudDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldENhbGN1bGF0ZWRSYXRpb3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkUmF0aW9zKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgICAgdmFyIHlSYXRpbyA9IFtdO1xuICAgICAgICB2YXIgaW52ZXJ0ZWRZUmF0aW8gPSAwO1xuICAgICAgICB2YXIgeFJhdGlvID0gMDtcbiAgICAgICAgdmFyIGluaXRpYWxYUmF0aW8gPSAwO1xuICAgICAgICB2YXIgaW52ZXJ0ZWRYUmF0aW8gPSAwO1xuICAgICAgICB2YXIgelJhdGlvID0gMDtcbiAgICAgICAgdmFyIGJhc2VMaW5lWSA9IFtdO1xuICAgICAgICB2YXIgYmFzZUxpbmVJbnZlcnRlZFkgPSAwLjE7XG4gICAgICAgIHZhciBiYXNlTGluZVggPSAwO1xuICAgICAgICBnbC55UmFuZ2UgPSBbXTtcblxuICAgICAgICBpZiAoZ2wuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5taW5ZQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnbC55UmFuZ2UucHVzaChNYXRoLmFicyhnbC5taW5ZQXJyW2ldIC0gZ2wubWF4WUFycltpXSkpO1xuICAgICAgICAgICAgYmFzZUxpbmVZLnB1c2goMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnlSYW5nZS5wdXNoKE1hdGguYWJzKGdsLm1pblkgLSBnbC5tYXhZKSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC54UmFuZ2UgPSBNYXRoLmFicyhnbC5tYXhYIC0gZ2wubWluWCk7XG4gICAgICAgIGdsLnpSYW5nZSA9IE1hdGguYWJzKGdsLm1heFogLSBnbC5taW5aKTsgLy8gbXVsdGlwbGUgeSBheGlzXG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGdsLnlSYW5nZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB5UmF0aW8ucHVzaChnbC55UmFuZ2VbX2ldIC8gZ2wuZ3JpZEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB4UmF0aW8gPSBnbC54UmFuZ2UgLyBnbC5ncmlkV2lkdGg7XG4gICAgICAgIGluaXRpYWxYUmF0aW8gPSBNYXRoLmFicyhnbC5pbml0aWFsTWF4WCAtIGdsLmluaXRpYWxNaW5YKSAvIGdsLmdyaWRXaWR0aDtcbiAgICAgICAgaW52ZXJ0ZWRZUmF0aW8gPSBnbC55UmFuZ2UgLyBnbC5ncmlkV2lkdGg7XG4gICAgICAgIGludmVydGVkWFJhdGlvID0gZ2wueFJhbmdlIC8gZ2wuZ3JpZEhlaWdodDtcbiAgICAgICAgelJhdGlvID0gZ2wuelJhbmdlIC8gZ2wuZ3JpZEhlaWdodCAqIDE2O1xuXG4gICAgICAgIGlmICghelJhdGlvKSB7XG4gICAgICAgICAgelJhdGlvID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbC5taW5ZICE9PSBOdW1iZXIuTUlOX1ZBTFVFICYmIE1hdGguYWJzKGdsLm1pblkpICE9PSAwKSB7XG4gICAgICAgICAgLy8gTmVnYXRpdmUgbnVtYmVycyBwcmVzZW50IGluIHNlcmllc1xuICAgICAgICAgIGdsLmhhc05lZ3MgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICAgIGJhc2VMaW5lWSA9IFtdOyAvLyBiYXNlbGluZSB2YXJpYWJsZXMgaXMgdGhlIDAgb2YgdGhlIHlheGlzIHdoaWNoIHdpbGwgYmUgbmVlZGVkIHdoZW4gdGhlcmUgYXJlIG5lZ2F0aXZlc1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgeVJhdGlvLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIGJhc2VMaW5lWS5wdXNoKC1nbC5taW5ZQXJyW19pMl0gLyB5UmF0aW9bX2kyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VMaW5lWS5wdXNoKC1nbC5taW5ZIC8geVJhdGlvWzBdKTtcblxuICAgICAgICAgIGlmIChnbC5taW5ZICE9PSBOdW1iZXIuTUlOX1ZBTFVFICYmIE1hdGguYWJzKGdsLm1pblkpICE9PSAwKSB7XG4gICAgICAgICAgICBiYXNlTGluZUludmVydGVkWSA9IC1nbC5taW5ZIC8gaW52ZXJ0ZWRZUmF0aW87IC8vIHRoaXMgaXMgZm9yIGJhciBjaGFydFxuXG4gICAgICAgICAgICBiYXNlTGluZVggPSBnbC5taW5YIC8geFJhdGlvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeVJhdGlvOiB5UmF0aW8sXG4gICAgICAgICAgaW52ZXJ0ZWRZUmF0aW86IGludmVydGVkWVJhdGlvLFxuICAgICAgICAgIHpSYXRpbzogelJhdGlvLFxuICAgICAgICAgIHhSYXRpbzogeFJhdGlvLFxuICAgICAgICAgIGluaXRpYWxYUmF0aW86IGluaXRpYWxYUmF0aW8sXG4gICAgICAgICAgaW52ZXJ0ZWRYUmF0aW86IGludmVydGVkWFJhdGlvLFxuICAgICAgICAgIGJhc2VMaW5lSW52ZXJ0ZWRZOiBiYXNlTGluZUludmVydGVkWSxcbiAgICAgICAgICBiYXNlTGluZVk6IGJhc2VMaW5lWSxcbiAgICAgICAgICBiYXNlTGluZVg6IGJhc2VMaW5lWFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRMb2dTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2dTZXJpZXMoc2VyaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNMb2cgPSBzZXJpZXMubWFwKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2ldICYmIHcuY29uZmlnLnlheGlzW2ldLmxvZ2FyaXRobWljKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgaWYgKGQgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0TG9nVmFsKHcuY29uZmlnLnlheGlzW2ldLmxvZ0Jhc2UsIGQsIGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3Lmdsb2JhbHMuaW52YWxpZExvZ1NjYWxlID8gc2VyaWVzIDogdy5nbG9iYWxzLnNlcmllc0xvZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0QmFzZUxvZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VMb2coYmFzZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHZhbHVlKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRMb2dWYWxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2dWYWwoYiwgZCwgeUluZGV4KSB7XG4gICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIG1pbl9sb2dfdmFsID0gdy5nbG9iYWxzLm1pbllBcnJbeUluZGV4XSA9PT0gMCA/IC0xIC8vIG1ha2Ugc3VyZSB3ZSBkb250IGNhbGN1bGF0ZSBsb2cgb2YgMFxuICAgICAgICA6IHRoaXMuZ2V0QmFzZUxvZyhiLCB3Lmdsb2JhbHMubWluWUFyclt5SW5kZXhdKTtcbiAgICAgICAgdmFyIG1heF9sb2dfdmFsID0gdy5nbG9iYWxzLm1heFlBcnJbeUluZGV4XSA9PT0gMCA/IDAgLy8gbWFrZSBzdXJlIHdlIGRvbnQgY2FsY3VsYXRlIGxvZyBvZiAwXG4gICAgICAgIDogdGhpcy5nZXRCYXNlTG9nKGIsIHcuZ2xvYmFscy5tYXhZQXJyW3lJbmRleF0pO1xuICAgICAgICB2YXIgbnVtYmVyX29mX2hlaWdodF9sZXZlbHMgPSBtYXhfbG9nX3ZhbCAtIG1pbl9sb2dfdmFsO1xuICAgICAgICBpZiAoZCA8IDEpIHJldHVybiBkIC8gbnVtYmVyX29mX2hlaWdodF9sZXZlbHM7XG4gICAgICAgIHZhciBsb2dfaGVpZ2h0X3ZhbHVlID0gdGhpcy5nZXRCYXNlTG9nKGIsIGQpIC0gbWluX2xvZ192YWw7XG4gICAgICAgIHJldHVybiBsb2dfaGVpZ2h0X3ZhbHVlIC8gbnVtYmVyX29mX2hlaWdodF9sZXZlbHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldExvZ1lSYXRpb3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2dZUmF0aW9zKHlSYXRpbykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIGdsLnlMb2dSYXRpbyA9IHlSYXRpby5zbGljZSgpO1xuICAgICAgICBnbC5sb2dZUmFuZ2UgPSBnbC55UmFuZ2UubWFwKGZ1bmN0aW9uICh5UmFuZ2UsIGkpIHtcbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbaV0gJiYgX3RoaXMyLncuY29uZmlnLnlheGlzW2ldLmxvZ2FyaXRobWljKSB7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgdmFyIG1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gMTtcbiAgICAgICAgICAgIGdsLnNlcmllc0xvZy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBzaSkge1xuICAgICAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbc2ldICYmIHcuY29uZmlnLnlheGlzW3NpXS5sb2dhcml0aG1pYykge1xuICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KHYsIG1heFkpO1xuICAgICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKHYsIG1pblkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJhbmdlID0gTWF0aC5wb3coZ2wueVJhbmdlW2ldLCBNYXRoLmFicyhtaW5ZIC0gbWF4WSkgLyBnbC55UmFuZ2VbaV0pO1xuICAgICAgICAgICAgZ2wueUxvZ1JhdGlvW2ldID0gcmFuZ2UgLyBnbC5ncmlkSGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbC5pbnZhbGlkTG9nU2NhbGUgPyB5UmF0aW8uc2xpY2UoKSA6IGdsLnlMb2dSYXRpbztcbiAgICAgIH0gLy8gU29tZSBjb25maWcgb2JqZWN0cyBjYW4gYmUgYXJyYXkgLSBhbmQgd2UgbmVlZCB0byBleHRlbmQgdGhlbSBjb3JyZWN0bHlcblxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImNoZWNrQ29tYm9TZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0NvbWJvU2VyaWVzKHNlcmllcykge1xuICAgICAgICB2YXIgY29tYm9DaGFydHMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvbWJvQmFyQ291bnQgPSAwO1xuICAgICAgICB2YXIgY29tYm9Db3VudCA9IDA7IC8vIGlmIHVzZXIgc3BlY2lmaWVkIGEgdHlwZSBpbiBzZXJpZXMgdG9vLCB0dXJuIG9uIGNvbWJvQ2hhcnRzIGZsYWdcblxuICAgICAgICBpZiAoc2VyaWVzLmxlbmd0aCAmJiB0eXBlb2Ygc2VyaWVzWzBdLnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLnR5cGUgPT09ICdiYXInIHx8IHMudHlwZSA9PT0gJ2NvbHVtbicgfHwgcy50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHMudHlwZSA9PT0gJ2JveFBsb3QnKSB7XG4gICAgICAgICAgICAgIGNvbWJvQmFyQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzLnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGNvbWJvQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21ib0NvdW50ID4gMCkge1xuICAgICAgICAgIGNvbWJvQ2hhcnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tYm9CYXJDb3VudDogY29tYm9CYXJDb3VudCxcbiAgICAgICAgICBjb21ib0NoYXJ0czogY29tYm9DaGFydHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZXh0ZW5kQXJyYXlQcm9wc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZEFycmF5UHJvcHMoY29uZmlnSW5zdGFuY2UsIG9wdGlvbnMsIHcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMueWF4aXMpIHtcbiAgICAgICAgICBvcHRpb25zID0gY29uZmlnSW5zdGFuY2UuZXh0ZW5kWUF4aXMob3B0aW9ucywgdyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucykge1xuICAgICAgICAgIGlmIChvcHRpb25zLmFubm90YXRpb25zLnlheGlzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlnSW5zdGFuY2UuZXh0ZW5kWUF4aXNBbm5vdGF0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucy54YXhpcykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbmZpZ0luc3RhbmNlLmV4dGVuZFhBeGlzQW5ub3RhdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYW5ub3RhdGlvbnMucG9pbnRzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlnSW5zdGFuY2UuZXh0ZW5kUG9pbnRBbm5vdGF0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29yZVV0aWxzO1xuICB9KCk7XG5cbiAgdmFyIEhlbHBlcnMkNCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVscGVycyhhbm5vQ3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVscGVycyk7XG5cbiAgICAgIHRoaXMudyA9IGFubm9DdHgudztcbiAgICAgIHRoaXMuYW5ub0N0eCA9IGFubm9DdHg7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEhlbHBlcnMsIFt7XG4gICAgICBrZXk6IFwic2V0T3JpZW50YXRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZW50YXRpb25zKGFubm8pIHtcbiAgICAgICAgdmFyIGFubm9JbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKGFubm8ubGFiZWwub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICB2YXIgaSA9IGFubm9JbmRleCAhPT0gbnVsbCA/IGFubm9JbmRleCA6IDA7XG4gICAgICAgICAgdmFyIHhBbm5vID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb25zIC5hcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb24tbGFiZWxbcmVsPSdcIi5jb25jYXQoaSwgXCInXVwiKSk7XG5cbiAgICAgICAgICBpZiAoeEFubm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB4QW5ub0Nvb3JkID0geEFubm8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB4QW5uby5zZXRBdHRyaWJ1dGUoJ3gnLCBwYXJzZUZsb2F0KHhBbm5vLmdldEF0dHJpYnV0ZSgneCcpKSAtIHhBbm5vQ29vcmQuaGVpZ2h0ICsgNCk7XG5cbiAgICAgICAgICAgIGlmIChhbm5vLmxhYmVsLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICB4QW5uby5zZXRBdHRyaWJ1dGUoJ3knLCBwYXJzZUZsb2F0KHhBbm5vLmdldEF0dHJpYnV0ZSgneScpKSArIHhBbm5vQ29vcmQud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeEFubm8uc2V0QXR0cmlidXRlKCd5JywgcGFyc2VGbG9hdCh4QW5uby5nZXRBdHRyaWJ1dGUoJ3knKSkgLSB4QW5ub0Nvb3JkLndpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFubm9Sb3RhdGluZ0NlbnRlciA9IHRoaXMuYW5ub0N0eC5ncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIoeEFubm8pO1xuICAgICAgICAgICAgdmFyIHggPSBhbm5vUm90YXRpbmdDZW50ZXIueDtcbiAgICAgICAgICAgIHZhciB5ID0gYW5ub1JvdGF0aW5nQ2VudGVyLnk7XG4gICAgICAgICAgICB4QW5uby5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKC05MCBcIi5jb25jYXQoeCwgXCIgXCIpLmNvbmNhdCh5LCBcIilcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRCYWNrZ3JvdW5kVG9Bbm5vXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQmFja2dyb3VuZFRvQW5ubyhhbm5vRWwsIGFubm8pIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIGlmICghYW5ub0VsIHx8IHR5cGVvZiBhbm5vLmxhYmVsLnRleHQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBhbm5vLmxhYmVsLnRleHQgIT09ICd1bmRlZmluZWQnICYmICFTdHJpbmcoYW5uby5sYWJlbC50ZXh0KS50cmltKCkpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgZWxHcmlkUmVjdCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGFubm9FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHBsZWZ0ID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLmxlZnQ7XG4gICAgICAgIHZhciBwcmlnaHQgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcucmlnaHQ7XG4gICAgICAgIHZhciBwdG9wID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLnRvcDtcbiAgICAgICAgdmFyIHBib3R0b20gPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcuYm90dG9tO1xuXG4gICAgICAgIGlmIChhbm5vLmxhYmVsLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgcHRvcCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5sZWZ0O1xuICAgICAgICAgIHBib3R0b20gPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgcGxlZnQgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcudG9wO1xuICAgICAgICAgIHByaWdodCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5ib3R0b207XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDEgPSBjb29yZHMubGVmdCAtIGVsR3JpZFJlY3QubGVmdCAtIHBsZWZ0O1xuICAgICAgICB2YXIgeTEgPSBjb29yZHMudG9wIC0gZWxHcmlkUmVjdC50b3AgLSBwdG9wO1xuICAgICAgICB2YXIgZWxSZWN0ID0gdGhpcy5hbm5vQ3R4LmdyYXBoaWNzLmRyYXdSZWN0KHgxIC0gdy5nbG9iYWxzLmJhclBhZEZvck51bWVyaWNBeGlzLCB5MSwgY29vcmRzLndpZHRoICsgcGxlZnQgKyBwcmlnaHQsIGNvb3Jkcy5oZWlnaHQgKyBwdG9wICsgcGJvdHRvbSwgYW5uby5sYWJlbC5ib3JkZXJSYWRpdXMsIGFubm8ubGFiZWwuc3R5bGUuYmFja2dyb3VuZCwgMSwgYW5uby5sYWJlbC5ib3JkZXJXaWR0aCwgYW5uby5sYWJlbC5ib3JkZXJDb2xvciwgMCk7XG5cbiAgICAgICAgaWYgKGFubm8uaWQpIHtcbiAgICAgICAgICAvLyBkb24ndCBlc2NhcGVTdHJpbmcgZm9yIHRoaXMgSUQgYXMgaXQgY2F1c2VzIGR1cGxpY2F0ZSByZWN0c1xuICAgICAgICAgIGVsUmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoYW5uby5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxSZWN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbm5vdGF0aW9uc0JhY2tncm91bmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbm5vdGF0aW9uc0JhY2tncm91bmQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChhbm5vLCBpLCB0eXBlKSB7XG4gICAgICAgICAgdmFyIGFubm9MYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYW5ub3RhdGlvbnMgLmFwZXhjaGFydHMtXCIpLmNvbmNhdCh0eXBlLCBcIi1hbm5vdGF0aW9uLWxhYmVsW3JlbD0nXCIpLmNvbmNhdChpLCBcIiddXCIpKTtcblxuICAgICAgICAgIGlmIChhbm5vTGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBhbm5vTGFiZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgdmFyIGVsUmVjdCA9IF90aGlzLmFkZEJhY2tncm91bmRUb0Fubm8oYW5ub0xhYmVsLCBhbm5vKTtcblxuICAgICAgICAgICAgaWYgKGVsUmVjdCkge1xuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsUmVjdC5ub2RlLCBhbm5vTGFiZWwpO1xuXG4gICAgICAgICAgICAgIGlmIChhbm5vLmxhYmVsLm1vdXNlRW50ZXIpIHtcbiAgICAgICAgICAgICAgICBlbFJlY3Qubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgYW5uby5sYWJlbC5tb3VzZUVudGVyLmJpbmQoX3RoaXMsIGFubm8pKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhbm5vLmxhYmVsLm1vdXNlTGVhdmUpIHtcbiAgICAgICAgICAgICAgICBlbFJlY3Qubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgYW5uby5sYWJlbC5tb3VzZUxlYXZlLmJpbmQoX3RoaXMsIGFubm8pKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhbm5vLmxhYmVsLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgZWxSZWN0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhbm5vLmxhYmVsLmNsaWNrLmJpbmQoX3RoaXMsIGFubm8pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy54YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGkpIHtcbiAgICAgICAgICBhZGQoYW5ubywgaSwgJ3hheGlzJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy55YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGkpIHtcbiAgICAgICAgICBhZGQoYW5ubywgaSwgJ3lheGlzJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy5wb2ludHMubWFwKGZ1bmN0aW9uIChhbm5vLCBpKSB7XG4gICAgICAgICAgYWRkKGFubm8sIGksICdwb2ludCcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0WTFZMlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFkxWTIodHlwZSwgYW5ubykge1xuICAgICAgICB2YXIgeSA9IHR5cGUgPT09ICd5MScgPyBhbm5vLnkgOiBhbm5vLnkyO1xuICAgICAgICB2YXIgeVA7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGlmICh0aGlzLmFubm9DdHguaW52ZXJ0QXhpcykge1xuICAgICAgICAgIHZhciBjYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZih5KTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgICAgIGNhdEluZGV4ID0gdy5nbG9iYWxzLmNhdGVnb3J5TGFiZWxzLmluZGV4T2YoeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHhMYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXlheGlzLXRleHRzLWcgdGV4dDpudGgtY2hpbGQoJyArIChjYXRJbmRleCArIDEpICsgJyknKTtcblxuICAgICAgICAgIGlmICh4TGFiZWwpIHtcbiAgICAgICAgICAgIHlQID0gcGFyc2VGbG9hdCh4TGFiZWwuZ2V0QXR0cmlidXRlKCd5JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgeVBvcztcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1thbm5vLnlBeGlzSW5kZXhdLmxvZ2FyaXRobWljKSB7XG4gICAgICAgICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmFubm9DdHguY3R4KTtcbiAgICAgICAgICAgIHkgPSBjb3JlVXRpbHMuZ2V0TG9nVmFsKHksIGFubm8ueUF4aXNJbmRleCk7XG4gICAgICAgICAgICB5UG9zID0geSAvIHcuZ2xvYmFscy55TG9nUmF0aW9bYW5uby55QXhpc0luZGV4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeVBvcyA9ICh5IC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHlQID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSB5UG9zO1xuXG4gICAgICAgICAgaWYgKGFubm8ubWFya2VyICYmIChhbm5vLnkgPT09IHVuZGVmaW5lZCB8fCBhbm5vLnkgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAvLyBwb2ludCBhbm5vdGF0aW9uXG4gICAgICAgICAgICB5UCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0gJiYgdy5jb25maWcueWF4aXNbYW5uby55QXhpc0luZGV4XS5yZXZlcnNlZCkge1xuICAgICAgICAgICAgeVAgPSB5UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeSA9PT0gJ3N0cmluZycgJiYgeS5pbmRleE9mKCdweCcpID4gLTEpIHtcbiAgICAgICAgICB5UCA9IHBhcnNlRmxvYXQoeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geVA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFgxWDJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYMVgyKHR5cGUsIGFubm8pIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBtaW4gPSB0aGlzLmFubm9DdHguaW52ZXJ0QXhpcyA/IHcuZ2xvYmFscy5taW5ZIDogdy5nbG9iYWxzLm1pblg7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLmFubm9DdHguaW52ZXJ0QXhpcyA/IHcuZ2xvYmFscy5tYXhZIDogdy5nbG9iYWxzLm1heFg7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuYW5ub0N0eC5pbnZlcnRBeGlzID8gdy5nbG9iYWxzLnlSYW5nZVswXSA6IHcuZ2xvYmFscy54UmFuZ2U7XG4gICAgICAgIHZhciB4MSA9IChhbm5vLnggLSBtaW4pIC8gKHJhbmdlIC8gdy5nbG9iYWxzLmdyaWRXaWR0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYW5ub0N0eC5pbnZlcnNlZFJldmVyc2VkQXhpcykge1xuICAgICAgICAgIHgxID0gKG1heCAtIGFubm8ueCkgLyAocmFuZ2UgLyB3Lmdsb2JhbHMuZ3JpZFdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpICYmICF0aGlzLmFubm9DdHguaW52ZXJ0QXhpcyAmJiAhdy5nbG9iYWxzLmRhdGFGb3JtYXRYTnVtZXJpYykge1xuICAgICAgICAgIHgxID0gdGhpcy5nZXRTdHJpbmdYKGFubm8ueCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDIgPSAoYW5uby54MiAtIG1pbikgLyAocmFuZ2UgLyB3Lmdsb2JhbHMuZ3JpZFdpZHRoKTtcblxuICAgICAgICBpZiAodGhpcy5hbm5vQ3R4LmludmVyc2VkUmV2ZXJzZWRBeGlzKSB7XG4gICAgICAgICAgeDIgPSAobWF4IC0gYW5uby54MikgLyAocmFuZ2UgLyB3Lmdsb2JhbHMuZ3JpZFdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpICYmICF0aGlzLmFubm9DdHguaW52ZXJ0QXhpcyAmJiAhdy5nbG9iYWxzLmRhdGFGb3JtYXRYTnVtZXJpYykge1xuICAgICAgICAgIHgyID0gdGhpcy5nZXRTdHJpbmdYKGFubm8ueDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChhbm5vLnggPT09IHVuZGVmaW5lZCB8fCBhbm5vLnggPT09IG51bGwpICYmIGFubm8ubWFya2VyKSB7XG4gICAgICAgICAgLy8gcG9pbnQgYW5ub3RhdGlvbiBpbiBhIGhvcml6b250YWwgY2hhcnRcbiAgICAgICAgICB4MSA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3gxJyAmJiB0eXBlb2YgYW5uby54ID09PSAnc3RyaW5nJyAmJiBhbm5vLnguaW5kZXhPZigncHgnKSA+IC0xKSB7XG4gICAgICAgICAgeDEgPSBwYXJzZUZsb2F0KGFubm8ueCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3gyJyAmJiB0eXBlb2YgYW5uby54MiA9PT0gJ3N0cmluZycgJiYgYW5uby54Mi5pbmRleE9mKCdweCcpID4gLTEpIHtcbiAgICAgICAgICB4MiA9IHBhcnNlRmxvYXQoYW5uby54Mik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ3gxJyA/IHgxIDogeDI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFN0cmluZ1hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHJpbmdYKHgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciByWCA9IHg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYyAmJiB3Lmdsb2JhbHMuY2F0ZWdvcnlMYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgeCA9IHcuZ2xvYmFscy5jYXRlZ29yeUxhYmVscy5pbmRleE9mKHgpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZih4KTtcbiAgICAgICAgdmFyIHhMYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXhheGlzLXRleHRzLWcgdGV4dDpudGgtY2hpbGQoJyArIChjYXRJbmRleCArIDEpICsgJyknKTtcblxuICAgICAgICBpZiAoeExhYmVsKSB7XG4gICAgICAgICAgclggPSBwYXJzZUZsb2F0KHhMYWJlbC5nZXRBdHRyaWJ1dGUoJ3gnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gclg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEhlbHBlcnM7XG4gIH0oKTtcblxuICB2YXIgWEFubm90YXRpb25zID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYQW5ub3RhdGlvbnMoYW5ub0N0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhBbm5vdGF0aW9ucyk7XG5cbiAgICAgIHRoaXMudyA9IGFubm9DdHgudztcbiAgICAgIHRoaXMuYW5ub0N0eCA9IGFubm9DdHg7XG4gICAgICB0aGlzLmludmVydEF4aXMgPSB0aGlzLmFubm9DdHguaW52ZXJ0QXhpcztcbiAgICAgIHRoaXMuaGVscGVycyA9IG5ldyBIZWxwZXJzJDQodGhpcy5hbm5vQ3R4KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoWEFubm90YXRpb25zLCBbe1xuICAgICAga2V5OiBcImFkZFhheGlzQW5ub3RhdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFhheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgeDEgPSB0aGlzLmhlbHBlcnMuZ2V0WDFYMigneDEnLCBhbm5vKTtcbiAgICAgICAgdmFyIHgyO1xuICAgICAgICB2YXIgdGV4dCA9IGFubm8ubGFiZWwudGV4dDtcbiAgICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IGFubm8uc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgICBpZiAoIVV0aWxzJDEuaXNOdW1iZXIoeDEpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGFubm8ueDIgPT09IG51bGwgfHwgdHlwZW9mIGFubm8ueDIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmFubm9DdHguZ3JhcGhpY3MuZHJhd0xpbmUoeDEgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgICAgMCArIGFubm8ub2Zmc2V0WSwgLy8geTFcbiAgICAgICAgICB4MSArIGFubm8ub2Zmc2V0WCwgLy8geDJcbiAgICAgICAgICB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGFubm8ub2Zmc2V0WSwgLy8geTJcbiAgICAgICAgICBhbm5vLmJvcmRlckNvbG9yLCAvLyBsaW5lQ29sb3JcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXksIC8vZGFzaEFycmF5XG4gICAgICAgICAgYW5uby5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmUubm9kZSk7XG5cbiAgICAgICAgICBpZiAoYW5uby5pZCkge1xuICAgICAgICAgICAgbGluZS5ub2RlLmNsYXNzTGlzdC5hZGQoYW5uby5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgyID0gdGhpcy5oZWxwZXJzLmdldFgxWDIoJ3gyJywgYW5ubyk7XG5cbiAgICAgICAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB4MTtcbiAgICAgICAgICAgIHgxID0geDI7XG4gICAgICAgICAgICB4MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmFubm9DdHguZ3JhcGhpY3MuZHJhd1JlY3QoeDEgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgICAgMCArIGFubm8ub2Zmc2V0WSwgLy8geTFcbiAgICAgICAgICB4MiAtIHgxLCAvLyB4MlxuICAgICAgICAgIHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgYW5uby5vZmZzZXRZLCAvLyB5MlxuICAgICAgICAgIDAsIC8vIHJhZGl1c1xuICAgICAgICAgIGFubm8uZmlsbENvbG9yLCAvLyBjb2xvclxuICAgICAgICAgIGFubm8ub3BhY2l0eSwgLy8gb3BhY2l0eSxcbiAgICAgICAgICAxLCAvLyBzdHJva2VXaWR0aFxuICAgICAgICAgIGFubm8uYm9yZGVyQ29sb3IsIC8vIHN0cm9rZUNvbG9yXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5IC8vIHN0b2tlRGFzaEFycmF5XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1hbm5vdGF0aW9uLXJlY3QnKTtcbiAgICAgICAgICByZWN0LmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHJlY3Qubm9kZSk7XG5cbiAgICAgICAgICBpZiAoYW5uby5pZCkge1xuICAgICAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoYW5uby5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRSZWN0cyA9IHRoaXMuYW5ub0N0eC5ncmFwaGljcy5nZXRUZXh0UmVjdHModGV4dCwgcGFyc2VGbG9hdChhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplKSk7XG4gICAgICAgIHZhciB0ZXh0WSA9IGFubm8ubGFiZWwucG9zaXRpb24gPT09ICd0b3AnID8gNCA6IGFubm8ubGFiZWwucG9zaXRpb24gPT09ICdjZW50ZXInID8gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyICsgKGFubm8ubGFiZWwub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB0ZXh0UmVjdHMud2lkdGggLyAyIDogMCkgOiB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuYW5ub0N0eC5ncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeDEgKyBhbm5vLmxhYmVsLm9mZnNldFgsXG4gICAgICAgICAgeTogdGV4dFkgKyBhbm5vLmxhYmVsLm9mZnNldFkgLSAoYW5uby5sYWJlbC5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IGFubm8ubGFiZWwucG9zaXRpb24gPT09ICd0b3AnID8gdGV4dFJlY3RzLndpZHRoIC8gMiAtIDEyIDogLXRleHRSZWN0cy53aWR0aCAvIDIgOiAwKSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6IGFubm8ubGFiZWwudGV4dEFuY2hvcixcbiAgICAgICAgICBmb250U2l6ZTogYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiBhbm5vLmxhYmVsLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFdlaWdodDogYW5uby5sYWJlbC5zdHlsZS5mb250V2VpZ2h0LFxuICAgICAgICAgIGZvcmVDb2xvcjogYW5uby5sYWJlbC5zdHlsZS5jb2xvcixcbiAgICAgICAgICBjc3NDbGFzczogXCJhcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb24tbGFiZWwgXCIuY29uY2F0KGFubm8ubGFiZWwuc3R5bGUuY3NzQ2xhc3MsIFwiIFwiKS5jb25jYXQoYW5uby5pZCA/IGFubm8uaWQgOiAnJylcbiAgICAgICAgfSk7XG4gICAgICAgIGVsVGV4dC5hdHRyKHtcbiAgICAgICAgICByZWw6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxUZXh0Lm5vZGUpOyAvLyBhZnRlciBwbGFjaW5nIHRoZSBhbm5vdGF0aW9ucyBvbiBzdmcsIHNldCBhbnkgdmVydGljYWxseSBwbGFjZWQgYW5ub3RhdGlvbnNcblxuICAgICAgICB0aGlzLmFubm9DdHguaGVscGVycy5zZXRPcmllbnRhdGlvbnMoYW5ubywgaW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3WEF4aXNBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYQXhpc0Fubm90YXRpb25zKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZWxnID0gdGhpcy5hbm5vQ3R4LmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMtYW5ub3RhdGlvbnMnXG4gICAgICAgIH0pO1xuICAgICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy54YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGluZGV4KSB7XG4gICAgICAgICAgX3RoaXMuYWRkWGF4aXNBbm5vdGF0aW9uKGFubm8sIGVsZy5ub2RlLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWxnO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBYQW5ub3RhdGlvbnM7XG4gIH0oKTtcblxuICB2YXIgWUFubm90YXRpb25zID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBZQW5ub3RhdGlvbnMoYW5ub0N0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBbm5vdGF0aW9ucyk7XG5cbiAgICAgIHRoaXMudyA9IGFubm9DdHgudztcbiAgICAgIHRoaXMuYW5ub0N0eCA9IGFubm9DdHg7XG4gICAgICB0aGlzLmhlbHBlcnMgPSBuZXcgSGVscGVycyQ0KHRoaXMuYW5ub0N0eCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFlBbm5vdGF0aW9ucywgW3tcbiAgICAgIGtleTogXCJhZGRZYXhpc0Fubm90YXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRZYXhpc0Fubm90YXRpb24oYW5ubywgcGFyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IGFubm8uc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgICB2YXIgeTEgPSB0aGlzLmhlbHBlcnMuZ2V0WTFZMigneTEnLCBhbm5vKTtcbiAgICAgICAgdmFyIHkyO1xuICAgICAgICB2YXIgdGV4dCA9IGFubm8ubGFiZWwudGV4dDtcblxuICAgICAgICBpZiAoYW5uby55MiA9PT0gbnVsbCB8fCB0eXBlb2YgYW5uby55MiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuYW5ub0N0eC5ncmFwaGljcy5kcmF3TGluZSgwICsgYW5uby5vZmZzZXRYLCAvLyB4MVxuICAgICAgICAgIHkxICsgYW5uby5vZmZzZXRZLCAvLyB5MVxuICAgICAgICAgIHRoaXMuX2dldFlBeGlzQW5ub3RhdGlvbldpZHRoKGFubm8pLCAvLyB4MlxuICAgICAgICAgIHkxICsgYW5uby5vZmZzZXRZLCAvLyB5MlxuICAgICAgICAgIGFubm8uYm9yZGVyQ29sb3IsIC8vIGxpbmVDb2xvclxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSwgLy8gZGFzaEFycmF5XG4gICAgICAgICAgYW5uby5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmUubm9kZSk7XG5cbiAgICAgICAgICBpZiAoYW5uby5pZCkge1xuICAgICAgICAgICAgbGluZS5ub2RlLmNsYXNzTGlzdC5hZGQoYW5uby5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkyID0gdGhpcy5oZWxwZXJzLmdldFkxWTIoJ3kyJywgYW5ubyk7XG5cbiAgICAgICAgICBpZiAoeTIgPiB5MSkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB5MTtcbiAgICAgICAgICAgIHkxID0geTI7XG4gICAgICAgICAgICB5MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmFubm9DdHguZ3JhcGhpY3MuZHJhd1JlY3QoMCArIGFubm8ub2Zmc2V0WCwgLy8geDFcbiAgICAgICAgICB5MiArIGFubm8ub2Zmc2V0WSwgLy8geTFcbiAgICAgICAgICB0aGlzLl9nZXRZQXhpc0Fubm90YXRpb25XaWR0aChhbm5vKSwgLy8geDJcbiAgICAgICAgICB5MSAtIHkyLCAvLyB5MlxuICAgICAgICAgIDAsIC8vIHJhZGl1c1xuICAgICAgICAgIGFubm8uZmlsbENvbG9yLCAvLyBjb2xvclxuICAgICAgICAgIGFubm8ub3BhY2l0eSwgLy8gb3BhY2l0eSxcbiAgICAgICAgICAxLCAvLyBzdHJva2VXaWR0aFxuICAgICAgICAgIGFubm8uYm9yZGVyQ29sb3IsIC8vIHN0cm9rZUNvbG9yXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5IC8vIHN0b2tlRGFzaEFycmF5XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1hbm5vdGF0aW9uLXJlY3QnKTtcbiAgICAgICAgICByZWN0LmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHJlY3Qubm9kZSk7XG5cbiAgICAgICAgICBpZiAoYW5uby5pZCkge1xuICAgICAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoYW5uby5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRYID0gYW5uby5sYWJlbC5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/IHcuZ2xvYmFscy5ncmlkV2lkdGggOiBhbm5vLmxhYmVsLnBvc2l0aW9uID09PSAnY2VudGVyJyA/IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyIDogMDtcbiAgICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuYW5ub0N0eC5ncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogdGV4dFggKyBhbm5vLmxhYmVsLm9mZnNldFgsXG4gICAgICAgICAgeTogKHkyICE9IG51bGwgPyB5MiA6IHkxKSArIGFubm8ubGFiZWwub2Zmc2V0WSAtIDMsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiBhbm5vLmxhYmVsLnRleHRBbmNob3IsXG4gICAgICAgICAgZm9udFNpemU6IGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogYW5uby5sYWJlbC5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IGFubm8ubGFiZWwuc3R5bGUuZm9udFdlaWdodCxcbiAgICAgICAgICBmb3JlQ29sb3I6IGFubm8ubGFiZWwuc3R5bGUuY29sb3IsXG4gICAgICAgICAgY3NzQ2xhc3M6IFwiYXBleGNoYXJ0cy15YXhpcy1hbm5vdGF0aW9uLWxhYmVsIFwiLmNvbmNhdChhbm5vLmxhYmVsLnN0eWxlLmNzc0NsYXNzLCBcIiBcIikuY29uY2F0KGFubm8uaWQgPyBhbm5vLmlkIDogJycpXG4gICAgICAgIH0pO1xuICAgICAgICBlbFRleHQuYXR0cih7XG4gICAgICAgICAgcmVsOiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsVGV4dC5ub2RlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldFlBeGlzQW5ub3RhdGlvbldpZHRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFlBeGlzQW5ub3RhdGlvbldpZHRoKGFubm8pIHtcbiAgICAgICAgLy8gaXNzdWUgYXBleGNoYXJ0cy5qcyMyMDA5XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgd2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuXG4gICAgICAgIGlmIChhbm5vLndpZHRoLmluZGV4T2YoJyUnKSA+IC0xKSB7XG4gICAgICAgICAgd2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoICogcGFyc2VJbnQoYW5uby53aWR0aCwgMTApIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQoYW5uby53aWR0aCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoICsgYW5uby5vZmZzZXRYO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3WUF4aXNBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZQXhpc0Fubm90YXRpb25zKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZWxnID0gdGhpcy5hbm5vQ3R4LmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtYW5ub3RhdGlvbnMnXG4gICAgICAgIH0pO1xuICAgICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy55YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGluZGV4KSB7XG4gICAgICAgICAgX3RoaXMuYWRkWWF4aXNBbm5vdGF0aW9uKGFubm8sIGVsZy5ub2RlLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWxnO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBZQW5ub3RhdGlvbnM7XG4gIH0oKTtcblxuICB2YXIgUG9pbnRBbm5vdGF0aW9ucyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9pbnRBbm5vdGF0aW9ucyhhbm5vQ3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9pbnRBbm5vdGF0aW9ucyk7XG5cbiAgICAgIHRoaXMudyA9IGFubm9DdHgudztcbiAgICAgIHRoaXMuYW5ub0N0eCA9IGFubm9DdHg7XG4gICAgICB0aGlzLmhlbHBlcnMgPSBuZXcgSGVscGVycyQ0KHRoaXMuYW5ub0N0eCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBvaW50QW5ub3RhdGlvbnMsIFt7XG4gICAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy53O1xuICAgICAgICB2YXIgeCA9IHRoaXMuaGVscGVycy5nZXRYMVgyKCd4MScsIGFubm8pO1xuICAgICAgICB2YXIgeSA9IHRoaXMuaGVscGVycy5nZXRZMVkyKCd5MScsIGFubm8pO1xuICAgICAgICBpZiAoIVV0aWxzJDEuaXNOdW1iZXIoeCkpIHJldHVybjtcbiAgICAgICAgdmFyIG9wdHNQb2ludHMgPSB7XG4gICAgICAgICAgcFNpemU6IGFubm8ubWFya2VyLnNpemUsXG4gICAgICAgICAgcG9pbnRTdHJva2VXaWR0aDogYW5uby5tYXJrZXIuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgcG9pbnRGaWxsQ29sb3I6IGFubm8ubWFya2VyLmZpbGxDb2xvcixcbiAgICAgICAgICBwb2ludFN0cm9rZUNvbG9yOiBhbm5vLm1hcmtlci5zdHJva2VDb2xvcixcbiAgICAgICAgICBzaGFwZTogYW5uby5tYXJrZXIuc2hhcGUsXG4gICAgICAgICAgcFJhZGl1czogYW5uby5tYXJrZXIucmFkaXVzLFxuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbi1tYXJrZXIgXCIuY29uY2F0KGFubm8ubWFya2VyLmNzc0NsYXNzLCBcIiBcIikuY29uY2F0KGFubm8uaWQgPyBhbm5vLmlkIDogJycpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuYW5ub0N0eC5ncmFwaGljcy5kcmF3TWFya2VyKHggKyBhbm5vLm1hcmtlci5vZmZzZXRYLCB5ICsgYW5uby5tYXJrZXIub2Zmc2V0WSwgb3B0c1BvaW50cyk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChwb2ludC5ub2RlKTtcbiAgICAgICAgdmFyIHRleHQgPSBhbm5vLmxhYmVsLnRleHQgPyBhbm5vLmxhYmVsLnRleHQgOiAnJztcbiAgICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuYW5ub0N0eC5ncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCArIGFubm8ubGFiZWwub2Zmc2V0WCxcbiAgICAgICAgICB5OiB5ICsgYW5uby5sYWJlbC5vZmZzZXRZIC0gYW5uby5tYXJrZXIuc2l6ZSAtIHBhcnNlRmxvYXQoYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSkgLyAxLjYsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiBhbm5vLmxhYmVsLnRleHRBbmNob3IsXG4gICAgICAgICAgZm9udFNpemU6IGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogYW5uby5sYWJlbC5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IGFubm8ubGFiZWwuc3R5bGUuZm9udFdlaWdodCxcbiAgICAgICAgICBmb3JlQ29sb3I6IGFubm8ubGFiZWwuc3R5bGUuY29sb3IsXG4gICAgICAgICAgY3NzQ2xhc3M6IFwiYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9uLWxhYmVsIFwiLmNvbmNhdChhbm5vLmxhYmVsLnN0eWxlLmNzc0NsYXNzLCBcIiBcIikuY29uY2F0KGFubm8uaWQgPyBhbm5vLmlkIDogJycpXG4gICAgICAgIH0pO1xuICAgICAgICBlbFRleHQuYXR0cih7XG4gICAgICAgICAgcmVsOiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsVGV4dC5ub2RlKTsgLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgYXMgd2Ugd2lsbCB1c2UgY3VzdG9tXG5cbiAgICAgICAgaWYgKGFubm8uY3VzdG9tU1ZHLlNWRykge1xuICAgICAgICAgIHZhciBnID0gdGhpcy5hbm5vQ3R4LmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9ucy1jdXN0b20tc3ZnICcgKyBhbm5vLmN1c3RvbVNWRy5jc3NDbGFzc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGcuYXR0cih7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4ICsgYW5uby5jdXN0b21TVkcub2Zmc2V0WCwgXCIsIFwiKS5jb25jYXQoeSArIGFubm8uY3VzdG9tU1ZHLm9mZnNldFksIFwiKVwiKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGcubm9kZS5pbm5lckhUTUwgPSBhbm5vLmN1c3RvbVNWRy5TVkc7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGcubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5uby5pbWFnZS5wYXRoKSB7XG4gICAgICAgICAgdmFyIGltZ1dpZHRoID0gYW5uby5pbWFnZS53aWR0aCA/IGFubm8uaW1hZ2Uud2lkdGggOiAyMDtcbiAgICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gYW5uby5pbWFnZS5oZWlnaHQgPyBhbm5vLmltYWdlLmhlaWdodCA6IDIwO1xuICAgICAgICAgIHBvaW50ID0gdGhpcy5hbm5vQ3R4LmFkZEltYWdlKHtcbiAgICAgICAgICAgIHg6IHggKyBhbm5vLmltYWdlLm9mZnNldFggLSBpbWdXaWR0aCAvIDIsXG4gICAgICAgICAgICB5OiB5ICsgYW5uby5pbWFnZS5vZmZzZXRZIC0gaW1nSGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHdpZHRoOiBpbWdXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaW1nSGVpZ2h0LFxuICAgICAgICAgICAgcGF0aDogYW5uby5pbWFnZS5wYXRoLFxuICAgICAgICAgICAgYXBwZW5kVG86ICcuYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9ucydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbm5vLm1vdXNlRW50ZXIpIHtcbiAgICAgICAgICBwb2ludC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBhbm5vLm1vdXNlRW50ZXIuYmluZCh0aGlzLCBhbm5vKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5uby5tb3VzZUxlYXZlKSB7XG4gICAgICAgICAgcG9pbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgYW5uby5tb3VzZUxlYXZlLmJpbmQodGhpcywgYW5ubykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFubm8uY2xpY2spIHtcbiAgICAgICAgICBwb2ludC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYW5uby5jbGljay5iaW5kKHRoaXMsIGFubm8pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3UG9pbnRBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQb2ludEFubm90YXRpb25zKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZWxnID0gdGhpcy5hbm5vQ3R4LmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbnMnXG4gICAgICAgIH0pO1xuICAgICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy5wb2ludHMubWFwKGZ1bmN0aW9uIChhbm5vLCBpbmRleCkge1xuICAgICAgICAgIF90aGlzLmFkZFBvaW50QW5ub3RhdGlvbihhbm5vLCBlbGcubm9kZSwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVsZztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUG9pbnRBbm5vdGF0aW9ucztcbiAgfSgpO1xuXG4gIGNvbnN0IG5hbWUgPSBcImVuXCI7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gIFx0bW9udGhzOiBbXG4gIFx0XHRcIkphbnVhcnlcIixcbiAgXHRcdFwiRmVicnVhcnlcIixcbiAgXHRcdFwiTWFyY2hcIixcbiAgXHRcdFwiQXByaWxcIixcbiAgXHRcdFwiTWF5XCIsXG4gIFx0XHRcIkp1bmVcIixcbiAgXHRcdFwiSnVseVwiLFxuICBcdFx0XCJBdWd1c3RcIixcbiAgXHRcdFwiU2VwdGVtYmVyXCIsXG4gIFx0XHRcIk9jdG9iZXJcIixcbiAgXHRcdFwiTm92ZW1iZXJcIixcbiAgXHRcdFwiRGVjZW1iZXJcIlxuICBcdF0sXG4gIFx0c2hvcnRNb250aHM6IFtcbiAgXHRcdFwiSmFuXCIsXG4gIFx0XHRcIkZlYlwiLFxuICBcdFx0XCJNYXJcIixcbiAgXHRcdFwiQXByXCIsXG4gIFx0XHRcIk1heVwiLFxuICBcdFx0XCJKdW5cIixcbiAgXHRcdFwiSnVsXCIsXG4gIFx0XHRcIkF1Z1wiLFxuICBcdFx0XCJTZXBcIixcbiAgXHRcdFwiT2N0XCIsXG4gIFx0XHRcIk5vdlwiLFxuICBcdFx0XCJEZWNcIlxuICBcdF0sXG4gIFx0ZGF5czogW1xuICBcdFx0XCJTdW5kYXlcIixcbiAgXHRcdFwiTW9uZGF5XCIsXG4gIFx0XHRcIlR1ZXNkYXlcIixcbiAgXHRcdFwiV2VkbmVzZGF5XCIsXG4gIFx0XHRcIlRodXJzZGF5XCIsXG4gIFx0XHRcIkZyaWRheVwiLFxuICBcdFx0XCJTYXR1cmRheVwiXG4gIFx0XSxcbiAgXHRzaG9ydERheXM6IFtcbiAgXHRcdFwiU3VuXCIsXG4gIFx0XHRcIk1vblwiLFxuICBcdFx0XCJUdWVcIixcbiAgXHRcdFwiV2VkXCIsXG4gIFx0XHRcIlRodVwiLFxuICBcdFx0XCJGcmlcIixcbiAgXHRcdFwiU2F0XCJcbiAgXHRdLFxuICBcdHRvb2xiYXI6IHtcbiAgXHRcdGV4cG9ydFRvU1ZHOiBcIkRvd25sb2FkIFNWR1wiLFxuICBcdFx0ZXhwb3J0VG9QTkc6IFwiRG93bmxvYWQgUE5HXCIsXG4gIFx0XHRleHBvcnRUb0NTVjogXCJEb3dubG9hZCBDU1ZcIixcbiAgXHRcdG1lbnU6IFwiTWVudVwiLFxuICBcdFx0c2VsZWN0aW9uOiBcIlNlbGVjdGlvblwiLFxuICBcdFx0c2VsZWN0aW9uWm9vbTogXCJTZWxlY3Rpb24gWm9vbVwiLFxuICBcdFx0em9vbUluOiBcIlpvb20gSW5cIixcbiAgXHRcdHpvb21PdXQ6IFwiWm9vbSBPdXRcIixcbiAgXHRcdHBhbjogXCJQYW5uaW5nXCIsXG4gIFx0XHRyZXNldDogXCJSZXNldCBab29tXCJcbiAgXHR9XG4gIH07XG4gIHZhciBlbiA9IHtcbiAgXHRuYW1lOiBuYW1lLFxuICBcdG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcblxuICB2YXIgT3B0aW9ucyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3B0aW9ucygpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25zKTtcblxuICAgICAgdGhpcy55QXhpcyA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgc2hvd0Fsd2F5czogZmFsc2UsXG4gICAgICAgIHNob3dGb3JOdWxsU2VyaWVzOiB0cnVlLFxuICAgICAgICBzZXJpZXNOYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIG9wcG9zaXRlOiBmYWxzZSxcbiAgICAgICAgcmV2ZXJzZWQ6IGZhbHNlLFxuICAgICAgICBsb2dhcml0aG1pYzogZmFsc2UsXG4gICAgICAgIGxvZ0Jhc2U6IDEwLFxuICAgICAgICB0aWNrQW1vdW50OiB1bmRlZmluZWQsXG4gICAgICAgIGZvcmNlTmljZVNjYWxlOiBmYWxzZSxcbiAgICAgICAgbWF4OiB1bmRlZmluZWQsXG4gICAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgIGRlY2ltYWxzSW5GbG9hdDogdW5kZWZpbmVkLFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgICAgIG1heFdpZHRoOiAxNjAsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIGFsaWduOiB1bmRlZmluZWQsXG4gICAgICAgICAgcm90YXRlOiAwLFxuICAgICAgICAgIHBhZGRpbmc6IDIwLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgYXhpc0JvcmRlcjoge1xuICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgIGNvbG9yOiAnI2UwZTBlMCcsXG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGF4aXNUaWNrczoge1xuICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgIGNvbG9yOiAnI2UwZTBlMCcsXG4gICAgICAgICAgd2lkdGg6IDYsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIHJvdGF0ZTogLTkwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiA5MDAsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjc3NDbGFzczogJydcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBvZmZzZXRYOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgIHBvc2l0aW9uOiAnZnJvbnQnLFxuICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgY29sb3I6ICcjYjZiNmI2JyxcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgZGFzaEFycmF5OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5wb2ludEFubm90YXRpb24gPSB7XG4gICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IG51bGwsXG4gICAgICAgIHlBeGlzSW5kZXg6IDAsXG4gICAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICBtb3VzZUVudGVyOiB1bmRlZmluZWQsXG4gICAgICAgIG1vdXNlTGVhdmU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2xpY2s6IHVuZGVmaW5lZCxcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICBmaWxsQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICBzdHJva2VDb2xvcjogJyMzMzMnLFxuICAgICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgcmFkaXVzOiAyLFxuICAgICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2MyYzJjMicsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAyLFxuICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgbW91c2VFbnRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIG1vdXNlTGVhdmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjbGljazogdW5kZWZpbmVkLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnJyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgbGVmdDogNSxcbiAgICAgICAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgICAgICAgIHRvcDogMixcbiAgICAgICAgICAgICAgYm90dG9tOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TVkc6IHtcbiAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGFzIGl0IGlzIGdvaW5nIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBiZXR0ZXIgYWx0ZXJuYXRpdmUgYmVsb3dcbiAgICAgICAgICBTVkc6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjc3NDbGFzczogdW5kZWZpbmVkLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgICB9LFxuICAgICAgICBpbWFnZToge1xuICAgICAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3aWR0aDogMjAsXG4gICAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMueUF4aXNBbm5vdGF0aW9uID0ge1xuICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICB5OiAwLFxuICAgICAgICB5MjogbnVsbCxcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAxLFxuICAgICAgICBmaWxsQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIG9wYWNpdHk6IDAuMyxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgeUF4aXNJbmRleDogMCxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyNjMmMyYzInLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICAgIGJvcmRlclJhZGl1czogMixcbiAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ2VuZCcsXG4gICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAtMyxcbiAgICAgICAgICBtb3VzZUVudGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgbW91c2VMZWF2ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGNsaWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmb250U2l6ZTogJzExcHgnLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICcnLFxuICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgICAgICByaWdodDogNSxcbiAgICAgICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgICAgICBib3R0b206IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnhBeGlzQW5ub3RhdGlvbiA9IHtcbiAgICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeDI6IG51bGwsXG4gICAgICAgIHN0cm9rZURhc2hBcnJheTogMSxcbiAgICAgICAgZmlsbENvbG9yOiAnI2MyYzJjMicsXG4gICAgICAgIGJvcmRlckNvbG9yOiAnI2MyYzJjMicsXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICBvcGFjaXR5OiAwLjMsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDIsXG4gICAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIG9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICAgICAgICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgbW91c2VFbnRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIG1vdXNlTGVhdmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjbGljazogdW5kZWZpbmVkLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnJyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgbGVmdDogNSxcbiAgICAgICAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgICAgICAgIHRvcDogMixcbiAgICAgICAgICAgICAgYm90dG9tOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy50ZXh0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0JyxcbiAgICAgICAgZm9yZUNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgIGZvbnRTaXplOiAnMTNweCcsXG4gICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgICBhcHBlbmRUbzogJy5hcGV4Y2hhcnRzLWFubm90YXRpb25zJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBib3JkZXJDb2xvcjogJyNjMmMyYzInLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICBwYWRkaW5nTGVmdDogNCxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxuICAgICAgICBwYWRkaW5nVG9wOiAyLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiAyXG4gICAgICB9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhPcHRpb25zLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFubm90YXRpb25zOiB7XG4gICAgICAgICAgICB5YXhpczogW3RoaXMueUF4aXNBbm5vdGF0aW9uXSxcbiAgICAgICAgICAgIHhheGlzOiBbdGhpcy54QXhpc0Fubm90YXRpb25dLFxuICAgICAgICAgICAgcG9pbnRzOiBbdGhpcy5wb2ludEFubm90YXRpb25dLFxuICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgaW1hZ2VzOiBbXSxcbiAgICAgICAgICAgIHNoYXBlczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2Vpbm91dCcsXG4gICAgICAgICAgICAgIC8vIGxpbmVhciwgZWFzZW91dCwgZWFzZWluLCBlYXNlaW5vdXQsIHN3aW5nLCBib3VuY2UsIGVsYXN0aWNcbiAgICAgICAgICAgICAgc3BlZWQ6IDgwMCxcbiAgICAgICAgICAgICAgYW5pbWF0ZUdyYWR1YWxseToge1xuICAgICAgICAgICAgICAgIGRlbGF5OiAxNTAsXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkeW5hbWljQW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzcGVlZDogMzUwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgbG9jYWxlczogW2VuXSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6ICdlbicsXG4gICAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBlbmFibGVkT25TZXJpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgICAgICBsZWZ0OiAyLFxuICAgICAgICAgICAgICBibHVyOiA0LFxuICAgICAgICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjM1XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkVuZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBiZWZvcmVNb3VudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBtb3VudGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHVwZGF0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY2xpY2s6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbW91c2VNb3ZlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG1vdXNlTGVhdmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgeEF4aXNMYWJlbENsaWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGxlZ2VuZENsaWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG1hcmtlckNsaWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBkYXRhUG9pbnRTZWxlY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZGF0YVBvaW50TW91c2VFbnRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBkYXRhUG9pbnRNb3VzZUxlYXZlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGJlZm9yZVpvb206IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgYmVmb3JlUmVzZXRab29tOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHpvb21lZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBzY3JvbGxlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBicnVzaFNjcm9sbGVkOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlQ29sb3I6ICcjMzczZDNmJyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgcGFyZW50SGVpZ2h0T2Zmc2V0OiAxNSxcbiAgICAgICAgICAgIHJlZHJhd09uUGFyZW50UmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgcmVkcmF3T25XaW5kb3dSZXNpemU6IHRydWUsXG4gICAgICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3JvdXA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB0eXBlOiAneCcsXG4gICAgICAgICAgICAgIC8vIHNlbGVjdGVkUG9pbnRzOiB1bmRlZmluZWQsIC8vIGRlZmF1bHQgZGF0YXBvaW50cyB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNCxcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXk6IDNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtYXg6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB5YXhpczoge1xuICAgICAgICAgICAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcGFya2xpbmU6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBicnVzaDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgYXV0b1NjYWxlWWF4aXM6IHRydWUsXG4gICAgICAgICAgICAgIHRhcmdldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB0YXJnZXRzOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YWNrVHlwZTogJ25vcm1hbCcsXG4gICAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgIHRvb2xzOiB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHpvb206IHRydWUsXG4gICAgICAgICAgICAgICAgem9vbWluOiB0cnVlLFxuICAgICAgICAgICAgICAgIHpvb21vdXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFuOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGN1c3RvbUljb25zOiBbXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBleHBvcnQ6IHtcbiAgICAgICAgICAgICAgICBjc3Y6IHtcbiAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBjb2x1bW5EZWxpbWl0ZXI6ICcsJyxcbiAgICAgICAgICAgICAgICAgIGhlYWRlckNhdGVnb3J5OiAnY2F0ZWdvcnknLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyVmFsdWU6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0dGVyOiBmdW5jdGlvbiBkYXRlRm9ybWF0dGVyKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wKS50b0RhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBuZzoge1xuICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3ZnOiB7XG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhdXRvU2VsZWN0ZWQ6ICd6b29tJyAvLyBhY2NlcHRzIC0+IHpvb20sIHBhbiwgc2VsZWN0aW9uXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiAneCcsXG4gICAgICAgICAgICAgIGF1dG9TY2FsZVlheGlzOiBmYWxzZSxcbiAgICAgICAgICAgICAgem9vbWVkQXJlYToge1xuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzkwQ0FGOScsXG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMEQ0N0ExJyxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNCxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgICBmaWxsVG86ICdvcmlnaW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBjb2x1bW5XaWR0aDogJzcwJScsXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbiBwZXJjZW50IDAgLSAxMDBcbiAgICAgICAgICAgICAgYmFySGVpZ2h0OiAnNzAlJyxcbiAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGluIHBlcmNlbnQgMCAtIDEwMFxuICAgICAgICAgICAgICBkaXN0cmlidXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzQXBwbGljYXRpb246ICdhcm91bmQnLFxuICAgICAgICAgICAgICAvLyBbYXJvdW5kLCBlbmRdXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1c1doZW5TdGFja2VkOiAnbGFzdCcsXG4gICAgICAgICAgICAgIC8vIFthbGwsIGxhc3RdXG4gICAgICAgICAgICAgIHJhbmdlQmFyT3ZlcmxhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgcmFuZ2VCYXJHcm91cFJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgICBoaWRlWmVyb0JhcnNXaGVuR3JvdXBlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGlzRHVtYmJlbGw6IGZhbHNlLFxuICAgICAgICAgICAgICBkdW1iYmVsbENvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc0Z1bm5lbDogZmFsc2UsXG4gICAgICAgICAgICAgIGlzRnVubmVsM2Q6IHRydWUsXG4gICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgIHJhbmdlczogW10sXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEJhckNvbG9yczogW10sXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEJhck9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEJhclJhZGl1czogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICAgICAgICAgIC8vIHRvcCwgY2VudGVyLCBib3R0b21cbiAgICAgICAgICAgICAgICBtYXhJdGVtczogMTAwLFxuICAgICAgICAgICAgICAgIGhpZGVPdmVyZmxvd2luZ0xhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgICAgIHRvdGFsOiB7XG4gICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyMzNzNkM2YnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDYwMFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1YmJsZToge1xuICAgICAgICAgICAgICB6U2NhbGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgbWluQnViYmxlUmFkaXVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG1heEJ1YmJsZVJhZGl1czogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuZGxlc3RpY2s6IHtcbiAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgdXB3YXJkOiAnIzAwQjc0NicsXG4gICAgICAgICAgICAgICAgZG93bndhcmQ6ICcjRUY0MDNDJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB3aWNrOiB7XG4gICAgICAgICAgICAgICAgdXNlRmlsbENvbG9yOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3hQbG90OiB7XG4gICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgIHVwcGVyOiAnIzAwRTM5NicsXG4gICAgICAgICAgICAgICAgbG93ZXI6ICcjMDA4RkZCJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhdG1hcDoge1xuICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgIGVuYWJsZVNoYWRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNSxcbiAgICAgICAgICAgICAgcmV2ZXJzZU5lZ2F0aXZlU2hhZGU6IGZhbHNlLFxuICAgICAgICAgICAgICBkaXN0cmlidXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHVzZUZpbGxDb2xvckFzU3Ryb2tlOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29sb3JTY2FsZToge1xuICAgICAgICAgICAgICAgIGludmVyc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJhbmdlczogW10sXG4gICAgICAgICAgICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWF4OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyZWVtYXA6IHtcbiAgICAgICAgICAgICAgZW5hYmxlU2hhZGVzOiB0cnVlLFxuICAgICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC41LFxuICAgICAgICAgICAgICBkaXN0cmlidXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHJldmVyc2VOZWdhdGl2ZVNoYWRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdXNlRmlsbENvbG9yQXNTdHJva2U6IGZhbHNlLFxuICAgICAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnc2NhbGUnIC8vIHNjYWxlIHwgdHJ1bmNhdGVcblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjb2xvclNjYWxlOiB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmFuZ2VzOiBbXSxcbiAgICAgICAgICAgICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtYXg6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmFkaWFsQmFyOiB7XG4gICAgICAgICAgICAgIGludmVyc2VPcmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiAzNjAsXG4gICAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgIGhvbGxvdzoge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogNSxcbiAgICAgICAgICAgICAgICBzaXplOiAnNTAlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIGltYWdlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aDogMTUwLFxuICAgICAgICAgICAgICAgIGltYWdlSGVpZ2h0OiAxNTAsXG4gICAgICAgICAgICAgICAgaW1hZ2VPZmZzZXRYOiAwLFxuICAgICAgICAgICAgICAgIGltYWdlT2Zmc2V0WTogMCxcbiAgICAgICAgICAgICAgICBpbWFnZUNsaXBwZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmcm9udCcsXG4gICAgICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgYmx1cjogMyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRyYWNrOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2YyZjJmMicsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICc5NyUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA1LFxuICAgICAgICAgICAgICAgIC8vIG1hcmdpbiBpcyBpbiBwaXhlbHNcbiAgICAgICAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICBibHVyOiAzLFxuICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldFk6IDE2LFxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgKyAnJSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBsYWJlbDogJ1RvdGFsJyxcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdy5nbG9iYWxzLnNlcmllc1RvdGFscy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApIC8gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggKyAnJSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGllOiB7XG4gICAgICAgICAgICAgIGN1c3RvbVNjYWxlOiAxLFxuICAgICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgICAgICAgICBlbmRBbmdsZTogMzYwLFxuICAgICAgICAgICAgICBleHBhbmRPbkNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50YWdlIHZhbHVlcyB3aGljaCBhcmUgZGlzcGxheWVkIG9uIHNsaWNlXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIC8vIG9mZnNldCBieSB3aGljaCBsYWJlbHMgd2lsbCBtb3ZlIG91dHNpZGVcbiAgICAgICAgICAgICAgICBtaW5BbmdsZVRvU2hvd0xhYmVsOiAxMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkb251dDoge1xuICAgICAgICAgICAgICAgIHNpemU6ICc2NSUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGlubmVyIGxhYmVscyBhcHBlYXJpbmcgaW5zaWRlIGRvbnV0XG4gICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNnB4JyxcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IC0xMCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMjBweCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRvdGFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzaG93QWx3YXlzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdUb3RhbCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHcuZ2xvYmFscy5zZXJpZXNUb3RhbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2xhckFyZWE6IHtcbiAgICAgICAgICAgICAgcmluZ3M6IHtcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogJyNlOGU4ZTgnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNwb2tlczoge1xuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RvckNvbG9yczogJyNlOGU4ZTgnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYWRhcjoge1xuICAgICAgICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgIHBvbHlnb25zOiB7XG4gICAgICAgICAgICAgICAgLy8gc3Ryb2tlQ29sb3I6ICcjZThlOGU4JywgLy8gc2hvdWxkIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIG1pbm9yIHZlcnNpb24gaS5lIDMuMlxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yczogJyNlOGU4ZTgnLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RvckNvbG9yczogJyNlOGU4ZTgnLFxuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgZW5hYmxlZE9uU2VyaWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbCAhPT0gbnVsbCA/IHZhbCA6ICcnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgZGlzdHJpYnV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGZvcmVDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDIsXG4gICAgICAgICAgICAgIHBhZGRpbmc6IDQsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOSxcbiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b3A6IDEsXG4gICAgICAgICAgICAgICAgbGVmdDogMSxcbiAgICAgICAgICAgICAgICBibHVyOiAxLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC40NVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgdG9wOiAxLFxuICAgICAgICAgICAgICBsZWZ0OiAxLFxuICAgICAgICAgICAgICBibHVyOiAxLFxuICAgICAgICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjQ1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICB0eXBlOiAnc29saWQnLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBhcnJheSBvZiBjb2xvcnNcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuODUsXG4gICAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgICBzaGFkZTogJ2RhcmsnLFxuICAgICAgICAgICAgICB0eXBlOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjUsXG4gICAgICAgICAgICAgIGdyYWRpZW50VG9Db2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgb3BhY2l0eUZyb206IDEsXG4gICAgICAgICAgICAgIG9wYWNpdHlUbzogMSxcbiAgICAgICAgICAgICAgc3RvcHM6IFswLCA1MCwgMTAwXSxcbiAgICAgICAgICAgICAgY29sb3JTdG9wczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICBzcmM6IFtdLFxuICAgICAgICAgICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZCAvLyBvcHRpb25hbFxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgICBzdHlsZTogJ3NxdWFyZXMnLFxuICAgICAgICAgICAgICAvLyBTdHJpbmcgfCBBcnJheSBvZiBTdHJpbmdzXG4gICAgICAgICAgICAgIHdpZHRoOiA2LFxuICAgICAgICAgICAgICBoZWlnaHQ6IDYsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JlY2FzdERhdGFQb2ludHM6IHtcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXNoQXJyYXk6IDRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNlMGUwZTAnLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAwLFxuICAgICAgICAgICAgcG9zaXRpb246ICdiYWNrJyxcbiAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgIGxpbmVzOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICAgIGxpbmVzOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm93OiB7XG4gICAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAvLyB0YWtlcyBhcyBhcnJheSB3aGljaCB3aWxsIGJlIHJlcGVhdGVkIG9uIHJvd3NcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sdW1uOiB7XG4gICAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAvLyB0YWtlcyBhbiBhcnJheSB3aGljaCB3aWxsIGJlIHJlcGVhdGVkIG9uIGNvbHVtbnNcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICBsZWZ0OiAxMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBzaG93Rm9yU2luZ2xlU2VyaWVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGb3JOdWxsU2VyaWVzOiB0cnVlLFxuICAgICAgICAgICAgc2hvd0Zvclplcm9TZXJpZXM6IHRydWUsXG4gICAgICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHRvIHBvc2l0aW9uIGxlZ2VuZHMgaW4gMSBvZiA0XG4gICAgICAgICAgICAvLyBkaXJlY3Rpb24gLSB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHRcbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAvLyB3aGVuIHBvc2l0aW9uIHRvcC9ib3R0b20sIHlvdSBjYW4gc3BlY2lmeSB3aGV0aGVyIHRvIGFsaWduIGxlZ2VuZHMgbGVmdCwgcmlnaHQgb3IgY2VudGVyXG4gICAgICAgICAgICBpbnZlcnNlT3JkZXI6IGZhbHNlLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG9vbHRpcEhvdmVyRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvZmZzZXRYOiAtMjAsXG4gICAgICAgICAgICBvZmZzZXRZOiA0LFxuICAgICAgICAgICAgY3VzdG9tTGVnZW5kSXRlbXM6IFtdLFxuICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB1c2VTZXJpZXNDb2xvcnM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgICB3aWR0aDogMTIsXG4gICAgICAgICAgICAgIGhlaWdodDogMTIsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAgICAgICBmaWxsQ29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgIHJhZGl1czogMTIsXG4gICAgICAgICAgICAgIGN1c3RvbUhUTUw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgICAgb25DbGljazogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbU1hcmdpbjoge1xuICAgICAgICAgICAgICBob3Jpem9udGFsOiA1LFxuICAgICAgICAgICAgICB2ZXJ0aWNhbDogMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uSXRlbUNsaWNrOiB7XG4gICAgICAgICAgICAgIHRvZ2dsZURhdGFTZXJpZXM6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkl0ZW1Ib3Zlcjoge1xuICAgICAgICAgICAgICBoaWdobGlnaHREYXRhU2VyaWVzOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgICBkaXNjcmV0ZTogW10sXG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvL3N0cm9rZUNvbG9yOiAnI2ZmZicsIC8vIFRPRE86IGRlcHJlY2F0ZSBpbiBtYWpvciB2ZXJzaW9uIDQuMFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3JzOiAnI2ZmZicsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuOSxcbiAgICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogMCxcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgd2lkdGg6IDgsXG4gICAgICAgICAgICAvLyBvbmx5IGFwcGxpY2FibGUgd2hlbiBzaGFwZSBpcyByZWN0L3NxdWFyZVxuICAgICAgICAgICAgaGVpZ2h0OiA4LFxuICAgICAgICAgICAgLy8gb25seSBhcHBsaWNhYmxlIHdoZW4gc2hhcGUgaXMgcmVjdC9zcXVhcmVcbiAgICAgICAgICAgIHJhZGl1czogMixcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgb25DbGljazogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25EYmxDbGljazogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2hvd051bGxEYXRhUG9pbnRzOiB0cnVlLFxuICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBzaXplT2Zmc2V0OiAzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBub0RhdGE6IHtcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3BvbnNpdmU6IFtdLFxuICAgICAgICAgIC8vIGJyZWFrcG9pbnRzIHNob3VsZCBmb2xsb3cgYXNjZW5kaW5nIG9yZGVyIDQwMCwgdGhlbiA3MDAsIHRoZW4gMTAwMFxuICAgICAgICAgIHNlcmllczogdW5kZWZpbmVkLFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdub25lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpZ2h0ZW4nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgICBhbGxvd011bHRpcGxlRGF0YVBvaW50c1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkYXJrZW4nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICBtYXJnaW46IDUsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDkwMCxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdWJ0aXRsZToge1xuICAgICAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgIG1hcmdpbjogNSxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAzMCxcbiAgICAgICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBjdXJ2ZTogJ3Ntb290aCcsXG4gICAgICAgICAgICAvLyBcInNtb290aFwiIC8gXCJzdHJhaWdodFwiIC8gXCJtb25vdG9uZUN1YmljXCIgLyBcInN0ZXBsaW5lXCJcbiAgICAgICAgICAgIGxpbmVDYXA6ICdidXR0JyxcbiAgICAgICAgICAgIC8vIHJvdW5kLCBidXR0ICwgc3F1YXJlXG4gICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gYXJyYXkgb2YgY29sb3JzXG4gICAgICAgICAgICBkYXNoQXJyYXk6IDAsXG4gICAgICAgICAgICAvLyBzaW5nbGUgdmFsdWUgb3IgYXJyYXkgb2YgdmFsdWVzXG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcsXG4gICAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAvLyBhcnJheSBvZiBjb2xvcnNcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC44NSxcbiAgICAgICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgICAgICBzaGFkZTogJ2RhcmsnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC41LFxuICAgICAgICAgICAgICAgIGdyYWRpZW50VG9Db2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpbnZlcnNlQ29sb3JzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAxLFxuICAgICAgICAgICAgICAgIG9wYWNpdHlUbzogMSxcbiAgICAgICAgICAgICAgICBzdG9wczogWzAsIDUwLCAxMDBdLFxuICAgICAgICAgICAgICAgIGNvbG9yU3RvcHM6IFtdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVkT25TZXJpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNoYXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0N1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICAvLyB3aGVuIGRpc2FibGVkLCB0aGUgdG9vbHRpcCB3aWxsIHNob3cgb24gdG9wIG9mIHRoZSBzZXJpZXMgaW5zdGVhZCBvZiBtb3VzZSBwb3NpdGlvblxuICAgICAgICAgICAgaW50ZXJzZWN0OiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHdoZW4gZW5hYmxlZCwgdG9vbHRpcCB3aWxsIG9ubHkgc2hvdyB3aGVuIHVzZXIgZGlyZWN0bHkgaG92ZXJzIG92ZXIgcG9pbnRcbiAgICAgICAgICAgIGludmVyc2VPcmRlcjogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b206IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGxTZXJpZXNDb2xvcjogZmFsc2UsXG4gICAgICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnJyxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGF0YXNldEhvdmVyOiB7XG4gICAgICAgICAgICAgIGhpZ2hsaWdodERhdGFTZXJpZXM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAvLyB4IHZhbHVlXG4gICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgIGZvcm1hdDogJ2RkIE1NTScsXG4gICAgICAgICAgICAgIC8vIGRkL01NLCBkZCBNTU0geXksIGRkIE1NTSB5eXl5XG4gICAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkIC8vIGEgY3VzdG9tIHVzZXIgc3VwcGxpZWQgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHNlcmllc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXNOYW1lID8gc2VyaWVzTmFtZSArICc6ICcgOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6OiB7XG4gICAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB0aXRsZTogJ1NpemU6ICdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgZmlsbENvbG9yczogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml4ZWQ6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wUmlnaHQnLFxuICAgICAgICAgICAgICAvLyB0b3BSaWdodCwgdG9wTGVmdCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnRcbiAgICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICAgIGNvbnZlcnRlZENhdFRvTnVtZXJpYzogZmFsc2UsXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBwcm9wZXJ0eSB3aGljaCBzaG91bGQgbm90IGJlIGFsdGVyZWQgb3V0c2lkZVxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBvdmVyd3JpdGVDYXRlZ29yaWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgcm90YXRlOiAtNDUsXG4gICAgICAgICAgICAgIHJvdGF0ZUFsd2F5czogZmFsc2UsXG4gICAgICAgICAgICAgIGhpZGVPdmVybGFwcGluZ0xhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgICAgdHJpbTogZmFsc2UsXG4gICAgICAgICAgICAgIG1pbkhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBtYXhIZWlnaHQ6IDEyMCxcbiAgICAgICAgICAgICAgc2hvd0R1cGxpY2F0ZXM6IHRydWUsXG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICcnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgIGZvcm1hdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgLy8gY3VzdG9tIGZvcm1hdHRlciBmdW5jdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIGZvcm1hdFxuICAgICAgICAgICAgICBkYXRldGltZVVUQzogdHJ1ZSxcbiAgICAgICAgICAgICAgZGF0ZXRpbWVGb3JtYXR0ZXI6IHtcbiAgICAgICAgICAgICAgICB5ZWFyOiAneXl5eScsXG4gICAgICAgICAgICAgICAgbW9udGg6IFwiTU1NICd5eVwiLFxuICAgICAgICAgICAgICAgIGRheTogJ2RkIE1NTScsXG4gICAgICAgICAgICAgICAgaG91cjogJ0hIOm1tJyxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICdISDptbTpzcycsXG4gICAgICAgICAgICAgICAgc2Vjb25kOiAnSEg6bW06c3MnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBncm91cDoge1xuICAgICAgICAgICAgICBncm91cHM6IFtdLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA0MDAsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXhpc0JvcmRlcjoge1xuICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICBjb2xvcjogJyNlMGUwZTAnLFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBheGlzVGlja3M6IHtcbiAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgY29sb3I6ICcjZTBlMGUwJyxcbiAgICAgICAgICAgICAgaGVpZ2h0OiA2LFxuICAgICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGlja0Ftb3VudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGlja1BsYWNlbWVudDogJ29uJyxcbiAgICAgICAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWF4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICByYW5nZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGVjaW1hbHNJbkZsb2F0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDkwMCxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICcnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAvLyB0aWNrV2lkdGgvYmFyV2lkdGggb3IgYW4gaW50ZWdlclxuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2JhY2snLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjksXG4gICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2I2YjZiNicsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgZGFzaEFycmF5OiAzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc29saWQnLFxuICAgICAgICAgICAgICAgIC8vIHNvbGlkLCBncmFkaWVudFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI0IxQjlDNCcsXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yRnJvbTogJyNEOEUzRjAnLFxuICAgICAgICAgICAgICAgICAgY29sb3JUbzogJyNCRUQxRTYnLFxuICAgICAgICAgICAgICAgICAgc3RvcHM6IFswLCAxMDBdLFxuICAgICAgICAgICAgICAgICAgb3BhY2l0eUZyb206IDAuNCxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHlUbzogMC41XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgYmx1cjogMSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeWF4aXM6IHRoaXMueUF4aXMsXG4gICAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICAgIG1vZGU6ICdsaWdodCcsXG4gICAgICAgICAgICBwYWxldHRlOiAncGFsZXR0ZTEnLFxuICAgICAgICAgICAgLy8gSWYgZGVmaW5lZCwgaXQgd2lsbCBvdmVyd3JpdGUgZ2xvYmFscy5jb2xvcnMgdmFyaWFibGVcbiAgICAgICAgICAgIG1vbm9jaHJvbWU6IHtcbiAgICAgICAgICAgICAgLy8gbW9ub2Nocm9tZSBhbGxvd3MgeW91IHRvIHNlbGVjdCBqdXN0IDEgY29sb3IgYW5kIGZpbGwgb3V0IHRoZSByZXN0IHdpdGggbGlnaHQvZGFyayBzaGFkZSAoaW50ZW5zaXR5IGNhbiBiZSBzZWxlY3RlZClcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbG9yOiAnIzAwOEZGQicsXG4gICAgICAgICAgICAgIHNoYWRlVG86ICdsaWdodCcsXG4gICAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjY1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBPcHRpb25zO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgQW5ub3RhdGlvbnMgQ2xhc3MgZm9yIGRyYXdpbmcgbGluZXMvcmVjdHMgb24gYm90aCB4YXhpcyBhbmQgeWF4aXMuXG4gICAqXG4gICAqIEBtb2R1bGUgQW5ub3RhdGlvbnNcbiAgICoqL1xuXG4gIHZhciBBbm5vdGF0aW9ucyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5ub3RhdGlvbnMoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5ub3RhdGlvbnMpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG5cbiAgICAgIGlmICh0aGlzLncuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgdGhpcy5pbnZlcnRBeGlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oZWxwZXJzID0gbmV3IEhlbHBlcnMkNCh0aGlzKTtcbiAgICAgIHRoaXMueEF4aXNBbm5vdGF0aW9ucyA9IG5ldyBYQW5ub3RhdGlvbnModGhpcyk7XG4gICAgICB0aGlzLnlBeGlzQW5ub3RhdGlvbnMgPSBuZXcgWUFubm90YXRpb25zKHRoaXMpO1xuICAgICAgdGhpcy5wb2ludHNBbm5vdGF0aW9ucyA9IG5ldyBQb2ludEFubm90YXRpb25zKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy53Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsICYmIHRoaXMudy5jb25maWcueWF4aXNbMF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgdGhpcy5pbnZlcnNlZFJldmVyc2VkQXhpcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueERpdmlzaW9uID0gdGhpcy53Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGhpcy53Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQW5ub3RhdGlvbnMsIFt7XG4gICAgICBrZXk6IFwiZHJhd0F4ZXNBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBeGVzQW5ub3RhdGlvbnMoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgIHZhciB5QW5ub3RhdGlvbnMgPSB0aGlzLnlBeGlzQW5ub3RhdGlvbnMuZHJhd1lBeGlzQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgICB2YXIgeEFubm90YXRpb25zID0gdGhpcy54QXhpc0Fubm90YXRpb25zLmRyYXdYQXhpc0Fubm90YXRpb25zKCk7XG4gICAgICAgICAgdmFyIHBvaW50QW5ub3RhdGlvbnMgPSB0aGlzLnBvaW50c0Fubm90YXRpb25zLmRyYXdQb2ludEFubm90YXRpb25zKCk7XG4gICAgICAgICAgdmFyIGluaXRpYWxBbmltID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuICAgICAgICAgIHZhciBhbm5vQXJyYXkgPSBbeUFubm90YXRpb25zLCB4QW5ub3RhdGlvbnMsIHBvaW50QW5ub3RhdGlvbnNdO1xuICAgICAgICAgIHZhciBhbm5vRWxBcnJheSA9IFt4QW5ub3RhdGlvbnMubm9kZSwgeUFubm90YXRpb25zLm5vZGUsIHBvaW50QW5ub3RhdGlvbnMubm9kZV07XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQoYW5ub0FycmF5W2ldKTtcblxuICAgICAgICAgICAgaWYgKGluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIC8vIGZpeGVzIGFwZXhjaGFydHMvYXBleGNoYXJ0cy5qcyM2ODVcbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdzY2F0dGVyJyAmJiB3LmNvbmZpZy5jaGFydC50eXBlICE9PSAnYnViYmxlJyAmJiB3Lmdsb2JhbHMuZGF0YVBvaW50cyA+IDEpIHtcbiAgICAgICAgICAgICAgICBhbm5vRWxBcnJheVtpXS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWVsZW1lbnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgZWw6IGFubm9FbEFycmF5W2ldLFxuICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBiYWNrZ3JvdW5kIHNpemVzIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgYWZ0ZXIgdGV4dCBpcyBkcmF3biwgc28gY2FsbGluZyB0aGVtIGxhc3RcblxuXG4gICAgICAgICAgdGhpcy5oZWxwZXJzLmFubm90YXRpb25zQmFja2dyb3VuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdJbWFnZUFubm9zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ltYWdlQW5ub3MoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHcuY29uZmlnLmFubm90YXRpb25zLmltYWdlcy5tYXAoZnVuY3Rpb24gKHMsIGluZGV4KSB7XG4gICAgICAgICAgX3RoaXMuYWRkSW1hZ2UocywgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1RleHRBbm5vc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUZXh0QW5ub3MoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy50ZXh0cy5tYXAoZnVuY3Rpb24gKHQsIGluZGV4KSB7XG4gICAgICAgICAgX3RoaXMyLmFkZFRleHQodCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkWGF4aXNBbm5vdGF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWGF4aXNBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy54QXhpc0Fubm90YXRpb25zLmFkZFhheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkWWF4aXNBbm5vdGF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWWF4aXNBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy55QXhpc0Fubm90YXRpb25zLmFkZFlheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5wb2ludHNBbm5vdGF0aW9ucy5hZGRQb2ludEFubm90YXRpb24oYW5ubywgcGFyZW50LCBpbmRleCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0KHBhcmFtcywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHggPSBwYXJhbXMueCxcbiAgICAgICAgICAgIHkgPSBwYXJhbXMueSxcbiAgICAgICAgICAgIHRleHQgPSBwYXJhbXMudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSBwYXJhbXMudGV4dEFuY2hvcixcbiAgICAgICAgICAgIGZvcmVDb2xvciA9IHBhcmFtcy5mb3JlQ29sb3IsXG4gICAgICAgICAgICBmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBwYXJhbXMuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQgPSBwYXJhbXMuZm9udFdlaWdodCxcbiAgICAgICAgICAgIGNzc0NsYXNzID0gcGFyYW1zLmNzc0NsYXNzLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gcGFyYW1zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlcldpZHRoID0gcGFyYW1zLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gcGFyYW1zLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1cyA9IHBhcmFtcy5ib3JkZXJSYWRpdXMsXG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHBhcmFtcy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIF9wYXJhbXMkYXBwZW5kVG8gPSBwYXJhbXMuYXBwZW5kVG8sXG4gICAgICAgICAgICBhcHBlbmRUbyA9IF9wYXJhbXMkYXBwZW5kVG8gPT09IHZvaWQgMCA/ICcuYXBleGNoYXJ0cy1hbm5vdGF0aW9ucycgOiBfcGFyYW1zJGFwcGVuZFRvLFxuICAgICAgICAgICAgX3BhcmFtcyRwYWRkaW5nTGVmdCA9IHBhcmFtcy5wYWRkaW5nTGVmdCxcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gX3BhcmFtcyRwYWRkaW5nTGVmdCA9PT0gdm9pZCAwID8gNCA6IF9wYXJhbXMkcGFkZGluZ0xlZnQsXG4gICAgICAgICAgICBfcGFyYW1zJHBhZGRpbmdSaWdodCA9IHBhcmFtcy5wYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBfcGFyYW1zJHBhZGRpbmdSaWdodCA9PT0gdm9pZCAwID8gNCA6IF9wYXJhbXMkcGFkZGluZ1JpZ2h0LFxuICAgICAgICAgICAgX3BhcmFtcyRwYWRkaW5nQm90dG9tID0gcGFyYW1zLnBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gX3BhcmFtcyRwYWRkaW5nQm90dG9tID09PSB2b2lkIDAgPyAyIDogX3BhcmFtcyRwYWRkaW5nQm90dG9tLFxuICAgICAgICAgICAgX3BhcmFtcyRwYWRkaW5nVG9wID0gcGFyYW1zLnBhZGRpbmdUb3AsXG4gICAgICAgICAgICBwYWRkaW5nVG9wID0gX3BhcmFtcyRwYWRkaW5nVG9wID09PSB2b2lkIDAgPyAyIDogX3BhcmFtcyRwYWRkaW5nVG9wO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IgfHwgJ3N0YXJ0JyxcbiAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUgfHwgJzEycHgnLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQgfHwgJ3JlZ3VsYXInLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseSxcbiAgICAgICAgICBmb3JlQ29sb3I6IGZvcmVDb2xvciB8fCB3LmNvbmZpZy5jaGFydC5mb3JlQ29sb3IsXG4gICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXRleHQgJyArIGNzc0NsYXNzID8gY3NzQ2xhc3MgOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxUZXh0Lm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRSZWN0ID0gZWxUZXh0LmJib3goKTtcblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHZhciBlbFJlY3QgPSB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KHRleHRSZWN0LnggLSBwYWRkaW5nTGVmdCwgdGV4dFJlY3QueSAtIHBhZGRpbmdUb3AsIHRleHRSZWN0LndpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQsIHRleHRSZWN0LmhlaWdodCArIHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nVG9wLCBib3JkZXJSYWRpdXMsIGJhY2tncm91bmRDb2xvciA/IGJhY2tncm91bmRDb2xvciA6ICd0cmFuc3BhcmVudCcsIDEsIGJvcmRlcldpZHRoLCBib3JkZXJDb2xvciwgc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsUmVjdC5ub2RlLCBlbFRleHQubm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkSW1hZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbWFnZShwYXJhbXMsIGluZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcGF0aCA9IHBhcmFtcy5wYXRoLFxuICAgICAgICAgICAgX3BhcmFtcyR4ID0gcGFyYW1zLngsXG4gICAgICAgICAgICB4ID0gX3BhcmFtcyR4ID09PSB2b2lkIDAgPyAwIDogX3BhcmFtcyR4LFxuICAgICAgICAgICAgX3BhcmFtcyR5ID0gcGFyYW1zLnksXG4gICAgICAgICAgICB5ID0gX3BhcmFtcyR5ID09PSB2b2lkIDAgPyAwIDogX3BhcmFtcyR5LFxuICAgICAgICAgICAgX3BhcmFtcyR3aWR0aCA9IHBhcmFtcy53aWR0aCxcbiAgICAgICAgICAgIHdpZHRoID0gX3BhcmFtcyR3aWR0aCA9PT0gdm9pZCAwID8gMjAgOiBfcGFyYW1zJHdpZHRoLFxuICAgICAgICAgICAgX3BhcmFtcyRoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0ID0gX3BhcmFtcyRoZWlnaHQgPT09IHZvaWQgMCA/IDIwIDogX3BhcmFtcyRoZWlnaHQsXG4gICAgICAgICAgICBfcGFyYW1zJGFwcGVuZFRvMiA9IHBhcmFtcy5hcHBlbmRUbyxcbiAgICAgICAgICAgIGFwcGVuZFRvID0gX3BhcmFtcyRhcHBlbmRUbzIgPT09IHZvaWQgMCA/ICcuYXBleGNoYXJ0cy1hbm5vdGF0aW9ucycgOiBfcGFyYW1zJGFwcGVuZFRvMjtcbiAgICAgICAgdmFyIGltZyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuaW1hZ2UocGF0aCk7XG4gICAgICAgIGltZy5zaXplKHdpZHRoLCBoZWlnaHQpLm1vdmUoeCwgeSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKGFwcGVuZFRvKTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGltZy5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgICB9IC8vIFRoZSBhZGRYYXhpc0Fubm90YXRpb24gbWV0aG9kIHJlcXVpcmVzIGEgcGFyZW50IGNsYXNzLCBhbmQgdXNlciBjYWxsaW5nIHRoaXMgbWV0aG9kIGV4dGVybmFsbHkgb24gdGhlIGNoYXJ0IGluc3RhbmNlIG1heSBub3Qgc3BlY2lmeSBwYXJlbnQsIGhlbmNlIGEgZGlmZmVyZW50IG1ldGhvZFxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFhheGlzQW5ub3RhdGlvbkV4dGVybmFsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWGF4aXNBbm5vdGF0aW9uRXh0ZXJuYWwocGFyYW1zLCBwdXNoVG9NZW1vcnksIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5hZGRBbm5vdGF0aW9uRXh0ZXJuYWwoe1xuICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIHB1c2hUb01lbW9yeTogcHVzaFRvTWVtb3J5LFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgdHlwZTogJ3hheGlzJyxcbiAgICAgICAgICBjb250ZXh0TWV0aG9kOiBjb250ZXh0LmFkZFhheGlzQW5ub3RhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFlheGlzQW5ub3RhdGlvbkV4dGVybmFsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWWF4aXNBbm5vdGF0aW9uRXh0ZXJuYWwocGFyYW1zLCBwdXNoVG9NZW1vcnksIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5hZGRBbm5vdGF0aW9uRXh0ZXJuYWwoe1xuICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIHB1c2hUb01lbW9yeTogcHVzaFRvTWVtb3J5LFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgdHlwZTogJ3lheGlzJyxcbiAgICAgICAgICBjb250ZXh0TWV0aG9kOiBjb250ZXh0LmFkZFlheGlzQW5ub3RhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFBvaW50QW5ub3RhdGlvbkV4dGVybmFsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRBbm5vdGF0aW9uRXh0ZXJuYWwocGFyYW1zLCBwdXNoVG9NZW1vcnksIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludmVydEF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5pbnZlcnRBeGlzID0gY29udGV4dC53Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRBbm5vdGF0aW9uRXh0ZXJuYWwoe1xuICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIHB1c2hUb01lbW9yeTogcHVzaFRvTWVtb3J5LFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgdHlwZTogJ3BvaW50JyxcbiAgICAgICAgICBjb250ZXh0TWV0aG9kOiBjb250ZXh0LmFkZFBvaW50QW5ub3RhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZEFubm90YXRpb25FeHRlcm5hbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFubm90YXRpb25FeHRlcm5hbChfcmVmKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBfcmVmLnBhcmFtcyxcbiAgICAgICAgICAgIHB1c2hUb01lbW9yeSA9IF9yZWYucHVzaFRvTWVtb3J5LFxuICAgICAgICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgICBjb250ZXh0TWV0aG9kID0gX3JlZi5jb250ZXh0TWV0aG9kO1xuICAgICAgICB2YXIgbWUgPSBjb250ZXh0O1xuICAgICAgICB2YXIgdyA9IG1lLnc7XG4gICAgICAgIHZhciBwYXJlbnQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLWFubm90YXRpb25zXCIpKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoICsgMTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgICB2YXIgYXhlc0Fubm8gPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlID09PSAneGF4aXMnID8gb3B0aW9ucy54QXhpc0Fubm90YXRpb24gOiB0eXBlID09PSAneWF4aXMnID8gb3B0aW9ucy55QXhpc0Fubm90YXRpb24gOiBvcHRpb25zLnBvaW50QW5ub3RhdGlvbik7XG4gICAgICAgIHZhciBhbm5vID0gVXRpbHMkMS5leHRlbmQoYXhlc0Fubm8sIHBhcmFtcyk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAneGF4aXMnOlxuICAgICAgICAgICAgdGhpcy5hZGRYYXhpc0Fubm90YXRpb24oYW5ubywgcGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3lheGlzJzpcbiAgICAgICAgICAgIHRoaXMuYWRkWWF4aXNBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwb2ludCc6XG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50QW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIGFkZCBiYWNrZ3JvdW5kXG5cblxuICAgICAgICB2YXIgYXhlc0Fubm9MYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYW5ub3RhdGlvbnMgLmFwZXhjaGFydHMtXCIpLmNvbmNhdCh0eXBlLCBcIi1hbm5vdGF0aW9uLWxhYmVsW3JlbD0nXCIpLmNvbmNhdChpbmRleCwgXCInXVwiKSk7XG4gICAgICAgIHZhciBlbFJlY3QgPSB0aGlzLmhlbHBlcnMuYWRkQmFja2dyb3VuZFRvQW5ubyhheGVzQW5ub0xhYmVsLCBhbm5vKTtcblxuICAgICAgICBpZiAoZWxSZWN0KSB7XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbFJlY3Qubm9kZSwgYXhlc0Fubm9MYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHVzaFRvTWVtb3J5KSB7XG4gICAgICAgICAgdy5nbG9iYWxzLm1lbW9yeS5tZXRob2RzVG9FeGVjLnB1c2goe1xuICAgICAgICAgICAgY29udGV4dDogbWUsXG4gICAgICAgICAgICBpZDogYW5uby5pZCA/IGFubm8uaWQgOiBVdGlscyQxLnJhbmRvbUlkKCksXG4gICAgICAgICAgICBtZXRob2Q6IGNvbnRleHRNZXRob2QsXG4gICAgICAgICAgICBsYWJlbDogJ2FkZEFubm90YXRpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhckFubm90YXRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9ucyhjdHgpIHtcbiAgICAgICAgdmFyIHcgPSBjdHgudztcbiAgICAgICAgdmFyIGFubm9zID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteWF4aXMtYW5ub3RhdGlvbnMsIC5hcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb25zLCAuYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9ucycpOyAvLyBhbm5vdGF0aW9ucyBhZGRlZCBleHRlcm5hbGx5IHNob3VsZCBiZSBjbGVhcmVkIG91dCB0b29cblxuICAgICAgICB3Lmdsb2JhbHMubWVtb3J5Lm1ldGhvZHNUb0V4ZWMubWFwKGZ1bmN0aW9uIChtLCBpKSB7XG4gICAgICAgICAgaWYgKG0ubGFiZWwgPT09ICdhZGRUZXh0JyB8fCBtLmxhYmVsID09PSAnYWRkQW5ub3RhdGlvbicpIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5tZW1vcnkubWV0aG9kc1RvRXhlYy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYW5ub3MgPSBVdGlscyQxLmxpc3RUb0FycmF5KGFubm9zKTsgLy8gZGVsZXRlIHRoZSBET00gZWxlbWVudHNcblxuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFubm9zLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHdoaWxlIChhLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVBbm5vdGF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQW5ub3RhdGlvbihjdHgsIGlkKSB7XG4gICAgICAgIHZhciB3ID0gY3R4Lnc7XG4gICAgICAgIHZhciBhbm5vcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIuY29uY2F0KGlkKSk7XG5cbiAgICAgICAgaWYgKGFubm9zKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLm1lbW9yeS5tZXRob2RzVG9FeGVjLm1hcChmdW5jdGlvbiAobSwgaSkge1xuICAgICAgICAgICAgaWYgKG0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5tZW1vcnkubWV0aG9kc1RvRXhlYy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhbm5vcywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBbm5vdGF0aW9ucztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBEYXRlVGltZSBDbGFzcyB0byBtYW5pcHVsYXRlIGRhdGV0aW1lIHZhbHVlcy5cbiAgICpcbiAgICogQG1vZHVsZSBEYXRlVGltZVxuICAgKiovXG5cbiAgdmFyIERhdGVUaW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlVGltZShjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVGltZSk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgICB0aGlzLm1vbnRoczMxID0gWzEsIDMsIDUsIDcsIDgsIDEwLCAxMl07XG4gICAgICB0aGlzLm1vbnRoczMwID0gWzIsIDQsIDYsIDksIDExXTtcbiAgICAgIHRoaXMuZGF5c0NudE9mWWVhciA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGVUaW1lLCBbe1xuICAgICAga2V5OiBcImlzVmFsaWREYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHRoaXMucGFyc2VEYXRlKGRhdGUpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0VGltZVN0YW1wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGltZVN0YW1wKGRhdGVTdHIpIHtcbiAgICAgICAgaWYgKCFEYXRlLnBhcnNlKGRhdGVTdHIpKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGVTdHI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXRjID0gdGhpcy53LmNvbmZpZy54YXhpcy5sYWJlbHMuZGF0ZXRpbWVVVEM7XG4gICAgICAgIHJldHVybiAhdXRjID8gbmV3IERhdGUoZGF0ZVN0cikuZ2V0VGltZSgpIDogbmV3IERhdGUobmV3IERhdGUoZGF0ZVN0cikudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwgMjUpKS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldERhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRlKHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgdXRjID0gdGhpcy53LmNvbmZpZy54YXhpcy5sYWJlbHMuZGF0ZXRpbWVVVEM7XG4gICAgICAgIHJldHVybiB1dGMgPyBuZXcgRGF0ZShuZXcgRGF0ZSh0aW1lc3RhbXApLnRvVVRDU3RyaW5nKCkpIDogbmV3IERhdGUodGltZXN0YW1wKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGFyc2VEYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHIpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IERhdGUucGFyc2UoZGF0ZVN0cik7XG5cbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGltZVN0YW1wKGRhdGVTdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IERhdGUucGFyc2UoZGF0ZVN0ci5yZXBsYWNlKC8tL2csICcvJykucmVwbGFjZSgvW2Etel0rL2dpLCAnICcpKTtcbiAgICAgICAgb3V0cHV0ID0gdGhpcy5nZXRUaW1lU3RhbXAob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0gLy8gVGhpcyBmaXhlcyB0aGUgZGlmZmVyZW5jZSBvZiB4LWF4aXMgbGFiZWxzIGJldHdlZW4gY2hyb21lL3NhZmFyaVxuICAgICAgLy8gRml4ZXMgIzE3MjYsICMxNTQ0LCAjMTQ4NSwgIzEyNTVcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXJzZURhdGVXaXRoVGltZXpvbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGVXaXRoVGltZXpvbmUoZGF0ZVN0cikge1xuICAgICAgICByZXR1cm4gRGF0ZS5wYXJzZShkYXRlU3RyLnJlcGxhY2UoLy0vZywgJy8nKS5yZXBsYWNlKC9bYS16XSsvZ2ksICcgJykpO1xuICAgICAgfSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NjM4MDE4L2N1cnJlbnQtdGltZS1mb3JtYXR0aW5nLXdpdGgtamF2YXNjcmlwdCNhbnN3ZXItMTQ2MzgxOTFcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JtYXREYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMudy5nbG9iYWxzLmxvY2FsZTtcbiAgICAgICAgdmFyIHV0YyA9IHRoaXMudy5jb25maWcueGF4aXMubGFiZWxzLmRhdGV0aW1lVVRDO1xuICAgICAgICB2YXIgTU1NTSA9IFsnXFx4MDAnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5tb250aHMpKTtcbiAgICAgICAgdmFyIE1NTSA9IFsnXFx4MDEnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5zaG9ydE1vbnRocykpO1xuICAgICAgICB2YXIgZGRkZCA9IFsnXFx4MDInXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5kYXlzKSk7XG4gICAgICAgIHZhciBkZGQgPSBbJ1xceDAzJ10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb2NhbGUuc2hvcnREYXlzKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaWkoaSwgbGVuKSB7XG4gICAgICAgICAgdmFyIHMgPSBpICsgJyc7XG4gICAgICAgICAgbGVuID0gbGVuIHx8IDI7XG5cbiAgICAgICAgICB3aGlsZSAocy5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkgPSB1dGMgPyBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgOiBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKXl5eXkrL2csICckMScgKyB5KTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peXkvZywgJyQxJyArIHkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMikpO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSl5L2csICckMScgKyB5KTtcbiAgICAgICAgdmFyIE0gPSAodXRjID8gZGF0ZS5nZXRVVENNb250aCgpIDogZGF0ZS5nZXRNb250aCgpKSArIDE7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NTU0rL2csICckMScgKyBNTU1NWzBdKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pTU1NL2csICckMScgKyBNTU1bMF0pO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlNTS9nLCAnJDEnICsgaWkoTSkpO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlNL2csICckMScgKyBNKTtcbiAgICAgICAgdmFyIGQgPSB1dGMgPyBkYXRlLmdldFVUQ0RhdGUoKSA6IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlkZGRkKy9nLCAnJDEnICsgZGRkZFswXSk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkZC9nLCAnJDEnICsgZGRkWzBdKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pZGQvZywgJyQxJyArIGlpKGQpKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pZC9nLCAnJDEnICsgZCk7XG4gICAgICAgIHZhciBIID0gdXRjID8gZGF0ZS5nZXRVVENIb3VycygpIDogZGF0ZS5nZXRIb3VycygpO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlISCsvZywgJyQxJyArIGlpKEgpKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pSC9nLCAnJDEnICsgSCk7XG4gICAgICAgIHZhciBoID0gSCA+IDEyID8gSCAtIDEyIDogSCA9PT0gMCA/IDEyIDogSDtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0paGgrL2csICckMScgKyBpaShoKSk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWgvZywgJyQxJyArIGgpO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IGRhdGUuZ2V0VVRDTWludXRlcygpIDogZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKW1tKy9nLCAnJDEnICsgaWkobSkpO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSltL2csICckMScgKyBtKTtcbiAgICAgICAgdmFyIHMgPSB1dGMgPyBkYXRlLmdldFVUQ1NlY29uZHMoKSA6IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlzcysvZywgJyQxJyArIGlpKHMpKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pcy9nLCAnJDEnICsgcyk7XG4gICAgICAgIHZhciBmID0gdXRjID8gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSA6IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWZmZisvZywgJyQxJyArIGlpKGYsIDMpKTtcbiAgICAgICAgZiA9IE1hdGgucm91bmQoZiAvIDEwKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pZmYvZywgJyQxJyArIGlpKGYpKTtcbiAgICAgICAgZiA9IE1hdGgucm91bmQoZiAvIDEwKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pZi9nLCAnJDEnICsgZik7XG4gICAgICAgIHZhciBUID0gSCA8IDEyID8gJ0FNJyA6ICdQTSc7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKVRUKy9nLCAnJDEnICsgVCk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKVQvZywgJyQxJyArIFQuY2hhckF0KDApKTtcbiAgICAgICAgdmFyIHQgPSBULnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKXR0Ky9nLCAnJDEnICsgdCk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKXQvZywgJyQxJyArIHQuY2hhckF0KDApKTtcbiAgICAgICAgdmFyIHR6ID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgdmFyIEsgPSB1dGMgfHwgIXR6ID8gJ1onIDogdHogPiAwID8gJysnIDogJy0nO1xuXG4gICAgICAgIGlmICghdXRjKSB7XG4gICAgICAgICAgdHogPSBNYXRoLmFicyh0eik7XG4gICAgICAgICAgdmFyIHR6SHJzID0gTWF0aC5mbG9vcih0eiAvIDYwKTtcbiAgICAgICAgICB2YXIgdHpNaW4gPSB0eiAlIDYwO1xuICAgICAgICAgIEsgKz0gaWkodHpIcnMpICsgJzonICsgaWkodHpNaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pSy9nLCAnJDEnICsgSyk7XG4gICAgICAgIHZhciBkYXkgPSAodXRjID8gZGF0ZS5nZXRVVENEYXkoKSA6IGRhdGUuZ2V0RGF5KCkpICsgMTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobmV3IFJlZ0V4cChkZGRkWzBdLCAnZycpLCBkZGRkW2RheV0pO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKGRkZFswXSwgJ2cnKSwgZGRkW2RheV0pO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKE1NTU1bMF0sICdnJyksIE1NTU1bTV0pO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKE1NTVswXSwgJ2cnKSwgTU1NW01dKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFRpbWVVbml0c2Zyb21UaW1lc3RhbXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaW1lVW5pdHNmcm9tVGltZXN0YW1wKG1pblgsIG1heFgsIHV0Yykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtaW5YID0gdy5jb25maWcueGF4aXMubWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWF4WCA9IHcuY29uZmlnLnhheGlzLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0c01pbiA9IHRoaXMuZ2V0RGF0ZShtaW5YKTtcbiAgICAgICAgdmFyIHRzTWF4ID0gdGhpcy5nZXREYXRlKG1heFgpO1xuICAgICAgICB2YXIgbWluRCA9IHRoaXMuZm9ybWF0RGF0ZSh0c01pbiwgJ3l5eXkgTU0gZGQgSEggbW0gc3MgZmZmJykuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIG1heEQgPSB0aGlzLmZvcm1hdERhdGUodHNNYXgsICd5eXl5IE1NIGRkIEhIIG1tIHNzIGZmZicpLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluTWlsbGlzZWNvbmQ6IHBhcnNlSW50KG1pbkRbNl0sIDEwKSxcbiAgICAgICAgICBtYXhNaWxsaXNlY29uZDogcGFyc2VJbnQobWF4RFs2XSwgMTApLFxuICAgICAgICAgIG1pblNlY29uZDogcGFyc2VJbnQobWluRFs1XSwgMTApLFxuICAgICAgICAgIG1heFNlY29uZDogcGFyc2VJbnQobWF4RFs1XSwgMTApLFxuICAgICAgICAgIG1pbk1pbnV0ZTogcGFyc2VJbnQobWluRFs0XSwgMTApLFxuICAgICAgICAgIG1heE1pbnV0ZTogcGFyc2VJbnQobWF4RFs0XSwgMTApLFxuICAgICAgICAgIG1pbkhvdXI6IHBhcnNlSW50KG1pbkRbM10sIDEwKSxcbiAgICAgICAgICBtYXhIb3VyOiBwYXJzZUludChtYXhEWzNdLCAxMCksXG4gICAgICAgICAgbWluRGF0ZTogcGFyc2VJbnQobWluRFsyXSwgMTApLFxuICAgICAgICAgIG1heERhdGU6IHBhcnNlSW50KG1heERbMl0sIDEwKSxcbiAgICAgICAgICBtaW5Nb250aDogcGFyc2VJbnQobWluRFsxXSwgMTApIC0gMSxcbiAgICAgICAgICBtYXhNb250aDogcGFyc2VJbnQobWF4RFsxXSwgMTApIC0gMSxcbiAgICAgICAgICBtaW5ZZWFyOiBwYXJzZUludChtaW5EWzBdLCAxMCksXG4gICAgICAgICAgbWF4WWVhcjogcGFyc2VJbnQobWF4RFswXSwgMTApXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzTGVhcFllYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FsY3VsY2F0ZUxhc3REYXlzT2ZNb250aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGNhdGVMYXN0RGF5c09mTW9udGgobW9udGgsIHllYXIsIHN1YnRyYWN0KSB7XG4gICAgICAgIHZhciBkYXlzID0gdGhpcy5kZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGgsIHllYXIpOyAvLyB3aGF0ZXZlciBkYXlzIHdlIGdldCwgc3VidHJhY3QgdGhlIG51bWJlciBvZiBkYXlzIGFza2VkXG5cbiAgICAgICAgcmV0dXJuIGRheXMgLSBzdWJ0cmFjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGV0ZXJtaW5lRGF5c09mWWVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZURheXNPZlllYXIoeWVhcikge1xuICAgICAgICB2YXIgZGF5cyA9IDM2NTtcblxuICAgICAgICBpZiAodGhpcy5pc0xlYXBZZWFyKHllYXIpKSB7XG4gICAgICAgICAgZGF5cyA9IDM2NjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXRlcm1pbmVSZW1haW5pbmdEYXlzT2ZZZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lUmVtYWluaW5nRGF5c09mWWVhcih5ZWFyLCBtb250aCwgZGF0ZSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gdGhpcy5kYXlzQ250T2ZZZWFyW21vbnRoXSArIGRhdGU7XG4gICAgICAgIGlmIChtb250aCA+IDEgJiYgdGhpcy5pc0xlYXBZZWFyKCkpIGRheU9mWWVhcisrO1xuICAgICAgICByZXR1cm4gZGF5T2ZZZWFyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXRlcm1pbmVEYXlzT2ZNb250aHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGgsIHllYXIpIHtcbiAgICAgICAgdmFyIGRheXMgPSAzMDtcbiAgICAgICAgbW9udGggPSBVdGlscyQxLm1vbnRoTW9kKG1vbnRoKTtcblxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICBjYXNlIHRoaXMubW9udGhzMzAuaW5kZXhPZihtb250aCkgPiAtMTpcbiAgICAgICAgICAgIGlmIChtb250aCA9PT0gMikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0xlYXBZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICAgICAgZGF5cyA9IDI5O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheXMgPSAyODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgdGhpcy5tb250aHMzMS5pbmRleE9mKG1vbnRoKSA+IC0xOlxuICAgICAgICAgICAgZGF5cyA9IDMxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGF5cyA9IDMxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF5cztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0ZVRpbWU7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBGb3JtYXR0ZXIgQ2xhc3MgZm9yIHNldHRpbmcgdmFsdWUgZm9ybWF0dGVycyBmb3IgYXhlcyBhcyB3ZWxsIGFzIHRvb2x0aXBzLlxuICAgKlxuICAgKiBAbW9kdWxlIEZvcm1hdHRlcnNcbiAgICoqL1xuXG4gIHZhciBGb3JtYXR0ZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb3JtYXR0ZXJzKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1hdHRlcnMpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdGhpcy50b29sdGlwS2V5Rm9ybWF0ID0gJ2RkIE1NTSc7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEZvcm1hdHRlcnMsIFt7XG4gICAgICBrZXk6IFwieExhYmVsRm9ybWF0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24geExhYmVsRm9ybWF0KGZuLCB2YWwsIHRpbWVzdGFtcCwgb3B0cykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHVzZXIgaGFzIG5vdCBzcGVjaWZpZWQgYSBjdXN0b20gZm9ybWF0dGVyLCB1c2UgdGhlIGRlZmF1bHQgdG9vbHRpcC54LmZvcm1hdFxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgZGF0ZXRpbWVPYmogPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVPYmouZm9ybWF0RGF0ZShkYXRldGltZU9iai5nZXREYXRlKHZhbCksIHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbih2YWwsIHRpbWVzdGFtcCwgb3B0cyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlZmF1bHRHZW5lcmFsRm9ybWF0dGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEdlbmVyYWxGb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWZhdWx0WUZvcm1hdHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRZRm9ybWF0dGVyKHYsIHlheGUsIGkpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKFV0aWxzJDEuaXNOdW1iZXIodikpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnlWYWx1ZURlY2ltYWwgIT09IDApIHtcbiAgICAgICAgICAgIHYgPSB2LnRvRml4ZWQoeWF4ZS5kZWNpbWFsc0luRmxvYXQgIT09IHVuZGVmaW5lZCA/IHlheGUuZGVjaW1hbHNJbkZsb2F0IDogdy5nbG9iYWxzLnlWYWx1ZURlY2ltYWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLm1heFlBcnJbaV0gLSB3Lmdsb2JhbHMubWluWUFycltpXSA8IDUpIHtcbiAgICAgICAgICAgIHYgPSB2LnRvRml4ZWQoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSB2LnRvRml4ZWQoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldExhYmVsRm9ybWF0dGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldExhYmVsRm9ybWF0dGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICB3Lmdsb2JhbHMueGF4aXNUb29sdGlwRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5kZWZhdWx0R2VuZXJhbEZvcm1hdHRlcih2YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZGVmYXVsdEdlbmVyYWxGb3JtYXR0ZXIodmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB3Lmdsb2JhbHMudHRaRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdy5nbG9iYWxzLmxlZ2VuZEZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZGVmYXVsdEdlbmVyYWxGb3JtYXR0ZXIodmFsKTtcbiAgICAgICAgfTsgLy8gZm9ybWF0dGVyIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIG92ZXJ3cml0ZSBmb3JtYXQgcHJvcGVydHlcblxuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKFV0aWxzJDEuaXNOdW1iZXIodmFsKSkge1xuICAgICAgICAgICAgICBpZiAoIXcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYyAmJiB3LmNvbmZpZy54YXhpcy50eXBlID09PSAnbnVtZXJpYycpIHtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMkMS5pc051bWJlcih3LmNvbmZpZy54YXhpcy5kZWNpbWFsc0luRmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQody5jb25maWcueGF4aXMuZGVjaW1hbHNJbkZsb2F0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSB3Lmdsb2JhbHMubWF4WCAtIHcuZ2xvYmFscy5taW5YO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDAgJiYgZGlmZiA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHcuZ2xvYmFscy5tYXhZIC0gdy5nbG9iYWxzLm1pbllBcnI7XG5cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPCA0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMudHRLZXlGb3JtYXR0ZXIgPSB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLnhheGlzLnRvb2x0aXAuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnhheGlzVG9vbHRpcEZvcm1hdHRlciA9IHcuY29uZmlnLnhheGlzLnRvb2x0aXAuZm9ybWF0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcudG9vbHRpcC55KSkge1xuICAgICAgICAgIHcuZ2xvYmFscy50dFZhbCA9IHcuY29uZmlnLnRvb2x0aXAueTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC55LmZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMudHRWYWwgPSB3LmNvbmZpZy50b29sdGlwLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuei5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHcuZ2xvYmFscy50dFpGb3JtYXR0ZXIgPSB3LmNvbmZpZy50b29sdGlwLnouZm9ybWF0dGVyO1xuICAgICAgICB9IC8vIGxlZ2VuZCBmb3JtYXR0ZXIgLSBpZiB1c2VyIHdhbnRzIHRvIGFwcGVuZCBhbnkgZ2xvYmFsIHZhbHVlcyBvZiBzZXJpZXMgdG8gbGVnZW5kIHRleHRcblxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQuZm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMubGVnZW5kRm9ybWF0dGVyID0gdy5jb25maWcubGVnZW5kLmZvcm1hdHRlcjtcbiAgICAgICAgfSAvLyBmb3JtYXR0ZXIgZnVuY3Rpb24gd2lsbCBhbHdheXMgb3ZlcndyaXRlIGZvcm1hdCBwcm9wZXJ0eVxuXG5cbiAgICAgICAgdy5jb25maWcueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaSkge1xuICAgICAgICAgIGlmICh5YXhlLmxhYmVscy5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaV0gPSB5YXhlLmxhYmVscy5mb3JtYXR0ZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzW2ldID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICBpZiAoIXcuZ2xvYmFscy54eUNoYXJ0cykgcmV0dXJuIHZhbDtcblxuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWZhdWx0WUZvcm1hdHRlcih2LCB5YXhlLCBpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVmYXVsdFlGb3JtYXR0ZXIodmFsLCB5YXhlLCBpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdy5nbG9iYWxzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoZWF0bWFwTGFiZWxGb3JtYXR0ZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGVhdG1hcExhYmVsRm9ybWF0dGVycygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICAgIHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLnJlc3VsdCA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lcy5zbGljZSgpOyAvLyAgZ2V0IHRoZSBsb25nZXN0IHN0cmluZyBmcm9tIHRoZSBsYWJlbHMgYXJyYXkgYW5kIGFsc28gYXBwbHkgbGFiZWwgZm9ybWF0dGVyIHRvIGl0XG5cbiAgICAgICAgICB2YXIgbG9uZ2VzdCA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1heCA9IGxvbmdlc3Q7XG4gICAgICAgICAgdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1pbiA9IGxvbmdlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRm9ybWF0dGVycztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIERlZmF1bHQgQ2xhc3MgZm9yIHNldHRpbmcgZGVmYXVsdCBvcHRpb25zIGZvciBhbGwgY2hhcnQgdHlwZXMuXG4gICAqXG4gICAqIEBtb2R1bGUgRGVmYXVsdHNcbiAgICoqL1xuXG4gIHZhciBnZXRSYW5nZVZhbHVlcyA9IGZ1bmN0aW9uIGdldFJhbmdlVmFsdWVzKF9yZWYpIHtcbiAgICB2YXIgX3ckY29uZmlnJHNlcmllcyRzZXJpO1xuXG4gICAgdmFyIGlzVGltZWxpbmUgPSBfcmVmLmlzVGltZWxpbmUsXG4gICAgICAgIGN0eCA9IF9yZWYuY3R4LFxuICAgICAgICBzZXJpZXNJbmRleCA9IF9yZWYuc2VyaWVzSW5kZXgsXG4gICAgICAgIGRhdGFQb2ludEluZGV4ID0gX3JlZi5kYXRhUG9pbnRJbmRleCxcbiAgICAgICAgeTEgPSBfcmVmLnkxLFxuICAgICAgICB5MiA9IF9yZWYueTIsXG4gICAgICAgIHcgPSBfcmVmLnc7XG4gICAgdmFyIHN0YXJ0ID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlU3RhcnRbc2VyaWVzSW5kZXhdW2RhdGFQb2ludEluZGV4XTtcbiAgICB2YXIgZW5kID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlRW5kW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF07XG4gICAgdmFyIHlsYWJlbCA9IHcuZ2xvYmFscy5sYWJlbHNbZGF0YVBvaW50SW5kZXhdO1xuICAgIHZhciBzZXJpZXNOYW1lID0gdy5jb25maWcuc2VyaWVzW3Nlcmllc0luZGV4XS5uYW1lID8gdy5jb25maWcuc2VyaWVzW3Nlcmllc0luZGV4XS5uYW1lIDogJyc7XG4gICAgdmFyIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy50dEtleUZvcm1hdHRlcjtcbiAgICB2YXIgeUxiVGl0bGVGb3JtYXR0ZXIgPSB3LmNvbmZpZy50b29sdGlwLnkudGl0bGUuZm9ybWF0dGVyO1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgdzogdyxcbiAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgIGRhdGFQb2ludEluZGV4OiBkYXRhUG9pbnRJbmRleCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgeUxiVGl0bGVGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlcmllc05hbWUgPSB5TGJUaXRsZUZvcm1hdHRlcihzZXJpZXNOYW1lLCBvcHRzKTtcbiAgICB9XG5cbiAgICBpZiAoKF93JGNvbmZpZyRzZXJpZXMkc2VyaSA9IHcuY29uZmlnLnNlcmllc1tzZXJpZXNJbmRleF0uZGF0YVtkYXRhUG9pbnRJbmRleF0pICE9PSBudWxsICYmIF93JGNvbmZpZyRzZXJpZXMkc2VyaSAhPT0gdm9pZCAwICYmIF93JGNvbmZpZyRzZXJpZXMkc2VyaS54KSB7XG4gICAgICB5bGFiZWwgPSB3LmNvbmZpZy5zZXJpZXNbc2VyaWVzSW5kZXhdLmRhdGFbZGF0YVBvaW50SW5kZXhdLng7XG4gICAgfVxuXG4gICAgaWYgKCFpc1RpbWVsaW5lKSB7XG4gICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICB2YXIgeEZvcm1hdCA9IG5ldyBGb3JtYXR0ZXJzKGN0eCk7XG4gICAgICAgIHlsYWJlbCA9IHhGb3JtYXQueExhYmVsRm9ybWF0KHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciwgeWxhYmVsLCB5bGFiZWwsIHtcbiAgICAgICAgICBpOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGF0ZUZvcm1hdHRlcjogbmV3IERhdGVUaW1lKGN0eCkuZm9ybWF0RGF0ZSxcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgeUxiRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB5bGFiZWwgPSB5TGJGb3JtYXR0ZXIoeWxhYmVsLCBvcHRzKTtcbiAgICB9XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHkxKSAmJiBOdW1iZXIuaXNGaW5pdGUoeTIpKSB7XG4gICAgICBzdGFydCA9IHkxO1xuICAgICAgZW5kID0geTI7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0VmFsID0gJyc7XG4gICAgdmFyIGVuZFZhbCA9ICcnO1xuICAgIHZhciBjb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbc2VyaWVzSW5kZXhdO1xuXG4gICAgaWYgKHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgdmFyIGRhdGV0aW1lT2JqID0gbmV3IERhdGVUaW1lKGN0eCk7XG4gICAgICAgIHN0YXJ0VmFsID0gZGF0ZXRpbWVPYmouZm9ybWF0RGF0ZShkYXRldGltZU9iai5nZXREYXRlKHN0YXJ0KSwgdy5jb25maWcudG9vbHRpcC54LmZvcm1hdCk7XG4gICAgICAgIGVuZFZhbCA9IGRhdGV0aW1lT2JqLmZvcm1hdERhdGUoZGF0ZXRpbWVPYmouZ2V0RGF0ZShlbmQpLCB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VmFsID0gc3RhcnQ7XG4gICAgICAgIGVuZFZhbCA9IGVuZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRWYWwgPSB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0dGVyKHN0YXJ0KTtcbiAgICAgIGVuZFZhbCA9IHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIoZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmQsXG4gICAgICBzdGFydFZhbDogc3RhcnRWYWwsXG4gICAgICBlbmRWYWw6IGVuZFZhbCxcbiAgICAgIHlsYWJlbDogeWxhYmVsLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTmFtZVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGJ1aWxkUmFuZ2VUb29sdGlwSFRNTCA9IGZ1bmN0aW9uIGJ1aWxkUmFuZ2VUb29sdGlwSFRNTChvcHRzKSB7XG4gICAgdmFyIGNvbG9yID0gb3B0cy5jb2xvcixcbiAgICAgICAgc2VyaWVzTmFtZSA9IG9wdHMuc2VyaWVzTmFtZSxcbiAgICAgICAgeWxhYmVsID0gb3B0cy55bGFiZWwsXG4gICAgICAgIHN0YXJ0ID0gb3B0cy5zdGFydCxcbiAgICAgICAgZW5kID0gb3B0cy5lbmQsXG4gICAgICAgIHNlcmllc0luZGV4ID0gb3B0cy5zZXJpZXNJbmRleCxcbiAgICAgICAgZGF0YVBvaW50SW5kZXggPSBvcHRzLmRhdGFQb2ludEluZGV4O1xuICAgIHZhciBmb3JtYXR0ZXIgPSBvcHRzLmN0eC50b29sdGlwLnRvb2x0aXBMYWJlbHMuZ2V0Rm9ybWF0dGVycyhzZXJpZXNJbmRleCk7XG4gICAgc3RhcnQgPSBmb3JtYXR0ZXIueUxiRm9ybWF0dGVyKHN0YXJ0KTtcbiAgICBlbmQgPSBmb3JtYXR0ZXIueUxiRm9ybWF0dGVyKGVuZCk7XG4gICAgdmFyIHZhbCA9IGZvcm1hdHRlci55TGJGb3JtYXR0ZXIob3B0cy53Lmdsb2JhbHMuc2VyaWVzW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF0pO1xuICAgIHZhciB2YWx1ZUhUTUwgPSAnJztcbiAgICB2YXIgcmFuZ2VWYWx1ZXMgPSBcIjxzcGFuIGNsYXNzPVxcXCJ2YWx1ZSBzdGFydC12YWx1ZVxcXCI+XFxuICBcIi5jb25jYXQoc3RhcnQsIFwiXFxuICA8L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJzZXBhcmF0b3JcXFwiPi08L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJ2YWx1ZSBlbmQtdmFsdWVcXFwiPlxcbiAgXCIpLmNvbmNhdChlbmQsIFwiXFxuICA8L3NwYW4+XCIpO1xuXG4gICAgaWYgKG9wdHMudy5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICBpZiAob3B0cy53LmNvbmZpZy5zZXJpZXNbc2VyaWVzSW5kZXhdLnR5cGUgPT09ICdyYW5nZUFyZWEnIHx8IG9wdHMudy5jb25maWcuc2VyaWVzW3Nlcmllc0luZGV4XS50eXBlID09PSAncmFuZ2VCYXInKSB7XG4gICAgICAgIHZhbHVlSFRNTCA9IHJhbmdlVmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVIVE1MID0gXCI8c3Bhbj5cIi5jb25jYXQodmFsLCBcIjwvc3Bhbj5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlSFRNTCA9IHJhbmdlVmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiAnPGRpdiBjbGFzcz1cImFwZXhjaGFydHMtdG9vbHRpcC1yYW5nZWJhclwiPicgKyAnPGRpdj4gPHNwYW4gY2xhc3M9XCJzZXJpZXMtbmFtZVwiIHN0eWxlPVwiY29sb3I6ICcgKyBjb2xvciArICdcIj4nICsgKHNlcmllc05hbWUgPyBzZXJpZXNOYW1lIDogJycpICsgJzwvc3Bhbj48L2Rpdj4nICsgJzxkaXY+IDxzcGFuIGNsYXNzPVwiY2F0ZWdvcnlcIj4nICsgeWxhYmVsICsgJzogPC9zcGFuPiAnICsgdmFsdWVIVE1MICsgJyA8L2Rpdj4nICsgJzwvZGl2Pic7XG4gIH07XG5cbiAgdmFyIERlZmF1bHRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0cyhvcHRzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdHMpO1xuXG4gICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEZWZhdWx0cywgW3tcbiAgICAgIGtleTogXCJoaWRlWUF4aXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlWUF4aXMoKSB7XG4gICAgICAgIHRoaXMub3B0cy55YXhpc1swXS5zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0cy55YXhpc1swXS50aXRsZS50ZXh0ID0gJyc7XG4gICAgICAgIHRoaXMub3B0cy55YXhpc1swXS5heGlzQm9yZGVyLnNob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRzLnlheGlzWzBdLmF4aXNUaWNrcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0cy55YXhpc1swXS5mbG9hdGluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxpbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgIGVhc2luZzogJ3N3aW5nJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgd2lkdGg6IDUsXG4gICAgICAgICAgICBjdXJ2ZTogJ3N0cmFpZ2h0J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICAgIHNpemVPZmZzZXQ6IDZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzcGFya2xpbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzcGFya2xpbmUoZGVmYXVsdHMpIHtcbiAgICAgICAgdGhpcy5oaWRlWUF4aXMoKTtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF4aXNCb3JkZXI6IHtcbiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBheGlzVGlja3M6IHtcbiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBVdGlscyQxLmV4dGVuZChkZWZhdWx0cywgcmV0KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYmFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmFyKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgZWFzaW5nOiAnc3dpbmcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2NlbnRlcidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBsaW5lQ2FwOiAncm91bmQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjg1XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgICAgc2hhcGU6ICdzcXVhcmUnLFxuICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHNoYXJlZDogZmFsc2UsXG4gICAgICAgICAgICBpbnRlcnNlY3Q6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGlja1BsYWNlbWVudDogJ2JldHdlZW4nLFxuICAgICAgICAgICAgY3Jvc3NoYWlyczoge1xuICAgICAgICAgICAgICB3aWR0aDogJ2JhcldpZHRoJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdiYWNrJyxcbiAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdncmFkaWVudCdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZ1bm5lbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZ1bm5lbCgpIHtcbiAgICAgICAgdGhpcy5oaWRlWUF4aXMoKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLmJhcigpKSwge30sIHtcbiAgICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgICAgICBhbmltYXRlR3JhZHVhbGx5OiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICBob3Jpem9udGFsOiB0cnVlLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXNBcHBsaWNhdGlvbjogJ2Fyb3VuZCcsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnY2VudGVyJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXhpc0JvcmRlcjoge1xuICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF4aXNUaWNrczoge1xuICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbmRsZXN0aWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuZGxlc3RpY2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgY29sb3JzOiBbJyMzMzMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHNoYXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBzZXJpZXNJbmRleCA9IF9yZWYyLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXggPSBfcmVmMi5kYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgIHcgPSBfcmVmMi53O1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dldEJveFRvb2x0aXAodywgc2VyaWVzSW5kZXgsIGRhdGFQb2ludEluZGV4LCBbJ09wZW4nLCAnSGlnaCcsICcnLCAnTG93JywgJ0Nsb3NlJ10sICdjYW5kbGVzdGljaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJib3hQbG90XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYm94UGxvdCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICBkeW5hbWljQW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgIGNvbG9yczogWycjMjQyOTJlJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBzaGFyZWQ6IHRydWUsXG4gICAgICAgICAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShfcmVmMykge1xuICAgICAgICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBfcmVmMy5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4ID0gX3JlZjMuZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICB3ID0gX3JlZjMudztcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fZ2V0Qm94VG9vbHRpcCh3LCBzZXJpZXNJbmRleCwgZGF0YVBvaW50SW5kZXgsIFsnTWluaW11bScsICdRMScsICdNZWRpYW4nLCAnUTMnLCAnTWF4aW11bSddLCAnYm94UGxvdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgc2l6ZTogNSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3JzOiAnIzExMSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyYW5nZUJhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlQmFyKCkge1xuICAgICAgICB2YXIgaGFuZGxlVGltZWxpbmVUb29sdGlwID0gZnVuY3Rpb24gaGFuZGxlVGltZWxpbmVUb29sdGlwKG9wdHMpIHtcbiAgICAgICAgICB2YXIgX2dldFJhbmdlVmFsdWVzID0gZ2V0UmFuZ2VWYWx1ZXMoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdHMpLCB7fSwge1xuICAgICAgICAgICAgaXNUaW1lbGluZTogdHJ1ZVxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgY29sb3IgPSBfZ2V0UmFuZ2VWYWx1ZXMuY29sb3IsXG4gICAgICAgICAgICAgIHNlcmllc05hbWUgPSBfZ2V0UmFuZ2VWYWx1ZXMuc2VyaWVzTmFtZSxcbiAgICAgICAgICAgICAgeWxhYmVsID0gX2dldFJhbmdlVmFsdWVzLnlsYWJlbCxcbiAgICAgICAgICAgICAgc3RhcnRWYWwgPSBfZ2V0UmFuZ2VWYWx1ZXMuc3RhcnRWYWwsXG4gICAgICAgICAgICAgIGVuZFZhbCA9IF9nZXRSYW5nZVZhbHVlcy5lbmRWYWw7XG5cbiAgICAgICAgICByZXR1cm4gYnVpbGRSYW5nZVRvb2x0aXBIVE1MKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRzKSwge30sIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICAgICAgICB5bGFiZWw6IHlsYWJlbCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydFZhbCxcbiAgICAgICAgICAgIGVuZDogZW5kVmFsXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVSYW5nZUNvbHVtblRvb2x0aXAgPSBmdW5jdGlvbiBoYW5kbGVSYW5nZUNvbHVtblRvb2x0aXAob3B0cykge1xuICAgICAgICAgIHZhciBfZ2V0UmFuZ2VWYWx1ZXMyID0gZ2V0UmFuZ2VWYWx1ZXMob3B0cyksXG4gICAgICAgICAgICAgIGNvbG9yID0gX2dldFJhbmdlVmFsdWVzMi5jb2xvcixcbiAgICAgICAgICAgICAgc2VyaWVzTmFtZSA9IF9nZXRSYW5nZVZhbHVlczIuc2VyaWVzTmFtZSxcbiAgICAgICAgICAgICAgeWxhYmVsID0gX2dldFJhbmdlVmFsdWVzMi55bGFiZWwsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gX2dldFJhbmdlVmFsdWVzMi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kID0gX2dldFJhbmdlVmFsdWVzMi5lbmQ7XG5cbiAgICAgICAgICByZXR1cm4gYnVpbGRSYW5nZVRvb2x0aXBIVE1MKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRzKSwge30sIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICAgICAgICB5bGFiZWw6IHlsYWJlbCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgYW5pbWF0ZUdyYWR1YWxseTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBsaW5lQ2FwOiAnc3F1YXJlJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2NlbnRlcidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwsIF9yZWY0KSB7XG4gICAgICAgICAgICAgIF9yZWY0LmN0eDtcbiAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJbmRleCA9IF9yZWY0LnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXggPSBfcmVmNC5kYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgIHcgPSBfcmVmNC53O1xuXG4gICAgICAgICAgICAgIHZhciBnZXRWYWwgPSBmdW5jdGlvbiBnZXRWYWwoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlU3RhcnRbc2VyaWVzSW5kZXhdW2RhdGFQb2ludEluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlRW5kW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuY29tYm9DaGFydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAody5jb25maWcuc2VyaWVzW3Nlcmllc0luZGV4XS50eXBlID09PSAncmFuZ2VCYXInIHx8IHcuY29uZmlnLnNlcmllc1tzZXJpZXNJbmRleF0udHlwZSA9PT0gJ3JhbmdlQXJlYScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWwoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNpemU6IDEwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZm9sbG93Q3Vyc29yOiB0cnVlLFxuICAgICAgICAgICAgY3VzdG9tOiBmdW5jdGlvbiBjdXN0b20ob3B0cykge1xuICAgICAgICAgICAgICBpZiAob3B0cy53LmNvbmZpZy5wbG90T3B0aW9ucyAmJiBvcHRzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhciAmJiBvcHRzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVRpbWVsaW5lVG9vbHRpcChvcHRzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmFuZ2VDb2x1bW5Ub29sdGlwKG9wdHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgdGlja1BsYWNlbWVudDogJ2JldHdlZW4nLFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHVtYmJlbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdW1iYmVsbChvcHRzKSB7XG4gICAgICAgIHZhciBfb3B0cyRwbG90T3B0aW9ucyRiYXIsIF9vcHRzJHBsb3RPcHRpb25zJGJhcjI7XG5cbiAgICAgICAgaWYgKCEoKF9vcHRzJHBsb3RPcHRpb25zJGJhciA9IG9wdHMucGxvdE9wdGlvbnMuYmFyKSAhPT0gbnVsbCAmJiBfb3B0cyRwbG90T3B0aW9ucyRiYXIgIT09IHZvaWQgMCAmJiBfb3B0cyRwbG90T3B0aW9ucyRiYXIuYmFySGVpZ2h0KSkge1xuICAgICAgICAgIG9wdHMucGxvdE9wdGlvbnMuYmFyLmJhckhlaWdodCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgoX29wdHMkcGxvdE9wdGlvbnMkYmFyMiA9IG9wdHMucGxvdE9wdGlvbnMuYmFyKSAhPT0gbnVsbCAmJiBfb3B0cyRwbG90T3B0aW9ucyRiYXIyICE9PSB2b2lkIDAgJiYgX29wdHMkcGxvdE9wdGlvbnMkYmFyMi5jb2x1bW5XaWR0aCkpIHtcbiAgICAgICAgICBvcHRzLnBsb3RPcHRpb25zLmJhci5jb2x1bW5XaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXJlYVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFyZWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICB3aWR0aDogNCxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgICAgICBpbnZlcnNlQ29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaGFkZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndmVydGljYWwnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAwLjY1LFxuICAgICAgICAgICAgICAgIG9wYWNpdHlUbzogMC41LFxuICAgICAgICAgICAgICAgIHN0b3BzOiBbMCwgMTAwLCAxMDBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIHR5cGU6ICdncmFkaWVudCcsXG4gICAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgICBpbnZlcnNlQ29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgc2hhZGU6ICdsaWdodCcsXG4gICAgICAgICAgICAgIHR5cGU6ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAwLjY1LFxuICAgICAgICAgICAgICBvcGFjaXR5VG86IDAuNSxcbiAgICAgICAgICAgICAgc3RvcHM6IFswLCAxMDAsIDEwMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgICBzaXplT2Zmc2V0OiA2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBmb2xsb3dDdXJzb3I6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyYW5nZUFyZWFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZUFyZWEoKSB7XG4gICAgICAgIHZhciBoYW5kbGVSYW5nZUFyZWFUb29sdGlwID0gZnVuY3Rpb24gaGFuZGxlUmFuZ2VBcmVhVG9vbHRpcChvcHRzKSB7XG4gICAgICAgICAgdmFyIF9nZXRSYW5nZVZhbHVlczMgPSBnZXRSYW5nZVZhbHVlcyhvcHRzKSxcbiAgICAgICAgICAgICAgY29sb3IgPSBfZ2V0UmFuZ2VWYWx1ZXMzLmNvbG9yLFxuICAgICAgICAgICAgICBzZXJpZXNOYW1lID0gX2dldFJhbmdlVmFsdWVzMy5zZXJpZXNOYW1lLFxuICAgICAgICAgICAgICB5bGFiZWwgPSBfZ2V0UmFuZ2VWYWx1ZXMzLnlsYWJlbCxcbiAgICAgICAgICAgICAgc3RhcnQgPSBfZ2V0UmFuZ2VWYWx1ZXMzLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQgPSBfZ2V0UmFuZ2VWYWx1ZXMzLmVuZDtcblxuICAgICAgICAgIHJldHVybiBidWlsZFJhbmdlVG9vbHRpcEhUTUwoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdHMpLCB7fSwge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTmFtZSxcbiAgICAgICAgICAgIHlsYWJlbDogeWxhYmVsLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgIGN1cnZlOiAnc3RyYWlnaHQnLFxuICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjZcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGludGVyc2VjdDogZmFsc2UsXG4gICAgICAgICAgICBzaGFyZWQ6IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dDdXJzb3I6IHRydWUsXG4gICAgICAgICAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShvcHRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSYW5nZUFyZWFUb29sdGlwKG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnJ1c2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBicnVzaChkZWZhdWx0cykge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICAgIGF1dG9TZWxlY3RlZDogJ3NlbGVjdGlvbicsXG4gICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgd2lkdGg6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFV0aWxzJDEuZXh0ZW5kKGRlZmF1bHRzLCByZXQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFja2VkMTAwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhY2tlZDEwMChvcHRzKSB7XG4gICAgICAgIG9wdHMuZGF0YUxhYmVscyA9IG9wdHMuZGF0YUxhYmVscyB8fCB7fTtcbiAgICAgICAgb3B0cy5kYXRhTGFiZWxzLmZvcm1hdHRlciA9IG9wdHMuZGF0YUxhYmVscy5mb3JtYXR0ZXIgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZXhpc3RpbmdEYXRhTGFiZWxGb3JtYXR0ZXIgPSBvcHRzLmRhdGFMYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgICBvcHRzLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgICAgb3B0cy55YXhpc1tpbmRleF0ubWluID0gMDtcbiAgICAgICAgICBvcHRzLnlheGlzW2luZGV4XS5tYXggPSAxMDA7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXNCYXIgPSBvcHRzLmNoYXJ0LnR5cGUgPT09ICdiYXInO1xuXG4gICAgICAgIGlmIChpc0Jhcikge1xuICAgICAgICAgIG9wdHMuZGF0YUxhYmVscy5mb3JtYXR0ZXIgPSBleGlzdGluZ0RhdGFMYWJlbEZvcm1hdHRlciB8fCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbCA/IHZhbC50b0ZpeGVkKDApICsgJyUnIDogdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhY2tlZEJhcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFja2VkQmFycygpIHtcbiAgICAgICAgdmFyIGJhckRlZmF1bHRzID0gdGhpcy5iYXIoKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXJEZWZhdWx0cyksIHt9LCB7XG4gICAgICAgICAgcGxvdE9wdGlvbnM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXJEZWZhdWx0cy5wbG90T3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICBiYXI6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXJEZWZhdWx0cy5wbG90T3B0aW9ucy5iYXIpLCB7fSwge1xuICAgICAgICAgICAgICBib3JkZXJSYWRpdXNBcHBsaWNhdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1c1doZW5TdGFja2VkOiAnbGFzdCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgbGVmdCBhbmQgcmlnaHQgc3BhY2luZyBpbiBjaGFydCBmb3IgbGluZS9hcmVhL3NjYXR0ZXIgaWYgeGF4aXMgdHlwZSA9IGNhdGVnb3J5IGZvciB0aG9zZSBjaGFydHMgYnkgY29udmVydGluZyB4YXhpcyA9IG51bWVyaWMuIE51bWVyaWMvRGF0ZXRpbWUgeGF4aXMgcHJldmVudHMgdGhlIHVubmVjZXNzYXJ5IHNwYWNpbmcgaW4gdGhlIGxlZnQvcmlnaHQgb2YgdGhlIGNoYXJ0IGFyZWFcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb252ZXJ0Q2F0VG9OdW1lcmljXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydENhdFRvTnVtZXJpYyhvcHRzKSB7XG4gICAgICAgIG9wdHMueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbnZlcnRDYXRUb051bWVyaWNYYXhpc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRDYXRUb051bWVyaWNYYXhpcyhvcHRzLCBjdHgsIGNhdHMpIHtcbiAgICAgICAgb3B0cy54YXhpcy50eXBlID0gJ251bWVyaWMnO1xuICAgICAgICBvcHRzLnhheGlzLmxhYmVscyA9IG9wdHMueGF4aXMubGFiZWxzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciA9IG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciB8fCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIFV0aWxzJDEuaXNOdW1iZXIodmFsKSA/IE1hdGguZmxvb3IodmFsKSA6IHZhbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGVmYXVsdEZvcm1hdHRlciA9IG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgICAgdmFyIGxhYmVscyA9IG9wdHMueGF4aXMuY2F0ZWdvcmllcyAmJiBvcHRzLnhheGlzLmNhdGVnb3JpZXMubGVuZ3RoID8gb3B0cy54YXhpcy5jYXRlZ29yaWVzIDogb3B0cy5sYWJlbHM7XG5cbiAgICAgICAgaWYgKGNhdHMgJiYgY2F0cy5sZW5ndGgpIHtcbiAgICAgICAgICBsYWJlbHMgPSBjYXRzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYykgPyBjIDogU3RyaW5nKGMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhYmVscyAmJiBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgb3B0cy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzJDEuaXNOdW1iZXIodmFsKSA/IGRlZmF1bHRGb3JtYXR0ZXIobGFiZWxzW01hdGguZmxvb3IodmFsKSAtIDFdKSA6IGRlZmF1bHRGb3JtYXR0ZXIodmFsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cy54YXhpcy5jYXRlZ29yaWVzID0gW107XG4gICAgICAgIG9wdHMubGFiZWxzID0gW107XG4gICAgICAgIG9wdHMueGF4aXMudGlja0Ftb3VudCA9IG9wdHMueGF4aXMudGlja0Ftb3VudCB8fCAnZGF0YVBvaW50cyc7XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJidWJibGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVyc2VjdDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgICBzaGFkZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgICAgaW52ZXJzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNTUsXG4gICAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAwLjQsXG4gICAgICAgICAgICAgIG9wYWNpdHlUbzogMC44XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzY2F0dGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2NhdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVyc2VjdDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgc2l6ZTogNixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgc2l6ZU9mZnNldDogMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGVhdG1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhlYXRtYXAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGZvbGxvd0N1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgICBzaGFwZTogJ3NxdWFyZScsXG4gICAgICAgICAgICAgIHNpemU6IDEwLFxuICAgICAgICAgICAgICBvZmZzZXRZOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgIHJpZ2h0OiAyMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidHJlZW1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRyZWVtYXAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogNjAwLFxuICAgICAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICAgIHN0b3BzOiBbMCwgMTAwXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgZm9sbG93Q3Vyc29yOiB0cnVlLFxuICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICByaWdodDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwaWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwaWUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIHRvb2xiYXI6IHtcbiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBsb3RPcHRpb25zOiB7XG4gICAgICAgICAgICBwaWU6IHtcbiAgICAgICAgICAgICAgZG9udXQ6IHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDEpICsgJyUnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgICBzaGFkZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgICAgc3RvcHM6IFswLCAxMDBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICB0aGVtZTogJ2RhcmsnLFxuICAgICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkb251dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvbnV0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDEpICsgJyUnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgICBzaGFkZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuMzUsXG4gICAgICAgICAgICAgIHN0b3BzOiBbODAsIDEwMF0sXG4gICAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAxLFxuICAgICAgICAgICAgICBvcGFjaXR5VG86IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHRoZW1lOiAnZGFyaycsXG4gICAgICAgICAgICBmaWxsU2VyaWVzQ29sb3I6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBvbGFyQXJlYVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBvbGFyQXJlYSgpIHtcbiAgICAgICAgdGhpcy5vcHRzLnlheGlzWzBdLnRpY2tBbW91bnQgPSB0aGlzLm9wdHMueWF4aXNbMF0udGlja0Ftb3VudCA/IHRoaXMub3B0cy55YXhpc1swXS50aWNrQW1vdW50IDogNjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgxKSArICclJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgdGhlbWU6ICdkYXJrJyxcbiAgICAgICAgICAgIGZpbGxTZXJpZXNDb2xvcjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0J1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmFkYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByYWRhcigpIHtcbiAgICAgICAgdGhpcy5vcHRzLnlheGlzWzBdLmxhYmVscy5vZmZzZXRZID0gdGhpcy5vcHRzLnlheGlzWzBdLmxhYmVscy5vZmZzZXRZID8gdGhpcy5vcHRzLnlheGlzWzBdLmxhYmVscy5vZmZzZXRZIDogNjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTFweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0N1cnNvcjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IFsnI2E4YThhOCddLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTFweCdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyYWRpYWxCYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByYWRpYWxCYXIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgZHluYW1pY0FuaW1hdGlvbjoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc3BlZWQ6IDgwMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgICAgc2hhZGU6ICdkYXJrJyxcbiAgICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNCxcbiAgICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICAgIHR5cGU6ICdkaWFnb25hbDInLFxuICAgICAgICAgICAgICBvcGFjaXR5RnJvbTogMSxcbiAgICAgICAgICAgICAgb3BhY2l0eVRvOiAxLFxuICAgICAgICAgICAgICBzdG9wczogWzcwLCA5OCwgMTAwXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbGxTZXJpZXNDb2xvcjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldEJveFRvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Qm94VG9vbHRpcCh3LCBzZXJpZXNJbmRleCwgZGF0YVBvaW50SW5kZXgsIGxhYmVscywgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBvID0gdy5nbG9iYWxzLnNlcmllc0NhbmRsZU9bc2VyaWVzSW5kZXhdW2RhdGFQb2ludEluZGV4XTtcbiAgICAgICAgdmFyIGggPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlSFtzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICB2YXIgbSA9IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVNW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgIHZhciBsID0gdy5nbG9iYWxzLnNlcmllc0NhbmRsZUxbc2VyaWVzSW5kZXhdW2RhdGFQb2ludEluZGV4XTtcbiAgICAgICAgdmFyIGMgPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlQ1tzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbc2VyaWVzSW5kZXhdLnR5cGUgJiYgdy5jb25maWcuc2VyaWVzW3Nlcmllc0luZGV4XS50eXBlICE9PSBjaGFydFR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJhcGV4Y2hhcnRzLWN1c3RvbS10b29sdGlwXFxcIj5cXG4gICAgICAgICAgXCIuY29uY2F0KHcuY29uZmlnLnNlcmllc1tzZXJpZXNJbmRleF0ubmFtZSA/IHcuY29uZmlnLnNlcmllc1tzZXJpZXNJbmRleF0ubmFtZSA6ICdzZXJpZXMtJyArIChzZXJpZXNJbmRleCArIDEpLCBcIjogPHN0cm9uZz5cIikuY29uY2F0KHcuZ2xvYmFscy5zZXJpZXNbc2VyaWVzSW5kZXhdW2RhdGFQb2ludEluZGV4XSwgXCI8L3N0cm9uZz5cXG4gICAgICAgIDwvZGl2PlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJhcGV4Y2hhcnRzLXRvb2x0aXAtYm94IGFwZXhjaGFydHMtdG9vbHRpcC1cIi5jb25jYXQody5jb25maWcuY2hhcnQudHlwZSwgXCJcXFwiPlwiKSArIFwiPGRpdj5cIi5jb25jYXQobGFiZWxzWzBdLCBcIjogPHNwYW4gY2xhc3M9XFxcInZhbHVlXFxcIj5cIikgKyBvICsgJzwvc3Bhbj48L2Rpdj4nICsgXCI8ZGl2PlwiLmNvbmNhdChsYWJlbHNbMV0sIFwiOiA8c3BhbiBjbGFzcz1cXFwidmFsdWVcXFwiPlwiKSArIGggKyAnPC9zcGFuPjwvZGl2PicgKyAobSA/IFwiPGRpdj5cIi5jb25jYXQobGFiZWxzWzJdLCBcIjogPHNwYW4gY2xhc3M9XFxcInZhbHVlXFxcIj5cIikgKyBtICsgJzwvc3Bhbj48L2Rpdj4nIDogJycpICsgXCI8ZGl2PlwiLmNvbmNhdChsYWJlbHNbM10sIFwiOiA8c3BhbiBjbGFzcz1cXFwidmFsdWVcXFwiPlwiKSArIGwgKyAnPC9zcGFuPjwvZGl2PicgKyBcIjxkaXY+XCIuY29uY2F0KGxhYmVsc1s0XSwgXCI6IDxzcGFuIGNsYXNzPVxcXCJ2YWx1ZVxcXCI+XCIpICsgYyArICc8L3NwYW4+PC9kaXY+JyArICc8L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERlZmF1bHRzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgQ29uZmlnIENsYXNzIGZvciBleHRlbmRpbmcgdXNlciBvcHRpb25zIHdpdGggcHJlLWRlZmluZWQgQXBleENoYXJ0cyBjb25maWcuXG4gICAqXG4gICAqIEBtb2R1bGUgQ29uZmlnXG4gICAqKi9cblxuICB2YXIgQ29uZmlnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25maWcob3B0cykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZyk7XG5cbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbmZpZywgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChfcmVmKSB7XG4gICAgICAgIHZhciByZXNwb25zaXZlT3ZlcnJpZGUgPSBfcmVmLnJlc3BvbnNpdmVPdmVycmlkZTtcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKG9wdHMpO1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IG9wdHMuY2hhcnQudHlwZTtcbiAgICAgICAgb3B0cyA9IHRoaXMuZXh0ZW5kWUF4aXMob3B0cyk7XG4gICAgICAgIG9wdHMgPSB0aGlzLmV4dGVuZEFubm90YXRpb25zKG9wdHMpO1xuICAgICAgICB2YXIgY29uZmlnID0gb3B0aW9ucy5pbml0KCk7XG4gICAgICAgIHZhciBuZXdEZWZhdWx0cyA9IHt9O1xuXG4gICAgICAgIGlmIChvcHRzICYmIF90eXBlb2Yob3B0cykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIF9vcHRzJHBsb3RPcHRpb25zLCBfb3B0cyRwbG90T3B0aW9ucyRiYXIsIF9vcHRzJGNoYXJ0JGJydXNoLCBfb3B0cyRwbG90T3B0aW9uczIsIF9vcHRzJHBsb3RPcHRpb25zMiRiYSwgX29wdHMsIF9vcHRzJHN0cm9rZSwgX29wdHMkY2hhcnQkc3BhcmtsaW5lLCBfd2luZG93JEFwZXgkY2hhcnQsIF93aW5kb3ckQXBleCRjaGFydCRzcDtcblxuICAgICAgICAgIHZhciBjaGFydERlZmF1bHRzID0ge307XG4gICAgICAgICAgdmFyIGNoYXJ0VHlwZXMgPSBbJ2xpbmUnLCAnYXJlYScsICdiYXInLCAnY2FuZGxlc3RpY2snLCAnYm94UGxvdCcsICdyYW5nZUJhcicsICdyYW5nZUFyZWEnLCAnYnViYmxlJywgJ3NjYXR0ZXInLCAnaGVhdG1hcCcsICd0cmVlbWFwJywgJ3BpZScsICdwb2xhckFyZWEnLCAnZG9udXQnLCAncmFkYXInLCAncmFkaWFsQmFyJ107XG5cbiAgICAgICAgICBpZiAoY2hhcnRUeXBlcy5pbmRleE9mKG9wdHMuY2hhcnQudHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHNbb3B0cy5jaGFydC50eXBlXSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMubGluZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgoX29wdHMkcGxvdE9wdGlvbnMgPSBvcHRzLnBsb3RPcHRpb25zKSAhPT0gbnVsbCAmJiBfb3B0cyRwbG90T3B0aW9ucyAhPT0gdm9pZCAwICYmIChfb3B0cyRwbG90T3B0aW9ucyRiYXIgPSBfb3B0cyRwbG90T3B0aW9ucy5iYXIpICE9PSBudWxsICYmIF9vcHRzJHBsb3RPcHRpb25zJGJhciAhPT0gdm9pZCAwICYmIF9vcHRzJHBsb3RPcHRpb25zJGJhci5pc0Z1bm5lbCkge1xuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmZ1bm5lbCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRzLmNoYXJ0LnN0YWNrZWQgJiYgb3B0cy5jaGFydC50eXBlID09PSAnYmFyJykge1xuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLnN0YWNrZWRCYXJzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChfb3B0cyRjaGFydCRicnVzaCA9IG9wdHMuY2hhcnQuYnJ1c2gpICE9PSBudWxsICYmIF9vcHRzJGNoYXJ0JGJydXNoICE9PSB2b2lkIDAgJiYgX29wdHMkY2hhcnQkYnJ1c2guZW5hYmxlZCkge1xuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmJydXNoKGNoYXJ0RGVmYXVsdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRzLmNoYXJ0LnN0YWNrZWQgJiYgb3B0cy5jaGFydC5zdGFja1R5cGUgPT09ICcxMDAlJykge1xuICAgICAgICAgICAgb3B0cyA9IGRlZmF1bHRzLnN0YWNrZWQxMDAob3B0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChfb3B0cyRwbG90T3B0aW9uczIgPSBvcHRzLnBsb3RPcHRpb25zKSAhPT0gbnVsbCAmJiBfb3B0cyRwbG90T3B0aW9uczIgIT09IHZvaWQgMCAmJiAoX29wdHMkcGxvdE9wdGlvbnMyJGJhID0gX29wdHMkcGxvdE9wdGlvbnMyLmJhcikgIT09IG51bGwgJiYgX29wdHMkcGxvdE9wdGlvbnMyJGJhICE9PSB2b2lkIDAgJiYgX29wdHMkcGxvdE9wdGlvbnMyJGJhLmlzRHVtYmJlbGwpIHtcbiAgICAgICAgICAgIG9wdHMgPSBkZWZhdWx0cy5kdW1iYmVsbChvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoKChfb3B0cyA9IG9wdHMpID09PSBudWxsIHx8IF9vcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdHMkc3Ryb2tlID0gX29wdHMuc3Ryb2tlKSA9PT0gbnVsbCB8fCBfb3B0cyRzdHJva2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJHN0cm9rZS5jdXJ2ZSkgPT09ICdtb25vdG9uZUN1YmljJykge1xuICAgICAgICAgICAgb3B0cy5zdHJva2UuY3VydmUgPSAnc21vb3RoJztcbiAgICAgICAgICB9IC8vIElmIHVzZXIgaGFzIHNwZWNpZmllZCBhIGRhcmsgdGhlbWUsIG1ha2UgdGhlIHRvb2x0aXAgZGFyayB0b29cblxuXG4gICAgICAgICAgdGhpcy5jaGVja0ZvckRhcmtUaGVtZSh3aW5kb3cuQXBleCk7IC8vIGNoZWNrIGdsb2JhbCB3aW5kb3cgQXBleCBvcHRpb25zXG5cbiAgICAgICAgICB0aGlzLmNoZWNrRm9yRGFya1RoZW1lKG9wdHMpOyAvLyBjaGVjayBsb2NhbGx5IHBhc3NlZCBvcHRpb25zXG5cbiAgICAgICAgICBvcHRzLnhheGlzID0gb3B0cy54YXhpcyB8fCB3aW5kb3cuQXBleC54YXhpcyB8fCB7fTsgLy8gYW4gaW1wb3J0YW50IGJvb2xlYW4gbmVlZHMgdG8gYmUgc2V0IGhlcmVcbiAgICAgICAgICAvLyBvdGhlcndpc2UgYWxsIHRoZSBjaGFydHMgd2lsbCBoYXZlIHRoaXMgZmxhZyBzZXQgdG8gdHJ1ZSB3aW5kb3cuQXBleC54YXhpcyBpcyBzZXQgZ2xvYmFsbHlcblxuICAgICAgICAgIGlmICghcmVzcG9uc2l2ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBvcHRzLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdHMgPSB0aGlzLmNoZWNrRm9yQ2F0VG9OdW1lcmljWEF4aXModGhpcy5jaGFydFR5cGUsIGNoYXJ0RGVmYXVsdHMsIG9wdHMpO1xuXG4gICAgICAgICAgaWYgKChfb3B0cyRjaGFydCRzcGFya2xpbmUgPSBvcHRzLmNoYXJ0LnNwYXJrbGluZSkgIT09IG51bGwgJiYgX29wdHMkY2hhcnQkc3BhcmtsaW5lICE9PSB2b2lkIDAgJiYgX29wdHMkY2hhcnQkc3BhcmtsaW5lLmVuYWJsZWQgfHwgKF93aW5kb3ckQXBleCRjaGFydCA9IHdpbmRvdy5BcGV4LmNoYXJ0KSAhPT0gbnVsbCAmJiBfd2luZG93JEFwZXgkY2hhcnQgIT09IHZvaWQgMCAmJiAoX3dpbmRvdyRBcGV4JGNoYXJ0JHNwID0gX3dpbmRvdyRBcGV4JGNoYXJ0LnNwYXJrbGluZSkgIT09IG51bGwgJiYgX3dpbmRvdyRBcGV4JGNoYXJ0JHNwICE9PSB2b2lkIDAgJiYgX3dpbmRvdyRBcGV4JGNoYXJ0JHNwLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5zcGFya2xpbmUoY2hhcnREZWZhdWx0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3RGVmYXVsdHMgPSBVdGlscyQxLmV4dGVuZChjb25maWcsIGNoYXJ0RGVmYXVsdHMpO1xuICAgICAgICB9IC8vIGNvbmZpZyBzaG91bGQgY2FzY2FkZSBpbiB0aGlzIGZhc2hpb25cbiAgICAgICAgLy8gZGVmYXVsdC1jb25maWcgPCBnbG9iYWwtYXBleC12YXJpYWJsZS1jb25maWcgPCB1c2VyLWRlZmluZWQtY29uZmlnXG4gICAgICAgIC8vIGdldCBHTE9CQUxMWSBkZWZpbmVkIG9wdGlvbnMgYW5kIG1lcmdlIHdpdGggdGhlIGRlZmF1bHQgY29uZmlnXG5cblxuICAgICAgICB2YXIgbWVyZ2VkV2l0aERlZmF1bHRDb25maWcgPSBVdGlscyQxLmV4dGVuZChuZXdEZWZhdWx0cywgd2luZG93LkFwZXgpOyAvLyBnZXQgdGhlIG1lcmdlZCBjb25maWcgYW5kIGV4dGVuZCB3aXRoIHVzZXIgZGVmaW5lZCBjb25maWdcblxuICAgICAgICBjb25maWcgPSBVdGlscyQxLmV4dGVuZChtZXJnZWRXaXRoRGVmYXVsdENvbmZpZywgb3B0cyk7IC8vIHNvbWUgZmVhdHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQuIHRob3NlIG1pc21hdGNoZXMgc2hvdWxkIGJlIGhhbmRsZWRcblxuICAgICAgICBjb25maWcgPSB0aGlzLmhhbmRsZVVzZXJJbnB1dEVycm9ycyhjb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja0ZvckNhdFRvTnVtZXJpY1hBeGlzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGb3JDYXRUb051bWVyaWNYQXhpcyhjaGFydFR5cGUsIGNoYXJ0RGVmYXVsdHMsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9vcHRzJHBsb3RPcHRpb25zMywgX29wdHMkcGxvdE9wdGlvbnMzJGJhO1xuXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyhvcHRzKTtcbiAgICAgICAgdmFyIGlzQmFySG9yaXpvbnRhbCA9IChjaGFydFR5cGUgPT09ICdiYXInIHx8IGNoYXJ0VHlwZSA9PT0gJ2JveFBsb3QnKSAmJiAoKF9vcHRzJHBsb3RPcHRpb25zMyA9IG9wdHMucGxvdE9wdGlvbnMpID09PSBudWxsIHx8IF9vcHRzJHBsb3RPcHRpb25zMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRzJHBsb3RPcHRpb25zMyRiYSA9IF9vcHRzJHBsb3RPcHRpb25zMy5iYXIpID09PSBudWxsIHx8IF9vcHRzJHBsb3RPcHRpb25zMyRiYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkcGxvdE9wdGlvbnMzJGJhLmhvcml6b250YWwpO1xuICAgICAgICB2YXIgdW5zdXBwb3J0ZWRab29tID0gY2hhcnRUeXBlID09PSAncGllJyB8fCBjaGFydFR5cGUgPT09ICdwb2xhckFyZWEnIHx8IGNoYXJ0VHlwZSA9PT0gJ2RvbnV0JyB8fCBjaGFydFR5cGUgPT09ICdyYWRhcicgfHwgY2hhcnRUeXBlID09PSAncmFkaWFsQmFyJyB8fCBjaGFydFR5cGUgPT09ICdoZWF0bWFwJztcbiAgICAgICAgdmFyIG5vdE51bWVyaWNYQXhpcyA9IG9wdHMueGF4aXMudHlwZSAhPT0gJ2RhdGV0aW1lJyAmJiBvcHRzLnhheGlzLnR5cGUgIT09ICdudW1lcmljJztcbiAgICAgICAgdmFyIHRpY2tQbGFjZW1lbnQgPSBvcHRzLnhheGlzLnRpY2tQbGFjZW1lbnQgPyBvcHRzLnhheGlzLnRpY2tQbGFjZW1lbnQgOiBjaGFydERlZmF1bHRzLnhheGlzICYmIGNoYXJ0RGVmYXVsdHMueGF4aXMudGlja1BsYWNlbWVudDtcblxuICAgICAgICBpZiAoIWlzQmFySG9yaXpvbnRhbCAmJiAhdW5zdXBwb3J0ZWRab29tICYmIG5vdE51bWVyaWNYQXhpcyAmJiB0aWNrUGxhY2VtZW50ICE9PSAnYmV0d2VlbicpIHtcbiAgICAgICAgICBvcHRzID0gZGVmYXVsdHMuY29udmVydENhdFRvTnVtZXJpYyhvcHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJleHRlbmRZQXhpc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZFlBeGlzKG9wdHMsIHcpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy55YXhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIW9wdHMueWF4aXMgfHwgQXJyYXkuaXNBcnJheShvcHRzLnlheGlzKSAmJiBvcHRzLnlheGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIG9wdHMueWF4aXMgPSB7fTtcbiAgICAgICAgfSAvLyBleHRlbmQgZ2xvYmFsIHlheGlzIGNvbmZpZyAob25seSBpZiBvYmplY3QgaXMgcHJvdmlkZWQgLyBub3QgYW4gYXJyYXkpXG5cblxuICAgICAgICBpZiAob3B0cy55YXhpcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkgJiYgd2luZG93LkFwZXgueWF4aXMgJiYgd2luZG93LkFwZXgueWF4aXMuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzJDEuZXh0ZW5kKG9wdHMueWF4aXMsIHdpbmRvdy5BcGV4LnlheGlzKTtcbiAgICAgICAgfSAvLyBhcyB3ZSBjYW4ndCBleHRlbmQgbmVzdGVkIG9iamVjdCdzIGFycmF5IHdpdGggZXh0ZW5kLCB3ZSBuZWVkIHRvIGRvIGl0IGZpcnN0XG4gICAgICAgIC8vIHVzZXIgY2FuIHByb3ZpZGUgZWl0aGVyIGFuIGFycmF5IG9yIG9iamVjdCBpbiB5YXhpcyBjb25maWdcblxuXG4gICAgICAgIGlmIChvcHRzLnlheGlzLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHlheGlzIHRvIGFycmF5IGlmIHVzZXIgc3VwcGxpZWQgb2JqZWN0XG4gICAgICAgICAgb3B0cy55YXhpcyA9IFtVdGlscyQxLmV4dGVuZChvcHRpb25zLnlBeGlzLCBvcHRzLnlheGlzKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzJDEuZXh0ZW5kQXJyYXkob3B0cy55YXhpcywgb3B0aW9ucy55QXhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNMb2dZID0gZmFsc2U7XG4gICAgICAgIG9wdHMueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgIGlmICh5LmxvZ2FyaXRobWljKSB7XG4gICAgICAgICAgICBpc0xvZ1kgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZXJpZXMgPSBvcHRzLnNlcmllcztcblxuICAgICAgICBpZiAodyAmJiAhc2VyaWVzKSB7XG4gICAgICAgICAgc2VyaWVzID0gdy5jb25maWcuc2VyaWVzO1xuICAgICAgICB9IC8vIEEgbG9nYXJpdGhtaWMgY2hhcnQgd29ya3MgY29ycmVjdGx5IHdoZW4gZWFjaCBzZXJpZXMgaGFzIGEgY29ycmVzcG9uZGluZyB5LWF4aXNcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGNhc2UsIHdlIG1hbnVhbGx5IGNyZWF0ZSB5YXhpcyBmb3IgbXVsdGktc2VyaWVzIGxvZyBjaGFydFxuXG5cbiAgICAgICAgaWYgKGlzTG9nWSAmJiBzZXJpZXMubGVuZ3RoICE9PSBvcHRzLnlheGlzLmxlbmd0aCAmJiBzZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgb3B0cy55YXhpcyA9IHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICAgIGlmICghcy5uYW1lKSB7XG4gICAgICAgICAgICAgIHNlcmllc1tpXS5uYW1lID0gXCJzZXJpZXMtXCIuY29uY2F0KGkgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMueWF4aXNbaV0pIHtcbiAgICAgICAgICAgICAgb3B0cy55YXhpc1tpXS5zZXJpZXNOYW1lID0gc2VyaWVzW2ldLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBvcHRzLnlheGlzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1lheGlzID0gVXRpbHMkMS5leHRlbmQob3B0aW9ucy55QXhpcywgb3B0cy55YXhpc1swXSk7XG4gICAgICAgICAgICAgIG5ld1lheGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1lheGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTG9nWSAmJiBzZXJpZXMubGVuZ3RoID4gMSAmJiBzZXJpZXMubGVuZ3RoICE9PSBvcHRzLnlheGlzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignQSBtdWx0aS1zZXJpZXMgbG9nYXJpdGhtaWMgY2hhcnQgc2hvdWxkIGhhdmUgZXF1YWwgbnVtYmVyIG9mIHNlcmllcyBhbmQgeS1heGVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgIH0gLy8gYW5ub3RhdGlvbnMgYWxzbyBhY2NlcHRzIGFycmF5LCBzbyB3ZSBuZWVkIHRvIGV4dGVuZCB0aGVtIG1hbnVhbGx5XG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZXh0ZW5kQW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRBbm5vdGF0aW9ucyhvcHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5hbm5vdGF0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBvcHRzLmFubm90YXRpb25zID0ge307XG4gICAgICAgICAgb3B0cy5hbm5vdGF0aW9ucy55YXhpcyA9IFtdO1xuICAgICAgICAgIG9wdHMuYW5ub3RhdGlvbnMueGF4aXMgPSBbXTtcbiAgICAgICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cyA9IHRoaXMuZXh0ZW5kWUF4aXNBbm5vdGF0aW9ucyhvcHRzKTtcbiAgICAgICAgb3B0cyA9IHRoaXMuZXh0ZW5kWEF4aXNBbm5vdGF0aW9ucyhvcHRzKTtcbiAgICAgICAgb3B0cyA9IHRoaXMuZXh0ZW5kUG9pbnRBbm5vdGF0aW9ucyhvcHRzKTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4dGVuZFlBeGlzQW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdHMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgICBvcHRzLmFubm90YXRpb25zLnlheGlzID0gVXRpbHMkMS5leHRlbmRBcnJheSh0eXBlb2Ygb3B0cy5hbm5vdGF0aW9ucy55YXhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnlheGlzIDogW10sIG9wdGlvbnMueUF4aXNBbm5vdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4dGVuZFhBeGlzQW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRYQXhpc0Fubm90YXRpb25zKG9wdHMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgICBvcHRzLmFubm90YXRpb25zLnhheGlzID0gVXRpbHMkMS5leHRlbmRBcnJheSh0eXBlb2Ygb3B0cy5hbm5vdGF0aW9ucy54YXhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnhheGlzIDogW10sIG9wdGlvbnMueEF4aXNBbm5vdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4dGVuZFBvaW50QW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRQb2ludEFubm90YXRpb25zKG9wdHMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFV0aWxzJDEuZXh0ZW5kQXJyYXkodHlwZW9mIG9wdHMuYW5ub3RhdGlvbnMucG9pbnRzICE9PSAndW5kZWZpbmVkJyA/IG9wdHMuYW5ub3RhdGlvbnMucG9pbnRzIDogW10sIG9wdGlvbnMucG9pbnRBbm5vdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrRm9yRGFya1RoZW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGb3JEYXJrVGhlbWUob3B0cykge1xuICAgICAgICBpZiAob3B0cy50aGVtZSAmJiBvcHRzLnRoZW1lLm1vZGUgPT09ICdkYXJrJykge1xuICAgICAgICAgIGlmICghb3B0cy50b29sdGlwKSB7XG4gICAgICAgICAgICBvcHRzLnRvb2x0aXAgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0cy50b29sdGlwLnRoZW1lICE9PSAnbGlnaHQnKSB7XG4gICAgICAgICAgICBvcHRzLnRvb2x0aXAudGhlbWUgPSAnZGFyayc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFvcHRzLmNoYXJ0LmZvcmVDb2xvcikge1xuICAgICAgICAgICAgb3B0cy5jaGFydC5mb3JlQ29sb3IgPSAnI2Y2ZjdmOCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFvcHRzLmNoYXJ0LmJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIG9wdHMuY2hhcnQuYmFja2dyb3VuZCA9ICcjNDI0MjQyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW9wdHMudGhlbWUucGFsZXR0ZSkge1xuICAgICAgICAgICAgb3B0cy50aGVtZS5wYWxldHRlID0gJ3BhbGV0dGU0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlVXNlcklucHV0RXJyb3JzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVXNlcklucHV0RXJyb3JzKG9wdHMpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IG9wdHM7IC8vIGNvbmZsaWN0aW5nIHRvb2x0aXAgb3B0aW9uLiBpbnRlcnNlY3QgbWFrZXMgc3VyZSB0byBmb2N1cyBvbiAxIHBvaW50IGF0IGEgdGltZS4gU2hhcmVkIGNhbm5vdCBiZSB1c2VkIGFsb25nIHdpdGggaXRcblxuICAgICAgICBpZiAoY29uZmlnLnRvb2x0aXAuc2hhcmVkICYmIGNvbmZpZy50b29sdGlwLmludGVyc2VjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHRpcC5zaGFyZWQgY2Fubm90IGJlIGVuYWJsZWQgd2hlbiB0b29sdGlwLmludGVyc2VjdCBpcyB0cnVlLiBUdXJuIG9mZiBhbnkgb3RoZXIgb3B0aW9uIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIGNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIC8vIE5vIG11bHRpcGxlIHlheGlzIGZvciBiYXJzXG4gICAgICAgICAgaWYgKGNvbmZpZy55YXhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIFkgQXhpcyBmb3IgYmFycyBhcmUgbm90IHN1cHBvcnRlZC4gU3dpdGNoIHRvIGNvbHVtbiBjaGFydCBieSBzZXR0aW5nIHBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsPWZhbHNlJyk7XG4gICAgICAgICAgfSAvLyBpZiB5YXhpcyBpcyByZXZlcnNlZCBpbiBob3Jpem9udGFsIGJhciBjaGFydCwgeW91IHNob3VsZCBkcmF3IHRoZSB5LWF4aXMgb24gcmlnaHQgc2lkZVxuXG5cbiAgICAgICAgICBpZiAoY29uZmlnLnlheGlzWzBdLnJldmVyc2VkKSB7XG4gICAgICAgICAgICBjb25maWcueWF4aXNbMF0ub3Bwb3NpdGUgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbmZpZy54YXhpcy50b29sdGlwLmVuYWJsZWQgPSBmYWxzZTsgLy8gbm8geGF4aXMgdG9vbHRpcCBmb3IgaG9yaXpvbnRhbCBiYXJcblxuICAgICAgICAgIGNvbmZpZy55YXhpc1swXS50b29sdGlwLmVuYWJsZWQgPSBmYWxzZTsgLy8gbm8geGF4aXMgdG9vbHRpcCBmb3IgaG9yaXpvbnRhbCBiYXJcblxuICAgICAgICAgIGNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQgPSBmYWxzZTsgLy8gbm8gem9vbWluZyBmb3IgaG9yeiBiYXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInIHx8IGNvbmZpZy5jaGFydC50eXBlID09PSAncmFuZ2VCYXInKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAnYmFyV2lkdGgnICYmIGNvbmZpZy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBjb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9ICd0aWNrV2lkdGgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJyB8fCBjb25maWcuY2hhcnQudHlwZSA9PT0gJ2JveFBsb3QnKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmV2ZXJzZWQgeS1heGlzIGluIFwiLmNvbmNhdChjb25maWcuY2hhcnQudHlwZSwgXCIgY2hhcnQgaXMgbm90IHN1cHBvcnRlZC5cIikpO1xuICAgICAgICAgICAgY29uZmlnLnlheGlzWzBdLnJldmVyc2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29uZmlnO1xuICB9KCk7XG5cbiAgdmFyIEdsb2JhbHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdsb2JhbHMoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2xvYmFscyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEdsb2JhbHMsIFt7XG4gICAgICBrZXk6IFwiaW5pdEdsb2JhbFZhcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0R2xvYmFsVmFycyhnbCkge1xuICAgICAgICBnbC5zZXJpZXMgPSBbXTsgLy8gdGhlIE1BSU4gc2VyaWVzIGFycmF5ICh5IHZhbHVlcylcblxuICAgICAgICBnbC5zZXJpZXNDYW5kbGVPID0gW107XG4gICAgICAgIGdsLnNlcmllc0NhbmRsZUggPSBbXTtcbiAgICAgICAgZ2wuc2VyaWVzQ2FuZGxlTSA9IFtdO1xuICAgICAgICBnbC5zZXJpZXNDYW5kbGVMID0gW107XG4gICAgICAgIGdsLnNlcmllc0NhbmRsZUMgPSBbXTtcbiAgICAgICAgZ2wuc2VyaWVzUmFuZ2VTdGFydCA9IFtdO1xuICAgICAgICBnbC5zZXJpZXNSYW5nZUVuZCA9IFtdO1xuICAgICAgICBnbC5zZXJpZXNSYW5nZSA9IFtdO1xuICAgICAgICBnbC5zZXJpZXNQZXJjZW50ID0gW107XG4gICAgICAgIGdsLnNlcmllc0dvYWxzID0gW107XG4gICAgICAgIGdsLnNlcmllc1ggPSBbXTtcbiAgICAgICAgZ2wuc2VyaWVzWiA9IFtdO1xuICAgICAgICBnbC5zZXJpZXNOYW1lcyA9IFtdO1xuICAgICAgICBnbC5zZXJpZXNUb3RhbHMgPSBbXTtcbiAgICAgICAgZ2wuc2VyaWVzTG9nID0gW107XG4gICAgICAgIGdsLnNlcmllc0NvbG9ycyA9IFtdO1xuICAgICAgICBnbC5zdGFja2VkU2VyaWVzVG90YWxzID0gW107XG4gICAgICAgIGdsLnNlcmllc1h2YWx1ZXMgPSBbXTsgLy8gd2Ugd2lsbCBuZWVkIHRoaXMgaW4gdG9vbHRpcCAoaXQncyB4IHBvc2l0aW9uKVxuICAgICAgICAvLyB3aGVuIHdlIHdpbGwgaGF2ZSB1bmVxdWFsIHggdmFsdWVzLCB3ZSB3aWxsIG5lZWRcbiAgICAgICAgLy8gc29tZSB3YXkgdG8gZ2V0IHggdmFsdWUgZGVwZW5kaW5nIG9uIG1vdXNlIHBvaW50ZXJcblxuICAgICAgICBnbC5zZXJpZXNZdmFsdWVzID0gW107IC8vIHdlIHdpbGwgbmVlZCB0aGlzIHdoZW4gZGVjaWRpbmcgd2hpY2ggc2VyaWVzXG4gICAgICAgIC8vIHVzZXIgaG92ZXJlZCBvblxuXG4gICAgICAgIGdsLmxhYmVscyA9IFtdO1xuICAgICAgICBnbC5oYXNYYXhpc0dyb3VwcyA9IGZhbHNlO1xuICAgICAgICBnbC5ncm91cHMgPSBbXTtcbiAgICAgICAgZ2wuaGFzU2VyaWVzR3JvdXBzID0gZmFsc2U7XG4gICAgICAgIGdsLnNlcmllc0dyb3VwcyA9IFtdO1xuICAgICAgICBnbC5jYXRlZ29yeUxhYmVscyA9IFtdO1xuICAgICAgICBnbC50aW1lc2NhbGVMYWJlbHMgPSBbXTtcbiAgICAgICAgZ2wubm9MYWJlbHNQcm92aWRlZCA9IGZhbHNlO1xuICAgICAgICBnbC5yZXNpemVUaW1lciA9IG51bGw7XG4gICAgICAgIGdsLnNlbGVjdGlvblJlc2l6ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgZ2wuZGVsYXllZEVsZW1lbnRzID0gW107XG4gICAgICAgIGdsLnBvaW50c0FycmF5ID0gW107XG4gICAgICAgIGdsLmRhdGFMYWJlbHNSZWN0cyA9IFtdO1xuICAgICAgICBnbC5pc1hOdW1lcmljID0gZmFsc2U7XG4gICAgICAgIGdsLnNraXBMYXN0VGltZWxpbmVsYWJlbCA9IGZhbHNlO1xuICAgICAgICBnbC5za2lwRmlyc3RUaW1lbGluZWxhYmVsID0gZmFsc2U7XG4gICAgICAgIGdsLmlzRGF0YVhZWiA9IGZhbHNlO1xuICAgICAgICBnbC5pc011bHRpTGluZVggPSBmYWxzZTtcbiAgICAgICAgZ2wuaXNNdWx0aXBsZVlBeGlzID0gZmFsc2U7XG4gICAgICAgIGdsLm1heFkgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgZ2wubWluWSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICAgIGdsLm1pbllBcnIgPSBbXTtcbiAgICAgICAgZ2wubWF4WUFyciA9IFtdO1xuICAgICAgICBnbC5tYXhYID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGdsLm1pblggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBnbC5pbml0aWFsTWF4WCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBnbC5pbml0aWFsTWluWCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGdsLm1heERhdGUgPSAwO1xuICAgICAgICBnbC5taW5EYXRlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgZ2wubWluWiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGdsLm1heFogPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgZ2wubWluWERpZmYgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBnbC55QXhpc1NjYWxlID0gW107XG4gICAgICAgIGdsLnhBeGlzU2NhbGUgPSBudWxsO1xuICAgICAgICBnbC54QXhpc1RpY2tzUG9zaXRpb25zID0gW107XG4gICAgICAgIGdsLnlMYWJlbHNDb29yZHMgPSBbXTtcbiAgICAgICAgZ2wueVRpdGxlQ29vcmRzID0gW107XG4gICAgICAgIGdsLmJhclBhZEZvck51bWVyaWNBeGlzID0gMDtcbiAgICAgICAgZ2wucGFkSG9yaXpvbnRhbCA9IDA7XG4gICAgICAgIGdsLnhSYW5nZSA9IDA7XG4gICAgICAgIGdsLnlSYW5nZSA9IFtdO1xuICAgICAgICBnbC56UmFuZ2UgPSAwO1xuICAgICAgICBnbC5kYXRhUG9pbnRzID0gMDtcbiAgICAgICAgZ2wueFRpY2tBbW91bnQgPSAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnbG9iYWxWYXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2xvYmFsVmFycyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFydElEOiBudWxsLFxuICAgICAgICAgIC8vIGNoYXJ0IElEIC0gYXBleGNoYXJ0cy1jdWlkXG4gICAgICAgICAgY3VpZDogbnVsbCxcbiAgICAgICAgICAvLyBjaGFydCBJRCAtIHJhbmRvbSBudW1iZXJzIGV4Y2x1ZGluZyBcImFwZXhjaGFydHNcIiBwYXJ0XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBiZWZvcmVNb3VudDogW10sXG4gICAgICAgICAgICBtb3VudGVkOiBbXSxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IFtdLFxuICAgICAgICAgICAgY2xpY2tlZDogW10sXG4gICAgICAgICAgICBzZWxlY3Rpb246IFtdLFxuICAgICAgICAgICAgZGF0YVBvaW50U2VsZWN0aW9uOiBbXSxcbiAgICAgICAgICAgIHpvb21lZDogW10sXG4gICAgICAgICAgICBzY3JvbGxlZDogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgY2xpZW50WDogbnVsbCxcbiAgICAgICAgICBjbGllbnRZOiBudWxsLFxuICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGNvbG9yczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgY29sb3JzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3JzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmFkYXJQb2x5Z29uczoge1xuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICBjb2xvcnM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgICAgc2l6ZTogY29uZmlnLm1hcmtlcnMuc2l6ZSxcbiAgICAgICAgICAgIGxhcmdlc3RTaXplOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbmltYXRpb25FbmRlZDogZmFsc2UsXG4gICAgICAgICAgaXNUb3VjaERldmljZTogJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzLFxuICAgICAgICAgIGlzRGlydHk6IGZhbHNlLFxuICAgICAgICAgIC8vIGNoYXJ0IGhhcyBiZWVuIHVwZGF0ZWQgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIGRhdGFDaGFuZ2VkIHByb3BlcnR5LiBpc0RpcnR5IG1lYW5zIHVzZXIgbWFudWFsbHkgY2FsbGVkIHNvbWUgbWV0aG9kIHRvIHVwZGF0ZVxuICAgICAgICAgIGlzRXhlY0NhbGxlZDogZmFsc2UsXG4gICAgICAgICAgLy8gd2hldGhlciB1c2VyIHVwZGF0ZWQgdGhlIGNoYXJ0IHRocm91Z2ggdGhlIGV4ZWMgbWV0aG9kXG4gICAgICAgICAgaW5pdGlhbENvbmZpZzogbnVsbCxcbiAgICAgICAgICAvLyB3ZSB3aWxsIHN0b3JlIHRoZSBmaXJzdCBjb25maWcgdXNlciBoYXMgc2V0IHRvIGdvIGJhY2sgd2hlbiB1c2VyIGZpbmlzaGVzIGludGVyYWN0aW9ucyBsaWtlIHpvb21pbmcgYW5kIGNvbWUgb3V0IG9mIGl0XG4gICAgICAgICAgaW5pdGlhbFNlcmllczogW10sXG4gICAgICAgICAgbGFzdFhBeGlzOiBbXSxcbiAgICAgICAgICBsYXN0WUF4aXM6IFtdLFxuICAgICAgICAgIGNvbHVtblNlcmllczogbnVsbCxcbiAgICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAgIC8vIHN0b3JlIHRoZSB0ZXh0IHRvIGRyYXcgb24geCBheGlzXG4gICAgICAgICAgLy8gRG9uJ3QgbXV0YXRlIHRoZSBsYWJlbHMsIG1hbnkgdGhpbmdzIGluY2x1ZGluZyB0b29sdGlwcyBkZXBlbmRzIG9uIGl0IVxuICAgICAgICAgIHRpbWVzY2FsZUxhYmVsczogW10sXG4gICAgICAgICAgLy8gc3RvcmUgdGhlIHRpbWVzY2FsZUxhYmVscyBMYWJlbHMgaW4gYW5vdGhlciB2YXJpYWJsZVxuICAgICAgICAgIG5vTGFiZWxzUHJvdmlkZWQ6IGZhbHNlLFxuICAgICAgICAgIC8vIGlmIHVzZXIgZGlkbid0IHByb3ZpZGUgYW55IGNhdGVnb3JpZXMvbGFiZWxzIG9yIHggdmFsdWVzLCBmYWxsYmFjayB0byAxLDIsMyw0Li4uXG4gICAgICAgICAgYWxsU2VyaWVzQ29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICBjb2xsYXBzZWRTZXJpZXM6IFtdLFxuICAgICAgICAgIC8vIHdoZW4gdXNlciBjb2xsYXBzZXMgYSBzZXJpZXMsIGl0IGdvZXMgaW50byB0aGlzIGFycmF5XG4gICAgICAgICAgY29sbGFwc2VkU2VyaWVzSW5kaWNlczogW10sXG4gICAgICAgICAgLy8gdGhpcyBzdG9yZXMgdGhlIGluZGV4IG9mIHRoZSBjb2xsYXBzZWRTZXJpZXMgaW5zdGVhZCBvZiB3aG9sZSBvYmplY3QgZm9yIHF1aWNrIGFjY2Vzc1xuICAgICAgICAgIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllczogW10sXG4gICAgICAgICAgLy8gd2hlbiB1c2VyIGNvbGxhcHNlcyBhbiBcImFsd2F5c1Zpc2libGVcIiBzZXJpZXMsIGl0IGdvZXMgaW50byB0aGlzIGFycmF5XG4gICAgICAgICAgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlczogW10sXG4gICAgICAgICAgLy8gdGhpcyBzdG9yZXMgdGhlIGluZGV4IG9mIHRoZSBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMgd2hvc2UgeS1heGlzIGlzIGFsd2F5cyB2aXNpYmxlXG4gICAgICAgICAgcmlzaW5nU2VyaWVzOiBbXSxcbiAgICAgICAgICAvLyB3aGVuIHVzZXIgcmUtb3BlbnMgYSBjb2xsYXBzZWQgc2VyaWVzLCBpdCBnb2VzIGhlcmVcbiAgICAgICAgICBkYXRhRm9ybWF0WE51bWVyaWM6IGZhbHNlLFxuICAgICAgICAgIC8vIGJvb2xlYW4gdmFsdWUgdG8gaW5kaWNhdGUgdXNlciBoYXMgcGFzc2VkIG51bWVyaWMgeCB2YWx1ZXNcbiAgICAgICAgICBjYXB0dXJlZFNlcmllc0luZGV4OiAtMSxcbiAgICAgICAgICBjYXB0dXJlZERhdGFQb2ludEluZGV4OiAtMSxcbiAgICAgICAgICBzZWxlY3RlZERhdGFQb2ludHM6IFtdLFxuICAgICAgICAgIGdvbGRlblBhZGRpbmc6IDM1LFxuICAgICAgICAgIC8vIHRoaXMgdmFsdWUgaXMgdXNlZCBhdCBhIGxvdCBvZiBwbGFjZXMgZm9yIHNwYWNpbmcgcHVycG9zZVxuICAgICAgICAgIGludmFsaWRMb2dTY2FsZTogZmFsc2UsXG4gICAgICAgICAgLy8gaWYgYSB1c2VyIGVuYWJsZWQgbG9nIHNjYWxlIGJ1dCB0aGUgZGF0YSBwcm92aWRlZCBpcyBub3QgdmFsaWQgdG8gZ2VuZXJhdGUgYSBsb2cgc2NhbGUsIHR1cm4gb24gdGhpcyBmbGFnXG4gICAgICAgICAgaWdub3JlWUF4aXNJbmRleGVzOiBbXSxcbiAgICAgICAgICAvLyB3aGVuIHNlcmllcyBhcmUgYmVpbmcgY29sbGFwc2VkIGluIG11bHRpcGxlIHkgYXhlcywgaWdub3JlIGNlcnRhaW4gaW5kZXhcbiAgICAgICAgICB5QXhpc1NhbWVTY2FsZUluZGljZXM6IFtdLFxuICAgICAgICAgIG1heFZhbHNJbkFycmF5SW5kZXg6IDAsXG4gICAgICAgICAgcmFkaWFsU2l6ZTogMCxcbiAgICAgICAgICBzZWxlY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICB6b29tRW5hYmxlZDogY29uZmlnLmNoYXJ0LnRvb2xiYXIuYXV0b1NlbGVjdGVkID09PSAnem9vbScgJiYgY29uZmlnLmNoYXJ0LnRvb2xiYXIudG9vbHMuem9vbSAmJiBjb25maWcuY2hhcnQuem9vbS5lbmFibGVkLFxuICAgICAgICAgIHBhbkVuYWJsZWQ6IGNvbmZpZy5jaGFydC50b29sYmFyLmF1dG9TZWxlY3RlZCA9PT0gJ3BhbicgJiYgY29uZmlnLmNoYXJ0LnRvb2xiYXIudG9vbHMucGFuLFxuICAgICAgICAgIHNlbGVjdGlvbkVuYWJsZWQ6IGNvbmZpZy5jaGFydC50b29sYmFyLmF1dG9TZWxlY3RlZCA9PT0gJ3NlbGVjdGlvbicgJiYgY29uZmlnLmNoYXJ0LnRvb2xiYXIudG9vbHMuc2VsZWN0aW9uLFxuICAgICAgICAgIHlheGlzOiBudWxsLFxuICAgICAgICAgIG1vdXNlZG93bjogZmFsc2UsXG4gICAgICAgICAgbGFzdENsaWVudFBvc2l0aW9uOiB7fSxcbiAgICAgICAgICAvLyBkb24ndCByZXNldCB0aGlzIHZhcmlhYmxlIHRoaXMgdGhlIGNoYXJ0IGlzIGRlc3Ryb3llZC4gSXQgaXMgdXNlZCB0byBkZXRlY3QgcmlnaHQgb3IgbGVmdCBtb3VzZW1vdmUgaW4gcGFubmluZ1xuICAgICAgICAgIHZpc2libGVYUmFuZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICB5VmFsdWVEZWNpbWFsOiAwLFxuICAgICAgICAgIC8vIGFyZSB0aGVyZSBmbG9hdGluZyBudW1iZXJzIGluIHRoZSBzZXJpZXMuIElmIHllcywgdGhpcyByZXByZXNlbnQgdGhlIGxlbiBvZiB0aGUgZGVjaW1hbHNcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICBTVkdOUzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgICAvLyBzdmcgbmFtZXNwYWNlXG4gICAgICAgICAgc3ZnV2lkdGg6IDAsXG4gICAgICAgICAgLy8gdGhlIHdob2xlIHN2ZyB3aWR0aFxuICAgICAgICAgIHN2Z0hlaWdodDogMCxcbiAgICAgICAgICAvLyB0aGUgd2hvbGUgc3ZnIGhlaWdodFxuICAgICAgICAgIG5vRGF0YTogZmFsc2UsXG4gICAgICAgICAgLy8gd2hldGhlciB0aGVyZSBpcyBhbnkgZGF0YSB0byBkaXNwbGF5IG9yIG5vdFxuICAgICAgICAgIGxvY2FsZToge30sXG4gICAgICAgICAgLy8gdGhlIGN1cnJlbnQgbG9jYWxlIHZhbHVlcyB3aWxsIGJlIHByZXNlcnZlZCBoZXJlIGZvciBnbG9iYWwgYWNjZXNzXG4gICAgICAgICAgZG9tOiB7fSxcbiAgICAgICAgICAvLyBmb3Igc3RvcmluZyBhbGwgZG9tIG5vZGVzIGluIHRoaXMgcGFydGljdWxhciBwcm9wZXJ0eVxuICAgICAgICAgIG1lbW9yeToge1xuICAgICAgICAgICAgbWV0aG9kc1RvRXhlYzogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3VsZEFuaW1hdGU6IHRydWUsXG4gICAgICAgICAgc2tpcExhc3RUaW1lbGluZWxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAvLyB3aGVuIGxhc3QgbGFiZWwgaXMgY3JvcHBlZCwgc2tpcCBkcmF3aW5nIGl0XG4gICAgICAgICAgc2tpcEZpcnN0VGltZWxpbmVsYWJlbDogZmFsc2UsXG4gICAgICAgICAgLy8gd2hlbiBmaXJzdCBsYWJlbCBpcyBjcm9wcGVkLCBza2lwIGRyYXdpbmcgaXRcbiAgICAgICAgICBkZWxheWVkRWxlbWVudHM6IFtdLFxuICAgICAgICAgIC8vIGVsZW1lbnQgd2hpY2ggYXBwZWFyIGFmdGVyIGFuaW1hdGlvbiBoYXMgZmluaXNoZWRcbiAgICAgICAgICBheGlzQ2hhcnRzOiB0cnVlLFxuICAgICAgICAgIC8vIGNoYXJ0IHR5cGUgPSBsaW5lIG9yIGFyZWEgb3IgYmFyXG4gICAgICAgICAgLy8gKHJlZmVyIHRoZW0gYWxzbyBhcyBwbG90IGNoYXJ0cyBpbiB0aGUgY29kZSlcbiAgICAgICAgICBpc0RhdGFYWVo6IGZhbHNlLFxuICAgICAgICAgIC8vIGJvb2w6IGRhdGEgd2FzIHByb3ZpZGVkIGluIGEge1t4LHksel19IHBhdHRlcm5cbiAgICAgICAgICByZXNpemVkOiBmYWxzZSxcbiAgICAgICAgICAvLyBib29sOiB1c2VyIGhhcyByZXNpemVkXG4gICAgICAgICAgcmVzaXplVGltZXI6IG51bGwsXG4gICAgICAgICAgLy8gdGltZW91dCBmdW5jdGlvbiB0byBtYWtlIGEgc21hbGwgZGVsYXkgYmVmb3JlXG4gICAgICAgICAgLy8gZHJhd2luZyB3aGVuIHVzZXIgcmVzaXplZFxuICAgICAgICAgIGNvbWJvQ2hhcnRzOiBmYWxzZSxcbiAgICAgICAgICAvLyBib29sOiB3aGV0aGVyIGl0J3MgYSBjb21iaW5hdGlvbiBvZiBsaW5lL2NvbHVtblxuICAgICAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgICAvLyBib29sOiBoYXMgZGF0YSBjaGFuZ2VkIGR5bmFtaWNhbGx5XG4gICAgICAgICAgcHJldmlvdXNQYXRoczogW10sXG4gICAgICAgICAgLy8gYXJyYXk6IHdoZW4gZGF0YSBpcyBjaGFuZ2VkLCBpdCB3aWxsIGFuaW1hdGUgZnJvbVxuICAgICAgICAgIC8vIHByZXZpb3VzIHBhdGhzXG4gICAgICAgICAgYWxsU2VyaWVzSGFzRXF1YWxYOiB0cnVlLFxuICAgICAgICAgIHBvaW50c0FycmF5OiBbXSxcbiAgICAgICAgICAvLyBzdG9yZSB0aGUgcG9pbnRzIHBvc2l0aW9ucyBoZXJlIHRvIGRyYXcgbGF0ZXIgb24gaG92ZXJcbiAgICAgICAgICAvLyBmb3JtYXQgaXMgLSBbW3gseV0sW3gseV0uLi4gW3gseV1dXG4gICAgICAgICAgZGF0YUxhYmVsc1JlY3RzOiBbXSxcbiAgICAgICAgICAvLyBzdG9yZSB0aGUgcG9zaXRpb25zIG9mIGRhdGFsYWJlbHMgdG8gcHJldmVudCBjb2xsaXNpb25cbiAgICAgICAgICBsYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlczogW10sXG4gICAgICAgICAgaGFzTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgICAgLy8gYm9vbDogd2hldGhlciBzZXJpZXMgY29udGFpbnMgbnVsbCB2YWx1ZXNcbiAgICAgICAgICBlYXNpbmc6IG51bGwsXG4gICAgICAgICAgLy8gZnVuY3Rpb246IGFuaW1hdGlvbiBlZmZlY3QgdG8gYXBwbHlcbiAgICAgICAgICB6b29tZWQ6IGZhbHNlLFxuICAgICAgICAgIC8vIHdoZXRoZXIgdXNlciBoYXMgem9vbWVkIG9yIG5vdFxuICAgICAgICAgIGdyaWRXaWR0aDogMCxcbiAgICAgICAgICAvLyBkcmF3YWJsZSB3aWR0aCBvZiBhY3R1YWwgZ3JhcGhzIChzZXJpZXMgcGF0aHMpXG4gICAgICAgICAgZ3JpZEhlaWdodDogMCxcbiAgICAgICAgICAvLyBkcmF3YWJsZSBoZWlnaHQgb2YgYWN0dWFsIGdyYXBocyAoc2VyaWVzIHBhdGhzKVxuICAgICAgICAgIHJvdGF0ZVhMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgIGRlZmF1bHRMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgIHhMYWJlbEZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIC8vIGZvcm1hdHRlciBmb3IgeCBheGlzIGxhYmVsc1xuICAgICAgICAgIHlMYWJlbEZvcm1hdHRlcnM6IFtdLFxuICAgICAgICAgIHhheGlzVG9vbHRpcEZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIC8vIGZvcm1hdHRlciBmb3IgeCBheGlzIHRvb2x0aXBcbiAgICAgICAgICB0dEtleUZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIHR0VmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgdHRaRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgTElORV9IRUlHSFRfUkFUSU86IDEuNjE4LFxuICAgICAgICAgIHhBeGlzTGFiZWxzSGVpZ2h0OiAwLFxuICAgICAgICAgIHhBeGlzR3JvdXBMYWJlbHNIZWlnaHQ6IDAsXG4gICAgICAgICAgeEF4aXNMYWJlbHNXaWR0aDogMCxcbiAgICAgICAgICB5QXhpc0xhYmVsc1dpZHRoOiAwLFxuICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICBzY2FsZVk6IDEsXG4gICAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICAgIHRyYW5zbGF0ZVlBeGlzWDogW10sXG4gICAgICAgICAgeUF4aXNXaWR0aHM6IFtdLFxuICAgICAgICAgIHRyYW5zbGF0ZVhBeGlzWTogMCxcbiAgICAgICAgICB0cmFuc2xhdGVYQXhpc1g6IDAsXG4gICAgICAgICAgdG9vbHRpcDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChjb25maWcpIHtcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbFZhcnMoY29uZmlnKTtcbiAgICAgICAgdGhpcy5pbml0R2xvYmFsVmFycyhnbG9iYWxzKTtcbiAgICAgICAgZ2xvYmFscy5pbml0aWFsQ29uZmlnID0gVXRpbHMkMS5leHRlbmQoe30sIGNvbmZpZyk7XG4gICAgICAgIGdsb2JhbHMuaW5pdGlhbFNlcmllcyA9IFV0aWxzJDEuY2xvbmUoY29uZmlnLnNlcmllcyk7XG4gICAgICAgIGdsb2JhbHMubGFzdFhBeGlzID0gVXRpbHMkMS5jbG9uZShnbG9iYWxzLmluaXRpYWxDb25maWcueGF4aXMpO1xuICAgICAgICBnbG9iYWxzLmxhc3RZQXhpcyA9IFV0aWxzJDEuY2xvbmUoZ2xvYmFscy5pbml0aWFsQ29uZmlnLnlheGlzKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEdsb2JhbHM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBCYXNlIENsYXNzIGZvciBleHRlbmRpbmcgdXNlciBvcHRpb25zIHdpdGggcHJlLWRlZmluZWQgQXBleENoYXJ0cyBjb25maWcuXG4gICAqXG4gICAqIEBtb2R1bGUgQmFzZVxuICAgKiovXG5cbiAgdmFyIEJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2Uob3B0cykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2UpO1xuXG4gICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhCYXNlLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IENvbmZpZyh0aGlzLm9wdHMpLmluaXQoe1xuICAgICAgICAgIHJlc3BvbnNpdmVPdmVycmlkZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBnbG9iYWxzID0gbmV3IEdsb2JhbHMoKS5pbml0KGNvbmZpZyk7XG4gICAgICAgIHZhciB3ID0ge1xuICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgIGdsb2JhbHM6IGdsb2JhbHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJhc2U7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBGaWxsIENsYXNzIGZvciBzZXR0aW5nIGZpbGwgb3B0aW9ucyBvZiB0aGUgcGF0aHMuXG4gICAqXG4gICAqIEBtb2R1bGUgRmlsbFxuICAgKiovXG5cbiAgdmFyIEZpbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbGwoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsbCk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgICB0aGlzLm9wdHMgPSBudWxsO1xuICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEZpbGwsIFt7XG4gICAgICBrZXk6IFwiY2xpcHBlZEltZ0FyZWFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGlwcGVkSW1nQXJlYShwYXJhbXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBjbmYgPSB3LmNvbmZpZztcbiAgICAgICAgdmFyIHN2Z1cgPSBwYXJzZUludCh3Lmdsb2JhbHMuZ3JpZFdpZHRoLCAxMCk7XG4gICAgICAgIHZhciBzdmdIID0gcGFyc2VJbnQody5nbG9iYWxzLmdyaWRIZWlnaHQsIDEwKTtcbiAgICAgICAgdmFyIHNpemUgPSBzdmdXID4gc3ZnSCA/IHN2Z1cgOiBzdmdIO1xuICAgICAgICB2YXIgZmlsbEltZyA9IHBhcmFtcy5pbWFnZTtcbiAgICAgICAgdmFyIGltZ1dpZHRoID0gMDtcbiAgICAgICAgdmFyIGltZ0hlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMud2lkdGggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMuaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChjbmYuZmlsbC5pbWFnZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGNuZi5maWxsLmltYWdlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbWdXaWR0aCA9IGNuZi5maWxsLmltYWdlLndpZHRoICsgMTtcbiAgICAgICAgICAgIGltZ0hlaWdodCA9IGNuZi5maWxsLmltYWdlLmhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1nV2lkdGggPSBzaXplICsgMTtcbiAgICAgICAgICAgIGltZ0hlaWdodCA9IHNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltZ1dpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICAgIGltZ0hlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxQYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3BhdHRlcm4nKTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXR0ZXJuLCB7XG4gICAgICAgICAgaWQ6IHBhcmFtcy5wYXR0ZXJuSUQsXG4gICAgICAgICAgcGF0dGVyblVuaXRzOiBwYXJhbXMucGF0dGVyblVuaXRzID8gcGFyYW1zLnBhdHRlcm5Vbml0cyA6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICAgICAgd2lkdGg6IGltZ1dpZHRoICsgJ3B4JyxcbiAgICAgICAgICBoZWlnaHQ6IGltZ0hlaWdodCArICdweCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbEltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ2ltYWdlJyk7XG4gICAgICAgIGVsUGF0dGVybi5hcHBlbmRDaGlsZChlbEltYWdlKTtcbiAgICAgICAgZWxJbWFnZS5zZXRBdHRyaWJ1dGVOUyh3aW5kb3cuU1ZHLnhsaW5rLCAnaHJlZicsIGZpbGxJbWcpO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbEltYWdlLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICdub25lJyxcbiAgICAgICAgICB3aWR0aDogaW1nV2lkdGggKyAncHgnLFxuICAgICAgICAgIGhlaWdodDogaW1nSGVpZ2h0ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgICAgZWxJbWFnZS5zdHlsZS5vcGFjaXR5ID0gcGFyYW1zLm9wYWNpdHk7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxEZWZzLm5vZGUuYXBwZW5kQ2hpbGQoZWxQYXR0ZXJuKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U2VyaWVzSW5kZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNJbmRleChvcHRzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgY1R5cGUgPSB3LmNvbmZpZy5jaGFydC50eXBlO1xuXG4gICAgICAgIGlmICgoY1R5cGUgPT09ICdiYXInIHx8IGNUeXBlID09PSAncmFuZ2VCYXInKSAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGlzdHJpYnV0ZWQgfHwgY1R5cGUgPT09ICdoZWF0bWFwJyB8fCBjVHlwZSA9PT0gJ3RyZWVtYXAnKSB7XG4gICAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IG9wdHMuc2VyaWVzTnVtYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VyaWVzSW5kZXggPSBvcHRzLnNlcmllc051bWJlciAlIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzSW5kZXg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbGxQYXRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbFBhdGgob3B0cykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICAgIHZhciBwYXRoRmlsbDtcbiAgICAgICAgdmFyIHBhdHRlcm5GaWxsLCBncmFkaWVudEZpbGw7XG4gICAgICAgIHRoaXMuc2VyaWVzSW5kZXggPSB0aGlzLmdldFNlcmllc0luZGV4KG9wdHMpO1xuICAgICAgICB2YXIgZmlsbENvbG9ycyA9IHRoaXMuZ2V0RmlsbENvbG9ycygpO1xuICAgICAgICB2YXIgZmlsbENvbG9yID0gZmlsbENvbG9yc1t0aGlzLnNlcmllc0luZGV4XTsgLy9vdmVycmlkZSBmaWxsY29sb3IgaWYgdXNlciBpbnB1dHRlZCBjb2xvciB3aXRoIGRhdGFcblxuICAgICAgICBpZiAody5nbG9iYWxzLnNlcmllc0NvbG9yc1t0aGlzLnNlcmllc0luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmlsbENvbG9yID0gdy5nbG9iYWxzLnNlcmllc0NvbG9yc1t0aGlzLnNlcmllc0luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsbENvbG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZmlsbENvbG9yID0gZmlsbENvbG9yKHtcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiB0aGlzLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IG9wdHMuZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogb3B0cy52YWx1ZSxcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWxsVHlwZSA9IG9wdHMuZmlsbFR5cGUgPyBvcHRzLmZpbGxUeXBlIDogdGhpcy5nZXRGaWxsVHlwZSh0aGlzLnNlcmllc0luZGV4KTtcbiAgICAgICAgdmFyIGZpbGxPcGFjaXR5ID0gQXJyYXkuaXNBcnJheShjbmYuZmlsbC5vcGFjaXR5KSA/IGNuZi5maWxsLm9wYWNpdHlbdGhpcy5zZXJpZXNJbmRleF0gOiBjbmYuZmlsbC5vcGFjaXR5O1xuXG4gICAgICAgIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgICAgICAgZmlsbENvbG9yID0gb3B0cy5jb2xvcjtcbiAgICAgICAgfSAvLyBpbiBjYXNlIGEgY29sb3IgaXMgdW5kZWZpbmVkLCBmYWxsYmFjayB0byB3aGl0ZSBjb2xvciB0byBwcmV2ZW50IHJ1bnRpbWUgZXJyb3JcblxuXG4gICAgICAgIGlmICghZmlsbENvbG9yKSB7XG4gICAgICAgICAgZmlsbENvbG9yID0gJyNmZmYnO1xuICAgICAgICAgIGNvbnNvbGUud2FybigndW5kZWZpbmVkIGNvbG9yIC0gQXBleENoYXJ0cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IGZpbGxDb2xvcjtcblxuICAgICAgICBpZiAoZmlsbENvbG9yLmluZGV4T2YoJ3JnYicpID09PSAtMSkge1xuICAgICAgICAgIGlmIChmaWxsQ29sb3IubGVuZ3RoIDwgOSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGhleCBjb250YWlucyBhbHBoYSBhbmQgaXMgb2YgOSBkaWdpdCwgc2tpcCB0aGUgb3BhY2l0eVxuICAgICAgICAgICAgZGVmYXVsdENvbG9yID0gVXRpbHMkMS5oZXhUb1JnYmEoZmlsbENvbG9yLCBmaWxsT3BhY2l0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaWxsQ29sb3IuaW5kZXhPZigncmdiYScpID4gLTEpIHtcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5ID0gVXRpbHMkMS5nZXRPcGFjaXR5RnJvbVJHQkEoZmlsbENvbG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5vcGFjaXR5KSBmaWxsT3BhY2l0eSA9IG9wdHMub3BhY2l0eTtcblxuICAgICAgICBpZiAoZmlsbFR5cGUgPT09ICdwYXR0ZXJuJykge1xuICAgICAgICAgIHBhdHRlcm5GaWxsID0gdGhpcy5oYW5kbGVQYXR0ZXJuRmlsbCh7XG4gICAgICAgICAgICBmaWxsQ29uZmlnOiBvcHRzLmZpbGxDb25maWcsXG4gICAgICAgICAgICBwYXR0ZXJuRmlsbDogcGF0dGVybkZpbGwsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IGZpbGxDb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSxcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcjogZGVmYXVsdENvbG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbFR5cGUgPT09ICdncmFkaWVudCcpIHtcbiAgICAgICAgICBncmFkaWVudEZpbGwgPSB0aGlzLmhhbmRsZUdyYWRpZW50RmlsbCh7XG4gICAgICAgICAgICBmaWxsQ29uZmlnOiBvcHRzLmZpbGxDb25maWcsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IGZpbGxDb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSxcbiAgICAgICAgICAgIGk6IHRoaXMuc2VyaWVzSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsVHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgIHZhciBpbWdTcmMgPSBjbmYuZmlsbC5pbWFnZS5zcmM7XG4gICAgICAgICAgdmFyIHBhdHRlcm5JRCA9IG9wdHMucGF0dGVybklEID8gb3B0cy5wYXR0ZXJuSUQgOiAnJztcbiAgICAgICAgICB0aGlzLmNsaXBwZWRJbWdBcmVhKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgaW1hZ2U6IEFycmF5LmlzQXJyYXkoaW1nU3JjKSA/IG9wdHMuc2VyaWVzTnVtYmVyIDwgaW1nU3JjLmxlbmd0aCA/IGltZ1NyY1tvcHRzLnNlcmllc051bWJlcl0gOiBpbWdTcmNbMF0gOiBpbWdTcmMsXG4gICAgICAgICAgICB3aWR0aDogb3B0cy53aWR0aCA/IG9wdHMud2lkdGggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdHMuaGVpZ2h0ID8gb3B0cy5oZWlnaHQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXR0ZXJuVW5pdHM6IG9wdHMucGF0dGVyblVuaXRzLFxuICAgICAgICAgICAgcGF0dGVybklEOiBcInBhdHRlcm5cIi5jb25jYXQody5nbG9iYWxzLmN1aWQpLmNvbmNhdChvcHRzLnNlcmllc051bWJlciArIDEpLmNvbmNhdChwYXR0ZXJuSUQpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGF0aEZpbGwgPSBcInVybCgjcGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KG9wdHMuc2VyaWVzTnVtYmVyICsgMSkuY29uY2F0KHBhdHRlcm5JRCwgXCIpXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGxUeXBlID09PSAnZ3JhZGllbnQnKSB7XG4gICAgICAgICAgcGF0aEZpbGwgPSBncmFkaWVudEZpbGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbFR5cGUgPT09ICdwYXR0ZXJuJykge1xuICAgICAgICAgIHBhdGhGaWxsID0gcGF0dGVybkZpbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aEZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIH0gLy8gb3ZlcnJpZGUgcGF0dGVybi9ncmFkaWVudCBpZiBvcHRzLnNvbGlkIGlzIHRydWVcblxuXG4gICAgICAgIGlmIChvcHRzLnNvbGlkKSB7XG4gICAgICAgICAgcGF0aEZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aEZpbGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEZpbGxUeXBlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsbFR5cGUoc2VyaWVzSW5kZXgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcuZmlsbC50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB3LmNvbmZpZy5maWxsLnR5cGVbc2VyaWVzSW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB3LmNvbmZpZy5maWxsLnR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RmlsbENvbG9yc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGxDb2xvcnMoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB2YXIgZmlsbENvbG9ycyA9IFtdO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuY29tYm9DaGFydHMpIHtcbiAgICAgICAgICBpZiAody5jb25maWcuc2VyaWVzW3RoaXMuc2VyaWVzSW5kZXhdLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMpKSB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcnMucHVzaCh3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuZ2xvYmFscy5maWxsLmNvbG9ycykpIHtcbiAgICAgICAgICAgICAgZmlsbENvbG9ycyA9IHcuZ2xvYmFscy5maWxsLmNvbG9ycztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcnMucHVzaCh3Lmdsb2JhbHMuZmlsbC5jb2xvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMpKSB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcnMucHVzaCh3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuZ2xvYmFscy5maWxsLmNvbG9ycykpIHtcbiAgICAgICAgICAgICAgZmlsbENvbG9ycyA9IHcuZ2xvYmFscy5maWxsLmNvbG9ycztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxDb2xvcnMucHVzaCh3Lmdsb2JhbHMuZmlsbC5jb2xvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjb2xvcnMgcGFzc2VkIGluIGFyZ3VtZW50c1xuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmZpbGxDb2xvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZmlsbENvbG9ycyA9IFtdO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5maWxsQ29sb3JzKSkge1xuICAgICAgICAgICAgZmlsbENvbG9ycyA9IG9wdHMuZmlsbENvbG9ycy5zbGljZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gob3B0cy5maWxsQ29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsbENvbG9ycztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlUGF0dGVybkZpbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQYXR0ZXJuRmlsbChfcmVmKSB7XG4gICAgICAgIHZhciBmaWxsQ29uZmlnID0gX3JlZi5maWxsQ29uZmlnLFxuICAgICAgICAgICAgcGF0dGVybkZpbGwgPSBfcmVmLnBhdHRlcm5GaWxsLFxuICAgICAgICAgICAgZmlsbENvbG9yID0gX3JlZi5maWxsQ29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eSA9IF9yZWYuZmlsbE9wYWNpdHksXG4gICAgICAgICAgICBkZWZhdWx0Q29sb3IgPSBfcmVmLmRlZmF1bHRDb2xvcjtcbiAgICAgICAgdmFyIGZpbGxDbmYgPSB0aGlzLncuY29uZmlnLmZpbGw7XG5cbiAgICAgICAgaWYgKGZpbGxDb25maWcpIHtcbiAgICAgICAgICBmaWxsQ25mID0gZmlsbENvbmZpZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgcGF0dGVyblN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheShmaWxsQ25mLnBhdHRlcm4uc3Ryb2tlV2lkdGgpID8gZmlsbENuZi5wYXR0ZXJuLnN0cm9rZVdpZHRoW3RoaXMuc2VyaWVzSW5kZXhdIDogZmlsbENuZi5wYXR0ZXJuLnN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgcGF0dGVybkxpbmVDb2xvciA9IGZpbGxDb2xvcjtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxsQ25mLnBhdHRlcm4uc3R5bGUpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWxsQ25mLnBhdHRlcm4uc3R5bGVbb3B0cy5zZXJpZXNOdW1iZXJdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIHBmID0gZ3JhcGhpY3MuZHJhd1BhdHRlcm4oZmlsbENuZi5wYXR0ZXJuLnN0eWxlW29wdHMuc2VyaWVzTnVtYmVyXSwgZmlsbENuZi5wYXR0ZXJuLndpZHRoLCBmaWxsQ25mLnBhdHRlcm4uaGVpZ2h0LCBwYXR0ZXJuTGluZUNvbG9yLCBwYXR0ZXJuU3Ryb2tlV2lkdGgsIGZpbGxPcGFjaXR5KTtcbiAgICAgICAgICAgIHBhdHRlcm5GaWxsID0gcGY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm5GaWxsID0gZGVmYXVsdENvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXR0ZXJuRmlsbCA9IGdyYXBoaWNzLmRyYXdQYXR0ZXJuKGZpbGxDbmYucGF0dGVybi5zdHlsZSwgZmlsbENuZi5wYXR0ZXJuLndpZHRoLCBmaWxsQ25mLnBhdHRlcm4uaGVpZ2h0LCBwYXR0ZXJuTGluZUNvbG9yLCBwYXR0ZXJuU3Ryb2tlV2lkdGgsIGZpbGxPcGFjaXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXR0ZXJuRmlsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlR3JhZGllbnRGaWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlR3JhZGllbnRGaWxsKF9yZWYyKSB7XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSBfcmVmMi5maWxsQ29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eSA9IF9yZWYyLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgZmlsbENvbmZpZyA9IF9yZWYyLmZpbGxDb25maWcsXG4gICAgICAgICAgICBpID0gX3JlZjIuaTtcbiAgICAgICAgdmFyIGZpbGxDbmYgPSB0aGlzLncuY29uZmlnLmZpbGw7XG5cbiAgICAgICAgaWYgKGZpbGxDb25maWcpIHtcbiAgICAgICAgICBmaWxsQ25mID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGZpbGxDbmYpLCBmaWxsQ29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgdXRpbHMgPSBuZXcgVXRpbHMkMSgpO1xuICAgICAgICB2YXIgdHlwZSA9IGZpbGxDbmYuZ3JhZGllbnQudHlwZTtcbiAgICAgICAgdmFyIGdyYWRpZW50RnJvbSA9IGZpbGxDb2xvcjtcbiAgICAgICAgdmFyIGdyYWRpZW50VG87XG4gICAgICAgIHZhciBvcGFjaXR5RnJvbSA9IGZpbGxDbmYuZ3JhZGllbnQub3BhY2l0eUZyb20gPT09IHVuZGVmaW5lZCA/IGZpbGxPcGFjaXR5IDogQXJyYXkuaXNBcnJheShmaWxsQ25mLmdyYWRpZW50Lm9wYWNpdHlGcm9tKSA/IGZpbGxDbmYuZ3JhZGllbnQub3BhY2l0eUZyb21baV0gOiBmaWxsQ25mLmdyYWRpZW50Lm9wYWNpdHlGcm9tO1xuXG4gICAgICAgIGlmIChncmFkaWVudEZyb20uaW5kZXhPZigncmdiYScpID4gLTEpIHtcbiAgICAgICAgICBvcGFjaXR5RnJvbSA9IFV0aWxzJDEuZ2V0T3BhY2l0eUZyb21SR0JBKGdyYWRpZW50RnJvbSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3BhY2l0eVRvID0gZmlsbENuZi5ncmFkaWVudC5vcGFjaXR5VG8gPT09IHVuZGVmaW5lZCA/IGZpbGxPcGFjaXR5IDogQXJyYXkuaXNBcnJheShmaWxsQ25mLmdyYWRpZW50Lm9wYWNpdHlUbykgPyBmaWxsQ25mLmdyYWRpZW50Lm9wYWNpdHlUb1tpXSA6IGZpbGxDbmYuZ3JhZGllbnQub3BhY2l0eVRvO1xuXG4gICAgICAgIGlmIChmaWxsQ25mLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnMgPT09IHVuZGVmaW5lZCB8fCBmaWxsQ25mLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKGZpbGxDbmYuZ3JhZGllbnQuc2hhZGUgPT09ICdkYXJrJykge1xuICAgICAgICAgICAgZ3JhZGllbnRUbyA9IHV0aWxzLnNoYWRlQ29sb3IocGFyc2VGbG9hdChmaWxsQ25mLmdyYWRpZW50LnNoYWRlSW50ZW5zaXR5KSAqIC0xLCBmaWxsQ29sb3IuaW5kZXhPZigncmdiJykgPiAtMSA/IFV0aWxzJDEucmdiMmhleChmaWxsQ29sb3IpIDogZmlsbENvbG9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JhZGllbnRUbyA9IHV0aWxzLnNoYWRlQ29sb3IocGFyc2VGbG9hdChmaWxsQ25mLmdyYWRpZW50LnNoYWRlSW50ZW5zaXR5KSwgZmlsbENvbG9yLmluZGV4T2YoJ3JnYicpID4gLTEgPyBVdGlscyQxLnJnYjJoZXgoZmlsbENvbG9yKSA6IGZpbGxDb2xvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaWxsQ25mLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnNbb3B0cy5zZXJpZXNOdW1iZXJdKSB7XG4gICAgICAgICAgICB2YXIgZ1RvQ29sb3IgPSBmaWxsQ25mLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnNbb3B0cy5zZXJpZXNOdW1iZXJdO1xuICAgICAgICAgICAgZ3JhZGllbnRUbyA9IGdUb0NvbG9yO1xuXG4gICAgICAgICAgICBpZiAoZ1RvQ29sb3IuaW5kZXhPZigncmdiYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgb3BhY2l0eVRvID0gVXRpbHMkMS5nZXRPcGFjaXR5RnJvbVJHQkEoZ1RvQ29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmFkaWVudFRvID0gZmlsbENvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsQ25mLmdyYWRpZW50LmdyYWRpZW50RnJvbSkge1xuICAgICAgICAgIGdyYWRpZW50RnJvbSA9IGZpbGxDbmYuZ3JhZGllbnQuZ3JhZGllbnRGcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGxDbmYuZ3JhZGllbnQuZ3JhZGllbnRUbykge1xuICAgICAgICAgIGdyYWRpZW50VG8gPSBmaWxsQ25mLmdyYWRpZW50LmdyYWRpZW50VG87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbENuZi5ncmFkaWVudC5pbnZlcnNlQ29sb3JzKSB7XG4gICAgICAgICAgdmFyIHQgPSBncmFkaWVudEZyb207XG4gICAgICAgICAgZ3JhZGllbnRGcm9tID0gZ3JhZGllbnRUbztcbiAgICAgICAgICBncmFkaWVudFRvID0gdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmFkaWVudEZyb20uaW5kZXhPZigncmdiJykgPiAtMSkge1xuICAgICAgICAgIGdyYWRpZW50RnJvbSA9IFV0aWxzJDEucmdiMmhleChncmFkaWVudEZyb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYWRpZW50VG8uaW5kZXhPZigncmdiJykgPiAtMSkge1xuICAgICAgICAgIGdyYWRpZW50VG8gPSBVdGlscyQxLnJnYjJoZXgoZ3JhZGllbnRUbyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JhcGhpY3MuZHJhd0dyYWRpZW50KHR5cGUsIGdyYWRpZW50RnJvbSwgZ3JhZGllbnRUbywgb3BhY2l0eUZyb20sIG9wYWNpdHlUbywgb3B0cy5zaXplLCBmaWxsQ25mLmdyYWRpZW50LnN0b3BzLCBmaWxsQ25mLmdyYWRpZW50LmNvbG9yU3RvcHMsIGkpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGaWxsO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgTWFya2VycyBDbGFzcyBmb3IgZHJhd2luZyBwb2ludHMgb24geSB2YWx1ZXMgaW4gYXhlcyBjaGFydHMuXG4gICAqXG4gICAqIEBtb2R1bGUgTWFya2Vyc1xuICAgKiovXG5cbiAgdmFyIE1hcmtlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmtlcnMoY3R4LCBvcHRzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFya2Vycyk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE1hcmtlcnMsIFt7XG4gICAgICBrZXk6IFwic2V0R2xvYmFsTWFya2VyU2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEdsb2JhbE1hcmtlclNpemUoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5tYXJrZXJzLnNpemUpID8gdy5jb25maWcubWFya2Vycy5zaXplIDogW3cuY29uZmlnLm1hcmtlcnMuc2l6ZV07XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMubWFya2Vycy5zaXplLmxlbmd0aCA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZS5wdXNoKHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbMF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcuZ2xvYmFscy5tYXJrZXJzLnNpemUgPSB3LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdy5jb25maWcubWFya2Vycy5zaXplO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBsb3RDaGFydE1hcmtlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbG90Q2hhcnRNYXJrZXJzKHBvaW50c1Bvcywgc2VyaWVzSW5kZXgsIGosIHBTaXplKSB7XG4gICAgICAgIHZhciBhbHdheXNEcmF3TWFya2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBpID0gc2VyaWVzSW5kZXg7XG4gICAgICAgIHZhciBwID0gcG9pbnRzUG9zO1xuICAgICAgICB2YXIgZWxQb2ludHNXcmFwID0gbnVsbDtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHBvaW50O1xuICAgICAgICB2YXIgaGFzRGlzY3JldGVNYXJrZXJzID0gdy5jb25maWcubWFya2Vycy5kaXNjcmV0ZSAmJiB3LmNvbmZpZy5tYXJrZXJzLmRpc2NyZXRlLmxlbmd0aDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtzZXJpZXNJbmRleF0gPiAwIHx8IGFsd2F5c0RyYXdNYXJrZXIgfHwgaGFzRGlzY3JldGVNYXJrZXJzKSB7XG4gICAgICAgICAgZWxQb2ludHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6IGFsd2F5c0RyYXdNYXJrZXIgfHwgaGFzRGlzY3JldGVNYXJrZXJzID8gJycgOiAnYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFBvaW50c1dyYXAuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFya2VyTWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHAueCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IHAueC5sZW5ndGg7IHErKykge1xuICAgICAgICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gajsgLy8gYSBzbWFsbCBoYWNrIGFzIHdlIGhhdmUgMiBwb2ludHMgZm9yIHRoZSBmaXJzdCB2YWwgdG8gY29ubmVjdCBpdFxuXG4gICAgICAgICAgICBpZiAoaiA9PT0gMSAmJiBxID09PSAwKSBkYXRhUG9pbnRJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoaiA9PT0gMSAmJiBxID09PSAxKSBkYXRhUG9pbnRJbmRleCA9IDE7XG4gICAgICAgICAgICB2YXIgUG9pbnRDbGFzc2VzID0gJ2FwZXhjaGFydHMtbWFya2VyJztcblxuICAgICAgICAgICAgaWYgKCh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnbGluZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2FyZWEnKSAmJiAhdy5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF3LmNvbmZpZy50b29sdGlwLmludGVyc2VjdCkge1xuICAgICAgICAgICAgICBQb2ludENsYXNzZXMgKz0gJyBuby1wb2ludGVyLWV2ZW50cyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaG91bGRNYXJrZXJEcmF3ID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5tYXJrZXJzLnNpemUpID8gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtzZXJpZXNJbmRleF0gPiAwIDogdy5jb25maWcubWFya2Vycy5zaXplID4gMDtcblxuICAgICAgICAgICAgaWYgKHNob3VsZE1hcmtlckRyYXcgfHwgYWx3YXlzRHJhd01hcmtlciB8fCBoYXNEaXNjcmV0ZU1hcmtlcnMpIHtcbiAgICAgICAgICAgICAgaWYgKFV0aWxzJDEuaXNOdW1iZXIocC55W3FdKSkge1xuICAgICAgICAgICAgICAgIFBvaW50Q2xhc3NlcyArPSBcIiB3XCIuY29uY2F0KFV0aWxzJDEucmFuZG9tSWQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgUG9pbnRDbGFzc2VzID0gJ2FwZXhjaGFydHMtbnVsbHBvaW50JztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5nZXRNYXJrZXJDb25maWcoe1xuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiBQb2ludENsYXNzZXMsXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBkYXRhUG9pbnRJbmRleFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuc2VyaWVzW2ldLmRhdGFbZGF0YVBvaW50SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2RhdGFQb2ludEluZGV4XS5maWxsQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIG9wdHMucG9pbnRGaWxsQ29sb3IgPSB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtkYXRhUG9pbnRJbmRleF0uZmlsbENvbG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtkYXRhUG9pbnRJbmRleF0uc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIG9wdHMucG9pbnRTdHJva2VDb2xvciA9IHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2RhdGFQb2ludEluZGV4XS5zdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocFNpemUpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBTaXplID0gcFNpemU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocC54W3FdIDwgMCB8fCBwLnhbcV0gPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIHx8IHAueVtxXSA8IDAgfHwgcC55W3FdID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBTaXplID0gMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBvaW50ID0gZ3JhcGhpY3MuZHJhd01hcmtlcihwLnhbcV0sIHAueVtxXSwgb3B0cyk7XG4gICAgICAgICAgICAgIHBvaW50LmF0dHIoJ3JlbCcsIGRhdGFQb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgcG9pbnQuYXR0cignaicsIGRhdGFQb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgcG9pbnQuYXR0cignaW5kZXgnLCBzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgIHBvaW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkZWZhdWx0LW1hcmtlci1zaXplJywgb3B0cy5wU2l6ZSk7XG4gICAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICAgICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihwb2ludCwgc2VyaWVzSW5kZXgsIGRhdGFQb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudHMocG9pbnQpO1xuXG4gICAgICAgICAgICAgIGlmIChlbFBvaW50c1dyYXApIHtcbiAgICAgICAgICAgICAgICBlbFBvaW50c1dyYXAuYWRkKHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZHluYW1pYyBhcnJheSBjcmVhdGlvbiAtIG11bHRpZGltZW5zaW9uYWxcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMucG9pbnRzQXJyYXlbc2VyaWVzSW5kZXhdID09PSAndW5kZWZpbmVkJykgdy5nbG9iYWxzLnBvaW50c0FycmF5W3Nlcmllc0luZGV4XSA9IFtdO1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMucG9pbnRzQXJyYXlbc2VyaWVzSW5kZXhdLnB1c2goW3AueFtxXSwgcC55W3FdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsUG9pbnRzV3JhcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TWFya2VyQ29uZmlnXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VyQ29uZmlnKF9yZWYpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gX3JlZi5jc3NDbGFzcyxcbiAgICAgICAgICAgIHNlcmllc0luZGV4ID0gX3JlZi5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgIF9yZWYkZGF0YVBvaW50SW5kZXggPSBfcmVmLmRhdGFQb2ludEluZGV4LFxuICAgICAgICAgICAgZGF0YVBvaW50SW5kZXggPSBfcmVmJGRhdGFQb2ludEluZGV4ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICAgIF9yZWYkZmluaXNoUmFkaXVzID0gX3JlZi5maW5pc2hSYWRpdXMsXG4gICAgICAgICAgICBmaW5pc2hSYWRpdXMgPSBfcmVmJGZpbmlzaFJhZGl1cyA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkZmluaXNoUmFkaXVzO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHBTdHlsZSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoc2VyaWVzSW5kZXgpO1xuICAgICAgICB2YXIgcFNpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW3Nlcmllc0luZGV4XTtcbiAgICAgICAgdmFyIG0gPSB3LmNvbmZpZy5tYXJrZXJzOyAvLyBkaXNjcmV0ZSBtYXJrZXJzIGlzIGFuIG9wdGlvbiB3aGVyZSB1c2VyIGNhbiBzcGVjaWZ5IGEgcGFydGljdWxhciBtYXJrZXIgd2l0aCBkaWZmZXJlbnQgc2hhcGUsIHNpemUgYW5kIGNvbG9yXG5cbiAgICAgICAgaWYgKGRhdGFQb2ludEluZGV4ICE9PSBudWxsICYmIG0uZGlzY3JldGUubGVuZ3RoKSB7XG4gICAgICAgICAgbS5kaXNjcmV0ZS5tYXAoZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgICAgaWYgKG1hcmtlci5zZXJpZXNJbmRleCA9PT0gc2VyaWVzSW5kZXggJiYgbWFya2VyLmRhdGFQb2ludEluZGV4ID09PSBkYXRhUG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICBwU3R5bGUucG9pbnRTdHJva2VDb2xvciA9IG1hcmtlci5zdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgcFN0eWxlLnBvaW50RmlsbENvbG9yID0gbWFya2VyLmZpbGxDb2xvcjtcbiAgICAgICAgICAgICAgcFNpemUgPSBtYXJrZXIuc2l6ZTtcbiAgICAgICAgICAgICAgcFN0eWxlLnBvaW50U2hhcGUgPSBtYXJrZXIuc2hhcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBTaXplOiBmaW5pc2hSYWRpdXMgPT09IG51bGwgPyBwU2l6ZSA6IGZpbmlzaFJhZGl1cyxcbiAgICAgICAgICBwUmFkaXVzOiBtLnJhZGl1cyxcbiAgICAgICAgICB3aWR0aDogQXJyYXkuaXNBcnJheShtLndpZHRoKSA/IG0ud2lkdGhbc2VyaWVzSW5kZXhdIDogbS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IEFycmF5LmlzQXJyYXkobS5oZWlnaHQpID8gbS5oZWlnaHRbc2VyaWVzSW5kZXhdIDogbS5oZWlnaHQsXG4gICAgICAgICAgcG9pbnRTdHJva2VXaWR0aDogQXJyYXkuaXNBcnJheShtLnN0cm9rZVdpZHRoKSA/IG0uc3Ryb2tlV2lkdGhbc2VyaWVzSW5kZXhdIDogbS5zdHJva2VXaWR0aCxcbiAgICAgICAgICBwb2ludFN0cm9rZUNvbG9yOiBwU3R5bGUucG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgICBwb2ludEZpbGxDb2xvcjogcFN0eWxlLnBvaW50RmlsbENvbG9yLFxuICAgICAgICAgIHNoYXBlOiBwU3R5bGUucG9pbnRTaGFwZSB8fCAoQXJyYXkuaXNBcnJheShtLnNoYXBlKSA/IG0uc2hhcGVbc2VyaWVzSW5kZXhdIDogbS5zaGFwZSksXG4gICAgICAgICAgY2xhc3M6IGNzc0NsYXNzLFxuICAgICAgICAgIHBvaW50U3Ryb2tlT3BhY2l0eTogQXJyYXkuaXNBcnJheShtLnN0cm9rZU9wYWNpdHkpID8gbS5zdHJva2VPcGFjaXR5W3Nlcmllc0luZGV4XSA6IG0uc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICBwb2ludFN0cm9rZURhc2hBcnJheTogQXJyYXkuaXNBcnJheShtLnN0cm9rZURhc2hBcnJheSkgPyBtLnN0cm9rZURhc2hBcnJheVtzZXJpZXNJbmRleF0gOiBtLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgICBwb2ludEZpbGxPcGFjaXR5OiBBcnJheS5pc0FycmF5KG0uZmlsbE9wYWNpdHkpID8gbS5maWxsT3BhY2l0eVtzZXJpZXNJbmRleF0gOiBtLmZpbGxPcGFjaXR5LFxuICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRFdmVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudHMoY2lyY2xlKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICBjaXJjbGUubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZ3JhcGhpY3MucGF0aE1vdXNlRW50ZXIuYmluZCh0aGlzLmN0eCwgY2lyY2xlKSk7XG4gICAgICAgIGNpcmNsZS5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBncmFwaGljcy5wYXRoTW91c2VMZWF2ZS5iaW5kKHRoaXMuY3R4LCBjaXJjbGUpKTtcbiAgICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZ3JhcGhpY3MucGF0aE1vdXNlRG93bi5iaW5kKHRoaXMuY3R4LCBjaXJjbGUpKTtcbiAgICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB3LmNvbmZpZy5tYXJrZXJzLm9uQ2xpY2spO1xuICAgICAgICBjaXJjbGUubm9kZS5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHcuY29uZmlnLm1hcmtlcnMub25EYmxDbGljayk7XG4gICAgICAgIGNpcmNsZS5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBncmFwaGljcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcy5jdHgsIGNpcmNsZSksIHtcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRNYXJrZXJTdHlsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlclN0eWxlKHNlcmllc0luZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgY29sb3JzID0gdy5nbG9iYWxzLm1hcmtlcnMuY29sb3JzO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3JzID0gdy5jb25maWcubWFya2Vycy5zdHJva2VDb2xvciB8fCB3LmNvbmZpZy5tYXJrZXJzLnN0cm9rZUNvbG9ycztcbiAgICAgICAgdmFyIHBvaW50U3Ryb2tlQ29sb3IgPSBBcnJheS5pc0FycmF5KHN0cm9rZUNvbG9ycykgPyBzdHJva2VDb2xvcnNbc2VyaWVzSW5kZXhdIDogc3Ryb2tlQ29sb3JzO1xuICAgICAgICB2YXIgcG9pbnRGaWxsQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9ycykgPyBjb2xvcnNbc2VyaWVzSW5kZXhdIDogY29sb3JzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvaW50U3Ryb2tlQ29sb3I6IHBvaW50U3Ryb2tlQ29sb3IsXG4gICAgICAgICAgcG9pbnRGaWxsQ29sb3I6IHBvaW50RmlsbENvbG9yXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1hcmtlcnM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBTY2F0dGVyIENsYXNzLlxuICAgKiBUaGlzIENsYXNzIGFsc28gaGFuZGxlcyBidWJibGVzIGNoYXJ0IGFzIGN1cnJlbnRseSB0aGVyZSBpcyBubyBtYWpvciBkaWZmZXJlbmNlIGluIGRyYXdpbmcgdGhlbSxcbiAgICogQG1vZHVsZSBTY2F0dGVyXG4gICAqKi9cblxuICB2YXIgU2NhdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NhdHRlcihjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2F0dGVyKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMuaW5pdGlhbEFuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICAgIHRoaXMuZHluYW1pY0FuaW0gPSB0aGlzLmluaXRpYWxBbmltICYmIHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQ7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNjYXR0ZXIsIFt7XG4gICAgICBrZXk6IFwiZHJhd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoZWxTZXJpZXMsIGosIG9wdHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciByZWFsSW5kZXggPSBvcHRzLnJlYWxJbmRleDtcbiAgICAgICAgdmFyIHBvaW50c1BvcyA9IG9wdHMucG9pbnRzUG9zO1xuICAgICAgICB2YXIgelJhdGlvID0gb3B0cy56UmF0aW87XG4gICAgICAgIHZhciBlbFBvaW50c01haW4gPSBvcHRzLmVsUGFyZW50O1xuICAgICAgICB2YXIgZWxQb2ludHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMgYXBleGNoYXJ0cy1zZXJpZXMtXCIuY29uY2F0KHcuY29uZmlnLmNoYXJ0LnR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBlbFBvaW50c1dyYXAuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFya2VyTWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHNQb3MueCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IHBvaW50c1Bvcy54Lmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVBvaW50SW5kZXggPSBqICsgMTtcbiAgICAgICAgICAgIHZhciBzaG91bGREcmF3ID0gdHJ1ZTsgLy8gYSBzbWFsbCBoYWNrIGFzIHdlIGhhdmUgMiBwb2ludHMgZm9yIHRoZSBmaXJzdCB2YWwgdG8gY29ubmVjdCBpdFxuXG4gICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBxID09PSAwKSBkYXRhUG9pbnRJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBxID09PSAxKSBkYXRhUG9pbnRJbmRleCA9IDE7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gMDtcbiAgICAgICAgICAgIHZhciBmaW5pc2hSYWRpdXMgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW3JlYWxJbmRleF07XG5cbiAgICAgICAgICAgIGlmICh6UmF0aW8gIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIC8vIG1lYW5zIHdlIGhhdmUgYSBidWJibGVcbiAgICAgICAgICAgICAgdmFyIGJ1YmJsZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJ1YmJsZTtcbiAgICAgICAgICAgICAgZmluaXNoUmFkaXVzID0gdy5nbG9iYWxzLnNlcmllc1pbcmVhbEluZGV4XVtkYXRhUG9pbnRJbmRleF07XG5cbiAgICAgICAgICAgICAgaWYgKGJ1YmJsZS56U2NhbGluZykge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJhZGl1cyAvPSB6UmF0aW87XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYnViYmxlLm1pbkJ1YmJsZVJhZGl1cyAmJiBmaW5pc2hSYWRpdXMgPCBidWJibGUubWluQnViYmxlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoUmFkaXVzID0gYnViYmxlLm1pbkJ1YmJsZVJhZGl1cztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChidWJibGUubWF4QnViYmxlUmFkaXVzICYmIGZpbmlzaFJhZGl1cyA+IGJ1YmJsZS5tYXhCdWJibGVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSYWRpdXMgPSBidWJibGUubWF4QnViYmxlUmFkaXVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIHJhZGl1cyA9IGZpbmlzaFJhZGl1cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHggPSBwb2ludHNQb3MueFtxXTtcbiAgICAgICAgICAgIHZhciB5ID0gcG9pbnRzUG9zLnlbcV07XG4gICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgMDtcblxuICAgICAgICAgICAgaWYgKHkgPT09IG51bGwgfHwgdHlwZW9mIHcuZ2xvYmFscy5zZXJpZXNbcmVhbEluZGV4XVtkYXRhUG9pbnRJbmRleF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHNob3VsZERyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3VsZERyYXcpIHtcbiAgICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5kcmF3UG9pbnQoeCwgeSwgcmFkaXVzLCBmaW5pc2hSYWRpdXMsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgsIGopO1xuICAgICAgICAgICAgICBlbFBvaW50c1dyYXAuYWRkKHBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxQb2ludHNNYWluLmFkZChlbFBvaW50c1dyYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3UG9pbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UG9pbnQoeCwgeSwgcmFkaXVzLCBmaW5pc2hSYWRpdXMsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgsIGopIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBpID0gcmVhbEluZGV4O1xuICAgICAgICB2YXIgYW5pbSA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBmaWxsID0gbmV3IEZpbGwodGhpcy5jdHgpO1xuICAgICAgICB2YXIgbWFya2VycyA9IG5ldyBNYXJrZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIG1hcmtlckNvbmZpZyA9IG1hcmtlcnMuZ2V0TWFya2VyQ29uZmlnKHtcbiAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMtbWFya2VyJyxcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgZmluaXNoUmFkaXVzOiB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYnViYmxlJyB8fCB3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0gJiYgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0udHlwZSA9PT0gJ2J1YmJsZScgPyBmaW5pc2hSYWRpdXMgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5pc2hSYWRpdXMgPSBtYXJrZXJDb25maWcucFNpemU7XG4gICAgICAgIHZhciBwYXRoRmlsbENpcmNsZSA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgIHNlcmllc051bWJlcjogcmVhbEluZGV4LFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICBjb2xvcjogbWFya2VyQ29uZmlnLnBvaW50RmlsbENvbG9yLFxuICAgICAgICAgIHBhdHRlcm5Vbml0czogJ29iamVjdEJvdW5kaW5nQm94JyxcbiAgICAgICAgICB2YWx1ZTogdy5nbG9iYWxzLnNlcmllc1tyZWFsSW5kZXhdW2pdXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZWw7XG5cbiAgICAgICAgaWYgKG1hcmtlckNvbmZpZy5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICBlbCA9IGdyYXBoaWNzLmRyYXdDaXJjbGUocmFkaXVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrZXJDb25maWcuc2hhcGUgPT09ICdzcXVhcmUnIHx8IG1hcmtlckNvbmZpZy5zaGFwZSA9PT0gJ3JlY3QnKSB7XG4gICAgICAgICAgZWwgPSBncmFwaGljcy5kcmF3UmVjdCgwLCAwLCBtYXJrZXJDb25maWcud2lkdGggLSBtYXJrZXJDb25maWcucG9pbnRTdHJva2VXaWR0aCAvIDIsIG1hcmtlckNvbmZpZy5oZWlnaHQgLSBtYXJrZXJDb25maWcucG9pbnRTdHJva2VXaWR0aCAvIDIsIG1hcmtlckNvbmZpZy5wUmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtkYXRhUG9pbnRJbmRleF0pIHtcbiAgICAgICAgICBpZiAody5jb25maWcuc2VyaWVzW2ldLmRhdGFbZGF0YVBvaW50SW5kZXhdLmZpbGxDb2xvcikge1xuICAgICAgICAgICAgcGF0aEZpbGxDaXJjbGUgPSB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtkYXRhUG9pbnRJbmRleF0uZmlsbENvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgIHg6IHggLSBtYXJrZXJDb25maWcud2lkdGggLyAyIC0gbWFya2VyQ29uZmlnLnBvaW50U3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICAgIHk6IHkgLSBtYXJrZXJDb25maWcuaGVpZ2h0IC8gMiAtIG1hcmtlckNvbmZpZy5wb2ludFN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgICBjeDogeCxcbiAgICAgICAgICBjeTogeSxcbiAgICAgICAgICBmaWxsOiBwYXRoRmlsbENpcmNsZSxcbiAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogbWFya2VyQ29uZmlnLnBvaW50RmlsbE9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlOiBtYXJrZXJDb25maWcucG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgICByOiBmaW5pc2hSYWRpdXMsXG4gICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG1hcmtlckNvbmZpZy5wb2ludFN0cm9rZVdpZHRoLFxuICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogbWFya2VyQ29uZmlnLnBvaW50U3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IG1hcmtlckNvbmZpZy5wb2ludFN0cm9rZU9wYWNpdHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBkcm9wU2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZWwsIGRyb3BTaGFkb3csIHJlYWxJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkICYmICF3Lmdsb2JhbHMucmVzaXplZCkge1xuICAgICAgICAgIHZhciBzcGVlZCA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgYW5pbS5hbmltYXRlTWFya2VyKGVsLCAwLCBtYXJrZXJDb25maWcuc2hhcGUgPT09ICdjaXJjbGUnID8gZmluaXNoUmFkaXVzIDoge1xuICAgICAgICAgICAgd2lkdGg6IG1hcmtlckNvbmZpZy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbWFya2VyQ29uZmlnLmhlaWdodFxuICAgICAgICAgIH0sIHNwZWVkLCB3Lmdsb2JhbHMuZWFzaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFuaW0uYW5pbWF0aW9uQ29tcGxldGVkKGVsKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgJiYgbWFya2VyQ29uZmlnLnNoYXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNBbmltKSB7XG4gICAgICAgICAgICB2YXIgX3NwZWVkID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkO1xuICAgICAgICAgICAgdmFyIHByZXZYLCBwcmV2WSwgcHJldlI7XG4gICAgICAgICAgICB2YXIgcHJldlBhdGhKID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZQYXRoSiA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3JlYWxJbmRleF0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcmVhbEluZGV4XVtqXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2UGF0aEogIT09ICd1bmRlZmluZWQnICYmIHByZXZQYXRoSiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBzZXJpZXMgY29udGFpbmluZyBsZXNzIGVsZW1lbnRzIHdpbGwgaWdub3JlIHRoZXNlIHZhbHVlcyBhbmQgcmV2ZXJ0IHRvIDBcbiAgICAgICAgICAgICAgcHJldlggPSBwcmV2UGF0aEoueDtcbiAgICAgICAgICAgICAgcHJldlkgPSBwcmV2UGF0aEoueTtcbiAgICAgICAgICAgICAgcHJldlIgPSB0eXBlb2YgcHJldlBhdGhKLnIgIT09ICd1bmRlZmluZWQnID8gcHJldlBhdGhKLnIgOiBmaW5pc2hSYWRpdXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNzID0gMDsgY3MgPCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aDsgY3MrKykge1xuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc1tjc10uaW5kZXggPT09IHJlYWxJbmRleCkge1xuICAgICAgICAgICAgICAgIF9zcGVlZCA9IDE7XG4gICAgICAgICAgICAgICAgZmluaXNoUmFkaXVzID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSBmaW5pc2hSYWRpdXMgPSAwO1xuICAgICAgICAgICAgYW5pbS5hbmltYXRlQ2lyY2xlKGVsLCB7XG4gICAgICAgICAgICAgIGN4OiBwcmV2WCxcbiAgICAgICAgICAgICAgY3k6IHByZXZZLFxuICAgICAgICAgICAgICByOiBwcmV2UlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjeDogeCxcbiAgICAgICAgICAgICAgY3k6IHksXG4gICAgICAgICAgICAgIHI6IGZpbmlzaFJhZGl1c1xuICAgICAgICAgICAgfSwgX3NwZWVkLCB3Lmdsb2JhbHMuZWFzaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgICAgIHI6IGZpbmlzaFJhZGl1c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgcmVsOiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICBqOiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICBpbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICdkZWZhdWx0LW1hcmtlci1zaXplJzogZmluaXNoUmFkaXVzXG4gICAgICAgIH0pO1xuICAgICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihlbCwgcmVhbEluZGV4LCBkYXRhUG9pbnRJbmRleCk7XG4gICAgICAgIG1hcmtlcnMuYWRkRXZlbnRzKGVsKTtcbiAgICAgICAgZWwubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLW1hcmtlcicpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNlbnRlclRleHRJbkJ1YmJsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNlbnRlclRleHRJbkJ1YmJsZSh5KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB5ID0geSArIHBhcnNlSW50KHcuY29uZmlnLmRhdGFMYWJlbHMuc3R5bGUuZm9udFNpemUsIDEwKSAvIDQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTY2F0dGVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgRGF0YUxhYmVscyBDbGFzcyBmb3IgZHJhd2luZyBkYXRhTGFiZWxzIG9uIEF4ZXMgYmFzZWQgQ2hhcnRzLlxuICAgKlxuICAgKiBAbW9kdWxlIERhdGFMYWJlbHNcbiAgICoqL1xuXG4gIHZhciBEYXRhTGFiZWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhTGFiZWxzKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFMYWJlbHMpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgIH0gLy8gV2hlbiB0aGVyZSBhcmUgbWFueSBkYXRhbGFiZWxzIHRvIGJlIHByaW50ZWQsIGFuZCBzb21lIG9mIHRoZW0gb3ZlcmxhcHMgZWFjaCBvdGhlciBpbiB0aGUgc2FtZSBzZXJpZXMsIHRoaXMgbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoYXRcbiAgICAvLyBBbHNvLCB3aGVuIGRhdGFsYWJlbHMgZXhjZWVkcyB0aGUgZHJhd2FibGUgYXJlYSBhbmQgZ2V0IGNsaXBwZWQgb2ZmLCB3ZSBuZWVkIHRvIGFkanVzdCBhbmQgbW92ZSBzb21lIHBpeGVscyB0byBtYWtlIHRoZW0gdmlzaWJsZSBhZ2FpblxuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRGF0YUxhYmVscywgW3tcbiAgICAgIGtleTogXCJkYXRhTGFiZWxzQ29ycmVjdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFMYWJlbHNDb3JyZWN0aW9uKHgsIHksIHZhbCwgaSwgZGF0YVBvaW50SW5kZXgsIGFsd2F5c0RyYXdEYXRhTGFiZWwsIGZvbnRTaXplKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgZHJhd25leHRMYWJlbCA9IGZhbHNlOyAvL1xuXG4gICAgICAgIHZhciB0ZXh0UmVjdHMgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModmFsLCBmb250U2l6ZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRleHRSZWN0cy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleHRSZWN0cy5oZWlnaHQ7XG4gICAgICAgIGlmICh5IDwgMCkgeSA9IDA7XG4gICAgICAgIGlmICh5ID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQgKyBoZWlnaHQpIHkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGhlaWdodCAvIDI7IC8vIGZpcnN0IHZhbHVlIGluIHNlcmllcywgc28gcHVzaCBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmRhdGFMYWJlbHNSZWN0c1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0gPSBbXTsgLy8gdGhlbiBzdGFydCBwdXNoaW5nIGFjdHVhbCByZWN0cyBpbiB0aGF0IHN1Yi1hcnJheVxuXG4gICAgICAgIHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ucHVzaCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbiA9IHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIGxhc3REcmF3bkluZGV4ID0gdHlwZW9mIHcuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXSAhPT0gJ3VuZGVmaW5lZCcgPyB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV1bdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldLmxlbmd0aCAtIDFdIDogMDtcblxuICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV1bbGVuXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgbGFzdERhdGFMYWJlbFJlY3QgPSB3Lmdsb2JhbHMuZGF0YUxhYmVsc1JlY3RzW2ldW2xhc3REcmF3bkluZGV4XTtcblxuICAgICAgICAgIGlmICggLy8gbmV4dCBsYWJlbCBmb3J3YXJkIGFuZCB4IG5vdCBpbnRlcnNlY3RpbmdcbiAgICAgICAgICB4ID4gbGFzdERhdGFMYWJlbFJlY3QueCArIGxhc3REYXRhTGFiZWxSZWN0LndpZHRoIHx8IHkgPiBsYXN0RGF0YUxhYmVsUmVjdC55ICsgbGFzdERhdGFMYWJlbFJlY3QuaGVpZ2h0IHx8IHkgKyBoZWlnaHQgPCBsYXN0RGF0YUxhYmVsUmVjdC55IHx8IHggKyB3aWR0aCA8IGxhc3REYXRhTGFiZWxSZWN0LnggLy8gbmV4dCBsYWJlbCBpcyBnb2luZyB0byBiZSBkcmF3biBiYWNrd2FyZHNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHRoZSAyIGluZGV4ZXMgZG9uJ3Qgb3ZlcnJpZGUsIHNvIE9LIHRvIGRyYXcgbmV4dCBsYWJlbFxuICAgICAgICAgICAgZHJhd25leHRMYWJlbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFQb2ludEluZGV4ID09PSAwIHx8IGFsd2F5c0RyYXdEYXRhTGFiZWwpIHtcbiAgICAgICAgICBkcmF3bmV4dExhYmVsID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRleHRSZWN0czogdGV4dFJlY3RzLFxuICAgICAgICAgIGRyYXduZXh0TGFiZWw6IGRyYXduZXh0TGFiZWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0RhdGFMYWJlbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdEYXRhTGFiZWwoX3JlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgICAgcG9zID0gX3JlZi5wb3MsXG4gICAgICAgICAgICBpID0gX3JlZi5pLFxuICAgICAgICAgICAgaiA9IF9yZWYuaixcbiAgICAgICAgICAgIGlzUmFuZ2VTdGFydCA9IF9yZWYuaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHZvaWQgMCA/IDIgOiBfcmVmJHN0cm9rZVdpZHRoO1xuICAgICAgICAvLyB0aGlzIG1ldGhvZCBoYW5kbGVzIGxpbmUsIGFyZWEsIGJ1YmJsZSwgc2NhdHRlciBjaGFydHMgYXMgdGhvc2UgY2hhcnRzIGNvbnRhaW5zIG1hcmtlcnMvcG9pbnRzIHdoaWNoIGhhdmUgcHJlLWRlZmluZWQgeC95IHBvc2l0aW9uc1xuICAgICAgICAvLyBhbGwgb3RoZXIgY2hhcnRzIGxpa2UgcmFkYXIgLyBiYXJzIC8gaGVhdG1hcHMgd2lsbCBkZWZpbmUgdGhlaXIgb3duIGRyYXdEYXRhTGFiZWwgcm91dGluZVxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGRhdGFMYWJlbHNDb25maWcgPSB3LmNvbmZpZy5kYXRhTGFiZWxzO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gajtcbiAgICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBudWxsO1xuXG4gICAgICAgIGlmICghZGF0YUxhYmVsc0NvbmZpZy5lbmFibGVkIHx8ICFBcnJheS5pc0FycmF5KHBvcy54KSkge1xuICAgICAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YS1sYWJlbHMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgcG9zLngubGVuZ3RoOyBxKyspIHtcbiAgICAgICAgICB4ID0gcG9zLnhbcV0gKyBkYXRhTGFiZWxzQ29uZmlnLm9mZnNldFg7XG4gICAgICAgICAgeSA9IHBvcy55W3FdICsgZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRZICsgc3Ryb2tlV2lkdGg7XG5cbiAgICAgICAgICBpZiAoIWlzTmFOKHgpKSB7XG4gICAgICAgICAgICAvLyBhIHNtYWxsIGhhY2sgYXMgd2UgaGF2ZSAyIHBvaW50cyBmb3IgdGhlIGZpcnN0IHZhbCB0byBjb25uZWN0IGl0XG4gICAgICAgICAgICBpZiAoaiA9PT0gMSAmJiBxID09PSAwKSBkYXRhUG9pbnRJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoaiA9PT0gMSAmJiBxID09PSAxKSBkYXRhUG9pbnRJbmRleCA9IDE7XG4gICAgICAgICAgICB2YXIgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXVtkYXRhUG9pbnRJbmRleF07XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAncmFuZ2VBcmVhJykge1xuICAgICAgICAgICAgICBpZiAoaXNSYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlU3RhcnRbaV1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZUVuZFtpXVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHQgPSAnJztcblxuICAgICAgICAgICAgdmFyIGdldFRleHQgPSBmdW5jdGlvbiBnZXRUZXh0KHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHcuY29uZmlnLmRhdGFMYWJlbHMuZm9ybWF0dGVyKHYsIHtcbiAgICAgICAgICAgICAgICBjdHg6IF90aGlzLmN0eCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYnViYmxlJykge1xuICAgICAgICAgICAgICB2YWwgPSB3Lmdsb2JhbHMuc2VyaWVzWltpXVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgICAgIHRleHQgPSBnZXRUZXh0KHZhbCk7XG4gICAgICAgICAgICAgIHkgPSBwb3MueVtxXTtcbiAgICAgICAgICAgICAgdmFyIHNjYXR0ZXIgPSBuZXcgU2NhdHRlcih0aGlzLmN0eCk7XG4gICAgICAgICAgICAgIHZhciBjZW50ZXJUZXh0SW5CdWJibGVDb29yZHMgPSBzY2F0dGVyLmNlbnRlclRleHRJbkJ1YmJsZSh5LCBpLCBkYXRhUG9pbnRJbmRleCk7XG4gICAgICAgICAgICAgIHkgPSBjZW50ZXJUZXh0SW5CdWJibGVDb29yZHMueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBnZXRUZXh0KHZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wbG90RGF0YUxhYmVsc1RleHQoe1xuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICBqOiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgcGFyZW50OiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgICBvZmZzZXRDb3JyZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiB3LmNvbmZpZy5kYXRhTGFiZWxzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxEYXRhTGFiZWxzV3JhcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGxvdERhdGFMYWJlbHNUZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGxvdERhdGFMYWJlbHNUZXh0KG9wdHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB4ID0gb3B0cy54LFxuICAgICAgICAgICAgeSA9IG9wdHMueSxcbiAgICAgICAgICAgIGkgPSBvcHRzLmksXG4gICAgICAgICAgICBqID0gb3B0cy5qLFxuICAgICAgICAgICAgdGV4dCA9IG9wdHMudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSBvcHRzLnRleHRBbmNob3IsXG4gICAgICAgICAgICBmb250U2l6ZSA9IG9wdHMuZm9udFNpemUsXG4gICAgICAgICAgICBwYXJlbnQgPSBvcHRzLnBhcmVudCxcbiAgICAgICAgICAgIGRhdGFMYWJlbHNDb25maWcgPSBvcHRzLmRhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgICBjb2xvciA9IG9wdHMuY29sb3IsXG4gICAgICAgICAgICBhbHdheXNEcmF3RGF0YUxhYmVsID0gb3B0cy5hbHdheXNEcmF3RGF0YUxhYmVsLFxuICAgICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbiA9IG9wdHMub2Zmc2V0Q29ycmVjdGlvbjtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5kYXRhTGFiZWxzLmVuYWJsZWRPblNlcmllcykpIHtcbiAgICAgICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkT25TZXJpZXMuaW5kZXhPZihpKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29ycmVjdGVkTGFiZWxzID0ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBkcmF3bmV4dExhYmVsOiB0cnVlLFxuICAgICAgICAgIHRleHRSZWN0czogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvZmZzZXRDb3JyZWN0aW9uKSB7XG4gICAgICAgICAgY29ycmVjdGVkTGFiZWxzID0gdGhpcy5kYXRhTGFiZWxzQ29ycmVjdGlvbih4LCB5LCB0ZXh0LCBpLCBqLCBhbHdheXNEcmF3RGF0YUxhYmVsLCBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplLCAxMCkpO1xuICAgICAgICB9IC8vIHdoZW4gem9vbWVkLCB3ZSBkb24ndCBuZWVkIHRvIGNvcnJlY3QgbGFiZWxzIG9mZnNldHMsXG4gICAgICAgIC8vIGJ1dCBpZiBub3JtYWxseSwgbGFiZWxzIGdldCBjcm9wcGVkLCBjb3JyZWN0IHRoZW1cblxuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLnpvb21lZCkge1xuICAgICAgICAgIHggPSBjb3JyZWN0ZWRMYWJlbHMueDtcbiAgICAgICAgICB5ID0gY29ycmVjdGVkTGFiZWxzLnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29ycmVjdGVkTGFiZWxzLnRleHRSZWN0cykge1xuICAgICAgICAgIC8vIGZpeGVzICMyMjY0XG4gICAgICAgICAgaWYgKHggPCAtMTAgLSBjb3JyZWN0ZWRMYWJlbHMudGV4dFJlY3RzLndpZHRoIHx8IHggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgY29ycmVjdGVkTGFiZWxzLnRleHRSZWN0cy53aWR0aCArIDEwKSB7XG4gICAgICAgICAgICAvLyBkYXRhbGFiZWxzIGZhbGwgb3V0c2lkZSBkcmF3aW5nIGFyZWEsIHNvIGRyYXcgYSBibGFuayBsYWJlbFxuICAgICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhTGFiZWxDb2xvciA9IHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9yc1tpXTtcblxuICAgICAgICBpZiAoKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYW5nZUJhcicpICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCB8fCB3LmNvbmZpZy5kYXRhTGFiZWxzLmRpc3RyaWJ1dGVkKSB7XG4gICAgICAgICAgZGF0YUxhYmVsQ29sb3IgPSB3Lmdsb2JhbHMuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnNbal07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGFMYWJlbENvbG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGF0YUxhYmVsQ29sb3IgPSBkYXRhTGFiZWxDb2xvcih7XG4gICAgICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgZGF0YUxhYmVsQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZYID0gZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRYO1xuICAgICAgICB2YXIgb2ZmWSA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WTtcblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJykge1xuICAgICAgICAgIC8vIGZvciBjZXJ0YWluIGNoYXJ0IHR5cGVzLCB3ZSBoYW5kbGUgb2Zmc2V0cyB3aGlsZSBjYWxjdWxhdGluZyBkYXRhbGFiZWxzIHBvc1xuICAgICAgICAgIC8vIHdoeT8gYmVjYXVzZSBiYXJzL2NvbHVtbiBtYXkgaGF2ZSBuZWdhdGl2ZSB2YWx1ZXMgYW5kIGJhc2VkIG9uIHRoYXRcbiAgICAgICAgICAvLyBvZmZzZXRzIGJlY29tZXMgcmV2ZXJzZWRcbiAgICAgICAgICBvZmZYID0gMDtcbiAgICAgICAgICBvZmZZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3JyZWN0ZWRMYWJlbHMuZHJhd25leHRMYWJlbCkge1xuICAgICAgICAgIHZhciBkYXRhTGFiZWxUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQoZGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250U2l6ZSwgMTApLFxuICAgICAgICAgICAgeDogeCArIG9mZlgsXG4gICAgICAgICAgICB5OiB5ICsgb2ZmWSxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogZGF0YUxhYmVsQ29sb3IsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yIHx8IGRhdGFMYWJlbHNDb25maWcudGV4dEFuY2hvcixcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUgfHwgZGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udFdlaWdodCB8fCAnbm9ybWFsJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRhdGFMYWJlbFRleHQuYXR0cih7XG4gICAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVsJyxcbiAgICAgICAgICAgIGN4OiB4LFxuICAgICAgICAgICAgY3k6IHlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHRleHRTaGFkb3cgPSBkYXRhTGFiZWxzQ29uZmlnLmRyb3BTaGFkb3c7XG4gICAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhkYXRhTGFiZWxUZXh0LCB0ZXh0U2hhZG93KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnQuYWRkKGRhdGFMYWJlbFRleHQpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV0gPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV0ucHVzaChqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRCYWNrZ3JvdW5kVG9EYXRhTGFiZWxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCYWNrZ3JvdW5kVG9EYXRhTGFiZWwoZWwsIGNvb3Jkcykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGJDbmYgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmJhY2tncm91bmQ7XG4gICAgICAgIHZhciBwYWRkaW5nSCA9IGJDbmYucGFkZGluZztcbiAgICAgICAgdmFyIHBhZGRpbmdWID0gYkNuZi5wYWRkaW5nIC8gMjtcbiAgICAgICAgdmFyIHdpZHRoID0gY29vcmRzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29vcmRzLmhlaWdodDtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGVsUmVjdCA9IGdyYXBoaWNzLmRyYXdSZWN0KGNvb3Jkcy54IC0gcGFkZGluZ0gsIGNvb3Jkcy55IC0gcGFkZGluZ1YgLyAyLCB3aWR0aCArIHBhZGRpbmdIICogMiwgaGVpZ2h0ICsgcGFkZGluZ1YsIGJDbmYuYm9yZGVyUmFkaXVzLCB3LmNvbmZpZy5jaGFydC5iYWNrZ3JvdW5kID09PSAndHJhbnNwYXJlbnQnID8gJyNmZmYnIDogdy5jb25maWcuY2hhcnQuYmFja2dyb3VuZCwgYkNuZi5vcGFjaXR5LCBiQ25mLmJvcmRlcldpZHRoLCBiQ25mLmJvcmRlckNvbG9yKTtcblxuICAgICAgICBpZiAoYkNuZi5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZWxSZWN0LCBiQ25mLmRyb3BTaGFkb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsUmVjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGF0YUxhYmVsc0JhY2tncm91bmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhTGFiZWxzQmFja2dyb3VuZCgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYnViYmxlJykgcmV0dXJuO1xuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtZGF0YWxhYmVscyB0ZXh0Jyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbERhdGFMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWwgPSBlbERhdGFMYWJlbHNbaV07XG4gICAgICAgICAgdmFyIGNvb3JkcyA9IGVsLmdldEJCb3goKTtcbiAgICAgICAgICB2YXIgZWxSZWN0ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjb29yZHMud2lkdGggJiYgY29vcmRzLmhlaWdodCkge1xuICAgICAgICAgICAgZWxSZWN0ID0gdGhpcy5hZGRCYWNrZ3JvdW5kVG9EYXRhTGFiZWwoZWwsIGNvb3Jkcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVsUmVjdCkge1xuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxSZWN0Lm5vZGUsIGVsKTtcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kID0gZWwuZ2V0QXR0cmlidXRlKCdmaWxsJyk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQW5pbSA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZCAmJiAhdy5nbG9iYWxzLnJlc2l6ZWQgJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZDtcblxuICAgICAgICAgICAgaWYgKHNob3VsZEFuaW0pIHtcbiAgICAgICAgICAgICAgZWxSZWN0LmFuaW1hdGUoKS5hdHRyKHtcbiAgICAgICAgICAgICAgICBmaWxsOiBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxSZWN0LmF0dHIoe1xuICAgICAgICAgICAgICAgIGZpbGw6IGJhY2tncm91bmRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHcuY29uZmlnLmRhdGFMYWJlbHMuYmFja2dyb3VuZC5mb3JlQ29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJicmluZ0ZvcndhcmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBicmluZ0ZvcndhcmQoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzTm9kZXMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1kYXRhbGFiZWxzJyk7XG4gICAgICAgIHZhciBlbFNlcmllcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzOmxhc3QtY2hpbGQnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsRGF0YUxhYmVsc05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVsU2VyaWVzKSB7XG4gICAgICAgICAgICBlbFNlcmllcy5pbnNlcnRCZWZvcmUoZWxEYXRhTGFiZWxzTm9kZXNbaV0sIGVsU2VyaWVzLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0YUxhYmVscztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIFNlcmllcyBDbGFzcyBmb3IgaW50ZXJhY3Rpb24gd2l0aCB0aGUgU2VyaWVzIG9mIHRoZSBjaGFydC5cbiAgICpcbiAgICogQG1vZHVsZSBTZXJpZXNcbiAgICoqL1xuXG4gIHZhciBTZXJpZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmllcyhjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJpZXMpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdGhpcy5sZWdlbmRJbmFjdGl2ZUNsYXNzID0gJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTZXJpZXMsIFt7XG4gICAgICBrZXk6IFwiZ2V0QWxsU2VyaWVzRWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsU2VyaWVzRWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYXBleGNoYXJ0cy1zZXJpZXNcIik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFNlcmllc0J5TmFtZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc0J5TmFtZShzZXJpZXNOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1pbm5lciAuYXBleGNoYXJ0cy1zZXJpZXNbc2VyaWVzTmFtZT0nXCIuY29uY2F0KFV0aWxzJDEuZXNjYXBlU3RyaW5nKHNlcmllc05hbWUpLCBcIiddXCIpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNTZXJpZXNIaWRkZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Nlcmllc0hpZGRlbihzZXJpZXNOYW1lKSB7XG4gICAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRTZXJpZXNCeU5hbWUoc2VyaWVzTmFtZSk7XG4gICAgICAgIHZhciByZWFsSW5kZXggPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSwgMTApO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNIaWRkZW46IGlzSGlkZGVuLFxuICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb2xsYXBzZWRDbGFzc1RvU2VyaWVzKGVsU2VyaWVzLCBpbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlT25BbGxDb2xsYXBzZWRTZXJpZXMoc2VyaWVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgY3MgPSAwOyBjcyA8IHNlcmllcy5sZW5ndGg7IGNzKyspIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNbY3NdLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICBlbFNlcmllcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtc2VyaWVzLWNvbGxhcHNlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGVPbkFsbENvbGxhcHNlZFNlcmllcyh3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzKTtcbiAgICAgICAgaXRlcmF0ZU9uQWxsQ29sbGFwc2VkU2VyaWVzKHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b2dnbGVTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVTZXJpZXMoc2VyaWVzTmFtZSkge1xuICAgICAgICB2YXIgaXNTZXJpZXNIaWRkZW4gPSB0aGlzLmlzU2VyaWVzSGlkZGVuKHNlcmllc05hbWUpO1xuICAgICAgICB0aGlzLmN0eC5sZWdlbmQubGVnZW5kSGVscGVycy50b2dnbGVEYXRhU2VyaWVzKGlzU2VyaWVzSGlkZGVuLnJlYWxJbmRleCwgaXNTZXJpZXNIaWRkZW4uaXNIaWRkZW4pO1xuICAgICAgICByZXR1cm4gaXNTZXJpZXNIaWRkZW4uaXNIaWRkZW47XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNob3dTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93U2VyaWVzKHNlcmllc05hbWUpIHtcbiAgICAgICAgdmFyIGlzU2VyaWVzSGlkZGVuID0gdGhpcy5pc1Nlcmllc0hpZGRlbihzZXJpZXNOYW1lKTtcblxuICAgICAgICBpZiAoaXNTZXJpZXNIaWRkZW4uaXNIaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLmN0eC5sZWdlbmQubGVnZW5kSGVscGVycy50b2dnbGVEYXRhU2VyaWVzKGlzU2VyaWVzSGlkZGVuLnJlYWxJbmRleCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGlkZVNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVTZXJpZXMoc2VyaWVzTmFtZSkge1xuICAgICAgICB2YXIgaXNTZXJpZXNIaWRkZW4gPSB0aGlzLmlzU2VyaWVzSGlkZGVuKHNlcmllc05hbWUpO1xuXG4gICAgICAgIGlmICghaXNTZXJpZXNIaWRkZW4uaXNIaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLmN0eC5sZWdlbmQubGVnZW5kSGVscGVycy50b2dnbGVEYXRhU2VyaWVzKGlzU2VyaWVzSGlkZGVuLnJlYWxJbmRleCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc2V0U2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTZXJpZXMoKSB7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVDaGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgICAgdmFyIHNob3VsZFJlc2V0Wm9vbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgdmFyIHNob3VsZFJlc2V0Q29sbGFwc2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHNlcmllcyA9IFV0aWxzJDEuY2xvbmUody5nbG9iYWxzLmluaXRpYWxTZXJpZXMpO1xuICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocyA9IFtdO1xuXG4gICAgICAgIGlmIChzaG91bGRSZXNldENvbGxhcHNlZCkge1xuICAgICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMgPSBbXTtcbiAgICAgICAgICB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzID0gW107XG4gICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMgPSBbXTtcbiAgICAgICAgICB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcmllcyA9IHRoaXMuZW1wdHlDb2xsYXBzZWRTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuY29uZmlnLnNlcmllcyA9IHNlcmllcztcblxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ2hhcnQpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkUmVzZXRab29tKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuem9vbWVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmN0eC51cGRhdGVIZWxwZXJzLnJldmVydERlZmF1bHRBeGlzTWluTWF4KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jdHgudXBkYXRlSGVscGVycy5fdXBkYXRlU2VyaWVzKHNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVtcHR5Q29sbGFwc2VkU2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW1wdHlDb2xsYXBzZWRTZXJpZXMoc2VyaWVzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgPiAtMSkge1xuICAgICAgICAgICAgc2VyaWVzW2ldLmRhdGEgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b2dnbGVTZXJpZXNPbkhvdmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlU2VyaWVzT25Ib3ZlcihlLCB0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHRhcmdldEVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGFsbFNlcmllc0VscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXMsIC5hcGV4Y2hhcnRzLWRhdGFsYWJlbHNcIik7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICB2YXIgc2VyaWVzQ250ID0gcGFyc2VJbnQodGFyZ2V0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpLCAxMCkgLSAxO1xuICAgICAgICAgIHZhciBzZXJpZXNFbCA9IG51bGw7XG4gICAgICAgICAgdmFyIGRhdGFMYWJlbEVsID0gbnVsbDtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkaWFsQmFyJykge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICAgIHNlcmllc0VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChzZXJpZXNDbnQsIFwiJ11cIikpO1xuICAgICAgICAgICAgICBkYXRhTGFiZWxFbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1kYXRhbGFiZWxzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHNlcmllc0NudCwgXCInXVwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIi5jb25jYXQoc2VyaWVzQ250ICsgMSwgXCInXVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmllc0VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChzZXJpZXNDbnQgKyAxLCBcIiddIHBhdGhcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHNlID0gMDsgc2UgPCBhbGxTZXJpZXNFbHMubGVuZ3RoOyBzZSsrKSB7XG4gICAgICAgICAgICBhbGxTZXJpZXNFbHNbc2VdLmNsYXNzTGlzdC5hZGQodGhpcy5sZWdlbmRJbmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VyaWVzRWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdy5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAgICAgc2VyaWVzRWwucGFyZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMubGVnZW5kSW5hY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlcmllc0VsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5sZWdlbmRJbmFjdGl2ZUNsYXNzKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFMYWJlbEVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRhdGFMYWJlbEVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5sZWdlbmRJbmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgX3NlID0gMDsgX3NlIDwgYWxsU2VyaWVzRWxzLmxlbmd0aDsgX3NlKyspIHtcbiAgICAgICAgICAgIGFsbFNlcmllc0Vsc1tfc2VdLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5sZWdlbmRJbmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGlnaGxpZ2h0UmFuZ2VJblNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZ2hsaWdodFJhbmdlSW5TZXJpZXMoZSwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgYWxsSGVhdE1hcEVsZW1lbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYXBleGNoYXJ0cy1oZWF0bWFwLXJlY3QnKTtcblxuICAgICAgICB2YXIgYWN0aXZlSW5hY3RpdmUgPSBmdW5jdGlvbiBhY3RpdmVJbmFjdGl2ZShhY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEhlYXRNYXBFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmNsYXNzTGlzdFthY3Rpb25dKF90aGlzLmxlZ2VuZEluYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVtb3ZlSW5hY3RpdmVDbGFzc0Zyb21Ib3ZlcmVkUmFuZ2UgPSBmdW5jdGlvbiByZW1vdmVJbmFjdGl2ZUNsYXNzRnJvbUhvdmVyZWRSYW5nZShyYW5nZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSGVhdE1hcEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gcGFyc2VJbnQoYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmdldEF0dHJpYnV0ZSgndmFsJyksIDEwKTtcblxuICAgICAgICAgICAgaWYgKHZhbCA+PSByYW5nZS5mcm9tICYmIHZhbCA8PSByYW5nZS50bykge1xuICAgICAgICAgICAgICBhbGxIZWF0TWFwRWxlbWVudHNbaV0uY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5sZWdlbmRJbmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICB2YXIgc2VyaWVzQ250ID0gcGFyc2VJbnQodGFyZ2V0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpLCAxMCkgLSAxO1xuICAgICAgICAgIGFjdGl2ZUluYWN0aXZlKCdhZGQnKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5oZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzW3Nlcmllc0NudF07XG4gICAgICAgICAgcmVtb3ZlSW5hY3RpdmVDbGFzc0Zyb21Ib3ZlcmVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgIGFjdGl2ZUluYWN0aXZlKCdyZW1vdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRBY3RpdmVDb25maWdTZXJpZXNJbmRleFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUNvbmZpZ1Nlcmllc0luZGV4KCkge1xuICAgICAgICB2YXIgb3JkZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdhc2MnO1xuICAgICAgICB2YXIgY2hhcnRUeXBlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSAwO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIGFjdGl2ZSBzZXJpZXMgZmxhZyBpcyByZXF1aXJlZCB0byBrbm93IGlmIHVzZXIgaGFzIG5vdCBkZWFjdGl2YXRlZCB2aWEgbGVnZW5kIGNsaWNrXG4gICAgICAgICAgdmFyIGFjdGl2ZVNlcmllc0luZGV4ID0gdy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjaGVja0NoYXJ0VHlwZSA9IGZ1bmN0aW9uIGNoZWNrQ2hhcnRUeXBlKCkge1xuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZXMubGVuZ3RoID09PSAwIHx8IGNoYXJ0VHlwZXMubGVuZ3RoICYmIGNoYXJ0VHlwZXMuaW5kZXhPZih3LmNvbmZpZy5zZXJpZXNbaW5kZXhdLnR5cGUpID4gLTE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBoYXNEYXRhID0gcy5kYXRhICYmIHMuZGF0YS5sZW5ndGggPiAwICYmIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgICAgICAgICAgIHJldHVybiBoYXNEYXRhICYmIGNoZWNrQ2hhcnRUeXBlKCkgPyBpbmRleCA6IC0xO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZm9yICh2YXIgYSA9IG9yZGVyID09PSAnYXNjJyA/IDAgOiBhY3RpdmVTZXJpZXNJbmRleC5sZW5ndGggLSAxOyBvcmRlciA9PT0gJ2FzYycgPyBhIDwgYWN0aXZlU2VyaWVzSW5kZXgubGVuZ3RoIDogYSA+PSAwOyBvcmRlciA9PT0gJ2FzYycgPyBhKysgOiBhLS0pIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVTZXJpZXNJbmRleFthXSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBhY3RpdmVTZXJpZXNJbmRleFthXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGl2ZUluZGV4O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRCYXJTZXJpZXNJbmRpY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFyU2VyaWVzSW5kaWNlcygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb21ib0NoYXJ0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLncuY29uZmlnLnNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnR5cGUgPT09ICdiYXInIHx8IHMudHlwZSA9PT0gJ2NvbHVtbicgPyBpIDogLTE7XG4gICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAhPT0gLTE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy53LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQcmV2aW91c1BhdGhzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJldmlvdXNQYXRocygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcHVzaFBhdGhzKHNlcmllc0VscywgaSwgdHlwZSkge1xuICAgICAgICAgIHZhciBwYXRocyA9IHNlcmllc0Vsc1tpXS5jaGlsZE5vZGVzO1xuICAgICAgICAgIHZhciBkQXJyID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBhdGhzOiBbXSxcbiAgICAgICAgICAgIHJlYWxJbmRleDogc2VyaWVzRWxzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhdGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGF0aHNbal0uaGFzQXR0cmlidXRlKCdwYXRoVG8nKSkge1xuICAgICAgICAgICAgICB2YXIgZCA9IHBhdGhzW2pdLmdldEF0dHJpYnV0ZSgncGF0aFRvJyk7XG4gICAgICAgICAgICAgIGRBcnIucGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZDogZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5wdXNoKGRBcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldFBhdGhzID0gZnVuY3Rpb24gZ2V0UGF0aHMoY2hhcnRUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQoY2hhcnRUeXBlLCBcIi1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzXCIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2hhcnRUeXBlcyA9IFsnbGluZScsICdhcmVhJywgJ2JhcicsICdyYW5nZWJhcicsICdyYW5nZUFyZWEnLCAnY2FuZGxlc3RpY2snLCAncmFkYXInXTtcbiAgICAgICAgY2hhcnRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdmFyIHBhdGhzID0gZ2V0UGF0aHModHlwZSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBwdXNoUGF0aHMocGF0aHMsIHAsIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUHJldkJ1YmJsZVNjYXR0ZXJQYXRocygnYnViYmxlJyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUHJldkJ1YmJsZVNjYXR0ZXJQYXRocygnc2NhdHRlcicpO1xuICAgICAgICB2YXIgaGVhdFRyZWVTZXJpZXMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KHcuY29uZmlnLmNoYXJ0LnR5cGUsIFwiIC5hcGV4Y2hhcnRzLXNlcmllc1wiKSk7XG5cbiAgICAgICAgaWYgKGhlYXRUcmVlU2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChoKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLVwiLmNvbmNhdCh3LmNvbmZpZy5jaGFydC50eXBlLCBcIiAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIikuY29uY2F0KGgsIFwiJ10gcmVjdFwiKSk7XG4gICAgICAgICAgICB2YXIgZEFyciA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGkpIHtcbiAgICAgICAgICAgICAgdmFyIGdldEF0dHIgPSBmdW5jdGlvbiBnZXRBdHRyKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzRWxzW2ldLmdldEF0dHJpYnV0ZSh4KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBwYXJzZUZsb2F0KGdldEF0dHIoJ3gnKSksXG4gICAgICAgICAgICAgICAgeTogcGFyc2VGbG9hdChnZXRBdHRyKCd5JykpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KGdldEF0dHIoJ3dpZHRoJykpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VGbG9hdChnZXRBdHRyKCdoZWlnaHQnKSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZEFyci5wdXNoKHtcbiAgICAgICAgICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICAgICAgICAgIGNvbG9yOiBzZXJpZXNFbHNbaV0uZ2V0QXR0cmlidXRlKCdjb2xvcicpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXNFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgX2xvb3AyKGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5wdXNoKGRBcnIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGhlYXRUcmVlU2VyaWVzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgICBfbG9vcChoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgLy8gZm9yIG5vbi1heGlzIGNoYXJ0cyAoaS5lLiwgY2lyY3VsYXIgY2hhcnRzLCBwYXRoRnJvbSBpcyBub3QgdXNhYmxlLiBXZSBuZWVkIHdob2xlIHNlcmllcylcbiAgICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocyA9IHcuZ2xvYmFscy5zZXJpZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlUHJldkJ1YmJsZVNjYXR0ZXJQYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVByZXZCdWJibGVTY2F0dGVyUGF0aHModHlwZSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzXCIpKTtcblxuICAgICAgICBpZiAocGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgcGF0aHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNFbHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIikuY29uY2F0KHMsIFwiJ10gY2lyY2xlXCIpKTtcbiAgICAgICAgICAgIHZhciBkQXJyID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGRBcnIucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogc2VyaWVzRWxzW2ldLmdldEF0dHJpYnV0ZSgnY3gnKSxcbiAgICAgICAgICAgICAgICB5OiBzZXJpZXNFbHNbaV0uZ2V0QXR0cmlidXRlKCdjeScpLFxuICAgICAgICAgICAgICAgIHI6IHNlcmllc0Vsc1tpXS5nZXRBdHRyaWJ1dGUoJ3InKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMucHVzaChkQXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYXJQcmV2aW91c1BhdGhzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJQcmV2aW91c1BhdGhzKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVOb0RhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVOb0RhdGEoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbm9EYXRhT3B0cyA9IHcuY29uZmlnLm5vRGF0YTtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKG1lLmN0eCk7XG4gICAgICAgIHZhciB4ID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC8gMjtcbiAgICAgICAgdmFyIHkgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgdy5nbG9iYWxzLm5vRGF0YSA9IHRydWU7XG4gICAgICAgIHcuZ2xvYmFscy5hbmltYXRpb25FbmRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG5vRGF0YU9wdHMuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHggPSAxMDtcbiAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgfSBlbHNlIGlmIChub0RhdGFPcHRzLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgeCA9IHcuZ2xvYmFscy5zdmdXaWR0aCAtIDEwO1xuICAgICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub0RhdGFPcHRzLnZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgeSA9IDUwO1xuICAgICAgICB9IGVsc2UgaWYgKG5vRGF0YU9wdHMudmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB5ID0gdy5nbG9iYWxzLnN2Z0hlaWdodCAtIDUwO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IHggKyBub0RhdGFPcHRzLm9mZnNldFg7XG4gICAgICAgIHkgPSB5ICsgcGFyc2VJbnQobm9EYXRhT3B0cy5zdHlsZS5mb250U2l6ZSwgMTApICsgMiArIG5vRGF0YU9wdHMub2Zmc2V0WTtcblxuICAgICAgICBpZiAobm9EYXRhT3B0cy50ZXh0ICE9PSB1bmRlZmluZWQgJiYgbm9EYXRhT3B0cy50ZXh0ICE9PSAnJykge1xuICAgICAgICAgIHZhciB0aXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHQ6IG5vRGF0YU9wdHMudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgICBmb250U2l6ZTogbm9EYXRhT3B0cy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IG5vRGF0YU9wdHMuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogbm9EYXRhT3B0cy5zdHlsZS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtdGV4dC1ub2RhdGEnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdy5nbG9iYWxzLmRvbS5QYXBlci5hZGQodGl0bGVUZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXaGVuIHVzZXIgY2xpY2tzIG9uIGxlZ2VuZHMsIHRoZSBjb2xsYXBzZWQgc2VyaWVzIGlzIGZpbGxlZCB3aXRoIFswLDAsMCwuLi4sMF1cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFsdGVyIHRoZSBzZXJpZXMnIGxlbmd0aCBhcyBpdCBpcyB1c2VkIGF0IG1hbnkgcGxhY2VzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TnVsbFNlcmllc1RvWmVyb1ZhbHVlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE51bGxTZXJpZXNUb1plcm9WYWx1ZXMoc2VyaWVzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGZvciAodmFyIHNsID0gMDsgc2wgPCBzZXJpZXMubGVuZ3RoOyBzbCsrKSB7XG4gICAgICAgICAgaWYgKHNlcmllc1tzbF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgc2VyaWVzW3NsXS5wdXNoKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXJpZXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhc0FsbFNlcmllc0VxdWFsWFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0FsbFNlcmllc0VxdWFsWCgpIHtcbiAgICAgICAgdmFyIGVxdWFsTGVuID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBmaWx0ZXJlZFNlclggPSB0aGlzLmZpbHRlcmVkU2VyaWVzWCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyZWRTZXJYLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGlmIChmaWx0ZXJlZFNlclhbaV1bMF0gIT09IGZpbHRlcmVkU2VyWFtpICsgMV1bMF0pIHtcbiAgICAgICAgICAgIGVxdWFsTGVuID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuYWxsU2VyaWVzSGFzRXF1YWxYID0gZXF1YWxMZW47XG4gICAgICAgIHJldHVybiBlcXVhbExlbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmlsdGVyZWRTZXJpZXNYXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyZWRTZXJpZXNYKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGZpbHRlcmVkU2VyaWVzWCA9IHcuZ2xvYmFscy5zZXJpZXNYLm1hcChmdW5jdGlvbiAoc2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHNlci5sZW5ndGggPiAwID8gc2VyIDogW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWRTZXJpZXNYO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTZXJpZXM7XG4gIH0oKTtcblxuICB2YXIgRGF0YSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YShjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMudHdvRFNlcmllcyA9IFtdO1xuICAgICAgdGhpcy50aHJlZURTZXJpZXMgPSBbXTtcbiAgICAgIHRoaXMudHdvRFNlcmllc1ggPSBbXTtcbiAgICAgIHRoaXMuc2VyaWVzR29hbHMgPSBbXTtcbiAgICAgIHRoaXMuY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGEsIFt7XG4gICAgICBrZXk6IFwiaXNNdWx0aUZvcm1hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzTXVsdGlGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9ybWF0WFkoKSB8fCB0aGlzLmlzRm9ybWF0MkRBcnJheSgpO1xuICAgICAgfSAvLyBnaXZlbiBmb3JtYXQgaXMgW3t4LCB5fSwge3gsIHl9XVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImlzRm9ybWF0WFlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zvcm1hdFhZKCkge1xuICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy53LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcbiAgICAgICAgdmFyIHNyID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2VyaWVzSW5kZXggPSBzci5nZXRBY3RpdmVDb25maWdTZXJpZXNJbmRleCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGEgIT09ICd1bmRlZmluZWQnICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhLmxlbmd0aCA+IDAgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0gIT09IG51bGwgJiYgdHlwZW9mIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdLnggIT09ICd1bmRlZmluZWQnICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZ2l2ZW4gZm9ybWF0IGlzIFtbeCwgeV0sIFt4LCB5XV1cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc0Zvcm1hdDJEQXJyYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zvcm1hdDJEQXJyYXkoKSB7XG4gICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLncuY29uZmlnLnNlcmllcy5zbGljZSgpO1xuICAgICAgICB2YXIgc3IgPSBuZXcgU2VyaWVzKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5hY3RpdmVTZXJpZXNJbmRleCA9IHNyLmdldEFjdGl2ZUNvbmZpZ1Nlcmllc0luZGV4KCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGEubGVuZ3RoID4gMCAmJiB0eXBlb2Ygc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0gIT09ICd1bmRlZmluZWQnICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdICE9PSBudWxsICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZUZvcm1hdDJEQXJyYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVGb3JtYXQyREFycmF5KHNlciwgaSkge1xuICAgICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBpc0JveFBsb3QgPSBjbmYuY2hhcnQudHlwZSA9PT0gJ2JveFBsb3QnIHx8IGNuZi5zZXJpZXNbaV0udHlwZSA9PT0gJ2JveFBsb3QnO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhW2pdWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VyW2ldLmRhdGFbal1bMV0pICYmIHNlcltpXS5kYXRhW2pdWzFdLmxlbmd0aCA9PT0gNCAmJiAhaXNCb3hQbG90KSB7XG4gICAgICAgICAgICAgIC8vIGNhbmRsZXN0aWNrIG5lc3RlZCBvaGxjIGZvcm1hdFxuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXMucHVzaChVdGlscyQxLnBhcnNlTnVtYmVyKHNlcltpXS5kYXRhW2pdWzFdWzNdKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcltpXS5kYXRhW2pdLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAgIC8vIGNhbmRsZXN0aWNrIG5vbi1uZXN0ZWQgb2hsYyBmb3JtYXRcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzLnB1c2goVXRpbHMkMS5wYXJzZU51bWJlcihzZXJbaV0uZGF0YVtqXVs0XSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzLnB1c2goVXRpbHMkMS5wYXJzZU51bWJlcihzZXJbaV0uZGF0YVtqXVsxXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5kYXRhRm9ybWF0WE51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgLy8gaWYgdGltZXN0YW1wcyBhcmUgcHJvdmlkZWQgYW5kIHhheGlzIHR5cGUgaXMgZGF0ZXRpbWUsXG4gICAgICAgICAgICB2YXIgdHMgPSBuZXcgRGF0ZShzZXJbaV0uZGF0YVtqXVswXSk7XG4gICAgICAgICAgICB0cyA9IG5ldyBEYXRlKHRzKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2godHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goc2VyW2ldLmRhdGFbal1bMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhW19qXVsyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMudGhyZWVEU2VyaWVzLnB1c2goc2VyW2ldLmRhdGFbX2pdWzJdKTtcbiAgICAgICAgICAgIGdsLmlzRGF0YVhZWiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZUZvcm1hdFhZXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRm9ybWF0WFkoc2VyLCBpKSB7XG4gICAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGFjdGl2ZUkgPSBpO1xuXG4gICAgICAgIGlmIChnbC5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgPiAtMSkge1xuICAgICAgICAgIC8vIGZpeCAjMzY4XG4gICAgICAgICAgYWN0aXZlSSA9IHRoaXMuYWN0aXZlU2VyaWVzSW5kZXg7XG4gICAgICAgIH0gLy8gZ2V0IHNlcmllc1xuXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2VyW2ldLmRhdGFbal0ueSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlcltpXS5kYXRhW2pdLnkpKSB7XG4gICAgICAgICAgICAgIHRoaXMudHdvRFNlcmllcy5wdXNoKFV0aWxzJDEucGFyc2VOdW1iZXIoc2VyW2ldLmRhdGFbal0ueVtzZXJbaV0uZGF0YVtqXS55Lmxlbmd0aCAtIDFdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXMucHVzaChVdGlscyQxLnBhcnNlTnVtYmVyKHNlcltpXS5kYXRhW2pdLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhW2pdLmdvYWxzICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheS5pc0FycmF5KHNlcltpXS5kYXRhW2pdLmdvYWxzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc0dvYWxzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0aGlzLnNlcmllc0dvYWxzW2ldID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2VyaWVzR29hbHNbaV0ucHVzaChzZXJbaV0uZGF0YVtqXS5nb2Fscyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXJpZXNHb2Fsc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXJpZXNHb2Fsc1tpXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlcmllc0dvYWxzW2ldLnB1c2gobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGdldCBzZXJpZXNYXG5cblxuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBzZXJbYWN0aXZlSV0uZGF0YS5sZW5ndGg7IF9qMisrKSB7XG4gICAgICAgICAgdmFyIGlzWFN0cmluZyA9IHR5cGVvZiBzZXJbYWN0aXZlSV0uZGF0YVtfajJdLnggPT09ICdzdHJpbmcnO1xuICAgICAgICAgIHZhciBpc1hBcnIgPSBBcnJheS5pc0FycmF5KHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCk7XG4gICAgICAgICAgdmFyIGlzWERhdGUgPSAhaXNYQXJyICYmICEhZHQuaXNWYWxpZERhdGUoc2VyW2FjdGl2ZUldLmRhdGFbX2oyXS54LnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgaWYgKGlzWFN0cmluZyB8fCBpc1hEYXRlKSB7XG4gICAgICAgICAgICAvLyB1c2VyIHN1cHBsaWVkICcwMS8wMS8yMDE3JyBvciBhIGRhdGUgc3RyaW5nIChhIEpTIGRhdGUgb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQpXG4gICAgICAgICAgICBpZiAoaXNYU3RyaW5nIHx8IGNuZi54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgICAgICAgdmFyIGlzUmFuZ2VDb2x1bW4gPSBnbC5pc0Jhckhvcml6b250YWwgJiYgZ2wuaXNSYW5nZURhdGE7XG5cbiAgICAgICAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnICYmICFpc1JhbmdlQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKGR0LnBhcnNlRGF0ZShzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhIGNhdGVnb3J5IGFuZCBub3QgYSBudW1lcmljIHggdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzLmZhbGxiYWNrVG9DYXRlZ29yeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCkgJiYgdGhpcy53LmNvbmZpZy54YXhpcy50eXBlICE9PSAnY2F0ZWdvcnknICYmIHR5cGVvZiBzZXJbYWN0aXZlSV0uZGF0YVtfajJdLnggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChkdC5wYXJzZURhdGUoc2VyW2FjdGl2ZUldLmRhdGFbX2oyXS54LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5kYXRhRm9ybWF0WE51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdsLmlzWE51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChwYXJzZUZsb2F0KHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1hBcnIpIHtcbiAgICAgICAgICAgIC8vIGEgbXVsdGlsaW5lIGxhYmVsIGRlc2NyaWJlZCBpbiBhcnJheSBmb3JtYXRcbiAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhIG51bWVyaWMgdmFsdWUgaW4geCBwcm9wZXJ0eVxuICAgICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICBnbC5kYXRhRm9ybWF0WE51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcltpXS5kYXRhWzBdICYmIHR5cGVvZiBzZXJbaV0uZGF0YVswXS56ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgc2VyW2ldLmRhdGEubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHRoaXMudGhyZWVEU2VyaWVzLnB1c2goc2VyW2ldLmRhdGFbdF0ueik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuaXNEYXRhWFlaID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVSYW5nZURhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSYW5nZURhdGEoc2VyLCBpKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgICB2YXIgcmFuZ2UgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5pc0Zvcm1hdDJEQXJyYXkoKSkge1xuICAgICAgICAgIHJhbmdlID0gdGhpcy5oYW5kbGVSYW5nZURhdGFGb3JtYXQoJ2FycmF5Jywgc2VyLCBpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRm9ybWF0WFkoKSkge1xuICAgICAgICAgIHJhbmdlID0gdGhpcy5oYW5kbGVSYW5nZURhdGFGb3JtYXQoJ3h5Jywgc2VyLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnNlcmllc1JhbmdlU3RhcnQucHVzaChyYW5nZS5zdGFydCk7XG4gICAgICAgIGdsLnNlcmllc1JhbmdlRW5kLnB1c2gocmFuZ2UuZW5kKTtcbiAgICAgICAgZ2wuc2VyaWVzUmFuZ2UucHVzaChyYW5nZS5yYW5nZVVuaXF1ZXMpOyAvLyBjaGVjayBmb3Igb3ZlcmxhcHMgdG8gYXZvaWQgY2xhc2hlcyBpbiBhIHRpbWVsaW5lIGNoYXJ0XG5cbiAgICAgICAgZ2wuc2VyaWVzUmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoc3IsIHNpKSB7XG4gICAgICAgICAgaWYgKHNyKSB7XG4gICAgICAgICAgICBzci5mb3JFYWNoKGZ1bmN0aW9uIChzYXJyLCBzYXJyaSkge1xuICAgICAgICAgICAgICBzYXJyLnkuZm9yRWFjaChmdW5jdGlvbiAoYXJyLCBhcnJpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc3JpID0gMDsgc3JpIDwgc2Fyci55Lmxlbmd0aDsgc3JpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJpICE9PSBzcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlMXkxID0gYXJyLnkxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UxeTIgPSBhcnIueTI7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZTJ5MSA9IHNhcnIueVtzcmldLnkxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UyeTIgPSBzYXJyLnlbc3JpXS55MjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UxeTEgPD0gcmFuZ2UyeTIgJiYgcmFuZ2UyeTEgPD0gcmFuZ2UxeTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Fyci5vdmVybGFwcy5pbmRleE9mKGFyci5yYW5nZU5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Fyci5vdmVybGFwcy5wdXNoKGFyci5yYW5nZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzYXJyLm92ZXJsYXBzLmluZGV4T2Yoc2Fyci55W3NyaV0ucmFuZ2VOYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhcnIub3ZlcmxhcHMucHVzaChzYXJyLnlbc3JpXS5yYW5nZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZUNhbmRsZVN0aWNrQm94RGF0YVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNhbmRsZVN0aWNrQm94RGF0YShzZXIsIGkpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBvaGxjID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuaXNGb3JtYXQyREFycmF5KCkpIHtcbiAgICAgICAgICBvaGxjID0gdGhpcy5oYW5kbGVDYW5kbGVTdGlja0JveERhdGFGb3JtYXQoJ2FycmF5Jywgc2VyLCBpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRm9ybWF0WFkoKSkge1xuICAgICAgICAgIG9obGMgPSB0aGlzLmhhbmRsZUNhbmRsZVN0aWNrQm94RGF0YUZvcm1hdCgneHknLCBzZXIsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuc2VyaWVzQ2FuZGxlT1tpXSA9IG9obGMubztcbiAgICAgICAgZ2wuc2VyaWVzQ2FuZGxlSFtpXSA9IG9obGMuaDtcbiAgICAgICAgZ2wuc2VyaWVzQ2FuZGxlTVtpXSA9IG9obGMubTtcbiAgICAgICAgZ2wuc2VyaWVzQ2FuZGxlTFtpXSA9IG9obGMubDtcbiAgICAgICAgZ2wuc2VyaWVzQ2FuZGxlQ1tpXSA9IG9obGMuYztcbiAgICAgICAgcmV0dXJuIG9obGM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZVJhbmdlRGF0YUZvcm1hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJhbmdlRGF0YUZvcm1hdChmb3JtYXQsIHNlciwgaSkge1xuICAgICAgICB2YXIgcmFuZ2VTdGFydCA9IFtdO1xuICAgICAgICB2YXIgcmFuZ2VFbmQgPSBbXTtcbiAgICAgICAgdmFyIHVuaXF1ZUtleXMgPSBzZXJbaV0uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHRoaW5nLCBpbmRleCwgc2VsZikge1xuICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gc2VsZi5maW5kSW5kZXgoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnggPT09IHRoaW5nLng7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAociwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogci54LFxuICAgICAgICAgICAgb3ZlcmxhcHM6IFtdLFxuICAgICAgICAgICAgeTogW11cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZm9ybWF0ID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VyW2ldLmRhdGFbal0pKSB7XG4gICAgICAgICAgICAgIHJhbmdlU3RhcnQucHVzaChzZXJbaV0uZGF0YVtqXVsxXVswXSk7XG4gICAgICAgICAgICAgIHJhbmdlRW5kLnB1c2goc2VyW2ldLmRhdGFbal1bMV1bMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmFuZ2VTdGFydC5wdXNoKHNlcltpXS5kYXRhW2pdKTtcbiAgICAgICAgICAgICAgcmFuZ2VFbmQucHVzaChzZXJbaV0uZGF0YVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3h5Jykge1xuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9qMykge1xuICAgICAgICAgICAgdmFyIGlzRGF0YVBvaW50MkQgPSBBcnJheS5pc0FycmF5KHNlcltpXS5kYXRhW19qM10ueSk7XG4gICAgICAgICAgICB2YXIgaWQgPSBVdGlscyQxLnJhbmRvbUlkKCk7XG4gICAgICAgICAgICB2YXIgeCA9IHNlcltpXS5kYXRhW19qM10ueDtcbiAgICAgICAgICAgIHZhciB5ID0ge1xuICAgICAgICAgICAgICB5MTogaXNEYXRhUG9pbnQyRCA/IHNlcltpXS5kYXRhW19qM10ueVswXSA6IHNlcltpXS5kYXRhW19qM10ueSxcbiAgICAgICAgICAgICAgeTI6IGlzRGF0YVBvaW50MkQgPyBzZXJbaV0uZGF0YVtfajNdLnlbMV0gOiBzZXJbaV0uZGF0YVtfajNdLnksXG4gICAgICAgICAgICAgIHJhbmdlTmFtZTogaWRcbiAgICAgICAgICAgIH07IC8vIENBVVRJT046IG11dGF0aW5nIGNvbmZpZyBvYmplY3QgYnkgYWRkaW5nIGEgbmV3IHByb3BlcnR5XG4gICAgICAgICAgICAvLyBUT0RPOiBBcyB0aGlzIGlzIHNwZWNpZmljYWxseSBmb3IgdGltZWxpbmUgcmFuZ2ViYXIgY2hhcnRzLCB1cGRhdGUgdGhlIGRvY3MgbWVudGlvbmluZyB0aGUgc2VyaWVzIG9ubHkgc3VwcG9ydHMgeHkgZm9ybWF0XG5cbiAgICAgICAgICAgIHNlcltpXS5kYXRhW19qM10ucmFuZ2VOYW1lID0gaWQ7XG4gICAgICAgICAgICB2YXIgdUkgPSB1bmlxdWVLZXlzLmZpbmRJbmRleChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdC54ID09PSB4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1bmlxdWVLZXlzW3VJXS55LnB1c2goeSk7XG4gICAgICAgICAgICByYW5nZVN0YXJ0LnB1c2goeS55MSk7XG4gICAgICAgICAgICByYW5nZUVuZC5wdXNoKHkueTIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBzZXJbaV0uZGF0YS5sZW5ndGg7IF9qMysrKSB7XG4gICAgICAgICAgICBfbG9vcChfajMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQ6IHJhbmdlU3RhcnQsXG4gICAgICAgICAgZW5kOiByYW5nZUVuZCxcbiAgICAgICAgICByYW5nZVVuaXF1ZXM6IHVuaXF1ZUtleXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlQ2FuZGxlU3RpY2tCb3hEYXRhRm9ybWF0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2FuZGxlU3RpY2tCb3hEYXRhRm9ybWF0KGZvcm1hdCwgc2VyLCBpKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgaXNCb3hQbG90ID0gdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JveFBsb3QnIHx8IHcuY29uZmlnLnNlcmllc1tpXS50eXBlID09PSAnYm94UGxvdCc7XG4gICAgICAgIHZhciBzZXJPID0gW107XG4gICAgICAgIHZhciBzZXJIID0gW107XG4gICAgICAgIHZhciBzZXJNID0gW107XG4gICAgICAgIHZhciBzZXJMID0gW107XG4gICAgICAgIHZhciBzZXJDID0gW107XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgIGlmIChpc0JveFBsb3QgJiYgc2VyW2ldLmRhdGFbMF0ubGVuZ3RoID09PSA2IHx8ICFpc0JveFBsb3QgJiYgc2VyW2ldLmRhdGFbMF0ubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcltpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHNlck8ucHVzaChzZXJbaV0uZGF0YVtqXVsxXSk7XG4gICAgICAgICAgICAgIHNlckgucHVzaChzZXJbaV0uZGF0YVtqXVsyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQm94UGxvdCkge1xuICAgICAgICAgICAgICAgIHNlck0ucHVzaChzZXJbaV0uZGF0YVtqXVszXSk7XG4gICAgICAgICAgICAgICAgc2VyTC5wdXNoKHNlcltpXS5kYXRhW2pdWzRdKTtcbiAgICAgICAgICAgICAgICBzZXJDLnB1c2goc2VyW2ldLmRhdGFbal1bNV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlckwucHVzaChzZXJbaV0uZGF0YVtqXVszXSk7XG4gICAgICAgICAgICAgICAgc2VyQy5wdXNoKHNlcltpXS5kYXRhW2pdWzRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfajQgPSAwOyBfajQgPCBzZXJbaV0uZGF0YS5sZW5ndGg7IF9qNCsrKSB7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlcltpXS5kYXRhW19qNF1bMV0pKSB7XG4gICAgICAgICAgICAgICAgc2VyTy5wdXNoKHNlcltpXS5kYXRhW19qNF1bMV1bMF0pO1xuICAgICAgICAgICAgICAgIHNlckgucHVzaChzZXJbaV0uZGF0YVtfajRdWzFdWzFdKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0JveFBsb3QpIHtcbiAgICAgICAgICAgICAgICAgIHNlck0ucHVzaChzZXJbaV0uZGF0YVtfajRdWzFdWzJdKTtcbiAgICAgICAgICAgICAgICAgIHNlckwucHVzaChzZXJbaV0uZGF0YVtfajRdWzFdWzNdKTtcbiAgICAgICAgICAgICAgICAgIHNlckMucHVzaChzZXJbaV0uZGF0YVtfajRdWzFdWzRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2VyTC5wdXNoKHNlcltpXS5kYXRhW19qNF1bMV1bMl0pO1xuICAgICAgICAgICAgICAgICAgc2VyQy5wdXNoKHNlcltpXS5kYXRhW19qNF1bMV1bM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICd4eScpIHtcbiAgICAgICAgICBmb3IgKHZhciBfajUgPSAwOyBfajUgPCBzZXJbaV0uZGF0YS5sZW5ndGg7IF9qNSsrKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXJbaV0uZGF0YVtfajVdLnkpKSB7XG4gICAgICAgICAgICAgIHNlck8ucHVzaChzZXJbaV0uZGF0YVtfajVdLnlbMF0pO1xuICAgICAgICAgICAgICBzZXJILnB1c2goc2VyW2ldLmRhdGFbX2o1XS55WzFdKTtcblxuICAgICAgICAgICAgICBpZiAoaXNCb3hQbG90KSB7XG4gICAgICAgICAgICAgICAgc2VyTS5wdXNoKHNlcltpXS5kYXRhW19qNV0ueVsyXSk7XG4gICAgICAgICAgICAgICAgc2VyTC5wdXNoKHNlcltpXS5kYXRhW19qNV0ueVszXSk7XG4gICAgICAgICAgICAgICAgc2VyQy5wdXNoKHNlcltpXS5kYXRhW19qNV0ueVs0XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VyTC5wdXNoKHNlcltpXS5kYXRhW19qNV0ueVsyXSk7XG4gICAgICAgICAgICAgICAgc2VyQy5wdXNoKHNlcltpXS5kYXRhW19qNV0ueVszXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG86IHNlck8sXG4gICAgICAgICAgaDogc2VySCxcbiAgICAgICAgICBtOiBzZXJNLFxuICAgICAgICAgIGw6IHNlckwsXG4gICAgICAgICAgYzogc2VyQ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXJzZURhdGFBeGlzQ2hhcnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEYXRhQXhpc0NoYXJ0cyhzZXIpIHtcbiAgICAgICAgdmFyIF9zZXIkLFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjdHggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY3R4O1xuICAgICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZShjdHgpO1xuICAgICAgICB2YXIgeGxhYmVscyA9IGNuZi5sYWJlbHMubGVuZ3RoID4gMCA/IGNuZi5sYWJlbHMuc2xpY2UoKSA6IGNuZi54YXhpcy5jYXRlZ29yaWVzLnNsaWNlKCk7XG4gICAgICAgIGdsLmlzUmFuZ2VCYXIgPSBjbmYuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJyAmJiBnbC5pc0Jhckhvcml6b250YWw7XG4gICAgICAgIGdsLmhhc1hheGlzR3JvdXBzID0gY25mLnhheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgY25mLnhheGlzLmdyb3VwLmdyb3Vwcy5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmIChnbC5oYXNYYXhpc0dyb3Vwcykge1xuICAgICAgICAgIGdsLmdyb3VwcyA9IGNuZi54YXhpcy5ncm91cC5ncm91cHM7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5oYXNTZXJpZXNHcm91cHMgPSAoX3NlciQgPSBzZXJbMF0pID09PSBudWxsIHx8IF9zZXIkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2VyJC5ncm91cDtcblxuICAgICAgICBpZiAoZ2wuaGFzU2VyaWVzR3JvdXBzKSB7XG4gICAgICAgICAgdmFyIGJ1Y2tldHMgPSBbXTtcblxuICAgICAgICAgIHZhciBncm91cHMgPSBfdG9Db25zdW1hYmxlQXJyYXkobmV3IFNldChzZXIubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5ncm91cDtcbiAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgc2VyLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdyb3Vwcy5pbmRleE9mKHMuZ3JvdXApO1xuICAgICAgICAgICAgaWYgKCFidWNrZXRzW2luZGV4XSkgYnVja2V0c1tpbmRleF0gPSBbXTtcbiAgICAgICAgICAgIGJ1Y2tldHNbaW5kZXhdLnB1c2gocy5uYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnbC5zZXJpZXNHcm91cHMgPSBidWNrZXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZURhdGVzID0gZnVuY3Rpb24gaGFuZGxlRGF0ZXMoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB4bGFiZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHhsYWJlbHNbal0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIHVzZXIgcHJvdmlkZWQgZGF0ZSBzdHJpbmdzXG4gICAgICAgICAgICAgIHZhciBpc0RhdGUgPSBkdC5pc1ZhbGlkRGF0ZSh4bGFiZWxzW2pdKTtcblxuICAgICAgICAgICAgICBpZiAoaXNEYXRlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHdvRFNlcmllc1gucHVzaChkdC5wYXJzZURhdGUoeGxhYmVsc1tqXSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgcHJvdmlkZWQgaW52YWxpZCBEYXRlIGZvcm1hdC4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdXNlciBwcm92aWRlZCB0aW1lc3RhbXBzXG4gICAgICAgICAgICAgIF90aGlzLnR3b0RTZXJpZXNYLnB1c2goeGxhYmVsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy50d29EU2VyaWVzID0gW107XG4gICAgICAgICAgdGhpcy50d29EU2VyaWVzWCA9IFtdO1xuICAgICAgICAgIHRoaXMudGhyZWVEU2VyaWVzID0gW107XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkl0IGlzIGEgcG9zc2liaWxpdHkgdGhhdCB5b3UgbWF5IGhhdmUgbm90IGluY2x1ZGVkICdkYXRhJyBwcm9wZXJ0eSBpbiBzZXJpZXMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjbmYuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQXJlYScgfHwgc2VyW2ldLnR5cGUgPT09ICdyYW5nZUJhcicgfHwgc2VyW2ldLnR5cGUgPT09ICdyYW5nZUFyZWEnKSB7XG4gICAgICAgICAgICBnbC5pc1JhbmdlRGF0YSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChnbC5pc0NvbWJvQ2hhcnRzKSB7XG4gICAgICAgICAgICAgIGlmIChzZXJbaV0udHlwZSA9PT0gJ3JhbmdlQmFyJyB8fCBzZXJbaV0udHlwZSA9PT0gJ3JhbmdlQXJlYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJhbmdlRGF0YShzZXIsIGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNuZi5jaGFydC50eXBlID09PSAncmFuZ2VCYXInIHx8IGNuZi5jaGFydC50eXBlID09PSAncmFuZ2VBcmVhJykge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJhbmdlRGF0YShzZXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGlGb3JtYXQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGb3JtYXQyREFycmF5KCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVGb3JtYXQyREFycmF5KHNlciwgaSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNGb3JtYXRYWSgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlRm9ybWF0WFkoc2VyLCBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNuZi5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHNlcltpXS50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IGNuZi5jaGFydC50eXBlID09PSAnYm94UGxvdCcgfHwgc2VyW2ldLnR5cGUgPT09ICdib3hQbG90Jykge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhbmRsZVN0aWNrQm94RGF0YShzZXIsIGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5zZXJpZXMucHVzaCh0aGlzLnR3b0RTZXJpZXMpO1xuICAgICAgICAgICAgZ2wubGFiZWxzLnB1c2godGhpcy50d29EU2VyaWVzWCk7XG4gICAgICAgICAgICBnbC5zZXJpZXNYLnB1c2godGhpcy50d29EU2VyaWVzWCk7XG4gICAgICAgICAgICBnbC5zZXJpZXNHb2FscyA9IHRoaXMuc2VyaWVzR29hbHM7XG5cbiAgICAgICAgICAgIGlmIChpID09PSB0aGlzLmFjdGl2ZVNlcmllc0luZGV4ICYmICF0aGlzLmZhbGxiYWNrVG9DYXRlZ29yeSkge1xuICAgICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICAgIC8vIHVzZXIgZGlkbid0IHN1cHBsaWVkIFt7eCx5fV0gb3IgW1t4LHldXSwgYnV0IHNpbmdsZSBhcnJheSBpbiBkYXRhLlxuICAgICAgICAgICAgICAvLyBBbHNvIGxhYmVscy9jYXRlZ29yaWVzIHdlcmUgc3VwcGxpZWQgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICAgIGhhbmRsZURhdGVzKCk7XG4gICAgICAgICAgICAgIGdsLnNlcmllc1gucHVzaCh0aGlzLnR3b0RTZXJpZXNYKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJykge1xuICAgICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoeGxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWCA9IHhsYWJlbHM7XG4gICAgICAgICAgICAgICAgZ2wuc2VyaWVzWC5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmxhYmVscy5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuICAgICAgICAgICAgdmFyIHNpbmdsZUFycmF5ID0gc2VyW2ldLmRhdGEubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBVdGlscyQxLnBhcnNlTnVtYmVyKGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnbC5zZXJpZXMucHVzaChzaW5nbGVBcnJheSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuc2VyaWVzWi5wdXNoKHRoaXMudGhyZWVEU2VyaWVzKTtcblxuICAgICAgICAgIGlmIChzZXJbaV0ubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNOYW1lcy5wdXNoKHNlcltpXS5uYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuc2VyaWVzTmFtZXMucHVzaCgnc2VyaWVzLScgKyBwYXJzZUludChpICsgMSwgMTApKTtcbiAgICAgICAgICB9IC8vIG92ZXJyaWRlZCBkZWZhdWx0IGNvbG9yIGlmIHVzZXIgaW5wdXRzIGNvbG9yIHdpdGggc2VyaWVzIGRhdGFcblxuXG4gICAgICAgICAgaWYgKHNlcltpXS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNDb2xvcnMucHVzaChzZXJbaV0uY29sb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNDb2xvcnMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhcnNlRGF0YU5vbkF4aXNDaGFydHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGFOb25BeGlzQ2hhcnRzKHNlcikge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICAgIGdsLnNlcmllcyA9IHNlci5zbGljZSgpO1xuICAgICAgICBnbC5zZXJpZXNOYW1lcyA9IGNuZi5sYWJlbHMuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChnbC5zZXJpZXNOYW1lc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNOYW1lcy5wdXNoKCdzZXJpZXMtJyArIChpICsgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnc7XG4gICAgICB9XG4gICAgICAvKiogVXNlciBwb3NzaWJseSBzZXQgc3RyaW5nIGNhdGVnb3JpZXMgaW4geGF4aXMuY2F0ZWdvcmllcyBvciBsYWJlbHMgcHJvcFxuICAgICAgICogT3IgZGlkbid0IHNldCB4YXhpcyBsYWJlbHMgYXQgYWxsIC0gaW4gd2hpY2ggY2FzZSB3ZSBtYW51YWxseSBkbyBpdC5cbiAgICAgICAqIElmIHVzZXIgcGFzc2VkIHNlcmllcyBkYXRhIGFzIFtbMywgMl0sIFs0LCA1XV0gb3IgW3sgeDogMywgeTogNTUgfV0sXG4gICAgICAgKiB0aGlzIHNob3VsZG4ndCBiZSBjYWxsZWRcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IHNlciAtIHRoZSBzZXJpZXMgd2hpY2ggdXNlciBwYXNzZWQgdG8gdGhlIGNvbmZpZ1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlRXh0ZXJuYWxMYWJlbHNEYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxMYWJlbHNEYXRhKHNlcikge1xuICAgICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy5jYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyB1c2VyIHByb3ZpZGVkIGxhYmVscyBpbiB4YXhpcy5jYXRlZ29yeSBwcm9wXG4gICAgICAgICAgZ2wubGFiZWxzID0gY25mLnhheGlzLmNhdGVnb3JpZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoY25mLmxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gdXNlciBwcm92aWRlZCBsYWJlbHMgaW4gbGFiZWxzIHByb3BzXG4gICAgICAgICAgZ2wubGFiZWxzID0gY25mLmxhYmVscy5zbGljZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5KSB7XG4gICAgICAgICAgLy8gdXNlciBwcm92aWRlZCBsYWJlbHMgaW4geCBwcm9wIGluIFt7IHg6IDMsIHk6IDU1IH1dIGRhdGEsIGFuZCB0aG9zZSBsYWJlbHMgYXJlIGFscmVhZHkgc3RvcmVkIGluIGdsLmxhYmVsc1swXSwgc28ganVzdCByZS1hcnJhbmdlIHRoZSBnbC5sYWJlbHMgYXJyYXlcbiAgICAgICAgICBnbC5sYWJlbHMgPSBnbC5sYWJlbHNbMF07XG5cbiAgICAgICAgICBpZiAoZ2wuc2VyaWVzUmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNSYW5nZS5tYXAoZnVuY3Rpb24gKHNydCkge1xuICAgICAgICAgICAgICBzcnQuZm9yRWFjaChmdW5jdGlvbiAoc3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2wubGFiZWxzLmluZGV4T2Yoc3IueCkgPCAwICYmIHNyLngpIHtcbiAgICAgICAgICAgICAgICAgIGdsLmxhYmVscy5wdXNoKHNyLngpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTsgLy8gcmVtb3ZlIGR1cGxpY2F0ZSB4LWF4aXMgbGFiZWxzXG5cbiAgICAgICAgICAgIGdsLmxhYmVscyA9IEFycmF5LmZyb20obmV3IFNldChnbC5sYWJlbHMubWFwKEpTT04uc3RyaW5naWZ5KSksIEpTT04ucGFyc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjbmYueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoY25mKTtcbiAgICAgICAgICAgIGRlZmF1bHRzLmNvbnZlcnRDYXRUb051bWVyaWNYYXhpcyhjbmYsIHRoaXMuY3R4LCBnbC5zZXJpZXNYWzBdKTtcblxuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVFeHRlcm5hbExhYmVscyhzZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9nZW5lcmF0ZUV4dGVybmFsTGFiZWxzKHNlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dlbmVyYXRlRXh0ZXJuYWxMYWJlbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVFeHRlcm5hbExhYmVscyhzZXIpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnOyAvLyB1c2VyIGRpZG4ndCBwcm92aWRlZCBhbnkgbGFiZWxzLCBmYWxsYmFjayB0byAxLTItMy00LTVcblxuICAgICAgICB2YXIgbGFiZWxBcnIgPSBbXTtcblxuICAgICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICAgIGlmIChnbC5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGb3JtYXRYWSgpKSB7XG4gICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlcmUgaXMgYSBjb21ibyBjaGFydCAoYm94cGxvdC9zY2F0dGVyKVxuICAgICAgICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIGR1cGxpY2F0ZWQgeCB2YWx1ZXMsIHdlIG5lZWQgdG8gZWxpbWluYXRlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgdmFyIHNlcmllc0RhdGFGaWx0ZXJlZCA9IGNuZi5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXJpZSwgcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZS5kYXRhLmZpbHRlcihmdW5jdGlvbiAodiwgaSwgYSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZmluZEluZGV4KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnggPT09IHYueDtcbiAgICAgICAgICAgICAgICAgIH0pID09PSBpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IHNlcmllc0RhdGFGaWx0ZXJlZC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMsIGksIGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtwXS5sZW5ndGggPiBjLmxlbmd0aCA/IHAgOiBpO1xuICAgICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllc0RhdGFGaWx0ZXJlZFtsZW5dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxBcnIucHVzaChpICsgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBnbC5zZXJpZXNbZ2wubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxBcnIucHVzaChfaSArIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuc2VyaWVzWCA9IFtdOyAvLyBjcmVhdGUgZ2wuc2VyaWVzWCBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gY2FsY3VsYXRpb25zIG9mIHggcG9zaXRpb25zXG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzZXIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgZ2wuc2VyaWVzWC5wdXNoKGxhYmVsQXJyKTtcbiAgICAgICAgICB9IC8vIHR1cm4gb24gdGhlIGlzWE51bWVyaWMgZmxhZyB0byBhbGxvdyBtaW5YIGFuZCBtYXhYIHRvIGZ1bmN0aW9uIHByb3Blcmx5XG5cblxuICAgICAgICAgIGlmICghdGhpcy53Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gbm8gc2VyaWVzIHRvIHB1bGwgbGFiZWxzIGZyb20sIHB1dCBhIDAtMTAgc2VyaWVzXG4gICAgICAgIC8vIHBvc3NpYmx5LCB1c2VyIGNvbGxhcHNlZCBhbGwgc2VyaWVzLiBIZW5jZSB3ZSBjYW4ndCB3b3JrIHdpdGggYWJvdmUgY2FsY1xuXG5cbiAgICAgICAgaWYgKGxhYmVsQXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxhYmVsQXJyID0gZ2wuYXhpc0NoYXJ0cyA/IFtdIDogZ2wuc2VyaWVzLm1hcChmdW5jdGlvbiAoZ2xzLCBnbHNpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xzaSArIDE7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBzZXIubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgZ2wuc2VyaWVzWC5wdXNoKGxhYmVsQXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRmluYWxseSwgcGFzcyB0aGUgbGFiZWxBcnIgaW4gZ2wubGFiZWxzIHdoaWNoIHdpbGwgYmUgcHJpbnRlZCBvbiB4LWF4aXNcblxuXG4gICAgICAgIGdsLmxhYmVscyA9IGxhYmVsQXJyO1xuXG4gICAgICAgIGlmIChjbmYueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgZ2wuY2F0ZWdvcnlMYWJlbHMgPSBsYWJlbEFyci5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjbmYueGF4aXMubGFiZWxzLmZvcm1hdHRlcihsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBUdXJuIG9uIHRoaXMgZ2xvYmFsIGZsYWcgdG8gaW5kaWNhdGUgbm8gbGFiZWxzIHdlcmUgcHJvdmlkZWQgYnkgdXNlclxuXG5cbiAgICAgICAgZ2wubm9MYWJlbHNQcm92aWRlZCA9IHRydWU7XG4gICAgICB9IC8vIFNlZ3JlZ2F0ZSB1c2VyIHByb3ZpZGVkIGRhdGEgaW50byBhcHByb3ByaWF0ZSB2YXJzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGFyc2VEYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEYXRhKHNlcikge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGNuZiA9IHcuY29uZmlnO1xuICAgICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICAgIHRoaXMuZXhjbHVkZUNvbGxhcHNlZFNlcmllc0luWUF4aXMoKTsgLy8gSWYgd2UgZGV0ZWN0ZWQgc3RyaW5nIGluIFggcHJvcCBvZiBzZXJpZXMsIHdlIGZhbGxiYWNrIHRvIGNhdGVnb3J5IHgtYXhpc1xuXG4gICAgICAgIHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3R4LmNvcmUucmVzZXRHbG9iYWxzKCk7XG4gICAgICAgIHRoaXMuY3R4LmNvcmUuaXNNdWx0aXBsZVkoKTtcblxuICAgICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICAgIC8vIGF4aXNDaGFydHMgaW5jbHVkZXMgbGluZSAvIGFyZWEgLyBjb2x1bW4gLyBzY2F0dGVyXG4gICAgICAgICAgdGhpcy5wYXJzZURhdGFBeGlzQ2hhcnRzKHNlcik7XG4gICAgICAgICAgdGhpcy5jb3JlVXRpbHMuZ2V0TGFyZ2VzdFNlcmllcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vbi1heGlzIGNoYXJ0cyBhcmUgcGllIC8gZG9udXRcbiAgICAgICAgICB0aGlzLnBhcnNlRGF0YU5vbkF4aXNDaGFydHMoc2VyKTtcbiAgICAgICAgfSAvLyBzZXQgTnVsbCB2YWx1ZXMgdG8gMCBpbiBhbGwgc2VyaWVzIHdoZW4gdXNlciBoaWRlcy9zaG93cyBzb21lIHNlcmllc1xuXG5cbiAgICAgICAgaWYgKGNuZi5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgICAgIGdsLnNlcmllcyA9IHNlcmllcy5zZXROdWxsU2VyaWVzVG9aZXJvVmFsdWVzKGdsLnNlcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvcmVVdGlscy5nZXRTZXJpZXNUb3RhbHMoKTtcblxuICAgICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICAgIGdsLnN0YWNrZWRTZXJpZXNUb3RhbHMgPSB0aGlzLmNvcmVVdGlscy5nZXRTdGFja2VkU2VyaWVzVG90YWxzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvcmVVdGlscy5nZXRQZXJjZW50U2VyaWVzKCk7XG5cbiAgICAgICAgaWYgKCFnbC5kYXRhRm9ybWF0WE51bWVyaWMgJiYgKCFnbC5pc1hOdW1lcmljIHx8IGNuZi54YXhpcy50eXBlID09PSAnbnVtZXJpYycgJiYgY25mLmxhYmVscy5sZW5ndGggPT09IDAgJiYgY25mLnhheGlzLmNhdGVnb3JpZXMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgIC8vIHgtYXhpcyBsYWJlbHMgY291bGRuJ3QgYmUgZGV0ZWN0ZWQ7IGhlbmNlIHRyeSBzZWFyY2hpbmcgZXZlcnkgb3B0aW9uIGluIGNvbmZpZ1xuICAgICAgICAgIHRoaXMuaGFuZGxlRXh0ZXJuYWxMYWJlbHNEYXRhKHNlcik7XG4gICAgICAgIH0gLy8gY2hlY2sgZm9yIG11bHRpbGluZSB4YXhpc1xuXG5cbiAgICAgICAgdmFyIGNhdExhYmVscyA9IHRoaXMuY29yZVV0aWxzLmdldENhdGVnb3J5TGFiZWxzKGdsLmxhYmVscyk7XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBjYXRMYWJlbHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXRMYWJlbHNbbF0pKSB7XG4gICAgICAgICAgICBnbC5pc011bHRpTGluZVggPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4Y2x1ZGVDb2xsYXBzZWRTZXJpZXNJbllBeGlzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXhjbHVkZUNvbGxhcHNlZFNlcmllc0luWUF4aXMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB3Lmdsb2JhbHMuaWdub3JlWUF4aXNJbmRleGVzID0gdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5tYXAoZnVuY3Rpb24gKGNvbGxhcHNlZCwgaSkge1xuICAgICAgICAgIC8vIGZpeCBpc3N1ZSAjMTIxNVxuICAgICAgICAgIC8vIGlmIHN0YWNrZWQsIG5vdCByZXR1cm5pbmcgY29sbGFwc2VkLmluZGV4IHRvIHByZXNlcnZlIHlheGlzXG4gICAgICAgICAgaWYgKF90aGlzMi53Lmdsb2JhbHMuaXNNdWx0aXBsZVlBeGlzICYmICF3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGFwc2VkLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGE7XG4gIH0oKTtcblxuICB2YXIgQXhlc1V0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBeGVzVXRpbHMoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXhlc1V0aWxzKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICB9IC8vIEJhc2VkIG9uIHRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24sIGdldCB0aGUgbGFiZWwgdGV4dCBhbmQgcG9zaXRpb25cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEF4ZXNVdGlscywgW3tcbiAgICAgIGtleTogXCJnZXRMYWJlbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsKGxhYmVscywgdGltZXNjYWxlTGFiZWxzLCB4LCBpKSB7XG4gICAgICAgIHZhciBkcmF3bkxhYmVscyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gICAgICAgIHZhciBmb250U2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogJzEycHgnO1xuICAgICAgICB2YXIgaXNMZWFmR3JvdXAgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRydWU7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcmF3TGFiZWwgPSB0eXBlb2YgbGFiZWxzW2ldID09PSAndW5kZWZpbmVkJyA/ICcnIDogbGFiZWxzW2ldO1xuICAgICAgICB2YXIgbGFiZWwgPSByYXdMYWJlbDtcbiAgICAgICAgdmFyIHhsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXI7XG4gICAgICAgIHZhciBjdXN0b21Gb3JtYXR0ZXIgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgICB2YXIgaXNCb2xkID0gZmFsc2U7XG4gICAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5jdHgpO1xuICAgICAgICB2YXIgdGltZXN0YW1wID0gcmF3TGFiZWw7XG5cbiAgICAgICAgaWYgKGlzTGVhZkdyb3VwKSB7XG4gICAgICAgICAgbGFiZWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh4bGJGb3JtYXR0ZXIsIHJhd0xhYmVsLCB0aW1lc3RhbXAsIHtcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBkYXRlRm9ybWF0dGVyOiBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpLmZvcm1hdERhdGUsXG4gICAgICAgICAgICB3OiB3XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY3VzdG9tRm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhYmVsID0gY3VzdG9tRm9ybWF0dGVyKHJhd0xhYmVsLCBsYWJlbHNbaV0sIHtcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgZGF0ZUZvcm1hdHRlcjogbmV3IERhdGVUaW1lKHRoaXMuY3R4KS5mb3JtYXREYXRlLFxuICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGV0ZXJtaW5lSGlnaGVzdFVuaXQgPSBmdW5jdGlvbiBkZXRlcm1pbmVIaWdoZXN0VW5pdCh1bml0KSB7XG4gICAgICAgICAgdmFyIGhpZ2hlc3RVbml0ID0gbnVsbDtcbiAgICAgICAgICB0aW1lc2NhbGVMYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaWYgKHQudW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICBoaWdoZXN0VW5pdCA9ICd5ZWFyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodC51bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgICBoaWdoZXN0VW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQudW5pdCA9PT0gJ2hvdXInKSB7XG4gICAgICAgICAgICAgIGhpZ2hlc3RVbml0ID0gJ2RheSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQudW5pdCA9PT0gJ21pbnV0ZScpIHtcbiAgICAgICAgICAgICAgaGlnaGVzdFVuaXQgPSAnaG91cic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGhpZ2hlc3RVbml0ID09PSB1bml0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aW1lc2NhbGVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlzQm9sZCA9IGRldGVybWluZUhpZ2hlc3RVbml0KHRpbWVzY2FsZUxhYmVsc1tpXS51bml0KTtcbiAgICAgICAgICB4ID0gdGltZXNjYWxlTGFiZWxzW2ldLnBvc2l0aW9uO1xuICAgICAgICAgIGxhYmVsID0gdGltZXNjYWxlTGFiZWxzW2ldLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnICYmIGN1c3RvbUZvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICd1bmRlZmluZWQnKSBsYWJlbCA9ICcnO1xuICAgICAgICBsYWJlbCA9IEFycmF5LmlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBsYWJlbC50b1N0cmluZygpO1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgdGV4dFJlY3QgPSB7fTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgJiYgaXNMZWFmR3JvdXApIHtcbiAgICAgICAgICB0ZXh0UmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyhsYWJlbCwgcGFyc2VJbnQoZm9udFNpemUsIDEwKSwgbnVsbCwgXCJyb3RhdGUoXCIuY29uY2F0KHcuY29uZmlnLnhheGlzLmxhYmVscy5yb3RhdGUsIFwiIDAgMClcIiksIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0UmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyhsYWJlbCwgcGFyc2VJbnQoZm9udFNpemUsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWxsb3dEdXBsaWNhdGVzSW5UaW1lU2NhbGUgPSAhdy5jb25maWcueGF4aXMubGFiZWxzLnNob3dEdXBsaWNhdGVzICYmIHRoaXMuY3R4LnRpbWVTY2FsZTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGFiZWwpICYmIChsYWJlbC5pbmRleE9mKCdOYU4nKSA9PT0gMCB8fCBsYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ludmFsaWQnKSA9PT0gMCB8fCBsYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2luZmluaXR5JykgPj0gMCB8fCBkcmF3bkxhYmVscy5pbmRleE9mKGxhYmVsKSA+PSAwICYmIGFsbG93RHVwbGljYXRlc0luVGltZVNjYWxlKSkge1xuICAgICAgICAgIGxhYmVsID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgdGV4dFJlY3Q6IHRleHRSZWN0LFxuICAgICAgICAgIGlzQm9sZDogaXNCb2xkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrTGFiZWxCYXNlZE9uVGlja2Ftb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrTGFiZWxCYXNlZE9uVGlja2Ftb3VudChpLCBsYWJlbCwgbGFiZWxzTGVuKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdGlja3MgPSB3LmNvbmZpZy54YXhpcy50aWNrQW1vdW50O1xuICAgICAgICBpZiAodGlja3MgPT09ICdkYXRhUG9pbnRzJykgdGlja3MgPSBNYXRoLnJvdW5kKHcuZ2xvYmFscy5ncmlkV2lkdGggLyAxMjApO1xuICAgICAgICBpZiAodGlja3MgPiBsYWJlbHNMZW4pIHJldHVybiBsYWJlbDtcbiAgICAgICAgdmFyIHRpY2tNdWx0aXBsZSA9IE1hdGgucm91bmQobGFiZWxzTGVuIC8gKHRpY2tzICsgMSkpO1xuXG4gICAgICAgIGlmIChpICUgdGlja011bHRpcGxlID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLnRleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hlY2tGb3JPdmVyZmxvd2luZ0xhYmVsc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRm9yT3ZlcmZsb3dpbmdMYWJlbHMoaSwgbGFiZWwsIGxhYmVsc0xlbiwgZHJhd25MYWJlbHMsIGRyYXduTGFiZWxzUmVjdHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBmaXJzdCBsYWJlbCBpcyBiZWluZyB0cnVuY2F0ZWRcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnNraXBGaXJzdFRpbWVsaW5lbGFiZWwpIHtcbiAgICAgICAgICAgIGxhYmVsLnRleHQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gbGFiZWxzTGVuIC0gMSkge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3QgbGFiZWwgaXMgYmVpbmcgdHJ1bmNhdGVkXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5za2lwTGFzdFRpbWVsaW5lbGFiZWwpIHtcbiAgICAgICAgICAgIGxhYmVsLnRleHQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLmhpZGVPdmVybGFwcGluZ0xhYmVscyAmJiBkcmF3bkxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBkcmF3bkxhYmVsc1JlY3RzW2RyYXduTGFiZWxzUmVjdHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAobGFiZWwueCA8IHByZXYudGV4dFJlY3Qud2lkdGggLyAody5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyBNYXRoLmFicyh3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlKSAvIDEyIDogMS4wMSkgKyBwcmV2LngpIHtcbiAgICAgICAgICAgIGxhYmVsLnRleHQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrRm9yUmV2ZXJzZWRMYWJlbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0ZvclJldmVyc2VkTGFiZWxzKGksIGxhYmVscykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbaV0gJiYgdy5jb25maWcueWF4aXNbaV0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICBsYWJlbHMucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNZQXhpc0hpZGRlblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzWUF4aXNIaWRkZW4oaW5kZXgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4KTtcbiAgICAgICAgcmV0dXJuICF3LmNvbmZpZy55YXhpc1tpbmRleF0uc2hvdyB8fCAhdy5jb25maWcueWF4aXNbaW5kZXhdLnNob3dGb3JOdWxsU2VyaWVzICYmIGNvcmVVdGlscy5pc1Nlcmllc051bGwoaW5kZXgpICYmIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgICAgIH0gLy8gZ2V0IHRoZSBsYWJlbCBjb2xvciBmb3IgeS1heGlzXG4gICAgICAvLyByZWFsSW5kZXggaXMgdGhlIGFjdHVhbCBzZXJpZXMgaW5kZXgsIHdoaWxlIGkgaXMgdGhlIHRpY2sgSW5kZXhcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRZQXhpc0ZvcmVDb2xvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFlBeGlzRm9yZUNvbG9yKHlDb2xvcnMsIHJlYWxJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh5Q29sb3JzKSAmJiB3Lmdsb2JhbHMueUF4aXNTY2FsZVtyZWFsSW5kZXhdKSB7XG4gICAgICAgICAgdGhpcy5jdHgudGhlbWUucHVzaEV4dHJhQ29sb3JzKHlDb2xvcnMsIHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0Lmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHlDb2xvcnM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdZQXhpc1RpY2tzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lBeGlzVGlja3MoeCwgdGlja0Ftb3VudCwgYXhpc0JvcmRlciwgYXhpc1RpY2tzLCByZWFsSW5kZXgsIGxhYmVsc0RpdmlkZXIsIGVsWWF4aXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7IC8vIGluaXRpYWwgbGFiZWwgcG9zaXRpb24gPSAwO1xuXG4gICAgICAgIHZhciB0ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVk7XG5cbiAgICAgICAgaWYgKGF4aXNUaWNrcy5zaG93ICYmIHRpY2tBbW91bnQgPiAwKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUgPT09IHRydWUpIHggPSB4ICsgYXhpc1RpY2tzLndpZHRoO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRpY2tBbW91bnQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgdFkgPSB0ICsgdGlja0Ftb3VudCAvIDEwICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMub2Zmc2V0WSAtIDE7XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgIHRZID0gbGFiZWxzRGl2aWRlciAqIGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgICAgdFkgPSB0WSArIGxhYmVsc0RpdmlkZXIgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxUaWNrID0gZ3JhcGhpY3MuZHJhd0xpbmUoeCArIGF4aXNCb3JkZXIub2Zmc2V0WCAtIGF4aXNUaWNrcy53aWR0aCArIGF4aXNUaWNrcy5vZmZzZXRYLCB0WSArIGF4aXNUaWNrcy5vZmZzZXRZLCB4ICsgYXhpc0JvcmRlci5vZmZzZXRYICsgYXhpc1RpY2tzLm9mZnNldFgsIHRZICsgYXhpc1RpY2tzLm9mZnNldFksIGF4aXNUaWNrcy5jb2xvcik7XG4gICAgICAgICAgICBlbFlheGlzLmFkZChlbFRpY2spO1xuICAgICAgICAgICAgdCA9IHQgKyBsYWJlbHNEaXZpZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBeGVzVXRpbHM7XG4gIH0oKTtcblxuICB2YXIgRXhwb3J0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwb3J0cyhjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHBvcnRzKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRXhwb3J0cywgW3tcbiAgICAgIGtleTogXCJzY2FsZVN2Z05vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FsZVN2Z05vZGUoc3ZnLCBzY2FsZSkge1xuICAgICAgICAvLyBnZXQgY3VycmVudCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHN2Z1xuICAgICAgICB2YXIgc3ZnV2lkdGggPSBwYXJzZUZsb2F0KHN2Zy5nZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnKSk7XG4gICAgICAgIHZhciBzdmdIZWlnaHQgPSBwYXJzZUZsb2F0KHN2Zy5nZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JykpOyAvLyBzZXQgbmV3IHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gdGhlIHNjYWxlXG5cbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIHN2Z1dpZHRoICogc2NhbGUpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIHN2Z0hlaWdodCAqIHNjYWxlKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsICd2aWV3Qm94JywgJzAgMCAnICsgc3ZnV2lkdGggKyAnICcgKyBzdmdIZWlnaHQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaXhTdmdTdHJpbmdGb3JJZTExXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZml4U3ZnU3RyaW5nRm9ySWUxMShzdmdEYXRhKSB7XG4gICAgICAgIC8vIElFMTEgZ2VuZXJhdGVzIGJyb2tlbiBTVkcgdGhhdCB3ZSBoYXZlIHRvIGZpeCBieSB1c2luZyByZWdleFxuICAgICAgICBpZiAoIVV0aWxzJDEuaXNJRTExKCkpIHtcbiAgICAgICAgICAvLyBub3QgSUUxMSAtIG5vb3BcbiAgICAgICAgICByZXR1cm4gc3ZnRGF0YS5yZXBsYWNlKC8mbmJzcDsvZywgJyYjMTYwOycpO1xuICAgICAgICB9IC8vIHJlcGxhY2Ugc2Vjb25kIG9jY3VycmVuY2Ugb2YgXCJ4bWxuc1wiIGF0dHJpYnV0ZSB3aXRoIFwieG1sbnM6eGxpbmtcIiB3aXRoIGNvcnJlY3QgdXJsICsgYWRkIHhtbG5zOnN2Z2pzXG5cblxuICAgICAgICB2YXIgblhtbG5zU2VlbiA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBzdmdEYXRhLnJlcGxhY2UoL3htbG5zPVwiaHR0cDpcXC9cXC93d3cudzMub3JnXFwvMjAwMFxcL3N2Z1wiL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIG5YbWxuc1NlZW4rKztcbiAgICAgICAgICByZXR1cm4gblhtbG5zU2VlbiA9PT0gMiA/ICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpzdmdqcz1cImh0dHA6Ly9zdmdqcy5kZXZcIicgOiBtYXRjaDtcbiAgICAgICAgfSk7IC8vIHJlbW92ZSB0aGUgaW52YWxpZCBlbXB0eSBuYW1lc3BhY2UgZGVjbGFyYXRpb25zXG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL3htbG5zOk5TXFxkKz1cIlwiL2csICcnKTsgLy8gcmVtb3ZlIHRoZXNlIGJyb2tlbiBuYW1lc3BhY2VzIGZyb20gYXR0cmlidXRlc1xuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9OU1xcZCs6KFxcdys6XFx3Kz1cIikvZywgJyQxJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFN2Z1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN2Z1N0cmluZyhzY2FsZSkge1xuICAgICAgICBpZiAoc2NhbGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2NhbGUgPSAxOyAvLyBpZiBubyBzY2FsZSBpcyBzcGVjaWZpZWQsIGRvbid0IHNjYWxlLi4uXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ZnU3RyaW5nID0gdGhpcy53Lmdsb2JhbHMuZG9tLlBhcGVyLnN2ZygpOyAvLyBpbiBjYXNlIHRoZSBzY2FsZSBpcyBkaWZmZXJlbnQgdGhhbiAxLCB0aGUgc3ZnIG5lZWRzIHRvIGJlIHJlc2NhbGVkXG5cbiAgICAgICAgaWYgKHNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgLy8gY2xvbmUgdGhlIHN2ZyBub2RlIHNvIGl0IHJlbWFpbnMgaW50YWN0IGluIHRoZSBVSVxuICAgICAgICAgIHZhciBzdmdOb2RlID0gdGhpcy53Lmdsb2JhbHMuZG9tLlBhcGVyLm5vZGUuY2xvbmVOb2RlKHRydWUpOyAvLyBzY2FsZSB0aGUgaW1hZ2VcblxuICAgICAgICAgIHRoaXMuc2NhbGVTdmdOb2RlKHN2Z05vZGUsIHNjYWxlKTsgLy8gZ2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN2Z05vZGVcblxuICAgICAgICAgIHN2Z1N0cmluZyA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5maXhTdmdTdHJpbmdGb3JJZTExKHN2Z1N0cmluZyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFudXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudzsgLy8gaGlkZSBzb21lIGVsZW1lbnRzIHRvIGF2b2lkIHByaW50aW5nIHRoZW0gb24gZXhwb3J0ZWQgc3ZnXG5cbiAgICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYXBleGNoYXJ0cy14Y3Jvc3NoYWlycycpO1xuICAgICAgICB2YXIgeWNyb3NzaGFpcnMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhcGV4Y2hhcnRzLXljcm9zc2hhaXJzJyk7XG4gICAgICAgIHZhciB6b29tU2VsZWN0aW9uUmVjdHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy16b29tLXJlY3QsIC5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0Jyk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoem9vbVNlbGVjdGlvblJlY3RzLCBmdW5jdGlvbiAoeikge1xuICAgICAgICAgIHouc2V0QXR0cmlidXRlKCd3aWR0aCcsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoeGNyb3NzaGFpcnMgJiYgeGNyb3NzaGFpcnNbMF0pIHtcbiAgICAgICAgICB4Y3Jvc3NoYWlyc1swXS5zZXRBdHRyaWJ1dGUoJ3gnLCAtNTAwKTtcbiAgICAgICAgICB4Y3Jvc3NoYWlyc1swXS5zZXRBdHRyaWJ1dGUoJ3gxJywgLTUwMCk7XG4gICAgICAgICAgeGNyb3NzaGFpcnNbMF0uc2V0QXR0cmlidXRlKCd4MicsIC01MDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHljcm9zc2hhaXJzICYmIHljcm9zc2hhaXJzWzBdKSB7XG4gICAgICAgICAgeWNyb3NzaGFpcnNbMF0uc2V0QXR0cmlidXRlKCd5JywgLTEwMCk7XG4gICAgICAgICAgeWNyb3NzaGFpcnNbMF0uc2V0QXR0cmlidXRlKCd5MScsIC0xMDApO1xuICAgICAgICAgIHljcm9zc2hhaXJzWzBdLnNldEF0dHJpYnV0ZSgneTInLCAtMTAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdmdVcmxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdmdVcmwoKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB2YXIgc3ZnRGF0YSA9IHRoaXMuZ2V0U3ZnU3RyaW5nKCk7XG4gICAgICAgIHZhciBzdmdCbG9iID0gbmV3IEJsb2IoW3N2Z0RhdGFdLCB7XG4gICAgICAgICAgdHlwZTogJ2ltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHN2Z0Jsb2IpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkYXRhVVJJXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YVVSSShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIHcgPSBfdGhpcy53O1xuICAgICAgICAgIHZhciBzY2FsZSA9IG9wdGlvbnMgPyBvcHRpb25zLnNjYWxlIHx8IG9wdGlvbnMud2lkdGggLyB3Lmdsb2JhbHMuc3ZnV2lkdGggOiAxO1xuXG4gICAgICAgICAgX3RoaXMuY2xlYW51cCgpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHcuZ2xvYmFscy5zdmdXaWR0aCAqIHNjYWxlO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJzZUludCh3Lmdsb2JhbHMuZG9tLmVsV3JhcC5zdHlsZS5oZWlnaHQsIDEwKSAqIHNjYWxlOyAvLyBiZWNhdXNlIG9mIHJlc2l6ZU5vbkF4aXNDaGFydHNcblxuICAgICAgICAgIHZhciBjYW52YXNCZyA9IHcuY29uZmlnLmNoYXJ0LmJhY2tncm91bmQgPT09ICd0cmFuc3BhcmVudCcgPyAnI2ZmZicgOiB3LmNvbmZpZy5jaGFydC5iYWNrZ3JvdW5kO1xuICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY2FudmFzQmc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCAqIHNjYWxlLCBjYW52YXMuaGVpZ2h0ICogc2NhbGUpO1xuXG4gICAgICAgICAgdmFyIHN2Z0RhdGEgPSBfdGhpcy5nZXRTdmdTdHJpbmcoc2NhbGUpO1xuXG4gICAgICAgICAgaWYgKHdpbmRvdy5jYW52ZyAmJiBVdGlscyQxLmlzSUUxMSgpKSB7XG4gICAgICAgICAgICAvLyB1c2UgY2FudmcgYXMgYSBwb2x5ZmlsbCB0byB3b3JrYXJvdW5kIGllMTEgY29uc2lkZXJpbmcgYSBjYW52YXMgd2l0aCBsb2FkZWQgc3ZnICd1bnNhZmUnXG4gICAgICAgICAgICAvLyB3aXRob3V0IGlnbm9yZUNsZWFyIHdlIGxvc2Ugb3VyIGJhY2tncm91bmQgY29sb3I7IHdpdGhvdXQgaWdub3JlRGltZW5zaW9ucyBzb21lIGdyaWQgbGluZXMgYmVjb21lIGludmlzaWJsZVxuICAgICAgICAgICAgdmFyIHYgPSB3aW5kb3cuY2FudmcuQ2FudmcuZnJvbVN0cmluZyhjdHgsIHN2Z0RhdGEsIHtcbiAgICAgICAgICAgICAgaWdub3JlQ2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWVcbiAgICAgICAgICAgIH0pOyAvLyByZW5kZXIgdGhlIHN2ZyB0byBjYW52YXNcblxuICAgICAgICAgICAgdi5zdGFydCgpO1xuICAgICAgICAgICAgdmFyIGJsb2IgPSBjYW52YXMubXNUb0Jsb2IoKTsgLy8gZGlzcG9zZSAtIG1pc3NpbmcgdGhpcyB3aWxsIGNhdXNlIGEgbWVtb3J5IGxlYWtcblxuICAgICAgICAgICAgdi5zdG9wKCk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgYmxvYjogYmxvYlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdmdVcmwgPSAnZGF0YTppbWFnZS9zdmcreG1sLCcgKyBlbmNvZGVVUklDb21wb25lbnQoc3ZnRGF0YSk7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblxuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuXG4gICAgICAgICAgICAgIGlmIChjYW52YXMubXNUb0Jsb2IpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSBhbmQgRWRnZSBjYW4ndCBuYXZpZ2F0ZSB0byBkYXRhIHVybHMsIHNvIHdlIHJldHVybiB0aGUgYmxvYiBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgdmFyIF9ibG9iID0gY2FudmFzLm1zVG9CbG9iKCk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgIGJsb2I6IF9ibG9iXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZ1VSSSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgaW1nVVJJOiBpbWdVUklcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1nLnNyYyA9IHN2Z1VybDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJleHBvcnRUb1NWR1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFRvU1ZHKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJEb3dubG9hZCh0aGlzLnN2Z1VybCgpLCB0aGlzLncuY29uZmlnLmNoYXJ0LnRvb2xiYXIuZXhwb3J0LnN2Zy5maWxlbmFtZSwgJy5zdmcnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZXhwb3J0VG9QbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRUb1BuZygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5kYXRhVVJJKCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBpbWdVUkkgPSBfcmVmLmltZ1VSSSxcbiAgICAgICAgICAgICAgYmxvYiA9IF9yZWYuYmxvYjtcblxuICAgICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iLCBfdGhpczIudy5nbG9iYWxzLmNoYXJ0SUQgKyAnLnBuZycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczIudHJpZ2dlckRvd25sb2FkKGltZ1VSSSwgX3RoaXMyLncuY29uZmlnLmNoYXJ0LnRvb2xiYXIuZXhwb3J0LnBuZy5maWxlbmFtZSwgJy5wbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJleHBvcnRUb0NTVlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFRvQ1NWKF9yZWYyKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzZXJpZXMgPSBfcmVmMi5zZXJpZXMsXG4gICAgICAgICAgICBmaWxlTmFtZSA9IF9yZWYyLmZpbGVOYW1lLFxuICAgICAgICAgICAgX3JlZjIkY29sdW1uRGVsaW1pdGVyID0gX3JlZjIuY29sdW1uRGVsaW1pdGVyLFxuICAgICAgICAgICAgY29sdW1uRGVsaW1pdGVyID0gX3JlZjIkY29sdW1uRGVsaW1pdGVyID09PSB2b2lkIDAgPyAnLCcgOiBfcmVmMiRjb2x1bW5EZWxpbWl0ZXIsXG4gICAgICAgICAgICBfcmVmMiRsaW5lRGVsaW1pdGVyID0gX3JlZjIubGluZURlbGltaXRlcixcbiAgICAgICAgICAgIGxpbmVEZWxpbWl0ZXIgPSBfcmVmMiRsaW5lRGVsaW1pdGVyID09PSB2b2lkIDAgPyAnXFxuJyA6IF9yZWYyJGxpbmVEZWxpbWl0ZXI7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICBpZiAoIXNlcmllcykgc2VyaWVzID0gdy5jb25maWcuc2VyaWVzO1xuICAgICAgICB2YXIgY29sdW1ucyA9IFtdO1xuICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciB1bml2ZXJzYWxCT00gPSBcIlxcdUZFRkZcIjtcbiAgICAgICAgdmFyIGdTZXJpZXMgPSB3Lmdsb2JhbHMuc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgIHJldHVybiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSA/IHMgOiBbXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGlzVGltZVN0YW1wID0gZnVuY3Rpb24gaXNUaW1lU3RhbXAobnVtKSB7XG4gICAgICAgICAgcmV0dXJuIHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScgJiYgU3RyaW5nKG51bSkubGVuZ3RoID49IDEwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZXJpZXNNYXhEYXRhTGVuZ3RoID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHNlcmllcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy5kYXRhID8gcy5kYXRhLmxlbmd0aCA6IDA7XG4gICAgICAgIH0pKSk7XG4gICAgICAgIHZhciBkYXRhRm9ybWF0ID0gbmV3IERhdGEodGhpcy5jdHgpO1xuICAgICAgICB2YXIgYXhlc1V0aWxzID0gbmV3IEF4ZXNVdGlscyh0aGlzLmN0eCk7XG5cbiAgICAgICAgdmFyIGdldENhdCA9IGZ1bmN0aW9uIGdldENhdChpKSB7XG4gICAgICAgICAgdmFyIGNhdCA9ICcnOyAvLyBwaWUgLyBkb251dC8gcmFkaWFsXG5cbiAgICAgICAgICBpZiAoIXcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICBjYXQgPSB3LmNvbmZpZy5sYWJlbHNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHh5IGNoYXJ0c1xuICAgICAgICAgICAgLy8gbm9uIGRhdGV0aW1lXG4gICAgICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgc3IgPSBuZXcgU2VyaWVzKF90aGlzMy5jdHgpO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVTZXJpZXMgPSBzci5nZXRBY3RpdmVDb25maWdTZXJpZXNJbmRleCgpO1xuICAgICAgICAgICAgICAgIGNhdCA9IGxiRm9ybWF0dGVyKHcuZ2xvYmFscy5sYWJlbHNbaV0sIHtcbiAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBhY3RpdmVTZXJpZXMsXG4gICAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYXQgPSBheGVzVXRpbHMuZ2V0TGFiZWwody5nbG9iYWxzLmxhYmVscywgdy5nbG9iYWxzLnRpbWVzY2FsZUxhYmVscywgMCwgaSkudGV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBkYXRldGltZSwgYnV0IGxhYmVscyBzcGVjaWZpZWQgaW4gY2F0ZWdvcmllcyBvciBsYWJlbHNcblxuXG4gICAgICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgICBpZiAody5jb25maWcueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXQgPSB3LmNvbmZpZy54YXhpcy5jYXRlZ29yaWVzW2ldO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXQgPSB3LmNvbmZpZy5sYWJlbHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXQpKSB7XG4gICAgICAgICAgICBjYXQgPSBjYXQuam9pbignICcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBVdGlscyQxLmlzTnVtYmVyKGNhdCkgPyBjYXQgOiBjYXQuc3BsaXQoY29sdW1uRGVsaW1pdGVyKS5qb2luKCcnKTtcbiAgICAgICAgfTsgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzMzNjVcblxuXG4gICAgICAgIHZhciBnZXRFbXB0eURhdGFGb3JDc3ZDb2x1bW4gPSBmdW5jdGlvbiBnZXRFbXB0eURhdGFGb3JDc3ZDb2x1bW4oKSB7XG4gICAgICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShBcnJheShzZXJpZXNNYXhEYXRhTGVuZ3RoKSkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlQXhpc1Jvd3NDb2x1bW5zID0gZnVuY3Rpb24gaGFuZGxlQXhpc1Jvd3NDb2x1bW5zKHMsIHNJKSB7XG4gICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIHNJID09PSAwKSB7XG4gICAgICAgICAgICAvLyBJdCdzIHRoZSBmaXJzdCBzZXJpZXMuICBHbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBmaXJzdCByb3cgd2l0aCBoZWFkZXIgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICByb3dzLnB1c2goY29sdW1ucy5qb2luKGNvbHVtbkRlbGltaXRlcikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZGF0YSB3ZSBoYXZlLCBvciBnZW5lcmF0ZSBhIHByb3Blcmx5IHNpemVkIGVtcHR5IGFycmF5IHdpdGggZW1wdHkgZGF0YSBpZiBzb21lIGRhdGEgaXMgbWlzc2luZy5cbiAgICAgICAgICAgIHMuZGF0YSA9IHMuZGF0YS5sZW5ndGggJiYgcy5kYXRhIHx8IGdldEVtcHR5RGF0YUZvckNzdkNvbHVtbigpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY29sdW1ucyBhcnJheSBzbyB0aGF0IHdlIGNhbiBzdGFydCBidWlsZGluZyBjb2x1bW5zIGZvciB0aGlzIHJvdy5cbiAgICAgICAgICAgICAgY29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgY2F0ID0gZ2V0Q2F0KGkpO1xuXG4gICAgICAgICAgICAgIGlmICghY2F0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFGb3JtYXQuaXNGb3JtYXRYWSgpKSB7XG4gICAgICAgICAgICAgICAgICBjYXQgPSBzZXJpZXNbc0ldLmRhdGFbaV0ueDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFGb3JtYXQuaXNGb3JtYXQyREFycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgIGNhdCA9IHNlcmllc1tzSV0uZGF0YVtpXSA/IHNlcmllc1tzSV0uZGF0YVtpXVswXSA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzSSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIGZpcnN0IHNlcmllcy4gIEFsc28gaGFuZGxlIHRoZSBjYXRlZ29yeS5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goaXNUaW1lU3RhbXAoY2F0KSA/IHcuY29uZmlnLmNoYXJ0LnRvb2xiYXIuZXhwb3J0LmNzdi5kYXRlRm9ybWF0dGVyKGNhdCkgOiBVdGlscyQxLmlzTnVtYmVyKGNhdCkgPyBjYXQgOiBjYXQuc3BsaXQoY29sdW1uRGVsaW1pdGVyKS5qb2luKCcnKSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhRm9ybWF0LmlzRm9ybWF0WFkoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3NlcmllcyRjaSRkYXRhJGk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKChfc2VyaWVzJGNpJGRhdGEkaSA9IHNlcmllc1tjaV0uZGF0YVtpXSkgPT09IG51bGwgfHwgX3NlcmllcyRjaSRkYXRhJGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zZXJpZXMkY2kkZGF0YSRpLnkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKGdTZXJpZXNbY2ldW2ldKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJyB8fCBzLnR5cGUgJiYgcy50eXBlID09PSAnY2FuZGxlc3RpY2snKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZU9bc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZUhbc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZUxbc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZUNbc0ldW2ldKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYm94UGxvdCcgfHwgcy50eXBlICYmIHMudHlwZSA9PT0gJ2JveFBsb3QnKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZU9bc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZUhbc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZU1bc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZUxbc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc0NhbmRsZUNbc0ldW2ldKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFuZ2VCYXInKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc1JhbmdlU3RhcnRbc0ldW2ldKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gody5nbG9iYWxzLnNlcmllc1JhbmdlRW5kW3NJXVtpXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goY29sdW1ucy5qb2luKGNvbHVtbkRlbGltaXRlcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbHVtbnMucHVzaCh3LmNvbmZpZy5jaGFydC50b29sYmFyLmV4cG9ydC5jc3YuaGVhZGVyQ2F0ZWdvcnkpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYm94UGxvdCcpIHtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goJ21pbmltdW0nKTtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goJ3ExJyk7XG4gICAgICAgICAgY29sdW1ucy5wdXNoKCdtZWRpYW4nKTtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goJ3EzJyk7XG4gICAgICAgICAgY29sdW1ucy5wdXNoKCdtYXhpbXVtJyk7XG4gICAgICAgIH0gZWxzZSBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICAgIGNvbHVtbnMucHVzaCgnb3BlbicpO1xuICAgICAgICAgIGNvbHVtbnMucHVzaCgnaGlnaCcpO1xuICAgICAgICAgIGNvbHVtbnMucHVzaCgnbG93Jyk7XG4gICAgICAgICAgY29sdW1ucy5wdXNoKCdjbG9zZScpO1xuICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYW5nZUJhcicpIHtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goJ21pbmltdW0nKTtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goJ21heGltdW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXMubWFwKGZ1bmN0aW9uIChzLCBzSSkge1xuICAgICAgICAgICAgdmFyIHNuYW1lID0gKHMubmFtZSA/IHMubmFtZSA6IFwic2VyaWVzLVwiLmNvbmNhdChzSSkpICsgJyc7XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goc25hbWUuc3BsaXQoY29sdW1uRGVsaW1pdGVyKS5qb2luKCcnKSA/IHNuYW1lLnNwbGl0KGNvbHVtbkRlbGltaXRlcikuam9pbignJykgOiBcInNlcmllcy1cIi5jb25jYXQoc0kpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICBjb2x1bW5zLnB1c2gody5jb25maWcuY2hhcnQudG9vbGJhci5leHBvcnQuY3N2LmhlYWRlclZhbHVlKTtcbiAgICAgICAgICByb3dzLnB1c2goY29sdW1ucy5qb2luKGNvbHVtbkRlbGltaXRlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWVzLm1hcChmdW5jdGlvbiAocywgc0kpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAgIGhhbmRsZUF4aXNSb3dzQ29sdW1ucyhzLCBzSSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh3Lmdsb2JhbHMubGFiZWxzW3NJXS5zcGxpdChjb2x1bW5EZWxpbWl0ZXIpLmpvaW4oJycpKTtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaChnU2VyaWVzW3NJXSk7XG4gICAgICAgICAgICByb3dzLnB1c2goY29sdW1ucy5qb2luKGNvbHVtbkRlbGltaXRlcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCArPSByb3dzLmpvaW4obGluZURlbGltaXRlcik7XG4gICAgICAgIHRoaXMudHJpZ2dlckRvd25sb2FkKCdkYXRhOnRleHQvY3N2OyBjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQodW5pdmVyc2FsQk9NICsgcmVzdWx0KSwgZmlsZU5hbWUgPyBmaWxlTmFtZSA6IHcuY29uZmlnLmNoYXJ0LnRvb2xiYXIuZXhwb3J0LmNzdi5maWxlbmFtZSwgJy5jc3YnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidHJpZ2dlckRvd25sb2FkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdHJpZ2dlckRvd25sb2FkKGhyZWYsIGZpbGVuYW1lLCBleHQpIHtcbiAgICAgICAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSBocmVmO1xuICAgICAgICBkb3dubG9hZExpbmsuZG93bmxvYWQgPSAoZmlsZW5hbWUgPyBmaWxlbmFtZSA6IHRoaXMudy5nbG9iYWxzLmNoYXJ0SUQpICsgZXh0O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkTGluayk7XG4gICAgICAgIGRvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkTGluayk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEV4cG9ydHM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBYQXhpcyBDbGFzcyBmb3IgZHJhd2luZyBYLUF4aXMuXG4gICAqXG4gICAqIEBtb2R1bGUgWEF4aXNcbiAgICoqL1xuXG4gIHZhciBYQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWEF4aXMoY3R4LCBlbGdyaWQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYQXhpcyk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy5lbGdyaWQgPSBlbGdyaWQ7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5heGVzVXRpbHMgPSBuZXcgQXhlc1V0aWxzKGN0eCk7XG4gICAgICB0aGlzLnhheGlzTGFiZWxzID0gdy5nbG9iYWxzLmxhYmVscy5zbGljZSgpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnRpbWVzY2FsZUxhYmVscy5sZW5ndGggPiAwICYmICF3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vICB0aW1lbGluZSBsYWJlbHMgYXJlIHRoZXJlIGFuZCBjaGFydCBpcyBub3QgcmFuZ2VhYnIgdGltZWxpbmVcbiAgICAgICAgdGhpcy54YXhpc0xhYmVscyA9IHcuZ2xvYmFscy50aW1lc2NhbGVMYWJlbHMuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLm92ZXJ3cml0ZUNhdGVnb3JpZXMpIHtcbiAgICAgICAgdGhpcy54YXhpc0xhYmVscyA9IHcuY29uZmlnLnhheGlzLm92ZXJ3cml0ZUNhdGVnb3JpZXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhd25MYWJlbHMgPSBbXTtcbiAgICAgIHRoaXMuZHJhd25MYWJlbHNSZWN0cyA9IFtdO1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIHRoaXMub2ZmWSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9mZlkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2ZmWSA9IHRoaXMub2ZmWSArIHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIub2Zmc2V0WTtcbiAgICAgIHRoaXMuaXNDYXRlZ29yeUJhckhvcml6b250YWwgPSB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbDtcbiAgICAgIHRoaXMueGF4aXNGb250U2l6ZSA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250U2l6ZTtcbiAgICAgIHRoaXMueGF4aXNGb250RmFtaWx5ID0gdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICB0aGlzLnhheGlzRm9yZUNvbG9ycyA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5jb2xvcnM7XG4gICAgICB0aGlzLnhheGlzQm9yZGVyV2lkdGggPSB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLndpZHRoO1xuXG4gICAgICBpZiAodGhpcy5pc0NhdGVnb3J5QmFySG9yaXpvbnRhbCkge1xuICAgICAgICB0aGlzLnhheGlzQm9yZGVyV2lkdGggPSB3LmNvbmZpZy55YXhpc1swXS5heGlzQm9yZGVyLndpZHRoLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnhheGlzQm9yZGVyV2lkdGguaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgICAgdGhpcy54YXhpc0JvcmRlcldpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAqIHBhcnNlSW50KHRoaXMueGF4aXNCb3JkZXJXaWR0aCwgMTApIC8gMTAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54YXhpc0JvcmRlcldpZHRoID0gcGFyc2VJbnQodGhpcy54YXhpc0JvcmRlcldpZHRoLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueGF4aXNCb3JkZXJIZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLmhlaWdodDsgLy8gRm9yIGJhcnMsIHdlIHdpbGwgb25seSBjb25zaWRlciBzaW5nbGUgeSB4YWlzLFxuICAgICAgLy8gYXMgd2UgYXJlIG5vdCBwcm92aWRpbmcgbXVsdGlwbGUgeWF4aXMgZm9yIGJhciBjaGFydHNcblxuICAgICAgdGhpcy55YXhpcyA9IHcuY29uZmlnLnlheGlzWzBdO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhYQXhpcywgW3tcbiAgICAgIGtleTogXCJkcmF3WGF4aXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WGF4aXMoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgZWxYYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMnLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHcuY29uZmlnLnhheGlzLm9mZnNldFgsIFwiLCBcIikuY29uY2F0KHcuY29uZmlnLnhheGlzLm9mZnNldFksIFwiKVwiKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVsWGF4aXNUZXh0cyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMtdGV4dHMtZycsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWCwgXCIsIFwiKS5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWSwgXCIpXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBlbFhheGlzLmFkZChlbFhheGlzVGV4dHMpO1xuICAgICAgICB2YXIgbGFiZWxzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhheGlzTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGFiZWxzLnB1c2godGhpcy54YXhpc0xhYmVsc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYXdYQXhpc0xhYmVsQW5kR3JvdXAodHJ1ZSwgZ3JhcGhpY3MsIGVsWGF4aXNUZXh0cywgbGFiZWxzLCB3Lmdsb2JhbHMuaXNYTnVtZXJpYywgZnVuY3Rpb24gKGksIGNvbFdpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbFdpZHRoO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmhhc1hheGlzR3JvdXBzKSB7XG4gICAgICAgICAgdmFyIGxhYmVsc0dyb3VwID0gdy5nbG9iYWxzLmdyb3VwcztcbiAgICAgICAgICBsYWJlbHMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYWJlbHNHcm91cC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKGxhYmVsc0dyb3VwW19pXS50aXRsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG92ZXJ3cml0ZVN0eWxlcyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmdyb3VwLnN0eWxlKSB7XG4gICAgICAgICAgICBvdmVyd3JpdGVTdHlsZXMueGF4aXNGb250U2l6ZSA9IHcuY29uZmlnLnhheGlzLmdyb3VwLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgICAgb3ZlcndyaXRlU3R5bGVzLnhheGlzRm9udEZhbWlseSA9IHcuY29uZmlnLnhheGlzLmdyb3VwLnN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICBvdmVyd3JpdGVTdHlsZXMueGF4aXNGb3JlQ29sb3JzID0gdy5jb25maWcueGF4aXMuZ3JvdXAuc3R5bGUuY29sb3JzO1xuICAgICAgICAgICAgb3ZlcndyaXRlU3R5bGVzLmZvbnRXZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5ncm91cC5zdHlsZS5mb250V2VpZ2h0O1xuICAgICAgICAgICAgb3ZlcndyaXRlU3R5bGVzLmNzc0NsYXNzID0gdy5jb25maWcueGF4aXMuZ3JvdXAuc3R5bGUuY3NzQ2xhc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kcmF3WEF4aXNMYWJlbEFuZEdyb3VwKGZhbHNlLCBncmFwaGljcywgZWxYYXhpc1RleHRzLCBsYWJlbHMsIGZhbHNlLCBmdW5jdGlvbiAoaSwgY29sV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNHcm91cFtpXS5jb2xzICogY29sV2lkdGg7XG4gICAgICAgICAgfSwgb3ZlcndyaXRlU3R5bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZWxYYXhpc1RpdGxlID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBlbFhBeGlzVGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIgKyB3LmNvbmZpZy54YXhpcy50aXRsZS5vZmZzZXRYLFxuICAgICAgICAgICAgeTogdGhpcy5vZmZZICsgcGFyc2VGbG9hdCh0aGlzLnhheGlzRm9udFNpemUpICsgKHcuY29uZmlnLnhheGlzLnBvc2l0aW9uID09PSAnYm90dG9tJyA/IHcuZ2xvYmFscy54QXhpc0xhYmVsc0hlaWdodCA6IC13Lmdsb2JhbHMueEF4aXNMYWJlbHNIZWlnaHQgLSAxMCkgKyB3LmNvbmZpZy54YXhpcy50aXRsZS5vZmZzZXRZLFxuICAgICAgICAgICAgdGV4dDogdy5jb25maWcueGF4aXMudGl0bGUudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgZm9udFNpemU6IHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICBmb3JlQ29sb3I6IHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlLXRleHQgJyArIHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxYYXhpc1RpdGxlLmFkZChlbFhBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgICBlbFhheGlzLmFkZChlbFhheGlzVGl0bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIuc2hvdykge1xuICAgICAgICAgIHZhciBvZmZYID0gdy5nbG9iYWxzLmJhclBhZEZvck51bWVyaWNBeGlzO1xuICAgICAgICAgIHZhciBlbEhvcnpMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwgKyB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLm9mZnNldFggLSBvZmZYLCB0aGlzLm9mZlksIHRoaXMueGF4aXNCb3JkZXJXaWR0aCArIG9mZlgsIHRoaXMub2ZmWSwgdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci5jb2xvciwgMCwgdGhpcy54YXhpc0JvcmRlckhlaWdodCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5lbGdyaWQgJiYgdGhpcy5lbGdyaWQuZWxHcmlkQm9yZGVycyAmJiB3LmNvbmZpZy5ncmlkLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuZWxncmlkLmVsR3JpZEJvcmRlcnMuYWRkKGVsSG9yekxpbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbFhheGlzLmFkZChlbEhvcnpMaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxYYXhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1hBeGlzTGFiZWxBbmRHcm91cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYQXhpc0xhYmVsQW5kR3JvdXAoaXNMZWFmR3JvdXAsIGdyYXBoaWNzLCBlbFhheGlzVGV4dHMsIGxhYmVscywgaXNYTnVtZXJpYywgY29sV2lkdGhDYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvdmVyd3JpdGVTdHlsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHt9O1xuICAgICAgICB2YXIgZHJhd25MYWJlbHMgPSBbXTtcbiAgICAgICAgdmFyIGRyYXduTGFiZWxzUmVjdHMgPSBbXTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4YXhpc0ZvbnRTaXplID0gb3ZlcndyaXRlU3R5bGVzLnhheGlzRm9udFNpemUgfHwgdGhpcy54YXhpc0ZvbnRTaXplO1xuICAgICAgICB2YXIgeGF4aXNGb250RmFtaWx5ID0gb3ZlcndyaXRlU3R5bGVzLnhheGlzRm9udEZhbWlseSB8fCB0aGlzLnhheGlzRm9udEZhbWlseTtcbiAgICAgICAgdmFyIHhheGlzRm9yZUNvbG9ycyA9IG92ZXJ3cml0ZVN0eWxlcy54YXhpc0ZvcmVDb2xvcnMgfHwgdGhpcy54YXhpc0ZvcmVDb2xvcnM7XG4gICAgICAgIHZhciBmb250V2VpZ2h0ID0gb3ZlcndyaXRlU3R5bGVzLmZvbnRXZWlnaHQgfHwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRXZWlnaHQ7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9IG92ZXJ3cml0ZVN0eWxlcy5jc3NDbGFzcyB8fCB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY3NzQ2xhc3M7XG4gICAgICAgIHZhciBjb2xXaWR0aDsgLy8gaW5pdGlhbCB4IFBvc2l0aW9uIChrZWVwIGFkZGluZyBjb2x1bW4gd2lkdGggaW4gdGhlIGxvb3ApXG5cbiAgICAgICAgdmFyIHhQb3MgPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbDtcbiAgICAgICAgdmFyIGxhYmVsc0xlbiA9IGxhYmVscy5sZW5ndGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsYWJlbHNMZW4gY2FuIGJlIGRpZmZlcmVudCAod2hldGhlciB5b3UgYXJlIGRyYXdpbmcgeC1heGlzIGxhYmVscyBvciB4LWF4aXMgZ3JvdXAgbGFiZWxzKVxuICAgICAgICAgKiBoZW5jZSwgd2UgaW50cm9kdWNlIGRhdGFQb2ludHMgdG8gYmUgY29uc2lzdGVudC5cbiAgICAgICAgICogQWxzbywgaW4gZGF0ZXRpbWUvbnVtZXJpYyB4YXhpcywgZGF0YVBvaW50cyBjYW4gYmUgbWlzbGVhZGluZywgc28gd2UgcmVzb3J0IHRvIGxhYmVsc0xlbiBmb3Igc3VjaCB4YXhpcyB0eXBlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBkYXRhUG9pbnRzID0gdy5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IHcuZ2xvYmFscy5kYXRhUG9pbnRzIDogbGFiZWxzTGVuOyAvLyB3aGVuIGFsbCBzZXJpZXMgYXJlIGNvbGxhcHNlZCwgZml4ZXMgIzMzODFcblxuICAgICAgICBpZiAoZGF0YVBvaW50cyA9PT0gMCAmJiBsYWJlbHNMZW4gPiBkYXRhUG9pbnRzKSBkYXRhUG9pbnRzID0gbGFiZWxzTGVuO1xuXG4gICAgICAgIGlmIChpc1hOdW1lcmljKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IGRhdGFQb2ludHMgPiAxID8gZGF0YVBvaW50cyAtIDEgOiBkYXRhUG9pbnRzO1xuICAgICAgICAgIGNvbFdpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIE1hdGgubWluKGxlbiwgbGFiZWxzTGVuIC0gMSk7XG4gICAgICAgICAgeFBvcyA9IHhQb3MgKyBjb2xXaWR0aENiKDAsIGNvbFdpZHRoKSAvIDIgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyBkYXRhUG9pbnRzO1xuICAgICAgICAgIHhQb3MgPSB4UG9zICsgY29sV2lkdGhDYigwLCBjb2xXaWR0aCkgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICB2YXIgeCA9IHhQb3MgLSBjb2xXaWR0aENiKGksIGNvbFdpZHRoKSAvIDIgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WDtcblxuICAgICAgICAgIGlmIChpID09PSAwICYmIGxhYmVsc0xlbiA9PT0gMSAmJiBjb2xXaWR0aCAvIDIgPT09IHhQb3MgJiYgZGF0YVBvaW50cyA9PT0gMSkge1xuICAgICAgICAgICAgLy8gc2luZ2xlIGRhdGFwb2ludFxuICAgICAgICAgICAgeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsYWJlbCA9IF90aGlzLmF4ZXNVdGlscy5nZXRMYWJlbChsYWJlbHMsIHcuZ2xvYmFscy50aW1lc2NhbGVMYWJlbHMsIHgsIGksIGRyYXduTGFiZWxzLCB4YXhpc0ZvbnRTaXplLCBpc0xlYWZHcm91cCk7XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0WUNvcnJlY3Rpb24gPSAyODtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMucm90YXRlWExhYmVscyAmJiBpc0xlYWZHcm91cCkge1xuICAgICAgICAgICAgb2Zmc2V0WUNvcnJlY3Rpb24gPSAyMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMudGl0bGUudGV4dCAmJiB3LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIG9mZnNldFlDb3JyZWN0aW9uICs9IHBhcnNlRmxvYXQody5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udFNpemUpICsgMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzTGVhZkdyb3VwKSB7XG4gICAgICAgICAgICBvZmZzZXRZQ29ycmVjdGlvbiA9IG9mZnNldFlDb3JyZWN0aW9uICsgcGFyc2VGbG9hdCh4YXhpc0ZvbnRTaXplKSArICh3Lmdsb2JhbHMueEF4aXNMYWJlbHNIZWlnaHQgLSB3Lmdsb2JhbHMueEF4aXNHcm91cExhYmVsc0hlaWdodCkgKyAody5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyAxMCA6IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0NhdGVnb3J5VGlja0Ftb3VudHMgPSB0eXBlb2Ygdy5jb25maWcueGF4aXMudGlja0Ftb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdy5jb25maWcueGF4aXMudGlja0Ftb3VudCAhPT0gJ2RhdGFQb2ludHMnICYmIHcuY29uZmlnLnhheGlzLnR5cGUgIT09ICdkYXRldGltZSc7XG5cbiAgICAgICAgICBpZiAoaXNDYXRlZ29yeVRpY2tBbW91bnRzKSB7XG4gICAgICAgICAgICBsYWJlbCA9IF90aGlzLmF4ZXNVdGlscy5jaGVja0xhYmVsQmFzZWRPblRpY2thbW91bnQoaSwgbGFiZWwsIGxhYmVsc0xlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsID0gX3RoaXMuYXhlc1V0aWxzLmNoZWNrRm9yT3ZlcmZsb3dpbmdMYWJlbHMoaSwgbGFiZWwsIGxhYmVsc0xlbiwgZHJhd25MYWJlbHMsIGRyYXduTGFiZWxzUmVjdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBnZXRDYXRGb3JlQ29sb3IgPSBmdW5jdGlvbiBnZXRDYXRGb3JlQ29sb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMZWFmR3JvdXAgJiYgdy5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljID8geGF4aXNGb3JlQ29sb3JzW3cuZ2xvYmFscy5taW5YICsgaSAtIDFdIDogeGF4aXNGb3JlQ29sb3JzW2ldO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLnNob3cpIHtcbiAgICAgICAgICAgIHZhciBlbFRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICAgIHg6IGxhYmVsLngsXG4gICAgICAgICAgICAgIHk6IF90aGlzLm9mZlkgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WSArIG9mZnNldFlDb3JyZWN0aW9uIC0gKHcuY29uZmlnLnhheGlzLnBvc2l0aW9uID09PSAndG9wJyA/IHcuZ2xvYmFscy54QXhpc0hlaWdodCArIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5oZWlnaHQgLSAyIDogMCksXG4gICAgICAgICAgICAgIHRleHQ6IGxhYmVsLnRleHQsXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbC5pc0JvbGQgPyA2MDAgOiBmb250V2VpZ2h0LFxuICAgICAgICAgICAgICBmb250U2l6ZTogeGF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogeGF4aXNGb250RmFtaWx5LFxuICAgICAgICAgICAgICBmb3JlQ29sb3I6IEFycmF5LmlzQXJyYXkoeGF4aXNGb3JlQ29sb3JzKSA/IGdldENhdEZvcmVDb2xvcigpIDogeGF4aXNGb3JlQ29sb3JzLFxuICAgICAgICAgICAgICBpc1BsYWluVGV4dDogZmFsc2UsXG4gICAgICAgICAgICAgIGNzc0NsYXNzOiAoaXNMZWFmR3JvdXAgPyAnYXBleGNoYXJ0cy14YXhpcy1sYWJlbCAnIDogJ2FwZXhjaGFydHMteGF4aXMtZ3JvdXAtbGFiZWwgJykgKyBjc3NDbGFzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbFhheGlzVGV4dHMuYWRkKGVsVGV4dCk7XG4gICAgICAgICAgICBlbFRleHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMueEF4aXNMYWJlbENsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB3LCB7XG4gICAgICAgICAgICAgICAgICBsYWJlbEluZGV4OiBpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnhBeGlzTGFiZWxDbGljayhlLCBfdGhpcy5jdHgsIG9wdHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzTGVhZkdyb3VwKSB7XG4gICAgICAgICAgICAgIHZhciBlbFRvb2x0aXBUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh3Lmdsb2JhbHMuU1ZHTlMsICd0aXRsZScpO1xuICAgICAgICAgICAgICBlbFRvb2x0aXBUaXRsZS50ZXh0Q29udGVudCA9IEFycmF5LmlzQXJyYXkobGFiZWwudGV4dCkgPyBsYWJlbC50ZXh0LmpvaW4oJyAnKSA6IGxhYmVsLnRleHQ7XG4gICAgICAgICAgICAgIGVsVGV4dC5ub2RlLmFwcGVuZENoaWxkKGVsVG9vbHRpcFRpdGxlKTtcblxuICAgICAgICAgICAgICBpZiAobGFiZWwudGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBkcmF3bkxhYmVscy5wdXNoKGxhYmVsLnRleHQpO1xuICAgICAgICAgICAgICAgIGRyYXduTGFiZWxzUmVjdHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA8IGxhYmVsc0xlbiAtIDEpIHtcbiAgICAgICAgICAgIHhQb3MgPSB4UG9zICsgY29sV2lkdGhDYihpICsgMSwgY29sV2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYWJlbHNMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICBfbG9vcChpKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyB0aGlzIGFjdHVhbGx5IGJlY29tZXMgdGhlIHZlcnRpY2FsIGF4aXMgKGZvciBiYXIgY2hhcnRzKVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdYYXhpc0ludmVyc2VkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1hheGlzSW52ZXJzZWQocmVhbEluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlWUF4aXNYID0gdy5jb25maWcueWF4aXNbMF0ub3Bwb3NpdGUgPyB3Lmdsb2JhbHMudHJhbnNsYXRlWUF4aXNYW3JlYWxJbmRleF0gOiAwO1xuICAgICAgICB2YXIgZWxZYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMgYXBleGNoYXJ0cy14YXhpcy1pbnZlcnNlZCcsXG4gICAgICAgICAgcmVsOiByZWFsSW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbFlheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzLXRleHRzLWcgYXBleGNoYXJ0cy14YXhpcy1pbnZlcnNlZC10ZXh0cy1nJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVlBeGlzWCArICcsIDApJ1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpcy5hZGQoZWxZYXhpc1RleHRzKTtcbiAgICAgICAgdmFyIGNvbEhlaWdodDsgLy8gaW5pdGlhbCB4IFBvc2l0aW9uIChrZWVwIGFkZGluZyBjb2x1bW4gd2lkdGggaW4gdGhlIGxvb3ApXG5cbiAgICAgICAgdmFyIHlQb3M7XG4gICAgICAgIHZhciBsYWJlbHMgPSBbXTtcblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5zaG93KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhheGlzTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbHMucHVzaCh0aGlzLnhheGlzTGFiZWxzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb2xIZWlnaHQgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIGxhYmVscy5sZW5ndGg7XG4gICAgICAgIHlQb3MgPSAtKGNvbEhlaWdodCAvIDIuMik7XG4gICAgICAgIHZhciBsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgICB2YXIgeWxhYmVscyA9IHcuY29uZmlnLnlheGlzWzBdLmxhYmVscztcblxuICAgICAgICBpZiAoeWxhYmVscy5zaG93KSB7XG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfaTIpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHR5cGVvZiBsYWJlbHNbX2kyXSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGxhYmVsc1tfaTJdO1xuICAgICAgICAgICAgbGFiZWwgPSBsYkZvcm1hdHRlcihsYWJlbCwge1xuICAgICAgICAgICAgICBzZXJpZXNJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogX2kyLFxuICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHlDb2xvcnMgPSBfdGhpczIuYXhlc1V0aWxzLmdldFlBeGlzRm9yZUNvbG9yKHlsYWJlbHMuc3R5bGUuY29sb3JzLCByZWFsSW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgZ2V0Rm9yZUNvbG9yID0gZnVuY3Rpb24gZ2V0Rm9yZUNvbG9yKCkge1xuICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh5Q29sb3JzKSA/IHlDb2xvcnNbX2kyXSA6IHlDb2xvcnM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbXVsdGlZID0gMDtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgICAgICAgIG11bHRpWSA9IGxhYmVsLmxlbmd0aCAvIDIgKiBwYXJzZUludCh5bGFiZWxzLnN0eWxlLmZvbnRTaXplLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0geWxhYmVscy5vZmZzZXRYIC0gMTU7XG4gICAgICAgICAgICB2YXIgdGV4dEFuY2hvciA9ICdlbmQnO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMyLnlheGlzLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbMF0ubGFiZWxzLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0WCA9IHlsYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLnlheGlzWzBdLmxhYmVscy5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0WCA9IHlsYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy55YXhpc1swXS5sYWJlbHMuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxMYWJlbCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgICAgeDogb2Zmc2V0WCxcbiAgICAgICAgICAgICAgeTogeVBvcyArIGNvbEhlaWdodCArIHlsYWJlbHMub2Zmc2V0WSAtIG11bHRpWSxcbiAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgICAgIGZvcmVDb2xvcjogZ2V0Rm9yZUNvbG9yKCksXG4gICAgICAgICAgICAgIGZvbnRTaXplOiB5bGFiZWxzLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiB5bGFiZWxzLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHlsYWJlbHMuc3R5bGUuZm9udFdlaWdodCxcbiAgICAgICAgICAgICAgaXNQbGFpblRleHQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtbGFiZWwgJyArIHlsYWJlbHMuc3R5bGUuY3NzQ2xhc3MsXG4gICAgICAgICAgICAgIG1heFdpZHRoOiB5bGFiZWxzLm1heFdpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsWWF4aXNUZXh0cy5hZGQoZWxMYWJlbCk7XG4gICAgICAgICAgICBlbExhYmVsLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnhBeGlzTGFiZWxDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdywge1xuICAgICAgICAgICAgICAgICAgbGFiZWxJbmRleDogX2kyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnhBeGlzTGFiZWxDbGljayhlLCBfdGhpczIuY3R4LCBvcHRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZWxUb29sdGlwVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAndGl0bGUnKTtcbiAgICAgICAgICAgIGVsVG9vbHRpcFRpdGxlLnRleHRDb250ZW50ID0gQXJyYXkuaXNBcnJheShsYWJlbCkgPyBsYWJlbC5qb2luKCcgJykgOiBsYWJlbDtcbiAgICAgICAgICAgIGVsTGFiZWwubm9kZS5hcHBlbmRDaGlsZChlbFRvb2x0aXBUaXRsZSk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5yb3RhdGUgIT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIGxhYmVsUm90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIoZWxMYWJlbC5ub2RlKTtcbiAgICAgICAgICAgICAgZWxMYWJlbC5ub2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoXCIuY29uY2F0KHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnJvdGF0ZSwgXCIgMCBcIikuY29uY2F0KGxhYmVsUm90YXRpbmdDZW50ZXIueSwgXCIpXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeVBvcyA9IHlQb3MgKyBjb2xIZWlnaHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8PSBsYWJlbHMubGVuZ3RoIC0gMTsgX2kyKyspIHtcbiAgICAgICAgICAgIF9sb29wMihfaTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZWxYYXhpc1RpdGxlID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzLXRpdGxlIGFwZXhjaGFydHMteGF4aXMtdGl0bGUtaW52ZXJzZWQnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVZQXhpc1ggKyAnLCAwKSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZWxYQXhpc1RpdGxlVGV4dCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgIHg6IHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLm9mZnNldFgsXG4gICAgICAgICAgICB5OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDIgKyB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5vZmZzZXRZLFxuICAgICAgICAgICAgdGV4dDogdy5jb25maWcueWF4aXNbMF0udGl0bGUudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgZm9yZUNvbG9yOiB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5jb2xvcixcbiAgICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzLXRpdGxlLXRleHQgJyArIHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxYYXhpc1RpdGxlLmFkZChlbFhBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgICBlbFlheGlzLmFkZChlbFhheGlzVGl0bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZlggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQ2F0ZWdvcnlCYXJIb3Jpem9udGFsICYmIHcuY29uZmlnLnlheGlzWzBdLm9wcG9zaXRlKSB7XG4gICAgICAgICAgb2ZmWCA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXhpc0JvcmRlciA9IHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXI7XG5cbiAgICAgICAgaWYgKGF4aXNCb3JkZXIuc2hvdykge1xuICAgICAgICAgIHZhciBlbFZlcnRpY2FsTGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgYXhpc0JvcmRlci5vZmZzZXRYICsgb2ZmWCwgMSArIGF4aXNCb3JkZXIub2Zmc2V0WSwgdy5nbG9iYWxzLnBhZEhvcml6b250YWwgKyBheGlzQm9yZGVyLm9mZnNldFggKyBvZmZYLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGF4aXNCb3JkZXIub2Zmc2V0WSwgYXhpc0JvcmRlci5jb2xvciwgMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5lbGdyaWQgJiYgdGhpcy5lbGdyaWQuZWxHcmlkQm9yZGVycyAmJiB3LmNvbmZpZy5ncmlkLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuZWxncmlkLmVsR3JpZEJvcmRlcnMuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxZYXhpcy5hZGQoZWxWZXJ0aWNhbExpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS5heGlzVGlja3Muc2hvdykge1xuICAgICAgICAgIHRoaXMuYXhlc1V0aWxzLmRyYXdZQXhpc1RpY2tzKG9mZlgsIGxhYmVscy5sZW5ndGgsIHcuY29uZmlnLnlheGlzWzBdLmF4aXNCb3JkZXIsIHcuY29uZmlnLnlheGlzWzBdLmF4aXNUaWNrcywgMCwgY29sSGVpZ2h0LCBlbFlheGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbFlheGlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3WGF4aXNUaWNrc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYYXhpc1RpY2tzKHgxLCB5MiwgYXBwZW5kVG9FbGVtZW50KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgeDIgPSB4MTtcbiAgICAgICAgaWYgKHgxIDwgMCB8fCB4MSAtIDIgPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSByZXR1cm47XG4gICAgICAgIHZhciB5MSA9IHRoaXMub2ZmWSArIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5vZmZzZXRZO1xuICAgICAgICB5MiA9IHkyICsgeTEgKyB3LmNvbmZpZy54YXhpcy5heGlzVGlja3MuaGVpZ2h0O1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB5MiA9IHkxIC0gdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5heGlzVGlja3Muc2hvdykge1xuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgICAgdmFyIGxpbmUgPSBncmFwaGljcy5kcmF3TGluZSh4MSArIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5vZmZzZXRYLCB5MSArIHcuY29uZmlnLnhheGlzLm9mZnNldFksIHgyICsgdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLm9mZnNldFgsIHkyICsgdy5jb25maWcueGF4aXMub2Zmc2V0WSwgdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLmNvbG9yKTsgLy8gd2UgYXJlIG5vdCByZXR1cm5pbmcgYW55dGhpbmcsIGJ1dCBhcHBlbmRpbmcgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgcGFzc2VkIGluIHBhcmFtXG5cbiAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQuYWRkKGxpbmUpO1xuICAgICAgICAgIGxpbmUubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXhheGlzLXRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRYQXhpc1RpY2tzUG9zaXRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WEF4aXNUaWNrc1Bvc2l0aW9ucygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4QXhpc1RpY2tzUG9zaXRpb25zID0gW107XG4gICAgICAgIHZhciB4Q291bnQgPSB0aGlzLnhheGlzTGFiZWxzLmxlbmd0aDtcbiAgICAgICAgdmFyIHgxID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWw7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy50aW1lc2NhbGVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHgxID0gdGhpcy54YXhpc0xhYmVsc1tpXS5wb3NpdGlvbjtcbiAgICAgICAgICAgIHhBeGlzVGlja3NQb3NpdGlvbnMucHVzaCh4MSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0cyA9IHhDb3VudDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzOyBfaTMrKykge1xuICAgICAgICAgICAgdmFyIHgxQ291bnQgPSB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0cztcblxuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdiYXInKSB7XG4gICAgICAgICAgICAgIHgxQ291bnQgLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeDEgPSB4MSArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyB4MUNvdW50O1xuICAgICAgICAgICAgeEF4aXNUaWNrc1Bvc2l0aW9ucy5wdXNoKHgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geEF4aXNUaWNrc1Bvc2l0aW9ucztcbiAgICAgIH0gLy8gdG8gcm90YXRlIHgtYXhpcyBsYWJlbHMgb3IgdG8gcHV0IC4uLiBmb3IgbG9uZ2VyIHRleHQgaW4geGF4aXNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ4QXhpc0xhYmVsQ29ycmVjdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB4QXhpc0xhYmVsQ29ycmVjdGlvbnMoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgeEF4aXMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nJyk7XG4gICAgICAgIHZhciB4QXhpc1RleHRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteGF4aXMtdGV4dHMtZyB0ZXh0Om5vdCguYXBleGNoYXJ0cy14YXhpcy1ncm91cC1sYWJlbCknKTtcbiAgICAgICAgdmFyIHlBeGlzVGV4dHNJbnZlcnNlZCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXlheGlzLWludmVyc2VkIHRleHQnKTtcbiAgICAgICAgdmFyIHhBeGlzVGV4dHNJbnZlcnNlZCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXhheGlzLWludmVyc2VkLXRleHRzLWcgdGV4dCB0c3BhbicpO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMucm90YXRlWExhYmVscyB8fCB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlQWx3YXlzKSB7XG4gICAgICAgICAgZm9yICh2YXIgeGF0ID0gMDsgeGF0IDwgeEF4aXNUZXh0cy5sZW5ndGg7IHhhdCsrKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFJvdGF0aW5nQ2VudGVyID0gZ3JhcGhpY3Mucm90YXRlQXJvdW5kQ2VudGVyKHhBeGlzVGV4dHNbeGF0XSk7XG4gICAgICAgICAgICB0ZXh0Um90YXRpbmdDZW50ZXIueSA9IHRleHRSb3RhdGluZ0NlbnRlci55IC0gMTsgLy8gKyB0aWNrV2lkdGgvNDtcblxuICAgICAgICAgICAgdGV4dFJvdGF0aW5nQ2VudGVyLnggPSB0ZXh0Um90YXRpbmdDZW50ZXIueCArIDE7XG4gICAgICAgICAgICB4QXhpc1RleHRzW3hhdF0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInJvdGF0ZShcIi5jb25jYXQody5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdCh0ZXh0Um90YXRpbmdDZW50ZXIueCwgXCIgXCIpLmNvbmNhdCh0ZXh0Um90YXRpbmdDZW50ZXIueSwgXCIpXCIpKTtcbiAgICAgICAgICAgIHhBeGlzVGV4dHNbeGF0XS5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgXCJlbmRcIik7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gMTA7XG4gICAgICAgICAgICB4QXhpcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwidHJhbnNsYXRlKDAsIFwiLmNvbmNhdCgtb2Zmc2V0SGVpZ2h0LCBcIilcIikpO1xuICAgICAgICAgICAgdmFyIHRTcGFuID0geEF4aXNUZXh0c1t4YXRdLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMudHJpbSkge1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRTcGFuLCBmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgICAgICAgICBncmFwaGljcy5wbGFjZVRleHRXaXRoRWxsaXBzaXModHMsIHRzLnRleHRDb250ZW50LCB3Lmdsb2JhbHMueEF4aXNMYWJlbHNIZWlnaHQgLSAody5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAnYm90dG9tJyA/IDIwIDogMTApKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gKHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoICsgMSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF94YXQgPSAwOyBfeGF0IDwgeEF4aXNUZXh0cy5sZW5ndGg7IF94YXQrKykge1xuICAgICAgICAgICAgICB2YXIgX3RTcGFuID0geEF4aXNUZXh0c1tfeGF0XS5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMudHJpbSAmJiB3LmNvbmZpZy54YXhpcy50eXBlICE9PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChfdFNwYW4sIGZ1bmN0aW9uICh0cykge1xuICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MucGxhY2VUZXh0V2l0aEVsbGlwc2lzKHRzLCB0cy50ZXh0Q29udGVudCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHRydW5jYXRlIHJvdGF0ZWQgeSBheGlzIGluIGJhciBjaGFydCAoeCBheGlzKVxuICAgICAgICAgIHZhciBmaXJzdExhYmVsUG9zWCA9IHlBeGlzVGV4dHNJbnZlcnNlZFt5QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoIC0gMV0uZ2V0QkJveCgpO1xuICAgICAgICAgIHZhciBsYXN0TGFiZWxQb3NYID0geUF4aXNUZXh0c0ludmVyc2VkWzBdLmdldEJCb3goKTtcblxuICAgICAgICAgIGlmIChmaXJzdExhYmVsUG9zWC54IDwgLTIwKSB7XG4gICAgICAgICAgICB5QXhpc1RleHRzSW52ZXJzZWRbeUF4aXNUZXh0c0ludmVyc2VkLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeUF4aXNUZXh0c0ludmVyc2VkW3lBeGlzVGV4dHNJbnZlcnNlZC5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhc3RMYWJlbFBvc1gueCArIGxhc3RMYWJlbFBvc1gud2lkdGggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoICYmICF3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB5QXhpc1RleHRzSW52ZXJzZWRbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh5QXhpc1RleHRzSW52ZXJzZWRbMF0pO1xuICAgICAgICAgIH0gLy8gdHJ1bmNhdGUgcm90YXRlZCB4IGF4aXMgaW4gYmFyIGNoYXJ0ICh5IGF4aXMpXG5cblxuICAgICAgICAgIGZvciAodmFyIF94YXQyID0gMDsgX3hhdDIgPCB4QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoOyBfeGF0MisrKSB7XG4gICAgICAgICAgICBncmFwaGljcy5wbGFjZVRleHRXaXRoRWxsaXBzaXMoeEF4aXNUZXh0c0ludmVyc2VkW194YXQyXSwgeEF4aXNUZXh0c0ludmVyc2VkW194YXQyXS50ZXh0Q29udGVudCwgdy5jb25maWcueWF4aXNbMF0ubGFiZWxzLm1heFdpZHRoIC0gKHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnRleHQgPyBwYXJzZUZsb2F0KHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmZvbnRTaXplKSAqIDIgOiAwKSAtIDE1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmVuZGVyWEF4aXNCYW5kcygpIHtcbiAgICAgIC8vICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgICAvLyAgIGxldCBwbG90QmFuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh3Lmdsb2JhbHMuU1ZHTlMsICdyZWN0JylcbiAgICAgIC8vICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQocGxvdEJhbmQpXG4gICAgICAvLyB9XG5cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gWEF4aXM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBHcmlkIENsYXNzIGZvciBkcmF3aW5nIENhcnRlc2lhbiBHcmlkLlxuICAgKlxuICAgKiBAbW9kdWxlIEdyaWRcbiAgICoqL1xuXG4gIHZhciBHcmlkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmlkKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyaWQpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLnhheGlzTGFiZWxzID0gdy5nbG9iYWxzLmxhYmVscy5zbGljZSgpO1xuICAgICAgdGhpcy5heGVzVXRpbHMgPSBuZXcgQXhlc1V0aWxzKGN0eCk7XG4gICAgICB0aGlzLmlzUmFuZ2VCYXIgPSB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2UubGVuZ3RoICYmIHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWw7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMudGltZXNjYWxlTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gIHRpbWVzY2FsZUxhYmVscyBsYWJlbHMgYXJlIHRoZXJlXG4gICAgICAgIHRoaXMueGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMudGltZXNjYWxlTGFiZWxzLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfSAvLyB3aGVuIHVzaW5nIHNwYXJrbGluZXMgb3Igd2hlbiBzaG93aW5nIG5vIGdyaWQsIHdlIG5lZWQgdG8gaGF2ZSBhIGdyaWQgYXJlYSB3aGljaCBpcyByZXVzZWQgYXQgbWFueSBwbGFjZXMgZm9yIG90aGVyIGNhbGN1bGF0aW9ucyBhcyB3ZWxsXG5cblxuICAgIF9jcmVhdGVDbGFzcyhHcmlkLCBbe1xuICAgICAga2V5OiBcImRyYXdHcmlkQXJlYVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmlkQXJlYSgpIHtcbiAgICAgICAgdmFyIGVsR3JpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG5cbiAgICAgICAgaWYgKGVsR3JpZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGVsR3JpZCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1ncmlkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsVmVydGljYWxMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwsIDEsIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgJ3RyYW5zcGFyZW50Jyk7XG4gICAgICAgIHZhciBlbEhvcnpMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwsIHcuZ2xvYmFscy5ncmlkSGVpZ2h0LCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgJ3RyYW5zcGFyZW50Jyk7XG4gICAgICAgIGVsR3JpZC5hZGQoZWxIb3J6TGluZSk7XG4gICAgICAgIGVsR3JpZC5hZGQoZWxWZXJ0aWNhbExpbmUpO1xuICAgICAgICByZXR1cm4gZWxHcmlkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3R3JpZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmlkKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgICAgdmFyIGVsZ3JpZCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAvLyBncmlkIGlzIGRyYXduIGFmdGVyIHhheGlzIGFuZCB5YXhpcyBhcmUgZHJhd25cbiAgICAgICAgICBlbGdyaWQgPSB0aGlzLnJlbmRlckdyaWQoKTtcbiAgICAgICAgICB0aGlzLmRyYXdHcmlkQXJlYShlbGdyaWQuZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZ3JpZDtcbiAgICAgIH0gLy8gVGhpcyBtYXNrIHdpbGwgY2xpcCBvZmYgb3ZlcmZsb3dpbmcgZ3JhcGhpY3MgZnJvbSB0aGUgZHJhd2FibGUgYXJlYVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNyZWF0ZUdyaWRNYXNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlR3JpZE1hc2soKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBzdHJva2VTaXplID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpID8gMCA6IHcuY29uZmlnLnN0cm9rZS53aWR0aDtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpKSB7XG4gICAgICAgICAgdmFyIHN0cm9rZU1heFNpemUgPSAwO1xuICAgICAgICAgIHcuY29uZmlnLnN0cm9rZS53aWR0aC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBzdHJva2VNYXhTaXplID0gTWF0aC5tYXgoc3Ryb2tlTWF4U2l6ZSwgbSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Ryb2tlU2l6ZSA9IHN0cm9rZU1heFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5kb20uZWxHcmlkUmVjdE1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZ2wuU1ZHTlMsICdjbGlwUGF0aCcpO1xuICAgICAgICBnbC5kb20uZWxHcmlkUmVjdE1hc2suc2V0QXR0cmlidXRlKCdpZCcsIFwiZ3JpZFJlY3RNYXNrXCIuY29uY2F0KGdsLmN1aWQpKTtcbiAgICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGdsLlNWR05TLCAnY2xpcFBhdGgnKTtcbiAgICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBcImdyaWRSZWN0TWFya2VyTWFza1wiLmNvbmNhdChnbC5jdWlkKSk7XG4gICAgICAgIGdsLmRvbS5lbEZvcmVjYXN0TWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhnbC5TVkdOUywgJ2NsaXBQYXRoJyk7XG4gICAgICAgIGdsLmRvbS5lbEZvcmVjYXN0TWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgXCJmb3JlY2FzdE1hc2tcIi5jb25jYXQoZ2wuY3VpZCkpO1xuICAgICAgICBnbC5kb20uZWxOb25Gb3JlY2FzdE1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZ2wuU1ZHTlMsICdjbGlwUGF0aCcpO1xuICAgICAgICBnbC5kb20uZWxOb25Gb3JlY2FzdE1hc2suc2V0QXR0cmlidXRlKCdpZCcsIFwibm9uRm9yZWNhc3RNYXNrXCIuY29uY2F0KGdsLmN1aWQpKTsgLy8gbGV0IGJhckhhbGZXaWR0aCA9IDBcblxuICAgICAgICB2YXIgdHlwZSA9IHcuY29uZmlnLmNoYXJ0LnR5cGU7XG4gICAgICAgIHZhciBoYXNCYXIgPSB0eXBlID09PSAnYmFyJyB8fCB0eXBlID09PSAncmFuZ2VCYXInIHx8IHR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgdHlwZSA9PT0gJ2JveFBsb3QnIHx8IHcuZ2xvYmFscy5jb21ib0JhckNvdW50ID4gMDtcbiAgICAgICAgdmFyIGJhcldpZHRoTGVmdCA9IDA7XG4gICAgICAgIHZhciBiYXJXaWR0aFJpZ2h0ID0gMDtcblxuICAgICAgICBpZiAoaGFzQmFyICYmIHcuZ2xvYmFscy5pc1hOdW1lcmljICYmICF3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgYmFyV2lkdGhMZWZ0ID0gdy5jb25maWcuZ3JpZC5wYWRkaW5nLmxlZnQ7XG4gICAgICAgICAgYmFyV2lkdGhSaWdodCA9IHcuY29uZmlnLmdyaWQucGFkZGluZy5yaWdodDtcblxuICAgICAgICAgIGlmIChnbC5iYXJQYWRGb3JOdW1lcmljQXhpcyA+IGJhcldpZHRoTGVmdCkge1xuICAgICAgICAgICAgYmFyV2lkdGhMZWZ0ID0gZ2wuYmFyUGFkRm9yTnVtZXJpY0F4aXM7XG4gICAgICAgICAgICBiYXJXaWR0aFJpZ2h0ID0gZ2wuYmFyUGFkRm9yTnVtZXJpY0F4aXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2wuZG9tLmVsR3JpZFJlY3QgPSBncmFwaGljcy5kcmF3UmVjdCgtc3Ryb2tlU2l6ZSAvIDIgLSBiYXJXaWR0aExlZnQgLSAyLCAtc3Ryb2tlU2l6ZSAvIDIsIGdsLmdyaWRXaWR0aCArIHN0cm9rZVNpemUgKyBiYXJXaWR0aFJpZ2h0ICsgYmFyV2lkdGhMZWZ0ICsgNCwgZ2wuZ3JpZEhlaWdodCArIHN0cm9rZVNpemUsIDAsICcjZmZmJyk7XG4gICAgICAgIHZhciBtYXJrZXJTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMubGFyZ2VzdFNpemUgKyAxO1xuICAgICAgICBnbC5kb20uZWxHcmlkUmVjdE1hcmtlciA9IGdyYXBoaWNzLmRyYXdSZWN0KC1tYXJrZXJTaXplICogMiwgLW1hcmtlclNpemUgKiAyLCBnbC5ncmlkV2lkdGggKyBtYXJrZXJTaXplICogNCwgZ2wuZ3JpZEhlaWdodCArIG1hcmtlclNpemUgKiA0LCAwLCAnI2ZmZicpO1xuICAgICAgICBnbC5kb20uZWxHcmlkUmVjdE1hc2suYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsR3JpZFJlY3Qubm9kZSk7XG4gICAgICAgIGdsLmRvbS5lbEdyaWRSZWN0TWFya2VyTWFzay5hcHBlbmRDaGlsZChnbC5kb20uZWxHcmlkUmVjdE1hcmtlci5ub2RlKTtcbiAgICAgICAgdmFyIGRlZnMgPSBnbC5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJ2RlZnMnKTtcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChnbC5kb20uZWxHcmlkUmVjdE1hc2spO1xuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGdsLmRvbS5lbEZvcmVjYXN0TWFzayk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsTm9uRm9yZWNhc3RNYXNrKTtcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChnbC5kb20uZWxHcmlkUmVjdE1hcmtlck1hc2spO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZHJhd0dyaWRMaW5lc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3R3JpZExpbmVzKF9yZWYpIHtcbiAgICAgICAgdmFyIGkgPSBfcmVmLmksXG4gICAgICAgICAgICB4MSA9IF9yZWYueDEsXG4gICAgICAgICAgICB5MSA9IF9yZWYueTEsXG4gICAgICAgICAgICB4MiA9IF9yZWYueDIsXG4gICAgICAgICAgICB5MiA9IF9yZWYueTIsXG4gICAgICAgICAgICB4Q291bnQgPSBfcmVmLnhDb3VudCxcbiAgICAgICAgICAgIHBhcmVudCA9IF9yZWYucGFyZW50O1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICB2YXIgc2hvdWxkRHJhdyA9IGZ1bmN0aW9uIHNob3VsZERyYXcoKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDAgJiYgdy5nbG9iYWxzLnNraXBGaXJzdFRpbWVsaW5lbGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0geENvdW50IC0gMSAmJiB3Lmdsb2JhbHMuc2tpcExhc3RUaW1lbGluZWxhYmVsICYmICF3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYWRhcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc2hvdWxkRHJhdygpKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueGF4aXMubGluZXMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0dyaWRMaW5lKHtcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgeTI6IHkyLFxuICAgICAgICAgICAgICB4Q291bnQ6IHhDb3VudCxcbiAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB5XzIgPSAwO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5oYXNYYXhpc0dyb3VwcyAmJiB3LmNvbmZpZy54YXhpcy50aWNrUGxhY2VtZW50ID09PSAnYmV0d2VlbicpIHtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSB3Lmdsb2JhbHMuZ3JvdXBzO1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgICAgICAgIHZhciBnYWNjID0gMDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBnaSA9IDA7IGdhY2MgPCBpICYmIGdpIDwgZ3JvdXBzLmxlbmd0aDsgZ2krKykge1xuICAgICAgICAgICAgICAgIGdhY2MgKz0gZ3JvdXBzW2dpXS5jb2xzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGdhY2MgPT09IGkpIHtcbiAgICAgICAgICAgICAgICB5XzIgPSB3Lmdsb2JhbHMueEF4aXNMYWJlbHNIZWlnaHQgKiAwLjY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeEF4aXMgPSBuZXcgWEF4aXModGhpcy5jdHgpO1xuICAgICAgICAgIHhBeGlzLmRyYXdYYXhpc1RpY2tzKHgxLCB5XzIsIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9kcmF3R3JpZExpbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0dyaWRMaW5lKF9yZWYyKSB7XG4gICAgICAgIHZhciBpID0gX3JlZjIuaSxcbiAgICAgICAgICAgIHgxID0gX3JlZjIueDEsXG4gICAgICAgICAgICB5MSA9IF9yZWYyLnkxLFxuICAgICAgICAgICAgeDIgPSBfcmVmMi54MixcbiAgICAgICAgICAgIHkyID0gX3JlZjIueTIsXG4gICAgICAgICAgICB4Q291bnQgPSBfcmVmMi54Q291bnQsXG4gICAgICAgICAgICBwYXJlbnQgPSBfcmVmMi5wYXJlbnQ7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZXhjbHVkZUJvcmRlcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzSG9yekxpbmUgPSBwYXJlbnQubm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtZ3JpZGxpbmVzLWhvcml6b250YWwnKTtcbiAgICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IHcuY29uZmlnLmdyaWQuc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgICB2YXIgb2ZmWCA9IHcuZ2xvYmFscy5iYXJQYWRGb3JOdW1lcmljQXhpcztcblxuICAgICAgICBpZiAoeTEgPT09IDAgJiYgeTIgPT09IDAgfHwgeDEgPT09IDAgJiYgeDIgPT09IDApIHtcbiAgICAgICAgICBleGNsdWRlQm9yZGVycyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeTEgPT09IHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICYmIHkyID09PSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkge1xuICAgICAgICAgIGV4Y2x1ZGVCb3JkZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsICYmIChpID09PSAwIHx8IGkgPT09IHhDb3VudCAtIDEpKSB7XG4gICAgICAgICAgZXhjbHVkZUJvcmRlcnMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMpO1xuICAgICAgICB2YXIgbGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHgxIC0gKGlzSG9yekxpbmUgPyBvZmZYIDogMCksIHkxLCB4MiArIChpc0hvcnpMaW5lID8gb2ZmWCA6IDApLCB5Miwgdy5jb25maWcuZ3JpZC5ib3JkZXJDb2xvciwgc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgICAgbGluZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZGxpbmUnKTtcblxuICAgICAgICBpZiAoZXhjbHVkZUJvcmRlcnMgJiYgdy5jb25maWcuZ3JpZC5zaG93KSB7XG4gICAgICAgICAgdGhpcy5lbEdyaWRCb3JkZXJzLmFkZChsaW5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnQuYWRkKGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9kcmF3R3JpZEJhbmRSZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdHcmlkQmFuZFJlY3QoX3JlZjMpIHtcbiAgICAgICAgdmFyIGMgPSBfcmVmMy5jLFxuICAgICAgICAgICAgeDEgPSBfcmVmMy54MSxcbiAgICAgICAgICAgIHkxID0gX3JlZjMueTEsXG4gICAgICAgICAgICB4MiA9IF9yZWYzLngyLFxuICAgICAgICAgICAgeTIgPSBfcmVmMy55MixcbiAgICAgICAgICAgIHR5cGUgPSBfcmVmMy50eXBlO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIG9mZlggPSB3Lmdsb2JhbHMuYmFyUGFkRm9yTnVtZXJpY0F4aXM7XG4gICAgICAgIGlmICh0eXBlID09PSAnY29sdW1uJyAmJiB3LmNvbmZpZy54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSByZXR1cm47XG4gICAgICAgIHZhciBjb2xvciA9IHcuY29uZmlnLmdyaWRbdHlwZV0uY29sb3JzW2NdO1xuICAgICAgICB2YXIgcmVjdCA9IGdyYXBoaWNzLmRyYXdSZWN0KHgxIC0gKHR5cGUgPT09ICdyb3cnID8gb2ZmWCA6IDApLCB5MSwgeDIgKyAodHlwZSA9PT0gJ3JvdycgPyBvZmZYICogMiA6IDApLCB5MiwgMCwgY29sb3IsIHcuY29uZmlnLmdyaWRbdHlwZV0ub3BhY2l0eSk7XG4gICAgICAgIHRoaXMuZWxnLmFkZChyZWN0KTtcbiAgICAgICAgcmVjdC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZChcImFwZXhjaGFydHMtZ3JpZC1cIi5jb25jYXQodHlwZSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZHJhd1hZTGluZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1hZTGluZXMoX3JlZjQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgeENvdW50ID0gX3JlZjQueENvdW50LFxuICAgICAgICAgICAgdGlja0Ftb3VudCA9IF9yZWY0LnRpY2tBbW91bnQ7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIHZhciBkYXRldGltZUxpbmVzID0gZnVuY3Rpb24gZGF0ZXRpbWVMaW5lcyhfcmVmNSkge1xuICAgICAgICAgIHZhciB4QyA9IF9yZWY1LnhDLFxuICAgICAgICAgICAgICB4MSA9IF9yZWY1LngxLFxuICAgICAgICAgICAgICB5MSA9IF9yZWY1LnkxLFxuICAgICAgICAgICAgICB4MiA9IF9yZWY1LngyLFxuICAgICAgICAgICAgICB5MiA9IF9yZWY1LnkyO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4QzsgaSsrKSB7XG4gICAgICAgICAgICB4MSA9IF90aGlzLnhheGlzTGFiZWxzW2ldLnBvc2l0aW9uO1xuICAgICAgICAgICAgeDIgPSBfdGhpcy54YXhpc0xhYmVsc1tpXS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgX3RoaXMuX2RyYXdHcmlkTGluZXMoe1xuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICAgIHhDb3VudDogeENvdW50LFxuICAgICAgICAgICAgICBwYXJlbnQ6IF90aGlzLmVsZ3JpZExpbmVzVlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjYXRlZ29yeUxpbmVzID0gZnVuY3Rpb24gY2F0ZWdvcnlMaW5lcyhfcmVmNikge1xuICAgICAgICAgIHZhciB4QyA9IF9yZWY2LnhDLFxuICAgICAgICAgICAgICB4MSA9IF9yZWY2LngxLFxuICAgICAgICAgICAgICB5MSA9IF9yZWY2LnkxLFxuICAgICAgICAgICAgICB4MiA9IF9yZWY2LngyLFxuICAgICAgICAgICAgICB5MiA9IF9yZWY2LnkyO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4QyArICh3Lmdsb2JhbHMuaXNYTnVtZXJpYyA/IDAgOiAxKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiB4QyA9PT0gMSAmJiB3Lmdsb2JhbHMuZGF0YVBvaW50cyA9PT0gMSkge1xuICAgICAgICAgICAgICAvLyBzaW5nbGUgZGF0YXBvaW50XG4gICAgICAgICAgICAgIHgxID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIHgyID0geDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLl9kcmF3R3JpZExpbmVzKHtcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgeTI6IHkyLFxuICAgICAgICAgICAgICB4Q291bnQ6IHhDb3VudCxcbiAgICAgICAgICAgICAgcGFyZW50OiBfdGhpcy5lbGdyaWRMaW5lc1ZcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4MSA9IHgxICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvICh3Lmdsb2JhbHMuaXNYTnVtZXJpYyA/IHhDIC0gMSA6IHhDKTtcbiAgICAgICAgICAgIHgyID0geDE7XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBkcmF3IHZlcnRpY2FsIGxpbmVzXG5cblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93IHx8IHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgICAgdmFyIHgxID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWw7XG4gICAgICAgICAgdmFyIHkxID0gMDtcbiAgICAgICAgICB2YXIgeDI7XG4gICAgICAgICAgdmFyIHkyID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLnRpbWVzY2FsZUxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGV0aW1lTGluZXMoe1xuICAgICAgICAgICAgICB4QzogeENvdW50LFxuICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgICB5MjogeTJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgICAgeENvdW50ID0gdy5nbG9iYWxzLnhBeGlzU2NhbGUucmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2F0ZWdvcnlMaW5lcyh7XG4gICAgICAgICAgICAgIHhDOiB4Q291bnQsXG4gICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICAgIHkyOiB5MlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRyYXcgaG9yaXpvbnRhbCBsaW5lc1xuXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueWF4aXMubGluZXMuc2hvdykge1xuICAgICAgICAgIHZhciBfeCA9IDA7XG4gICAgICAgICAgdmFyIF95ID0gMDtcbiAgICAgICAgICB2YXIgX3kyID0gMDtcbiAgICAgICAgICB2YXIgX3gyID0gdy5nbG9iYWxzLmdyaWRXaWR0aDtcbiAgICAgICAgICB2YXIgdEEgPSB0aWNrQW1vdW50ICsgMTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzUmFuZ2VCYXIpIHtcbiAgICAgICAgICAgIHRBID0gdy5nbG9iYWxzLmxhYmVscy5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0QSArICh0aGlzLmlzUmFuZ2VCYXIgPyAxIDogMCk7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0dyaWRMaW5lKHtcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgeENvdW50OiB0QSArICh0aGlzLmlzUmFuZ2VCYXIgPyAxIDogMCksXG4gICAgICAgICAgICAgIHgxOiBfeCxcbiAgICAgICAgICAgICAgeTE6IF95LFxuICAgICAgICAgICAgICB4MjogX3gyLFxuICAgICAgICAgICAgICB5MjogX3kyLFxuICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuZWxncmlkTGluZXNIXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX3kgPSBfeSArIHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gKHRoaXMuaXNSYW5nZUJhciA/IHRBIDogdGlja0Ftb3VudCk7XG4gICAgICAgICAgICBfeTIgPSBfeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2RyYXdJbnZlcnRlZFhZTGluZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ludmVydGVkWFlMaW5lcyhfcmVmNykge1xuICAgICAgICB2YXIgeENvdW50ID0gX3JlZjcueENvdW50O1xuICAgICAgICB2YXIgdyA9IHRoaXMudzsgLy8gZHJhdyB2ZXJ0aWNhbCBsaW5lc1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnhheGlzLmxpbmVzLnNob3cgfHwgdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLnNob3cpIHtcbiAgICAgICAgICB2YXIgeDEgPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbDtcbiAgICAgICAgICB2YXIgeTEgPSAwO1xuICAgICAgICAgIHZhciB4MjtcbiAgICAgICAgICB2YXIgeTIgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeENvdW50ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RyYXdHcmlkTGluZSh7XG4gICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICB4Q291bnQ6IHhDb3VudCArIDEsXG4gICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICAgICAgeTI6IHkyLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5lbGdyaWRMaW5lc1ZcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4QXhpcyA9IG5ldyBYQXhpcyh0aGlzLmN0eCk7XG4gICAgICAgICAgICB4QXhpcy5kcmF3WGF4aXNUaWNrcyh4MSwgMCwgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbCk7XG4gICAgICAgICAgICB4MSA9IHgxICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHhDb3VudCArIDAuMztcbiAgICAgICAgICAgIHgyID0geDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRyYXcgaG9yaXpvbnRhbCBsaW5lc1xuXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueWF4aXMubGluZXMuc2hvdykge1xuICAgICAgICAgIHZhciBfeDMgPSAwO1xuICAgICAgICAgIHZhciBfeTMgPSAwO1xuICAgICAgICAgIHZhciBfeTQgPSAwO1xuICAgICAgICAgIHZhciBfeDQgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHcuZ2xvYmFscy5kYXRhUG9pbnRzICsgMTsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0dyaWRMaW5lKHtcbiAgICAgICAgICAgICAgaTogX2ksXG4gICAgICAgICAgICAgIHhDb3VudDogdy5nbG9iYWxzLmRhdGFQb2ludHMgKyAxLFxuICAgICAgICAgICAgICB4MTogX3gzLFxuICAgICAgICAgICAgICB5MTogX3kzLFxuICAgICAgICAgICAgICB4MjogX3g0LFxuICAgICAgICAgICAgICB5MjogX3k0LFxuICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuZWxncmlkTGluZXNIXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX3kzID0gX3kzICsgdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgICAgIF95NCA9IF95MztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYWN0dWFsIGdyaWQgcmVuZGVyaW5nXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyR3JpZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckdyaWQoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmVsZyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZ3JpZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxncmlkTGluZXNIID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1ncmlkbGluZXMtaG9yaXpvbnRhbCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxncmlkTGluZXNWID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1ncmlkbGluZXMtdmVydGljYWwnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsR3JpZEJvcmRlcnMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWdyaWQtYm9yZGVycydcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxnLmFkZCh0aGlzLmVsZ3JpZExpbmVzSCk7XG4gICAgICAgIHRoaXMuZWxnLmFkZCh0aGlzLmVsZ3JpZExpbmVzVik7XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5ncmlkLnNob3cpIHtcbiAgICAgICAgICB0aGlzLmVsZ3JpZExpbmVzVi5oaWRlKCk7XG4gICAgICAgICAgdGhpcy5lbGdyaWRMaW5lc0guaGlkZSgpO1xuICAgICAgICAgIHRoaXMuZWxHcmlkQm9yZGVycy5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeVRpY2tBbW91bnQgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZS5sZW5ndGggPyB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQubGVuZ3RoIC0gMSA6IDU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMueUF4aXNTY2FsZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHlUaWNrQW1vdW50ID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbaV0ucmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHlUaWNrQW1vdW50ID4gMikgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeENvdW50O1xuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCB8fCB0aGlzLmlzUmFuZ2VCYXIpIHtcbiAgICAgICAgICB4Q291bnQgPSB0aGlzLnhheGlzTGFiZWxzLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLmlzUmFuZ2VCYXIpIHtcbiAgICAgICAgICAgIHhDb3VudC0tO1xuICAgICAgICAgICAgeVRpY2tBbW91bnQgPSB3Lmdsb2JhbHMubGFiZWxzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnRpY2tBbW91bnQgJiYgdy5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdHRlcikge1xuICAgICAgICAgICAgICB4Q291bnQgPSB3LmNvbmZpZy54YXhpcy50aWNrQW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2RyYXdYWUxpbmVzKHtcbiAgICAgICAgICAgIHhDb3VudDogeENvdW50LFxuICAgICAgICAgICAgdGlja0Ftb3VudDogeVRpY2tBbW91bnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4Q291bnQgPSB5VGlja0Ftb3VudDsgLy8gZm9yIGhvcml6b250YWwgYmFyIGNoYXJ0LCBnZXQgdGhlIHhheGlzIHRpY2thbW91bnRcblxuICAgICAgICAgIHlUaWNrQW1vdW50ID0gdy5nbG9iYWxzLnhUaWNrQW1vdW50O1xuXG4gICAgICAgICAgdGhpcy5fZHJhd0ludmVydGVkWFlMaW5lcyh7XG4gICAgICAgICAgICB4Q291bnQ6IHhDb3VudCxcbiAgICAgICAgICAgIHRpY2tBbW91bnQ6IHlUaWNrQW1vdW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYXdHcmlkQmFuZHMoeENvdW50LCB5VGlja0Ftb3VudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWw6IHRoaXMuZWxnLFxuICAgICAgICAgIGVsR3JpZEJvcmRlcnM6IHRoaXMuZWxHcmlkQm9yZGVycyxcbiAgICAgICAgICB4QXhpc1RpY2tXaWR0aDogdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHhDb3VudFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3R3JpZEJhbmRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0dyaWRCYW5kcyh4Q291bnQsIHRpY2tBbW91bnQpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIHJvd3MgYmFja2dyb3VuZCBiYW5kc1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB4MSA9IDA7XG4gICAgICAgICAgdmFyIHkxID0gMDtcbiAgICAgICAgICB2YXIgeTIgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgICAgdmFyIHgyID0gdy5nbG9iYWxzLmdyaWRXaWR0aDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjID0gMDsgaSA8IHRpY2tBbW91bnQ7IGkrKywgYysrKSB7XG4gICAgICAgICAgICBpZiAoYyA+PSB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kcmF3R3JpZEJhbmRSZWN0KHtcbiAgICAgICAgICAgICAgYzogYyxcbiAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgeTI6IHkyLFxuICAgICAgICAgICAgICB0eXBlOiAncm93J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHkxID0geTEgKyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGNvbHVtbnMgYmFja2dyb3VuZCBiYW5kc1xuXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycyAhPT0gdW5kZWZpbmVkICYmIHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHhjID0gIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwgJiYgdy5jb25maWcueGF4aXMudGlja1BsYWNlbWVudCA9PT0gJ29uJyAmJiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpID8geENvdW50IC0gMSA6IHhDb3VudDtcbiAgICAgICAgICB2YXIgX3g1ID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWw7XG4gICAgICAgICAgdmFyIF95NSA9IDA7XG5cbiAgICAgICAgICB2YXIgX3g2ID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWwgKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8geGM7XG5cbiAgICAgICAgICB2YXIgX3k2ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfYyA9IDA7IF9pMiA8IHhDb3VudDsgX2kyKyssIF9jKyspIHtcbiAgICAgICAgICAgIGlmIChfYyA+PSB3LmNvbmZpZy5ncmlkLmNvbHVtbi5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIF9jID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZHJhd0dyaWRCYW5kUmVjdCh7XG4gICAgICAgICAgICAgIGM6IF9jLFxuICAgICAgICAgICAgICB4MTogX3g1LFxuICAgICAgICAgICAgICB5MTogX3k1LFxuICAgICAgICAgICAgICB4MjogX3g2LFxuICAgICAgICAgICAgICB5MjogX3k2LFxuICAgICAgICAgICAgICB0eXBlOiAnY29sdW1uJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF94NSA9IF94NSArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyB4YztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gR3JpZDtcbiAgfSgpO1xuXG4gIHZhciBSYW5nZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5nZShjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZSk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgfSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMyNjY3OS9jaG9vc2luZy1hbi1hdHRyYWN0aXZlLWxpbmVhci1zY2FsZS1mb3ItYS1ncmFwaHMteS1heGlzc1xuICAgIC8vIFRoaXMgcm91dGluZSBjcmVhdGVzIHRoZSBZIGF4aXMgdmFsdWVzIGZvciBhIGdyYXBoLlxuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUmFuZ2UsIFt7XG4gICAgICBrZXk6IFwibmljZVNjYWxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmljZVNjYWxlKHlNaW4sIHlNYXgpIHtcbiAgICAgICAgdmFyIHRpY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgICB2YXIgTk9fTUlOX01BWF9QUk9WSURFRCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdyA9IHRoaXMudzsgLy8gRGV0ZXJtaW5lIFJhbmdlXG5cbiAgICAgICAgdmFyIHJhbmdlID0gTWF0aC5hYnMoeU1heCAtIHlNaW4pO1xuICAgICAgICB0aWNrcyA9IHRoaXMuX2FkanVzdFRpY2tzRm9yU21hbGxSYW5nZSh0aWNrcywgaW5kZXgsIHJhbmdlKTtcblxuICAgICAgICBpZiAodGlja3MgPT09ICdkYXRhUG9pbnRzJykge1xuICAgICAgICAgIHRpY2tzID0gdy5nbG9iYWxzLmRhdGFQb2ludHMgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlNaW4gPT09IE51bWJlci5NSU5fVkFMVUUgJiYgeU1heCA9PT0gMCB8fCAhVXRpbHMkMS5pc051bWJlcih5TWluKSAmJiAhVXRpbHMkMS5pc051bWJlcih5TWF4KSB8fCB5TWluID09PSBOdW1iZXIuTUlOX1ZBTFVFICYmIHlNYXggPT09IC1OdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgLy8gd2hlbiBhbGwgdmFsdWVzIGFyZSAwXG4gICAgICAgICAgeU1pbiA9IDA7XG4gICAgICAgICAgeU1heCA9IHRpY2tzO1xuICAgICAgICAgIHZhciBsaW5lYXJTY2FsZSA9IHRoaXMubGluZWFyU2NhbGUoeU1pbiwgeU1heCwgdGlja3MpO1xuICAgICAgICAgIHJldHVybiBsaW5lYXJTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5TWluID4geU1heCkge1xuICAgICAgICAgIC8vIGlmIHNvbWVob3cgZHVlIHRvIHNvbWUgd3JvbmcgY29uZmlnLCB1c2VyIHNlbnQgbWF4IGxlc3MgdGhhbiBtaW4sXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBtaW4vbWF4IGFnYWluXG4gICAgICAgICAgY29uc29sZS53YXJuKCdheGlzLm1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIGF4aXMubWF4Jyk7XG4gICAgICAgICAgeU1heCA9IHlNaW4gKyAwLjE7XG4gICAgICAgIH0gZWxzZSBpZiAoeU1pbiA9PT0geU1heCkge1xuICAgICAgICAgIC8vIElmIHlNaW4gYW5kIHlNYXggYXJlIGlkZW50aWNhbCwgdGhlblxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgeU1pbiBhbmQgeU1heCB2YWx1ZXMgdG8gYWN0dWFsbHlcbiAgICAgICAgICAvLyBtYWtlIGEgZ3JhcGguIEFsc28gYXZvaWRzIGRpdmlzaW9uIGJ5IHplcm8gZXJyb3JzLlxuICAgICAgICAgIHlNaW4gPSB5TWluID09PSAwID8gMCA6IHlNaW4gLSAwLjU7IC8vIHNvbWUgc21hbGwgdmFsdWVcblxuICAgICAgICAgIHlNYXggPSB5TWF4ID09PSAwID8gMiA6IHlNYXggKyAwLjU7IC8vIHNvbWUgc21hbGwgdmFsdWVcbiAgICAgICAgfSAvLyBDYWxjdWxhdGUgTWluIGFtZCBNYXggZ3JhcGhpY2FsIGxhYmVscyBhbmQgZ3JhcGhcbiAgICAgICAgLy8gaW5jcmVtZW50cy4gIFRoZSBudW1iZXIgb2YgdGlja3MgZGVmYXVsdHMgdG9cbiAgICAgICAgLy8gMTAgd2hpY2ggaXMgdGhlIFNVR0dFU1RFRCB2YWx1ZS4gIEFueSB0aWNrIHZhbHVlXG4gICAgICAgIC8vIGVudGVyZWQgaXMgdXNlZCBhcyBhIHN1Z2dlc3RlZCB2YWx1ZSB3aGljaCBpc1xuICAgICAgICAvLyBhZGp1c3RlZCB0byBiZSBhICdwcmV0dHknIHZhbHVlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBPdXRwdXQgd2lsbCBiZSBhbiBhcnJheSBvZiB0aGUgWSBheGlzIHZhbHVlcyB0aGF0XG4gICAgICAgIC8vIGVuY29tcGFzcyB0aGUgWSB2YWx1ZXMuXG5cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHJhbmdlIDwgMSAmJiBOT19NSU5fTUFYX1BST1ZJREVEICYmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHcuY29uZmlnLnNlcmllc1tpbmRleF0udHlwZSA9PT0gJ2NhbmRsZXN0aWNrJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYm94UGxvdCcgfHwgdy5jb25maWcuc2VyaWVzW2luZGV4XS50eXBlID09PSAnYm94UGxvdCcgfHwgdy5nbG9iYWxzLmlzUmFuZ2VEYXRhKSkge1xuICAgICAgICAgIC8qIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy80MzAgKi9cbiAgICAgICAgICB5TWF4ID0geU1heCAqIDEuMDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlrcyA9IHRpY2tzICsgMTsgLy8gQWRqdXN0IHRpY2tzIGlmIG5lZWRlZFxuXG4gICAgICAgIGlmICh0aWtzIDwgMikge1xuICAgICAgICAgIHRpa3MgPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHRpa3MgPiAyKSB7XG4gICAgICAgICAgdGlrcyAtPSAyO1xuICAgICAgICB9IC8vIEdldCByYXcgc3RlcCB2YWx1ZVxuXG5cbiAgICAgICAgdmFyIHRlbXBTdGVwID0gcmFuZ2UgLyB0aWtzOyAvLyBDYWxjdWxhdGUgcHJldHR5IHN0ZXAgdmFsdWVcblxuICAgICAgICB2YXIgbWFnID0gTWF0aC5mbG9vcihVdGlscyQxLmxvZzEwKHRlbXBTdGVwKSk7XG4gICAgICAgIHZhciBtYWdQb3cgPSBNYXRoLnBvdygxMCwgbWFnKTtcbiAgICAgICAgdmFyIG1hZ01zZCA9IE1hdGgucm91bmQodGVtcFN0ZXAgLyBtYWdQb3cpO1xuXG4gICAgICAgIGlmIChtYWdNc2QgPCAxKSB7XG4gICAgICAgICAgbWFnTXNkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGVwU2l6ZSA9IG1hZ01zZCAqIG1hZ1BvdzsgLy8gYnVpbGQgWSBsYWJlbCBhcnJheS5cbiAgICAgICAgLy8gTG93ZXIgYW5kIHVwcGVyIGJvdW5kcyBjYWxjdWxhdGlvbnNcblxuICAgICAgICB2YXIgbGIgPSBzdGVwU2l6ZSAqIE1hdGguZmxvb3IoeU1pbiAvIHN0ZXBTaXplKTtcbiAgICAgICAgdmFyIHViID0gc3RlcFNpemUgKiBNYXRoLmNlaWwoeU1heCAvIHN0ZXBTaXplKTsgLy8gQnVpbGQgYXJyYXlcblxuICAgICAgICB2YXIgdmFsID0gbGI7XG5cbiAgICAgICAgaWYgKE5PX01JTl9NQVhfUFJPVklERUQgJiYgcmFuZ2UgPiAyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFV0aWxzJDEuc3RyaXBOdW1iZXIodmFsLCA3KSk7XG4gICAgICAgICAgICB2YWwgKz0gc3RlcFNpemU7XG5cbiAgICAgICAgICAgIGlmICh2YWwgPiB1Yikge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICBuaWNlTWluOiByZXN1bHRbMF0sXG4gICAgICAgICAgICBuaWNlTWF4OiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICB2YXIgdiA9IHlNaW47XG4gICAgICAgICAgcmVzdWx0LnB1c2goVXRpbHMkMS5zdHJpcE51bWJlcih2LCA3KSk7XG4gICAgICAgICAgdmFyIHZhbHVlc0RpdmlkZXIgPSBNYXRoLmFicyh5TWF4IC0geU1pbikgLyB0aWNrcztcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRpY2tzOyBpKyspIHtcbiAgICAgICAgICAgIHYgPSB2ICsgdmFsdWVzRGl2aWRlcjtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdID49IHlNYXgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICBuaWNlTWluOiByZXN1bHRbMF0sXG4gICAgICAgICAgICBuaWNlTWF4OiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsaW5lYXJTY2FsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmVhclNjYWxlKHlNaW4sIHlNYXgpIHtcbiAgICAgICAgdmFyIHRpY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByYW5nZSA9IE1hdGguYWJzKHlNYXggLSB5TWluKTtcbiAgICAgICAgdGlja3MgPSB0aGlzLl9hZGp1c3RUaWNrc0ZvclNtYWxsUmFuZ2UodGlja3MsIGluZGV4LCByYW5nZSk7XG5cbiAgICAgICAgaWYgKHRpY2tzID09PSAnZGF0YVBvaW50cycpIHtcbiAgICAgICAgICB0aWNrcyA9IHRoaXMudy5nbG9iYWxzLmRhdGFQb2ludHMgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0ZXAgPSByYW5nZSAvIHRpY2tzO1xuXG4gICAgICAgIGlmICh0aWNrcyA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgIHRpY2tzID0gMTA7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciB2ID0geU1pbjtcblxuICAgICAgICB3aGlsZSAodGlja3MgPj0gMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICAgIHYgPSB2ICsgc3RlcDtcbiAgICAgICAgICB0aWNrcyAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICBuaWNlTWluOiByZXN1bHRbMF0sXG4gICAgICAgICAgbmljZU1heDogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2dhcml0aG1pY1NjYWxlTmljZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ2FyaXRobWljU2NhbGVOaWNlKHlNaW4sIHlNYXgsIGJhc2UpIHtcbiAgICAgICAgLy8gQmFzaWMgdmFsaWRhdGlvbiB0byBhdm9pZCBmb3IgbG9vcCBzdGFydGluZyBhdCAtaW5mLlxuICAgICAgICBpZiAoeU1heCA8PSAwKSB5TWF4ID0gTWF0aC5tYXgoeU1pbiwgYmFzZSk7XG4gICAgICAgIGlmICh5TWluIDw9IDApIHlNaW4gPSBNYXRoLm1pbih5TWF4LCBiYXNlKTtcbiAgICAgICAgdmFyIGxvZ3MgPSBbXTtcbiAgICAgICAgdmFyIGxvZ01heCA9IE1hdGguY2VpbChNYXRoLmxvZyh5TWF4KSAvIE1hdGgubG9nKGJhc2UpICsgMSk7IC8vIEdldCBwb3dlcnMgb2YgYmFzZSBmb3Igb3VyIG1heCBhbmQgbWluXG5cbiAgICAgICAgdmFyIGxvZ01pbiA9IE1hdGguZmxvb3IoTWF0aC5sb2coeU1pbikgLyBNYXRoLmxvZyhiYXNlKSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxvZ01pbjsgaSA8IGxvZ01heDsgaSsrKSB7XG4gICAgICAgICAgbG9ncy5wdXNoKE1hdGgucG93KGJhc2UsIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBsb2dzLFxuICAgICAgICAgIG5pY2VNaW46IGxvZ3NbMF0sXG4gICAgICAgICAgbmljZU1heDogbG9nc1tsb2dzLmxlbmd0aCAtIDFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxvZ2FyaXRobWljU2NhbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dhcml0aG1pY1NjYWxlKHlNaW4sIHlNYXgsIGJhc2UpIHtcbiAgICAgICAgLy8gQmFzaWMgdmFsaWRhdGlvbiB0byBhdm9pZCBmb3IgbG9vcCBzdGFydGluZyBhdCAtaW5mLlxuICAgICAgICBpZiAoeU1heCA8PSAwKSB5TWF4ID0gTWF0aC5tYXgoeU1pbiwgYmFzZSk7XG4gICAgICAgIGlmICh5TWluIDw9IDApIHlNaW4gPSBNYXRoLm1pbih5TWF4LCBiYXNlKTtcbiAgICAgICAgdmFyIGxvZ3MgPSBbXTsgLy8gR2V0IHRoZSBsb2dhcml0aG1pYyByYW5nZS5cblxuICAgICAgICB2YXIgbG9nTWF4ID0gTWF0aC5sb2coeU1heCkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICAgICAgdmFyIGxvZ01pbiA9IE1hdGgubG9nKHlNaW4pIC8gTWF0aC5sb2coYmFzZSk7IC8vIEdldCB0aGUgZXhhY3QgbG9nYXJpdGhtaWMgcmFuZ2UuXG4gICAgICAgIC8vIChUaGlzIGlzIHRoZSBleGFjdCBudW1iZXIgb2YgbXVsdGlwbGVzIG9mIHRoZSBiYXNlIHRoZXJlIGFyZSBiZXR3ZWVuIHlNaW4gYW5kIHlNYXgpLlxuXG4gICAgICAgIHZhciBsb2dSYW5nZSA9IGxvZ01heCAtIGxvZ01pbjsgLy8gUm91bmQgdGhlIGxvZ2FyaXRobWljIHJhbmdlIHRvIGdldCB0aGUgbnVtYmVyIG9mIHRpY2tzIHdlIHdpbGwgY3JlYXRlLlxuICAgICAgICAvLyBJZiB0aGUgY2hvc2VuIG1pbi9tYXggdmFsdWVzIGFyZSBtdWx0aXBsZXMgb2YgZWFjaCBvdGhlciBXUlQgdGhlIGJhc2UsIHRoaXMgd2lsbCBiZSBuZWF0LlxuICAgICAgICAvLyBJZiB0aGUgY2hvc2VuIG1pbi9tYXggYXJlbid0LCB3ZSB3aWxsIGF0IGxlYXN0IHN0aWxsIHByb3ZpZGUgVVNFRlVMIHRpY2tzLlxuXG4gICAgICAgIHZhciB0aWNrcyA9IE1hdGgucm91bmQobG9nUmFuZ2UpOyAvLyBHZXQgdGhlIGxvZ2FyaXRobWljIHNwYWNpbmcgYmV0d2VlbiB0aWNrcy5cblxuICAgICAgICB2YXIgbG9nVGlja1NwYWNpbmcgPSBsb2dSYW5nZSAvIHRpY2tzOyAvLyBDcmVhdGUgYXMgbWFueSB0aWNrcyBhcyB0aGVyZSBpcyByYW5nZSBpbiB0aGUgbG9ncy5cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbG9nVGljayA9IGxvZ01pbjsgaSA8IHRpY2tzOyBpKyssIGxvZ1RpY2sgKz0gbG9nVGlja1NwYWNpbmcpIHtcbiAgICAgICAgICBsb2dzLnB1c2goTWF0aC5wb3coYmFzZSwgbG9nVGljaykpO1xuICAgICAgICB9IC8vIEFkZCBhIGZpbmFsIHRpY2sgYXQgdGhlIHlNYXguXG5cblxuICAgICAgICBsb2dzLnB1c2goTWF0aC5wb3coYmFzZSwgbG9nTWF4KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBsb2dzLFxuICAgICAgICAgIG5pY2VNaW46IHlNaW4sXG4gICAgICAgICAgbmljZU1heDogeU1heFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYWRqdXN0VGlja3NGb3JTbWFsbFJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkanVzdFRpY2tzRm9yU21hbGxSYW5nZSh0aWNrcywgaW5kZXgsIHJhbmdlKSB7XG4gICAgICAgIHZhciBuZXdUaWNrcyA9IHRpY2tzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnICYmIHRoaXMudy5jb25maWcueWF4aXNbaW5kZXhdLmxhYmVscy5mb3JtYXR0ZXIgJiYgdGhpcy53LmNvbmZpZy55YXhpc1tpbmRleF0udGlja0Ftb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbCA9IE51bWJlcih0aGlzLncuY29uZmlnLnlheGlzW2luZGV4XS5sYWJlbHMuZm9ybWF0dGVyKDEpKTtcblxuICAgICAgICAgIGlmIChVdGlscyQxLmlzTnVtYmVyKGZvcm1hdHRlZFZhbCkgJiYgdGhpcy53Lmdsb2JhbHMueVZhbHVlRGVjaW1hbCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3VGlja3MgPSBNYXRoLmNlaWwocmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdUaWNrcyA8IHRpY2tzID8gbmV3VGlja3MgOiB0aWNrcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0WVNjYWxlRm9ySW5kZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZU2NhbGVGb3JJbmRleChpbmRleCwgbWluWSwgbWF4WSkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICAgIHZhciB5ID0gZ2wuaXNCYXJIb3Jpem9udGFsID8gY25mLnhheGlzIDogY25mLnlheGlzW2luZGV4XTtcblxuICAgICAgICBpZiAodHlwZW9mIGdsLnlBeGlzU2NhbGVbaW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGdsLnlBeGlzU2NhbGVbaW5kZXhdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKG1heFkgLSBtaW5ZKTtcblxuICAgICAgICBpZiAoeS5sb2dhcml0aG1pYyAmJiBkaWZmIDw9IDUpIHtcbiAgICAgICAgICBnbC5pbnZhbGlkTG9nU2NhbGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkubG9nYXJpdGhtaWMgJiYgZGlmZiA+IDUpIHtcbiAgICAgICAgICBnbC5hbGxTZXJpZXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgICBnbC55QXhpc1NjYWxlW2luZGV4XSA9IHRoaXMubG9nYXJpdGhtaWNTY2FsZShtaW5ZLCBtYXhZLCB5LmxvZ0Jhc2UpO1xuICAgICAgICAgIGdsLnlBeGlzU2NhbGVbaW5kZXhdID0geS5mb3JjZU5pY2VTY2FsZSA/IHRoaXMubG9nYXJpdGhtaWNTY2FsZU5pY2UobWluWSwgbWF4WSwgeS5sb2dCYXNlKSA6IHRoaXMubG9nYXJpdGhtaWNTY2FsZShtaW5ZLCBtYXhZLCB5LmxvZ0Jhc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtYXhZID09PSAtTnVtYmVyLk1BWF9WQUxVRSB8fCAhVXRpbHMkMS5pc051bWJlcihtYXhZKSkge1xuICAgICAgICAgICAgLy8gbm8gZGF0YSBpbiB0aGUgY2hhcnQuIEVpdGhlciBhbGwgc2VyaWVzIGNvbGxhcHNlZCBvciB1c2VyIHBhc3NlZCBhIGJsYW5rIGFycmF5XG4gICAgICAgICAgICBnbC55QXhpc1NjYWxlW2luZGV4XSA9IHRoaXMubGluZWFyU2NhbGUoMCwgNSwgNSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIHNvbWUgZGF0YS4gVHVybiBvZmYgdGhlIGFsbFNlcmllc0NvbGxhcHNlZCBmbGFnXG4gICAgICAgICAgICBnbC5hbGxTZXJpZXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCh5Lm1pbiAhPT0gdW5kZWZpbmVkIHx8IHkubWF4ICE9PSB1bmRlZmluZWQpICYmICF5LmZvcmNlTmljZVNjYWxlKSB7XG4gICAgICAgICAgICAgIC8vIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy80OTJcbiAgICAgICAgICAgICAgZ2wueUF4aXNTY2FsZVtpbmRleF0gPSB0aGlzLmxpbmVhclNjYWxlKG1pblksIG1heFksIHkudGlja0Ftb3VudCwgaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5vTWluTWF4UHJvdmlkZWQgPSBjbmYueWF4aXNbaW5kZXhdLm1heCA9PT0gdW5kZWZpbmVkICYmIGNuZi55YXhpc1tpbmRleF0ubWluID09PSB1bmRlZmluZWQgfHwgY25mLnlheGlzW2luZGV4XS5mb3JjZU5pY2VTY2FsZTtcbiAgICAgICAgICAgICAgZ2wueUF4aXNTY2FsZVtpbmRleF0gPSB0aGlzLm5pY2VTY2FsZShtaW5ZLCBtYXhZLCB5LnRpY2tBbW91bnQgPyB5LnRpY2tBbW91bnQgOiBkaWZmIDwgNSAmJiBkaWZmID4gMSA/IGRpZmYgKyAxIDogNSwgaW5kZXgsIC8vIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy8zOTdcbiAgICAgICAgICAgICAgbm9NaW5NYXhQcm92aWRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFhTY2FsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFhTY2FsZShtaW5YLCBtYXhYKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICAgIHZhciB4ID0gdy5jb25maWcueGF4aXM7XG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMobWF4WCAtIG1pblgpO1xuXG4gICAgICAgIGlmIChtYXhYID09PSAtTnVtYmVyLk1BWF9WQUxVRSB8fCAhVXRpbHMkMS5pc051bWJlcihtYXhYKSkge1xuICAgICAgICAgIC8vIG5vIGRhdGEgaW4gdGhlIGNoYXJ0LiBFaXRoZXIgYWxsIHNlcmllcyBjb2xsYXBzZWQgb3IgdXNlciBwYXNzZWQgYSBibGFuayBhcnJheVxuICAgICAgICAgIGdsLnhBeGlzU2NhbGUgPSB0aGlzLmxpbmVhclNjYWxlKDAsIDUsIDUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnhBeGlzU2NhbGUgPSB0aGlzLmxpbmVhclNjYWxlKG1pblgsIG1heFgsIHgudGlja0Ftb3VudCA/IHgudGlja0Ftb3VudCA6IGRpZmYgPCA1ICYmIGRpZmYgPiAxID8gZGlmZiArIDEgOiA1LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbC54QXhpc1NjYWxlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRNdWx0aXBsZVlTY2FsZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNdWx0aXBsZVlTY2FsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgICB2YXIgbWluWUFyciA9IGdsLm1pbllBcnIuY29uY2F0KFtdKTtcbiAgICAgICAgdmFyIG1heFlBcnIgPSBnbC5tYXhZQXJyLmNvbmNhdChbXSk7XG4gICAgICAgIHZhciBzY2FsZXNJbmRpY2VzID0gW107IC8vIGhlcmUsIHdlIGxvb3AgdGhyb3VnaCB0aGUgeWF4aXMgYXJyYXkgYW5kIGZpbmQgdGhlIGl0ZW0gd2hpY2ggaGFzIFwic2VyaWVzTmFtZVwiIHByb3BlcnR5XG5cbiAgICAgICAgY25mLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgICAgIGNuZi5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocywgc2kpIHtcbiAgICAgICAgICAgIC8vIGlmIHNlcmllc05hbWUgbWF0Y2hlcyBhbmQgdGhhdCBzZXJpZXMgaXMgbm90IGNvbGxhcHNlZCwgd2UgdXNlIHRoYXQgc2NhbGVcbiAgICAgICAgICAgIC8vIGZpeCBpc3N1ZSAjMTIxNVxuICAgICAgICAgICAgLy8gcHJvY2VlZCBldmVuIGlmIHNpIGlzIGluIGdsLmNvbGxhcHNlZFNlcmllc0luZGljZXNcbiAgICAgICAgICAgIGlmIChzLm5hbWUgPT09IHlheGUuc2VyaWVzTmFtZSkge1xuICAgICAgICAgICAgICBpbmRleCA9IHNpO1xuXG4gICAgICAgICAgICAgIGlmIChpICE9PSBzaSkge1xuICAgICAgICAgICAgICAgIHNjYWxlc0luZGljZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpbmRleDogc2ksXG4gICAgICAgICAgICAgICAgICBzaW1pbGFySW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICBhbHJlYWR5RXhpc3RzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbGVzSW5kaWNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBzaVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIG1pblkgPSBtaW5ZQXJyW2luZGV4XTtcbiAgICAgICAgICB2YXIgbWF4WSA9IG1heFlBcnJbaW5kZXhdO1xuXG4gICAgICAgICAgX3RoaXMuc2V0WVNjYWxlRm9ySW5kZXgoaSwgbWluWSwgbWF4WSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNhbWVTY2FsZUluTXVsdGlwbGVBeGVzKG1pbllBcnIsIG1heFlBcnIsIHNjYWxlc0luZGljZXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzYW1lU2NhbGVJbk11bHRpcGxlQXhlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNhbWVTY2FsZUluTXVsdGlwbGVBeGVzKG1pbllBcnIsIG1heFlBcnIsIHNjYWxlc0luZGljZXMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzOyAvLyB3ZSBnb3QgdGhlIHNjYWxlc0luZGljZXMgYXJyYXkgaW4gdGhlIGFib3ZlIGNvZGUsIGJ1dCB3ZSBuZWVkIHRvIGZpbHRlciBvdXQgdGhlIGl0ZW1zIHdoaWNoIGRvZXNuJ3QgaGF2ZSBzYW1lIHNjYWxlc1xuXG4gICAgICAgIHZhciBzaW1pbGFySW5kaWNlcyA9IFtdO1xuICAgICAgICBzY2FsZXNJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgICAgaWYgKHNjYWxlLmFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBzaW1pbGFySW5kaWNlc1tzY2FsZS5pbmRleF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdLnB1c2goc2NhbGUuaW5kZXgpO1xuICAgICAgICAgICAgc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdLnB1c2goc2NhbGUuc2ltaWxhckluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGIuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wueUF4aXNTYW1lU2NhbGVJbmRpY2VzID0gc2ltaWxhckluZGljZXM7XG4gICAgICAgIHNpbWlsYXJJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNpLCBpKSB7XG4gICAgICAgICAgc2ltaWxhckluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoc2osIGopIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Qoc2ksIHNqKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2ltaWxhckluZGljZXNbaV0gPSBzaW1pbGFySW5kaWNlc1tpXS5jb25jYXQoc2ltaWxhckluZGljZXNbal0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pOyAvLyB0aGVuLCB3ZSByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBzaW1pbGFyU2NhbGUgYXJyYXlcblxuICAgICAgICB2YXIgdW5pcXVlU2ltaWxhckluZGljZXMgPSBzaW1pbGFySW5kaWNlcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbS5maWx0ZXIoZnVuY3Rpb24gKGksIHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5kZXhPZihpKSA9PT0gcG9zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gc29ydCBmdXJ0aGVyIHRvIHJlbW92ZSB3aG9sZSBkdXBsaWNhdGUgYXJyYXlzIGxhdGVyXG5cbiAgICAgICAgdmFyIHNvcnRlZEluZGljZXMgPSB1bmlxdWVTaW1pbGFySW5kaWNlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy5zb3J0KCk7XG4gICAgICAgIH0pOyAvLyByZW1vdmUgdW5kZWZpbmVkIGl0ZW1zXG5cbiAgICAgICAgc2ltaWxhckluZGljZXMgPSBzaW1pbGFySW5kaWNlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gISFzO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGluZGljZXMgPSBzb3J0ZWRJbmRpY2VzLnNsaWNlKCk7XG4gICAgICAgIHZhciBzdHJpbmdJbmRpY2VzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZCkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5kaWNlcyA9IGluZGljZXMuZmlsdGVyKGZ1bmN0aW9uIChpbmQsIHApIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nSW5kaWNlcy5pbmRleE9mKEpTT04uc3RyaW5naWZ5KGluZCkpID09PSBwO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNhbWVTY2FsZU1pbllBcnIgPSBbXTtcbiAgICAgICAgdmFyIHNhbWVTY2FsZU1heFlBcnIgPSBbXTtcbiAgICAgICAgbWluWUFyci5mb3JFYWNoKGZ1bmN0aW9uIChtaW5ZVmFsdWUsIHlpKSB7XG4gICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzY2FsZSwgaSkge1xuICAgICAgICAgICAgLy8gd2UgY29tcGFyZSBvbmx5IHRoZSB5SW5kZXggd2hpY2ggZXhpc3RzIGluIHRoZSBpbmRpY2VzIGFycmF5XG4gICAgICAgICAgICBpZiAoc2NhbGUuaW5kZXhPZih5aSkgPiAtMSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNhbWVTY2FsZU1pbllBcnJbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2FtZVNjYWxlTWluWUFycltpXSA9IFtdO1xuICAgICAgICAgICAgICAgIHNhbWVTY2FsZU1heFlBcnJbaV0gPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNhbWVTY2FsZU1pbllBcnJbaV0ucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiB5aSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWluWVZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzYW1lU2NhbGVNYXhZQXJyW2ldLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeWksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1heFlBcnJbeWldXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNhbWVTY2FsZU1pbiA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGluZGljZXMubGVuZ3RoKSkubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICAgIHZhciBzYW1lU2NhbGVNYXggPSBBcnJheS5hcHBseShudWxsLCBBcnJheShpbmRpY2VzLmxlbmd0aCkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgc2FtZVNjYWxlTWluWUFyci5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChzYywgaikge1xuICAgICAgICAgICAgc2FtZVNjYWxlTWluW2ldID0gTWF0aC5taW4oc2MudmFsdWUsIHNhbWVTY2FsZU1pbltpXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzYW1lU2NhbGVNYXhZQXJyLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHNjLCBqKSB7XG4gICAgICAgICAgICBzYW1lU2NhbGVNYXhbaV0gPSBNYXRoLm1heChzYy52YWx1ZSwgc2FtZVNjYWxlTWF4W2ldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1pbllBcnIuZm9yRWFjaChmdW5jdGlvbiAobWluLCBpKSB7XG4gICAgICAgICAgc2FtZVNjYWxlTWF4WUFyci5mb3JFYWNoKGZ1bmN0aW9uIChzLCBzaSkge1xuICAgICAgICAgICAgdmFyIG1pblkgPSBzYW1lU2NhbGVNaW5bc2ldO1xuICAgICAgICAgICAgdmFyIG1heFkgPSBzYW1lU2NhbGVNYXhbc2ldO1xuXG4gICAgICAgICAgICBpZiAoY25mLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgLy8gZm9yIHN0YWNrZWQgY2hhcnRzLCB3ZSBuZWVkIHRvIGFkZCB0aGUgdmFsdWVzXG4gICAgICAgICAgICAgIG1heFkgPSAwO1xuICAgICAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKGluZCwgaykge1xuICAgICAgICAgICAgICAgIC8vIGZpeCBpbmNvcnJlY3RseSBhZGp1c3QgeSBzY2FsZSBpc3N1ZSAjMTIxNVxuICAgICAgICAgICAgICAgIGlmIChpbmQudmFsdWUgIT09IC1OdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICAgICBtYXhZICs9IGluZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWluWSAhPT0gTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgICAgICAgICAgbWluWSArPSBzYW1lU2NhbGVNaW5ZQXJyW3NpXVtrXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKGluZCwgaykge1xuICAgICAgICAgICAgICBpZiAoc1trXS5rZXkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY25mLnlheGlzW2ldLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNuZi55YXhpc1tpXS5taW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IGNuZi55YXhpc1tpXS5taW4oZ2wubWluWSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gY25mLnlheGlzW2ldLm1pbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY25mLnlheGlzW2ldLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNuZi55YXhpc1tpXS5tYXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IGNuZi55YXhpc1tpXS5tYXgoZ2wubWF4WSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gY25mLnlheGlzW2ldLm1heDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpczIuc2V0WVNjYWxlRm9ySW5kZXgoaSwgbWluWSwgbWF4WSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gZXhwZXJpbWVudGFsIGZlYXR1cmUgd2hpY2ggc2NhbGVzIHRoZSB5LWF4aXMgdG8gYSBtaW4vbWF4IGJhc2VkIG9uIHgtYXhpcyByYW5nZVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImF1dG9TY2FsZVlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvU2NhbGVZKGN0eCwgeWF4aXMsIGUpIHtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICBjdHggPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSBjdHgudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzTXVsdGlwbGVZQXhpcyB8fCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZSBhdXRvU2NhbGUgb3B0aW9uIGZvciBtdWx0aXBsZSB5LWF4aXMgaXMgdHVybmVkIG9mZiBhcyBpdCBsZWFkcyB0byBidWdneSBiZWhhdmlvci5cbiAgICAgICAgICAvLyBBbHNvLCB3aGVuIGEgc2VyaWVzIGlzIGNvbGxhcHNlZCwgaXQgcmVzdWx0cyBpbiBpbmNvcnJlY3QgYmVoYXZpb3IuIEhlbmNlIHR1cm5lZCBpdCBvZmYgZm9yIHRoYXQgdG9vIC0gZml4ZXMgYXBleGNoYXJ0cy5qcyM3OTVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2F1dG9TY2FsZVlheGlzIG5vdCBzdXBwb3J0ZWQgaW4gYSBtdWx0aS15YXhpcyBjaGFydC4nKTtcbiAgICAgICAgICByZXR1cm4geWF4aXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VyaWVzWCA9IHcuZ2xvYmFscy5zZXJpZXNYWzBdO1xuICAgICAgICB2YXIgaXNTdGFja2VkID0gdy5jb25maWcuY2hhcnQuc3RhY2tlZDtcbiAgICAgICAgeWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgeWkpIHtcbiAgICAgICAgICB2YXIgZmlyc3RYSW5kZXggPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgeGkgPSAwOyB4aSA8IHNlcmllc1gubGVuZ3RoOyB4aSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzWFt4aV0gPj0gZS54YXhpcy5taW4pIHtcbiAgICAgICAgICAgICAgZmlyc3RYSW5kZXggPSB4aTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluaXRpYWxNaW4gPSB3Lmdsb2JhbHMubWluWUFyclt5aV07XG4gICAgICAgICAgdmFyIGluaXRpYWxNYXggPSB3Lmdsb2JhbHMubWF4WUFyclt5aV07XG4gICAgICAgICAgdmFyIG1pbiwgbWF4O1xuICAgICAgICAgIHZhciBzdGFja2VkU2VyID0gdy5nbG9iYWxzLnN0YWNrZWRTZXJpZXNUb3RhbHM7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZSwgc0kpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFZhbHVlID0gc2VyaWVbZmlyc3RYSW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoaXNTdGFja2VkKSB7XG4gICAgICAgICAgICAgIGZpcnN0VmFsdWUgPSBzdGFja2VkU2VyW2ZpcnN0WEluZGV4XTtcbiAgICAgICAgICAgICAgbWluID0gbWF4ID0gZmlyc3RWYWx1ZTtcbiAgICAgICAgICAgICAgc3RhY2tlZFNlci5mb3JFYWNoKGZ1bmN0aW9uICh5LCB5SSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNYW3lJXSA8PSBlLnhheGlzLm1heCAmJiBzZXJpZXNYW3lJXSA+PSBlLnhheGlzLm1pbikge1xuICAgICAgICAgICAgICAgICAgaWYgKHkgPiBtYXggJiYgeSAhPT0gbnVsbCkgbWF4ID0geTtcbiAgICAgICAgICAgICAgICAgIGlmIChzZXJpZVt5SV0gPCBtaW4gJiYgc2VyaWVbeUldICE9PSBudWxsKSBtaW4gPSBzZXJpZVt5SV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pbiA9IG1heCA9IGZpcnN0VmFsdWU7XG4gICAgICAgICAgICAgIHNlcmllLmZvckVhY2goZnVuY3Rpb24gKHksIHlJKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc1hbeUldIDw9IGUueGF4aXMubWF4ICYmIHNlcmllc1hbeUldID49IGUueGF4aXMubWluKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsTWluID0geTtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWxNYXggPSB5O1xuICAgICAgICAgICAgICAgICAgdy5nbG9iYWxzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uICh3Uywgd1NJKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsTWluID0gTWF0aC5taW4od1NbeUldLCB2YWxNaW4pO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbE1heCA9IE1hdGgubWF4KHdTW3lJXSwgdmFsTWF4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsTWF4ID4gbWF4ICYmIHZhbE1heCAhPT0gbnVsbCkgbWF4ID0gdmFsTWF4O1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbE1pbiA8IG1pbiAmJiB2YWxNaW4gIT09IG51bGwpIG1pbiA9IHZhbE1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQgJiYgbWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbWluID0gaW5pdGlhbE1pbjtcbiAgICAgICAgICAgICAgbWF4ID0gaW5pdGlhbE1heDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluICo9IG1pbiA8IDAgPyAxLjEgOiAwLjk7XG4gICAgICAgICAgICBtYXggKj0gbWF4IDwgMCA/IDAuOSA6IDEuMTtcblxuICAgICAgICAgICAgaWYgKG1pbiA9PT0gMCAmJiBtYXggPT09IDApIHtcbiAgICAgICAgICAgICAgbWluID0gLTE7XG4gICAgICAgICAgICAgIG1heCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXggPCAwICYmIG1heCA8IGluaXRpYWxNYXgpIHtcbiAgICAgICAgICAgICAgbWF4ID0gaW5pdGlhbE1heDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbiA8IDAgJiYgbWluID4gaW5pdGlhbE1pbikge1xuICAgICAgICAgICAgICBtaW4gPSBpbml0aWFsTWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeWF4aXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB5YXhpc1tzSV0ubWluID0geWF4ZS5taW4gPT09IHVuZGVmaW5lZCA/IG1pbiA6IHlheGUubWluO1xuICAgICAgICAgICAgICB5YXhpc1tzSV0ubWF4ID0geWF4ZS5tYXggPT09IHVuZGVmaW5lZCA/IG1heCA6IHlheGUubWF4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeWF4aXNbMF0ubWluID0geWF4ZS5taW4gPT09IHVuZGVmaW5lZCA/IG1pbiA6IHlheGUubWluO1xuICAgICAgICAgICAgICB5YXhpc1swXS5tYXggPSB5YXhlLm1heCA9PT0gdW5kZWZpbmVkID8gbWF4IDogeWF4ZS5tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geWF4aXM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFJhbmdlO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFJhbmdlIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIHZhbHVlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICAgKlxuICAgKiBAbW9kdWxlIFJhbmdlXG4gICAqKi9cblxuICB2YXIgUmFuZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhbmdlKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMuc2NhbGVzID0gbmV3IFJhbmdlJDEoY3R4KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUmFuZ2UsIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0WVJhbmdlKCk7XG4gICAgICAgIHRoaXMuc2V0WFJhbmdlKCk7XG4gICAgICAgIHRoaXMuc2V0WlJhbmdlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE1pbllNYXhZXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWluWU1heFkoc3RhcnRpbmdJbmRleCkge1xuICAgICAgICB2YXIgbG93ZXN0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGhpZ2hlc3RZID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgICB2YXIgbWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgbWluWSA9IE51bWJlci5NSU5fVkFMVUU7XG5cbiAgICAgICAgaWYgKGxlbiA9PT0gbnVsbCkge1xuICAgICAgICAgIGxlbiA9IHN0YXJ0aW5nSW5kZXggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlcmllcyA9IGdsLnNlcmllcztcbiAgICAgICAgdmFyIHNlcmllc01pbiA9IHNlcmllcztcbiAgICAgICAgdmFyIHNlcmllc01heCA9IHNlcmllcztcblxuICAgICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycpIHtcbiAgICAgICAgICBzZXJpZXNNaW4gPSBnbC5zZXJpZXNDYW5kbGVMO1xuICAgICAgICAgIHNlcmllc01heCA9IGdsLnNlcmllc0NhbmRsZUg7XG4gICAgICAgIH0gZWxzZSBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdib3hQbG90Jykge1xuICAgICAgICAgIHNlcmllc01pbiA9IGdsLnNlcmllc0NhbmRsZU87XG4gICAgICAgICAgc2VyaWVzTWF4ID0gZ2wuc2VyaWVzQ2FuZGxlQztcbiAgICAgICAgfSBlbHNlIGlmIChnbC5pc1JhbmdlRGF0YSkge1xuICAgICAgICAgIHNlcmllc01pbiA9IGdsLnNlcmllc1JhbmdlU3RhcnQ7XG4gICAgICAgICAgc2VyaWVzTWF4ID0gZ2wuc2VyaWVzUmFuZ2VFbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRpbmdJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZ2wuZGF0YVBvaW50cyA9IE1hdGgubWF4KGdsLmRhdGFQb2ludHMsIHNlcmllc1tpXS5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKGdsLmNhdGVnb3J5TGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgZ2wuZGF0YVBvaW50cyA9IGdsLmNhdGVnb3J5TGFiZWxzLmZpbHRlcihmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBsYWJlbCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGdsLmxhYmVscy5sZW5ndGggJiYgY25mLnhheGlzLnR5cGUgIT09ICdkYXRldGltZScgJiYgZ2wuc2VyaWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBjLmxlbmd0aDtcbiAgICAgICAgICB9LCAwKSAhPT0gMCkge1xuICAgICAgICAgICAgLy8gdGhlIGNvbmRpdGlvbiBjbmYueGF4aXMudHlwZSAhPT0gJ2RhdGV0aW1lJyBmaXhlcyAjMzg5NyBhbmQgIzM5MDVcbiAgICAgICAgICAgIGdsLmRhdGFQb2ludHMgPSBNYXRoLm1heChnbC5kYXRhUG9pbnRzLCBnbC5sYWJlbHMubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdsLnNlcmllc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHNlcmllc1tpXVtqXTtcblxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiBVdGlscyQxLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNNYXhbaV1bal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHNlcmllc01heFtpXVtqXSk7XG4gICAgICAgICAgICAgICAgbG93ZXN0WSA9IE1hdGgubWluKGxvd2VzdFksIHNlcmllc01heFtpXVtqXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcmllc01pbltpXVtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsb3dlc3RZID0gTWF0aC5taW4obG93ZXN0WSwgc2VyaWVzTWluW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBoaWdoZXN0WSA9IE1hdGgubWF4KGhpZ2hlc3RZLCBzZXJpZXNNaW5baV1bal0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMudy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJyB8fCB0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdib3hQbG90JyB8fCB0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdyYW5nZUFyZWEnIHx8IHRoaXMudy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ3JhbmdlQmFyJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgdGhpcy53LmNvbmZpZy5jaGFydC50eXBlID09PSAnYm94UGxvdCcpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2wuc2VyaWVzQ2FuZGxlQ1tpXVtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIGdsLnNlcmllc0NhbmRsZU9baV1bal0pO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgZ2wuc2VyaWVzQ2FuZGxlSFtpXVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBnbC5zZXJpZXNDYW5kbGVMW2ldW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIGdsLnNlcmllc0NhbmRsZUNbaV1bal0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdib3hQbG90Jykge1xuICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBnbC5zZXJpZXNDYW5kbGVNW2ldW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gdGhlcmUgaXMgYSBjb21ibyBjaGFydCBhbmQgdGhlIHNwZWNpZmllZCBzZXJpZXMgaW4gbm90IGVpdGhlciBjYW5kbGVzdGljaywgYm94cGxvdCwgb3IgcmFuZ2VBcmVhL3JhbmdlQmFyOyBmaW5kIHRoZSBtYXggdGhlcmVcblxuXG4gICAgICAgICAgICAgICAgaWYgKGNuZi5zZXJpZXNbaV0udHlwZSAmJiAoY25mLnNlcmllc1tpXS50eXBlICE9PSAnY2FuZGxlc3RpY2snIHx8IGNuZi5zZXJpZXNbaV0udHlwZSAhPT0gJ2JveFBsb3QnIHx8IGNuZi5zZXJpZXNbaV0udHlwZSAhPT0gJ3JhbmdlQXJlYScgfHwgY25mLnNlcmllc1tpXS50eXBlICE9PSAncmFuZ2VCYXInKSkge1xuICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIGdsLnNlcmllc1tpXVtqXSk7XG4gICAgICAgICAgICAgICAgICBsb3dlc3RZID0gTWF0aC5taW4obG93ZXN0WSwgZ2wuc2VyaWVzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBoaWdoZXN0WSA9IG1heFk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZ2wuc2VyaWVzR29hbHNbaV0gJiYgZ2wuc2VyaWVzR29hbHNbaV1bal0gJiYgQXJyYXkuaXNBcnJheShnbC5zZXJpZXNHb2Fsc1tpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICBnbC5zZXJpZXNHb2Fsc1tpXVtqXS5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWluWSAhPT0gTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VzdFkgPSBtaW5ZO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBoaWdoZXN0WSA9IG1heFk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoVXRpbHMkMS5pc0Zsb2F0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBVdGlscyQxLm5vRXhwb25lbnRzKHZhbCk7XG4gICAgICAgICAgICAgICAgZ2wueVZhbHVlRGVjaW1hbCA9IE1hdGgubWF4KGdsLnlWYWx1ZURlY2ltYWwsIHZhbC50b1N0cmluZygpLnNwbGl0KCcuJylbMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtaW5ZID4gc2VyaWVzTWluW2ldW2pdICYmIHNlcmllc01pbltpXVtqXSA8IDApIHtcbiAgICAgICAgICAgICAgICBtaW5ZID0gc2VyaWVzTWluW2ldW2pdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnbC5oYXNOdWxsVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdyYW5nZUJhcicgJiYgZ2wuc2VyaWVzUmFuZ2VTdGFydC5sZW5ndGggJiYgZ2wuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgbWluWSA9IGxvd2VzdFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdiYXInKSB7XG4gICAgICAgICAgaWYgKG1pblkgPCAwICYmIG1heFkgPCAwKSB7XG4gICAgICAgICAgICAvLyBhbGwgbmVnYXRpdmUgdmFsdWVzIGluIGEgYmFyIGNoYXJ0LCBoZW5jZSBtYWtlIHRoZSBtYXggdG8gMFxuICAgICAgICAgICAgbWF4WSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pblkgPT09IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgICAgIG1pblkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgICBtYXhZOiBtYXhZLFxuICAgICAgICAgIGxvd2VzdFk6IGxvd2VzdFksXG4gICAgICAgICAgaGlnaGVzdFk6IGhpZ2hlc3RZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFlSYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFlSYW5nZSgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgICBnbC5tYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGdsLm1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICB2YXIgbG93ZXN0WUluQWxsU2VyaWVzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICBpZiAoZ2wuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBnZXQgbWluWSBhbmQgbWF4WSBmb3IgbXVsdGlwbGUgeSBheGlzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtaW5ZTWF4WUFyciA9IHRoaXMuZ2V0TWluWU1heFkoaSwgbG93ZXN0WUluQWxsU2VyaWVzLCBudWxsLCBpICsgMSk7XG4gICAgICAgICAgICBnbC5taW5ZQXJyLnB1c2gobWluWU1heFlBcnIubWluWSk7XG4gICAgICAgICAgICBnbC5tYXhZQXJyLnB1c2gobWluWU1heFlBcnIubWF4WSk7XG4gICAgICAgICAgICBsb3dlc3RZSW5BbGxTZXJpZXMgPSBtaW5ZTWF4WUFyci5sb3dlc3RZO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBhbmQgdGhlbiwgZ2V0IHRoZSBtaW5ZIGFuZCBtYXhZIGZyb20gYWxsIHNlcmllc1xuXG5cbiAgICAgICAgdmFyIG1pbllNYXhZID0gdGhpcy5nZXRNaW5ZTWF4WSgwLCBsb3dlc3RZSW5BbGxTZXJpZXMsIG51bGwsIGdsLnNlcmllcy5sZW5ndGgpO1xuICAgICAgICBnbC5taW5ZID0gbWluWU1heFkubWluWTtcbiAgICAgICAgZ2wubWF4WSA9IG1pbllNYXhZLm1heFk7XG4gICAgICAgIGxvd2VzdFlJbkFsbFNlcmllcyA9IG1pbllNYXhZLmxvd2VzdFk7XG5cbiAgICAgICAgaWYgKGNuZi5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U3RhY2tlZE1pbk1heCgpO1xuICAgICAgICB9IC8vIGlmIHRoZSBudW1iZXJzIGFyZSB0b28gYmlnLCByZWR1Y2UgdGhlIHJhbmdlXG4gICAgICAgIC8vIGZvciBlZywgaWYgbnVtYmVyIGlzIGJldHdlZW4gMTAwMDAwLTExMDAwMCwgcHV0dGluZyAwIGFzIHRoZSBsb3dlc3QgdmFsdWUgaXMgbm90IHNvIGdvb2QgaWRlYS4gU28gY2hhbmdlIHRoZSBnbC5taW5ZIGZvciBsaW5lL2FyZWEvY2FuZGxlc3RpY2tzL2JveFBsb3RcblxuXG4gICAgICAgIGlmIChjbmYuY2hhcnQudHlwZSA9PT0gJ2xpbmUnIHx8IGNuZi5jaGFydC50eXBlID09PSAnYXJlYScgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdib3hQbG90JyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJyAmJiAhZ2wuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgaWYgKGdsLm1pblkgPT09IE51bWJlci5NSU5fVkFMVUUgJiYgbG93ZXN0WUluQWxsU2VyaWVzICE9PSAtTnVtYmVyLk1BWF9WQUxVRSAmJiBsb3dlc3RZSW5BbGxTZXJpZXMgIT09IGdsLm1heFkgLy8gc2luZ2xlIHZhbHVlIHBvc3NpYmlsaXR5XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGdsLm1heFkgLSBsb3dlc3RZSW5BbGxTZXJpZXM7XG5cbiAgICAgICAgICAgIGlmIChsb3dlc3RZSW5BbGxTZXJpZXMgPj0gMCAmJiBsb3dlc3RZSW5BbGxTZXJpZXMgPD0gMTAgfHwgY25mLnlheGlzWzBdLm1pbiAhPT0gdW5kZWZpbmVkIHx8IGNuZi55YXhpc1swXS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBpZiBtaW5ZIGlzIGFscmVhZHkgMC9sb3cgdmFsdWUsIHdlIGRvbid0IHdhbnQgdG8gZ28gbmVnYXRpdmVzIGhlcmUgLSBzbyB0aGlzIGNoZWNrIGlzIGVzc2VudGlhbC5cbiAgICAgICAgICAgICAgZGlmZiA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLm1pblkgPSBsb3dlc3RZSW5BbGxTZXJpZXMgLSBkaWZmICogNSAvIDEwMDtcbiAgICAgICAgICAgIC8qIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy82MTQgKi9cblxuICAgICAgICAgICAgLyogZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzk2OCAqL1xuXG4gICAgICAgICAgICBpZiAobG93ZXN0WUluQWxsU2VyaWVzID4gMCAmJiBnbC5taW5ZIDwgMCkge1xuICAgICAgICAgICAgICBnbC5taW5ZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy80MjYgKi9cblxuXG4gICAgICAgICAgICBnbC5tYXhZID0gZ2wubWF4WSArIGRpZmYgKiA1IC8gMTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNuZi55YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgIC8vIG92ZXJyaWRlIGFsbCBtaW4vbWF4IHZhbHVlcyBieSB1c2VyIGRlZmluZWQgdmFsdWVzICh5IGF4aXMpXG4gICAgICAgICAgaWYgKHlheGUubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgeWF4ZS5tYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIGdsLm1heFlBcnJbaW5kZXhdID0geWF4ZS5tYXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB5YXhlLm1heCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBmaXhlcyBhcGV4Y2hhcnRzLmpzL2lzc3Vlcy8yMDk4XG4gICAgICAgICAgICAgIGdsLm1heFlBcnJbaW5kZXhdID0geWF4ZS5tYXgoZ2wuaXNNdWx0aXBsZVlBeGlzID8gZ2wubWF4WUFycltpbmRleF0gOiBnbC5tYXhZKTtcbiAgICAgICAgICAgIH0gLy8gZ2wubWF4WSBpcyBmb3Igc2luZ2xlIHktYXhpcyBjaGFydCwgaXQgd2lsbCBiZSBpZ25vcmVkIGluIG11bHRpLXlheGlzXG5cblxuICAgICAgICAgICAgZ2wubWF4WSA9IGdsLm1heFlBcnJbaW5kZXhdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh5YXhlLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHlheGUubWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBnbC5taW5ZQXJyW2luZGV4XSA9IHlheGUubWluO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeWF4ZS5taW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gZml4ZXMgYXBleGNoYXJ0cy5qcy9pc3N1ZXMvMjA5OFxuICAgICAgICAgICAgICBnbC5taW5ZQXJyW2luZGV4XSA9IHlheGUubWluKGdsLmlzTXVsdGlwbGVZQXhpcyA/IGdsLm1pbllBcnJbaW5kZXhdID09PSBOdW1iZXIuTUlOX1ZBTFVFID8gMCA6IGdsLm1pbllBcnJbaW5kZXhdIDogZ2wubWluWSk7XG4gICAgICAgICAgICB9IC8vIGdsLm1pblkgaXMgZm9yIHNpbmdsZSB5LWF4aXMgY2hhcnQsIGl0IHdpbGwgYmUgaWdub3JlZCBpbiBtdWx0aS15YXhpc1xuXG5cbiAgICAgICAgICAgIGdsLm1pblkgPSBnbC5taW5ZQXJyW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBmb3IgaG9yaXpvbnRhbCBiYXIgY2hhcnRzLCB3ZSBuZWVkIHRvIGNoZWNrIHhheGlzIG1pbi9tYXggYXMgdXNlciBtYXkgaGF2ZSBzcGVjaWZpZWQgdGhlcmVcblxuICAgICAgICBpZiAoZ2wuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgdmFyIG1pbm1heCA9IFsnbWluJywgJ21heCddO1xuICAgICAgICAgIG1pbm1heC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAoY25mLnhheGlzW21dICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNuZi54YXhpc1ttXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgbSA9PT0gJ21pbicgPyBnbC5taW5ZID0gY25mLnhheGlzW21dIDogZ2wubWF4WSA9IGNuZi54YXhpc1ttXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBmb3IgbXVsdGkgeS1heGlzIHdlIG5lZWQgZGlmZmVyZW50IHNjYWxlcyBmb3IgZWFjaFxuXG5cbiAgICAgICAgaWYgKGdsLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICAgIHRoaXMuc2NhbGVzLnNldE11bHRpcGxlWVNjYWxlcygpO1xuICAgICAgICAgIGdsLm1pblkgPSBsb3dlc3RZSW5BbGxTZXJpZXM7XG4gICAgICAgICAgZ2wueUF4aXNTY2FsZS5mb3JFYWNoKGZ1bmN0aW9uIChzY2FsZSwgaSkge1xuICAgICAgICAgICAgZ2wubWluWUFycltpXSA9IHNjYWxlLm5pY2VNaW47XG4gICAgICAgICAgICBnbC5tYXhZQXJyW2ldID0gc2NhbGUubmljZU1heDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNjYWxlcy5zZXRZU2NhbGVGb3JJbmRleCgwLCBnbC5taW5ZLCBnbC5tYXhZKTtcbiAgICAgICAgICBnbC5taW5ZID0gZ2wueUF4aXNTY2FsZVswXS5uaWNlTWluO1xuICAgICAgICAgIGdsLm1heFkgPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNYXg7XG4gICAgICAgICAgZ2wubWluWUFyclswXSA9IGdsLnlBeGlzU2NhbGVbMF0ubmljZU1pbjtcbiAgICAgICAgICBnbC5tYXhZQXJyWzBdID0gZ2wueUF4aXNTY2FsZVswXS5uaWNlTWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtaW5ZOiBnbC5taW5ZLFxuICAgICAgICAgIG1heFk6IGdsLm1heFksXG4gICAgICAgICAgbWluWUFycjogZ2wubWluWUFycixcbiAgICAgICAgICBtYXhZQXJyOiBnbC5tYXhZQXJyLFxuICAgICAgICAgIHlBeGlzU2NhbGU6IGdsLnlBeGlzU2NhbGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0WFJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WFJhbmdlKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICAgIHZhciBpc1hOdW1lcmljID0gY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJyB8fCBjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJyB8fCBjbmYueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiAhZ2wubm9MYWJlbHNQcm92aWRlZCB8fCBnbC5ub0xhYmVsc1Byb3ZpZGVkIHx8IGdsLmlzWE51bWVyaWM7XG5cbiAgICAgICAgdmFyIGdldEluaXRpYWxNaW5YTWF4WCA9IGZ1bmN0aW9uIGdldEluaXRpYWxNaW5YTWF4WCgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGdsLmxhYmVsc1tpXSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdsLmxhYmVsc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChnbC5sYWJlbHNbaV1bal0gIT09IG51bGwgJiYgVXRpbHMkMS5pc051bWJlcihnbC5sYWJlbHNbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgICBnbC5tYXhYID0gTWF0aC5tYXgoZ2wubWF4WCwgZ2wubGFiZWxzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICAgIGdsLmluaXRpYWxNYXhYID0gTWF0aC5tYXgoZ2wubWF4WCwgZ2wubGFiZWxzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICAgIGdsLm1pblggPSBNYXRoLm1pbihnbC5taW5YLCBnbC5sYWJlbHNbaV1bal0pO1xuICAgICAgICAgICAgICAgICAgZ2wuaW5pdGlhbE1pblggPSBNYXRoLm1pbihnbC5taW5YLCBnbC5sYWJlbHNbaV1bal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gbWluWCBtYXhYIHN0YXJ0cyBoZXJlXG5cblxuICAgICAgICBpZiAoZ2wuaXNYTnVtZXJpYykge1xuICAgICAgICAgIGdldEluaXRpYWxNaW5YTWF4WCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsLm5vTGFiZWxzUHJvdmlkZWQpIHtcbiAgICAgICAgICBpZiAoY25mLnhheGlzLmNhdGVnb3JpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnbC5tYXhYID0gZ2wubGFiZWxzW2dsLmxhYmVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGdsLmluaXRpYWxNYXhYID0gZ2wubGFiZWxzW2dsLmxhYmVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGdsLm1pblggPSAxO1xuICAgICAgICAgICAgZ2wuaW5pdGlhbE1pblggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbC5pc1hOdW1lcmljIHx8IGdsLm5vTGFiZWxzUHJvdmlkZWQgfHwgZ2wuZGF0YUZvcm1hdFhOdW1lcmljKSB7XG4gICAgICAgICAgdmFyIHRpY2tzO1xuXG4gICAgICAgICAgaWYgKGNuZi54YXhpcy50aWNrQW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpY2tzID0gTWF0aC5yb3VuZChnbC5zdmdXaWR0aCAvIDE1MCk7IC8vIG5vIGxhYmVscyBwcm92aWRlZCBhbmQgdG90YWwgbnVtYmVyIG9mIGRhdGFQb2ludHMgaXMgbGVzcyB0aGFuIDMwXG5cbiAgICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnICYmIGdsLmRhdGFQb2ludHMgPCAzMCkge1xuICAgICAgICAgICAgICB0aWNrcyA9IGdsLmRhdGFQb2ludHMgLSAxO1xuICAgICAgICAgICAgfSAvLyB0aGlzIGNoZWNrIGlzIGZvciB3aGVuIHRpY2tzIGV4Y2VlZHMgdG90YWwgZGF0YXBvaW50cyBhbmQgdGhhdCB3b3VsZCByZXN1bHQgaW4gZHVwbGljYXRlIGxhYmVsc1xuXG5cbiAgICAgICAgICAgIGlmICh0aWNrcyA+IGdsLmRhdGFQb2ludHMgJiYgZ2wuZGF0YVBvaW50cyAhPT0gMCkge1xuICAgICAgICAgICAgICB0aWNrcyA9IGdsLmRhdGFQb2ludHMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY25mLnhheGlzLnRpY2tBbW91bnQgPT09ICdkYXRhUG9pbnRzJykge1xuICAgICAgICAgICAgaWYgKGdsLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHRpY2tzID0gZ2wuc2VyaWVzW2dsLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnbC5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgICAgIHRpY2tzID0gZ2wubWF4WCAtIGdsLm1pblggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrcyA9IGNuZi54YXhpcy50aWNrQW1vdW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLnhUaWNrQW1vdW50ID0gdGlja3M7IC8vIG92ZXJyaWRlIGFsbCBtaW4vbWF4IHZhbHVlcyBieSB1c2VyIGRlZmluZWQgdmFsdWVzICh4IGF4aXMpXG5cbiAgICAgICAgICBpZiAoY25mLnhheGlzLm1heCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjbmYueGF4aXMubWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZ2wubWF4WCA9IGNuZi54YXhpcy5tYXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNuZi54YXhpcy5taW4gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY25mLnhheGlzLm1pbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGdsLm1pblggPSBjbmYueGF4aXMubWluO1xuICAgICAgICAgIH0gLy8gaWYgcmFuZ2UgaXMgcHJvdmlkZWQsIGFkanVzdCB0aGUgbmV3IG1pblhcblxuXG4gICAgICAgICAgaWYgKGNuZi54YXhpcy5yYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbC5taW5YID0gZ2wubWF4WCAtIGNuZi54YXhpcy5yYW5nZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2wubWluWCAhPT0gTnVtYmVyLk1BWF9WQUxVRSAmJiBnbC5tYXhYICE9PSAtTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgaWYgKGNuZi54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMgJiYgIWdsLmRhdGFGb3JtYXRYTnVtZXJpYykge1xuICAgICAgICAgICAgICB2YXIgY2F0U2NhbGUgPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZ2wubWluWCAtIDE7IGkgPCBnbC5tYXhYOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYXRTY2FsZS5wdXNoKGkgKyAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdsLnhBeGlzU2NhbGUgPSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBjYXRTY2FsZSxcbiAgICAgICAgICAgICAgICBuaWNlTWluOiBjYXRTY2FsZVswXSxcbiAgICAgICAgICAgICAgICBuaWNlTWF4OiBjYXRTY2FsZVtjYXRTY2FsZS5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2wueEF4aXNTY2FsZSA9IHRoaXMuc2NhbGVzLnNldFhTY2FsZShnbC5taW5YLCBnbC5tYXhYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wueEF4aXNTY2FsZSA9IHRoaXMuc2NhbGVzLmxpbmVhclNjYWxlKDAsIHRpY2tzLCB0aWNrcyk7XG5cbiAgICAgICAgICAgIGlmIChnbC5ub0xhYmVsc1Byb3ZpZGVkICYmIGdsLmxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGdsLnhBeGlzU2NhbGUgPSB0aGlzLnNjYWxlcy5saW5lYXJTY2FsZSgxLCBnbC5sYWJlbHMubGVuZ3RoLCB0aWNrcyAtIDEpOyAvLyB0aGlzIGlzIHRoZSBvbmx5IHBsYWNlIHNlcmllc1ggaXMgYWdhaW4gbXV0YXRlZFxuXG4gICAgICAgICAgICAgIGdsLnNlcmllc1ggPSBnbC5sYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHdlIHdpbGwgc3RpbGwgc3RvcmUgdGhlc2UgbGFiZWxzIGFzIHRoZSBjb3VudCBmb3IgdGhpcyB3aWxsIGJlIGRpZmZlcmVudCAodG8gZHJhdyBncmlkIGFuZCBsYWJlbHMgcGxhY2VtZW50KVxuXG5cbiAgICAgICAgICBpZiAoaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgZ2wubGFiZWxzID0gZ2wueEF4aXNTY2FsZS5yZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2wuaXNCYXJIb3Jpem9udGFsICYmIGdsLmxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgICBnbC54VGlja0Ftb3VudCA9IGdsLmxhYmVscy5sZW5ndGg7XG4gICAgICAgIH0gLy8gc2luZ2xlIGRhdGFQb2ludFxuXG5cbiAgICAgICAgdGhpcy5faGFuZGxlU2luZ2xlRGF0YVBvaW50KCk7IC8vIG1pbmltdW0geCBkaWZmZXJlbmNlIHRvIGNhbGN1bGF0ZSBiYXIgd2lkdGggaW4gbnVtZXJpYyBiYXJzXG5cblxuICAgICAgICB0aGlzLl9nZXRNaW5YRGlmZigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluWDogZ2wubWluWCxcbiAgICAgICAgICBtYXhYOiBnbC5tYXhYXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFpSYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFpSYW5nZSgpIHtcbiAgICAgICAgLy8gbWluWiwgbWF4WiBzdGFydHMgaGVyZVxuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgICAgaWYgKCFnbC5pc0RhdGFYWVopIHJldHVybjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZ2wuc2VyaWVzWltpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzWltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoZ2wuc2VyaWVzWltpXVtqXSAhPT0gbnVsbCAmJiBVdGlscyQxLmlzTnVtYmVyKGdsLnNlcmllc1pbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgZ2wubWF4WiA9IE1hdGgubWF4KGdsLm1heFosIGdsLnNlcmllc1pbaV1bal0pO1xuICAgICAgICAgICAgICAgIGdsLm1pblogPSBNYXRoLm1pbihnbC5taW5aLCBnbC5zZXJpZXNaW2ldW2pdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlU2luZ2xlRGF0YVBvaW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVNpbmdsZURhdGFQb2ludCgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuXG4gICAgICAgIGlmIChnbC5taW5YID09PSBnbC5tYXhYKSB7XG4gICAgICAgICAgdmFyIGRhdGV0aW1lT2JqID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcblxuICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgdmFyIG5ld01pblggPSBkYXRldGltZU9iai5nZXREYXRlKGdsLm1pblgpO1xuXG4gICAgICAgICAgICBpZiAoY25mLnhheGlzLmxhYmVscy5kYXRldGltZVVUQykge1xuICAgICAgICAgICAgICBuZXdNaW5YLnNldFVUQ0RhdGUobmV3TWluWC5nZXRVVENEYXRlKCkgLSAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld01pblguc2V0RGF0ZShuZXdNaW5YLmdldERhdGUoKSAtIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5taW5YID0gbmV3IERhdGUobmV3TWluWCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIG5ld01heFggPSBkYXRldGltZU9iai5nZXREYXRlKGdsLm1heFgpO1xuXG4gICAgICAgICAgICBpZiAoY25mLnhheGlzLmxhYmVscy5kYXRldGltZVVUQykge1xuICAgICAgICAgICAgICBuZXdNYXhYLnNldFVUQ0RhdGUobmV3TWF4WC5nZXRVVENEYXRlKCkgKyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld01heFguc2V0RGF0ZShuZXdNYXhYLmdldERhdGUoKSArIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5tYXhYID0gbmV3IERhdGUobmV3TWF4WCkuZ2V0VGltZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJyB8fCBjbmYueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiAhZ2wubm9MYWJlbHNQcm92aWRlZCkge1xuICAgICAgICAgICAgZ2wubWluWCA9IGdsLm1pblggLSAyO1xuICAgICAgICAgICAgZ2wuaW5pdGlhbE1pblggPSBnbC5taW5YO1xuICAgICAgICAgICAgZ2wubWF4WCA9IGdsLm1heFggKyAyO1xuICAgICAgICAgICAgZ2wuaW5pdGlhbE1heFggPSBnbC5tYXhYO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0TWluWERpZmZcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWluWERpZmYoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuXG4gICAgICAgIGlmIChnbC5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBsZWFzdCB4IGRpZmYgaWYgbnVtZXJpYyB4IGF4aXMgaXMgcHJlc2VudFxuICAgICAgICAgIGdsLnNlcmllc1guZm9yRWFjaChmdW5jdGlvbiAoc1gsIGkpIHtcbiAgICAgICAgICAgIGlmIChzWC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gYSBzbWFsbCBoYWNrIHRvIHByZXZlbnQgb3ZlcmxhcHBpbmcgbXVsdGlwbGUgYmFycyB3aGVuIHRoZXJlIGlzIGp1c3QgMSBkYXRhcG9pbnQgaW4gYmFyIHNlcmllcy5cbiAgICAgICAgICAgICAgLy8gZml4ICM4MTFcbiAgICAgICAgICAgICAgc1gucHVzaChnbC5zZXJpZXNYW2dsLm1heFZhbHNJbkFycmF5SW5kZXhdW2dsLnNlcmllc1hbZ2wubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfSAvLyBmaXggIzk4MyAoY2xvbmUgdGhlIGFycmF5IHRvIGF2b2lkIHNpZGUgZWZmZWN0cylcblxuXG4gICAgICAgICAgICB2YXIgc2VyaWVzWCA9IHNYLnNsaWNlKCk7XG4gICAgICAgICAgICBzZXJpZXNYLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXJpZXNYLmZvckVhY2goZnVuY3Rpb24gKHMsIGopIHtcbiAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhEaWZmID0gcyAtIHNlcmllc1hbaiAtIDFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHhEaWZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgZ2wubWluWERpZmYgPSBNYXRoLm1pbih4RGlmZiwgZ2wubWluWERpZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChnbC5kYXRhUG9pbnRzID09PSAxIHx8IGdsLm1pblhEaWZmID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICAgIC8vIGZpeGVzIGFwZXhjaGFydHMuanMgIzEyMjFcbiAgICAgICAgICAgICAgZ2wubWluWERpZmYgPSAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFN0YWNrZWRNaW5NYXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3RhY2tlZE1pbk1heCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFsczsgLy8gZm9yIHN0YWNrZWQgY2hhcnRzLCB3ZSBjYWxjdWxhdGUgZWFjaCBzZXJpZXMncyBwYXJhbGxlbCB2YWx1ZXMuIGkuZSwgc2VyaWVzWzBdW2pdICsgc2VyaWVzWzFdW2pdIC4uLi4gW3Nlcmllc1tpLmxlbmd0aF1bal1dIGFuZCBnZXQgdGhlIG1heCBvdXQgb2YgaXRcblxuICAgICAgICBpZiAoIWdsLnNlcmllcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgdmFyIHNlcmllc0dyb3VwcyA9IGdsLnNlcmllc0dyb3VwcztcblxuICAgICAgICBpZiAoIXNlcmllc0dyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZXJpZXNHcm91cHMgPSBbdGhpcy53LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXJpZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllLm5hbWU7XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrZWRQb3NzID0ge307XG4gICAgICAgIHZhciBzdGFja2VkTmVncyA9IHt9O1xuICAgICAgICBzZXJpZXNHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICBzdGFja2VkUG9zc1tncm91cF0gPSBbXTtcbiAgICAgICAgICBzdGFja2VkTmVnc1tncm91cF0gPSBbXTtcblxuICAgICAgICAgIHZhciBpbmRpY2VzT2ZTZXJpZXNJbkdyb3VwID0gX3RoaXMudy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAoc2VyaWUsIHNpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAuaW5kZXhPZihzZXJpZS5uYW1lKSA+IC0xID8gc2kgOiBudWxsO1xuICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIGYgIT09IG51bGw7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbmRpY2VzT2ZTZXJpZXNJbkdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzW2dsLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhY2tlZFBvc3NbZ3JvdXBdW2pdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN0YWNrZWRQb3NzW2dyb3VwXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgc3RhY2tlZE5lZ3NbZ3JvdXBdW2pdID0gMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChnbC5zZXJpZXNbaV1bal0gIT09IG51bGwgJiYgVXRpbHMkMS5pc051bWJlcihnbC5zZXJpZXNbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgZ2wuc2VyaWVzW2ldW2pdID4gMCA/IHN0YWNrZWRQb3NzW2dyb3VwXVtqXSArPSBwYXJzZUZsb2F0KGdsLnNlcmllc1tpXVtqXSkgKyAwLjAwMDEgOiBzdGFja2VkTmVnc1tncm91cF1bal0gKz0gcGFyc2VGbG9hdChnbC5zZXJpZXNbaV1bal0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZW50cmllcyhzdGFja2VkUG9zcykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgICAgICBrZXkgPSBfcmVmMlswXTtcblxuICAgICAgICAgIHN0YWNrZWRQb3NzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoXywgc3RnaSkge1xuICAgICAgICAgICAgZ2wubWF4WSA9IE1hdGgubWF4KGdsLm1heFksIHN0YWNrZWRQb3NzW2tleV1bc3RnaV0pO1xuICAgICAgICAgICAgZ2wubWluWSA9IE1hdGgubWluKGdsLm1pblksIHN0YWNrZWROZWdzW2tleV1bc3RnaV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmFuZ2U7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBZQXhpcyBDbGFzcyBmb3IgZHJhd2luZyBZLUF4aXMuXG4gICAqXG4gICAqIEBtb2R1bGUgWUF4aXNcbiAgICoqL1xuXG4gIHZhciBZQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWUF4aXMoY3R4LCBlbGdyaWQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZQXhpcyk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy5lbGdyaWQgPSBlbGdyaWQ7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy54YXhpc0ZvbnRTaXplID0gdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplO1xuICAgICAgdGhpcy5heGlzRm9udEZhbWlseSA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250RmFtaWx5O1xuICAgICAgdGhpcy54YXhpc0ZvcmVDb2xvcnMgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY29sb3JzO1xuICAgICAgdGhpcy5pc0NhdGVnb3J5QmFySG9yaXpvbnRhbCA9IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsO1xuICAgICAgdGhpcy54QXhpc29mZlggPSAwO1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHRoaXMueEF4aXNvZmZYID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhd25MYWJlbHMgPSBbXTtcbiAgICAgIHRoaXMuYXhlc1V0aWxzID0gbmV3IEF4ZXNVdGlscyhjdHgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhZQXhpcywgW3tcbiAgICAgIGtleTogXCJkcmF3WWF4aXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WWF4aXMocmVhbEluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB5YXhpc1N0eWxlID0gdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMuc3R5bGU7XG4gICAgICAgIHZhciB5YXhpc0ZvbnRTaXplID0geWF4aXNTdHlsZS5mb250U2l6ZTtcbiAgICAgICAgdmFyIHlheGlzRm9udEZhbWlseSA9IHlheGlzU3R5bGUuZm9udEZhbWlseTtcbiAgICAgICAgdmFyIHlheGlzRm9udFdlaWdodCA9IHlheGlzU3R5bGUuZm9udFdlaWdodDtcbiAgICAgICAgdmFyIGVsWWF4aXMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzJyxcbiAgICAgICAgICByZWw6IHJlYWxJbmRleCxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHcuZ2xvYmFscy50cmFuc2xhdGVZQXhpc1hbcmVhbEluZGV4XSArICcsIDApJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5heGVzVXRpbHMuaXNZQXhpc0hpZGRlbihyZWFsSW5kZXgpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsWWF4aXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxZYXhpc1RleHRzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nJ1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpcy5hZGQoZWxZYXhpc1RleHRzKTtcbiAgICAgICAgdmFyIHRpY2tBbW91bnQgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVtyZWFsSW5kZXhdLnJlc3VsdC5sZW5ndGggLSAxOyAvLyBsYWJlbHNEaXZpZGVyIGlzIHNpbXBseSBzdmcgaGVpZ2h0L251bWJlciBvZiB0aWNrc1xuXG4gICAgICAgIHZhciBsYWJlbHNEaXZpZGVyID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB0aWNrQW1vdW50OyAvLyBpbml0aWFsIGxhYmVsIHBvc2l0aW9uID0gMDtcblxuICAgICAgICB2YXIgbCA9IHcuZ2xvYmFscy50cmFuc2xhdGVZO1xuICAgICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tyZWFsSW5kZXhdO1xuICAgICAgICB2YXIgbGFiZWxzID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbcmVhbEluZGV4XS5yZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgbGFiZWxzID0gdGhpcy5heGVzVXRpbHMuY2hlY2tGb3JSZXZlcnNlZExhYmVscyhyZWFsSW5kZXgsIGxhYmVscyk7XG4gICAgICAgIHZhciBmaXJzdExhYmVsID0gJyc7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnNob3cpIHtcbiAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gbGFiZWxzW2ldO1xuICAgICAgICAgICAgdmFsID0gbGJGb3JtYXR0ZXIodmFsLCBpLCB3KTtcbiAgICAgICAgICAgIHZhciB4UGFkID0gdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMucGFkZGluZztcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUgJiYgdy5jb25maWcueWF4aXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHhQYWQgPSB4UGFkICogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0QW5jaG9yID0gJ2VuZCc7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeUNvbG9ycyA9IF90aGlzLmF4ZXNVdGlscy5nZXRZQXhpc0ZvcmVDb2xvcih5YXhpc1N0eWxlLmNvbG9ycywgcmVhbEluZGV4KTtcblxuICAgICAgICAgICAgdmFyIGdldEZvcmVDb2xvciA9IGZ1bmN0aW9uIGdldEZvcmVDb2xvcigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeUNvbG9ycykgPyB5Q29sb3JzW2ldIDogeUNvbG9ycztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMub2Zmc2V0WTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICAgICAgICB2YXIgZGl2aXNvciA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBvZmZzZXRZID0gb2Zmc2V0WSAtIGRpdmlzb3IgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICAgIHg6IHhQYWQsXG4gICAgICAgICAgICAgIHk6IGwgKyB0aWNrQW1vdW50IC8gMTAgKyBvZmZzZXRZICsgMSxcbiAgICAgICAgICAgICAgdGV4dDogdmFsLFxuICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgICAgICBmb250U2l6ZTogeWF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogeWF4aXNGb250RmFtaWx5LFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiB5YXhpc0ZvbnRXZWlnaHQsXG4gICAgICAgICAgICAgIG1heFdpZHRoOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgZm9yZUNvbG9yOiBnZXRGb3JlQ29sb3IoKSxcbiAgICAgICAgICAgICAgaXNQbGFpblRleHQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtbGFiZWwgJyArIHlheGlzU3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gdGlja0Ftb3VudCkge1xuICAgICAgICAgICAgICBmaXJzdExhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsWWF4aXNUZXh0cy5hZGQobGFiZWwpO1xuICAgICAgICAgICAgdmFyIGVsVG9vbHRpcFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3RpdGxlJyk7XG4gICAgICAgICAgICBlbFRvb2x0aXBUaXRsZS50ZXh0Q29udGVudCA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5qb2luKCcgJykgOiB2YWw7XG4gICAgICAgICAgICBsYWJlbC5ub2RlLmFwcGVuZENoaWxkKGVsVG9vbHRpcFRpdGxlKTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnJvdGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgICB2YXIgZmlyc3RhYmVsUm90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIoZmlyc3RMYWJlbC5ub2RlKTtcbiAgICAgICAgICAgICAgdmFyIGxhYmVsUm90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIobGFiZWwubm9kZSk7XG4gICAgICAgICAgICAgIGxhYmVsLm5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInJvdGF0ZShcIi5jb25jYXQody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMucm90YXRlLCBcIiBcIikuY29uY2F0KGZpcnN0YWJlbFJvdGF0aW5nQ2VudGVyLngsIFwiIFwiKS5jb25jYXQobGFiZWxSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsID0gbCArIGxhYmVsc0RpdmlkZXI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSB0aWNrQW1vdW50OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGVsWWF4aXNUaXRsZSA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10aXRsZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgX3ggPSAwO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICAgIF94ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbFlBeGlzVGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogX3gsXG4gICAgICAgICAgICB5OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDIgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSArIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUub2Zmc2V0WSxcbiAgICAgICAgICAgIHRleHQ6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdlbmQnLFxuICAgICAgICAgICAgZm9yZUNvbG9yOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgZm9udFNpemU6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUuc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUtdGV4dCAnICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsWWF4aXNUaXRsZS5hZGQoZWxZQXhpc1RpdGxlVGV4dCk7XG4gICAgICAgICAgZWxZYXhpcy5hZGQoZWxZYXhpc1RpdGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzQm9yZGVyID0gdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5heGlzQm9yZGVyO1xuICAgICAgICB2YXIgeCA9IDMxICsgYXhpc0JvcmRlci5vZmZzZXRYO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLm9wcG9zaXRlKSB7XG4gICAgICAgICAgeCA9IC0zMSAtIGF4aXNCb3JkZXIub2Zmc2V0WDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgICB2YXIgZWxWZXJ0aWNhbExpbmUgPSBncmFwaGljcy5kcmF3TGluZSh4LCB3Lmdsb2JhbHMudHJhbnNsYXRlWSArIGF4aXNCb3JkZXIub2Zmc2V0WSAtIDIsIHgsIHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVkgKyBheGlzQm9yZGVyLm9mZnNldFkgKyAyLCBheGlzQm9yZGVyLmNvbG9yLCAwLCBheGlzQm9yZGVyLndpZHRoKTtcbiAgICAgICAgICBlbFlheGlzLmFkZChlbFZlcnRpY2FsTGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5heGlzVGlja3Muc2hvdykge1xuICAgICAgICAgIHRoaXMuYXhlc1V0aWxzLmRyYXdZQXhpc1RpY2tzKHgsIHRpY2tBbW91bnQsIGF4aXNCb3JkZXIsIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0uYXhpc1RpY2tzLCByZWFsSW5kZXgsIGxhYmVsc0RpdmlkZXIsIGVsWWF4aXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsWWF4aXM7XG4gICAgICB9IC8vIFRoaXMgYWN0dWFsbHkgYmVjb21lcyBob3Jpem9udGFsIGF4aXMgKGZvciBiYXIgY2hhcnRzKVxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdZYXhpc0ludmVyc2VkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lheGlzSW52ZXJzZWQocmVhbEluZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgZWxYYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMgYXBleGNoYXJ0cy15YXhpcy1pbnZlcnNlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbFhheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRleHRzLWcnLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHcuZ2xvYmFscy50cmFuc2xhdGVYQXhpc1gsIFwiLCBcIikuY29uY2F0KHcuZ2xvYmFscy50cmFuc2xhdGVYQXhpc1ksIFwiKVwiKVxuICAgICAgICB9KTtcbiAgICAgICAgZWxYYXhpcy5hZGQoZWxYYXhpc1RleHRzKTtcbiAgICAgICAgdmFyIHRpY2tBbW91bnQgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVtyZWFsSW5kZXhdLnJlc3VsdC5sZW5ndGggLSAxOyAvLyBsYWJlbHNEaXZpZGVyIGlzIHNpbXBseSBzdmcgd2lkdGgvbnVtYmVyIG9mIHRpY2tzXG5cbiAgICAgICAgdmFyIGxhYmVsc0RpdmlkZXIgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGlja0Ftb3VudCArIDAuMTsgLy8gaW5pdGlhbCBsYWJlbCBwb3NpdGlvbjtcblxuICAgICAgICB2YXIgbCA9IGxhYmVsc0RpdmlkZXIgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgdmFyIGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnhMYWJlbEZvcm1hdHRlcjtcbiAgICAgICAgdmFyIGxhYmVscyA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0LnNsaWNlKCk7XG4gICAgICAgIHZhciB0aW1lc2NhbGVMYWJlbHMgPSB3Lmdsb2JhbHMudGltZXNjYWxlTGFiZWxzO1xuXG4gICAgICAgIGlmICh0aW1lc2NhbGVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMueGF4aXNMYWJlbHMgPSB0aW1lc2NhbGVMYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgICBsYWJlbHMgPSB0aW1lc2NhbGVMYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgICB0aWNrQW1vdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVscyA9IHRoaXMuYXhlc1V0aWxzLmNoZWNrRm9yUmV2ZXJzZWRMYWJlbHMocmVhbEluZGV4LCBsYWJlbHMpO1xuICAgICAgICB2YXIgdGwgPSB0aW1lc2NhbGVMYWJlbHMubGVuZ3RoO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSB0bCA/IDAgOiB0aWNrQW1vdW50OyB0bCA/IGkgPCB0bCA6IGkgPj0gMDsgdGwgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgICB2YWwgPSBsYkZvcm1hdHRlcih2YWwsIGksIHcpO1xuICAgICAgICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgdy5nbG9iYWxzLnBhZEhvcml6b250YWwgLSAobCAtIGxhYmVsc0RpdmlkZXIgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WCk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lc2NhbGVMYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuYXhlc1V0aWxzLmdldExhYmVsKGxhYmVscywgdGltZXNjYWxlTGFiZWxzLCB4LCBpLCB0aGlzLmRyYXduTGFiZWxzLCB0aGlzLnhheGlzRm9udFNpemUpO1xuICAgICAgICAgICAgICB4ID0gbGFiZWwueDtcbiAgICAgICAgICAgICAgdmFsID0gbGFiZWwudGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5kcmF3bkxhYmVscy5wdXNoKGxhYmVsLnRleHQpO1xuXG4gICAgICAgICAgICAgIGlmIChpID09PSAwICYmIHcuZ2xvYmFscy5za2lwRmlyc3RUaW1lbGluZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFiZWxzLmxlbmd0aCAtIDEgJiYgdy5nbG9iYWxzLnNraXBMYXN0VGltZWxpbmVsYWJlbCkge1xuICAgICAgICAgICAgICAgIHZhbCA9ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbFRpY2sgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHRoaXMueEF4aXNvZmZYICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFkgKyAzMCAtICh3LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcgPyB3Lmdsb2JhbHMueEF4aXNIZWlnaHQgKyB3LmNvbmZpZy54YXhpcy5heGlzVGlja3MuaGVpZ2h0IC0gMiA6IDApLFxuICAgICAgICAgICAgICB0ZXh0OiB2YWwsXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgICBmb3JlQ29sb3I6IEFycmF5LmlzQXJyYXkodGhpcy54YXhpc0ZvcmVDb2xvcnMpID8gdGhpcy54YXhpc0ZvcmVDb2xvcnNbcmVhbEluZGV4XSA6IHRoaXMueGF4aXNGb3JlQ29sb3JzLFxuICAgICAgICAgICAgICBmb250U2l6ZTogdGhpcy54YXhpc0ZvbnRTaXplLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiB0aGlzLnhheGlzRm9udEZhbWlseSxcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICAgIGlzUGxhaW5UZXh0OiBmYWxzZSxcbiAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLWxhYmVsICcgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxYYXhpc1RleHRzLmFkZChlbFRpY2spO1xuICAgICAgICAgICAgZWxUaWNrLnRzcGFuKHZhbCk7XG4gICAgICAgICAgICB2YXIgZWxUb29sdGlwVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAndGl0bGUnKTtcbiAgICAgICAgICAgIGVsVG9vbHRpcFRpdGxlLnRleHRDb250ZW50ID0gdmFsO1xuICAgICAgICAgICAgZWxUaWNrLm5vZGUuYXBwZW5kQ2hpbGQoZWxUb29sdGlwVGl0bGUpO1xuICAgICAgICAgICAgbCA9IGwgKyBsYWJlbHNEaXZpZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW52ZXJzZWRZQXhpc1RpdGxlVGV4dChlbFhheGlzKTtcbiAgICAgICAgdGhpcy5pbnZlcnNlZFlBeGlzQm9yZGVyKGVsWGF4aXMpO1xuICAgICAgICByZXR1cm4gZWxYYXhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW52ZXJzZWRZQXhpc0JvcmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmVyc2VkWUF4aXNCb3JkZXIocGFyZW50KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgYXhpc0JvcmRlciA9IHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXI7XG5cbiAgICAgICAgaWYgKGF4aXNCb3JkZXIuc2hvdykge1xuICAgICAgICAgIHZhciBsaW5lQ29ycmVjdGlvbiA9IDA7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgIGxpbmVDb3JyZWN0aW9uID0gbGluZUNvcnJlY3Rpb24gLSAxNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZWxIb3J6TGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgbGluZUNvcnJlY3Rpb24gKyBheGlzQm9yZGVyLm9mZnNldFgsIHRoaXMueEF4aXNvZmZYLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCB0aGlzLnhBeGlzb2ZmWCwgYXhpc0JvcmRlci5jb2xvciwgMCwgYXhpc0JvcmRlci5oZWlnaHQpOyAvLyBpbiBob3Jpem9udGFsIGJhcnMsIHdlIGFwcGVuZCBheGlzQm9yZGVyIHRvIGVsR3JpZEJvcmRlcnMgZWxlbWVudCB0byBhdm9pZCB6LWluZGV4IGlzc3Vlc1xuXG4gICAgICAgICAgaWYgKHRoaXMuZWxncmlkICYmIHRoaXMuZWxncmlkLmVsR3JpZEJvcmRlcnMgJiYgdy5jb25maWcuZ3JpZC5zaG93KSB7XG4gICAgICAgICAgICB0aGlzLmVsZ3JpZC5lbEdyaWRCb3JkZXJzLmFkZChlbEhvcnpMaW5lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LmFkZChlbEhvcnpMaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW52ZXJzZWRZQXhpc1RpdGxlVGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmVyc2VkWUF4aXNUaXRsZVRleHQocGFyZW50KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZWxZYXhpc1RpdGxlID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlIGFwZXhjaGFydHMteWF4aXMtdGl0bGUtaW52ZXJzZWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGVsWUF4aXNUaXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICB4OiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLnRpdGxlLm9mZnNldFgsXG4gICAgICAgICAgICB5OiB0aGlzLnhBeGlzb2ZmWCArIHBhcnNlRmxvYXQodGhpcy54YXhpc0ZvbnRTaXplKSArIHBhcnNlRmxvYXQody5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udFNpemUpICsgdy5jb25maWcueGF4aXMudGl0bGUub2Zmc2V0WSArIDIwLFxuICAgICAgICAgICAgdGV4dDogdy5jb25maWcueGF4aXMudGl0bGUudGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgZm9udFNpemU6IHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICBmb3JlQ29sb3I6IHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlLXRleHQgJyArIHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxZYXhpc1RpdGxlLmFkZChlbFlBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgICBwYXJlbnQuYWRkKGVsWWF4aXNUaXRsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwieUF4aXNUaXRsZVJvdGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHlBeGlzVGl0bGVSb3RhdGUocmVhbEluZGV4LCB5QXhpc09wcG9zaXRlKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgeUF4aXNMYWJlbHNDb29yZCA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHlBeGlzVGl0bGVDb29yZCA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVsWUF4aXNMYWJlbHNXcmFwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIiAuYXBleGNoYXJ0cy15YXhpc1tyZWw9J1wiLmNvbmNhdChyZWFsSW5kZXgsIFwiJ10gLmFwZXhjaGFydHMteWF4aXMtdGV4dHMtZ1wiKSk7XG5cbiAgICAgICAgaWYgKGVsWUF4aXNMYWJlbHNXcmFwICE9PSBudWxsKSB7XG4gICAgICAgICAgeUF4aXNMYWJlbHNDb29yZCA9IGVsWUF4aXNMYWJlbHNXcmFwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHlBeGlzVGl0bGUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMteWF4aXNbcmVsPSdcIi5jb25jYXQocmVhbEluZGV4LCBcIiddIC5hcGV4Y2hhcnRzLXlheGlzLXRpdGxlIHRleHRcIikpO1xuXG4gICAgICAgIGlmICh5QXhpc1RpdGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgeUF4aXNUaXRsZUNvb3JkID0geUF4aXNUaXRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5QXhpc1RpdGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHggPSB0aGlzLnhQYWRkaW5nRm9yWUF4aXNUaXRsZShyZWFsSW5kZXgsIHlBeGlzTGFiZWxzQ29vcmQsIHlBeGlzVGl0bGVDb29yZCwgeUF4aXNPcHBvc2l0ZSk7XG4gICAgICAgICAgeUF4aXNUaXRsZS5zZXRBdHRyaWJ1dGUoJ3gnLCB4LnhQb3MgLSAoeUF4aXNPcHBvc2l0ZSA/IDEwIDogMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlBeGlzVGl0bGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdGl0bGVSb3RhdGluZ0NlbnRlciA9IGdyYXBoaWNzLnJvdGF0ZUFyb3VuZENlbnRlcih5QXhpc1RpdGxlKTtcbiAgICAgICAgICB5QXhpc1RpdGxlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoXCIuY29uY2F0KHlBeGlzT3Bwb3NpdGUgPyB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnJvdGF0ZSAqIC0xIDogdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5yb3RhdGUsIFwiIFwiKS5jb25jYXQodGl0bGVSb3RhdGluZ0NlbnRlci54LCBcIiBcIikuY29uY2F0KHRpdGxlUm90YXRpbmdDZW50ZXIueSwgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ4UGFkZGluZ0ZvcllBeGlzVGl0bGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB4UGFkZGluZ0ZvcllBeGlzVGl0bGUocmVhbEluZGV4LCB5QXhpc0xhYmVsc0Nvb3JkLCB5QXhpc1RpdGxlQ29vcmQsIHlBeGlzT3Bwb3NpdGUpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBvcHBvc2l0ZUF4aXNDb3VudCA9IDA7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHBhZGQgPSAxMDtcblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS50ZXh0ID09PSB1bmRlZmluZWQgfHwgcmVhbEluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4UG9zOiB4LFxuICAgICAgICAgICAgcGFkZDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeUF4aXNPcHBvc2l0ZSkge1xuICAgICAgICAgIHggPSB5QXhpc0xhYmVsc0Nvb3JkLndpZHRoICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5vZmZzZXRYICsgeUF4aXNUaXRsZUNvb3JkLndpZHRoIC8gMiArIHBhZGQgLyAyO1xuICAgICAgICAgIG9wcG9zaXRlQXhpc0NvdW50ICs9IDE7XG5cbiAgICAgICAgICBpZiAob3Bwb3NpdGVBeGlzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHggPSB4IC0gcGFkZCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSB5QXhpc0xhYmVsc0Nvb3JkLndpZHRoICogLTEgKyB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLm9mZnNldFggKyBwYWRkIC8gMiArIHlBeGlzVGl0bGVDb29yZC53aWR0aCAvIDI7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcGFkZCA9IDI1O1xuICAgICAgICAgICAgeCA9IHlBeGlzTGFiZWxzQ29vcmQud2lkdGggKiAtMSAtIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUub2Zmc2V0WCAtIHBhZGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4UG9zOiB4LFxuICAgICAgICAgIHBhZGQ6IHBhZGRcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gc2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgeS1heGlzIGJ5IGNvdW50aW5nIHRoZSBsYWJlbHMgd2lkdGgsIHRpdGxlIHdpZHRoIGFuZCBhbnkgb2Zmc2V0XG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0WUF4aXNYUG9zaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZQXhpc1hQb3NpdGlvbih5YXhpc0xhYmVsQ29vcmRzLCB5VGl0bGVDb29yZHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4TGVmdCA9IDA7XG4gICAgICAgIHZhciB4UmlnaHQgPSAwO1xuICAgICAgICB2YXIgbGVmdE9mZnNldFggPSAxODtcbiAgICAgICAgdmFyIHJpZ2h0T2Zmc2V0WCA9IDE7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLm11bHRpcGxlWXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBzaG91bGROb3REcmF3QXhpcyA9IHcuZ2xvYmFscy5pZ25vcmVZQXhpc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPiAtMSB8fCAheWF4ZS5zaG93IHx8IHlheGUuZmxvYXRpbmcgfHwgeWF4aXNMYWJlbENvb3Jkc1tpbmRleF0ud2lkdGggPT09IDA7XG4gICAgICAgICAgdmFyIGF4aXNXaWR0aCA9IHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoICsgeVRpdGxlQ29vcmRzW2luZGV4XS53aWR0aDtcblxuICAgICAgICAgIGlmICgheWF4ZS5vcHBvc2l0ZSkge1xuICAgICAgICAgICAgeExlZnQgPSB3Lmdsb2JhbHMudHJhbnNsYXRlWCAtIGxlZnRPZmZzZXRYO1xuXG4gICAgICAgICAgICBpZiAoIXNob3VsZE5vdERyYXdBeGlzKSB7XG4gICAgICAgICAgICAgIGxlZnRPZmZzZXRYID0gbGVmdE9mZnNldFggKyBheGlzV2lkdGggKyAyMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gPSB4TGVmdCArIHlheGUubGFiZWxzLm9mZnNldFg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgIHhSaWdodCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWCAtIDE7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy50cmFuc2xhdGVZQXhpc1hbaW5kZXhdID0geFJpZ2h0IC0geWF4ZS5sYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHhSaWdodCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWCArIHJpZ2h0T2Zmc2V0WDtcblxuICAgICAgICAgICAgICBpZiAoIXNob3VsZE5vdERyYXdBeGlzKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRPZmZzZXRYID0gcmlnaHRPZmZzZXRYICsgYXhpc1dpZHRoICsgMjA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWUF4aXNYW2luZGV4XSA9IHhSaWdodCAtIHlheGUubGFiZWxzLm9mZnNldFggKyAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRZQXhpc1RleHRBbGlnbm1lbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WUF4aXNUZXh0QWxpZ25tZW50cygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB5YXhpcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJhcGV4Y2hhcnRzLXlheGlzXCIpO1xuICAgICAgICB5YXhpcyA9IFV0aWxzJDEubGlzdFRvQXJyYXkoeWF4aXMpO1xuICAgICAgICB5YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5LCBpbmRleCkge1xuICAgICAgICAgIHZhciB5YXhlID0gdy5jb25maWcueWF4aXNbaW5kZXhdOyAvLyBwcm9jZWVkIG9ubHkgaWYgdXNlciBoYXMgc3BlY2lmaWVkIGFsaWdubWVudFxuXG4gICAgICAgICAgaWYgKHlheGUgJiYgIXlheGUuZmxvYXRpbmcgJiYgeWF4ZS5sYWJlbHMuYWxpZ24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHlBeGlzSW5uZXIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMteWF4aXNbcmVsPSdcIi5jb25jYXQoaW5kZXgsIFwiJ10gLmFwZXhjaGFydHMteWF4aXMtdGV4dHMtZ1wiKSk7XG4gICAgICAgICAgICB2YXIgeUF4aXNUZXh0cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy15YXhpc1tyZWw9J1wiLmNvbmNhdChpbmRleCwgXCInXSAuYXBleGNoYXJ0cy15YXhpcy1sYWJlbFwiKSk7XG4gICAgICAgICAgICB5QXhpc1RleHRzID0gVXRpbHMkMS5saXN0VG9BcnJheSh5QXhpc1RleHRzKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0geUF4aXNJbm5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgaWYgKHlheGUubGFiZWxzLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgeUF4aXNUZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChsYWJlbCwgbEkpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICgheWF4ZS5vcHBvc2l0ZSkge1xuICAgICAgICAgICAgICAgIHlBeGlzSW5uZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInRyYW5zbGF0ZSgtXCIuY29uY2F0KHJlY3Qud2lkdGgsIFwiLCAwKVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeWF4ZS5sYWJlbHMuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgIHlBeGlzVGV4dHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwsIGxJKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHlBeGlzSW5uZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInRyYW5zbGF0ZShcIi5jb25jYXQocmVjdC53aWR0aCAvIDIgKiAoIXlheGUub3Bwb3NpdGUgPyAtMSA6IDEpLCBcIiwgMClcIikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh5YXhlLmxhYmVscy5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICB5QXhpc1RleHRzLmZvckVhY2goZnVuY3Rpb24gKGxhYmVsLCBsSSkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCAnZW5kJyk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICh5YXhlLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNJbm5lci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwidHJhbnNsYXRlKFwiLmNvbmNhdChyZWN0LndpZHRoLCBcIiwgMClcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gWUF4aXM7XG4gIH0oKTtcblxuICB2YXIgRXZlbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudHMoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRzKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMuZG9jdW1lbnRFdmVudCA9IFV0aWxzJDEuYmluZCh0aGlzLmRvY3VtZW50RXZlbnQsIHRoaXMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhFdmVudHMsIFt7XG4gICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHcuZ2xvYmFscy5ldmVudHNbbmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZXZlbnRzW25hbWVdID0gW2hhbmRsZXJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdy5nbG9iYWxzLmV2ZW50c1tuYW1lXS5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZXZlbnRzW25hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmlyZUV2ZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZUV2ZW50KG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhcmdzIHx8ICFhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldnMgPSB3Lmdsb2JhbHMuZXZlbnRzW25hbWVdO1xuICAgICAgICB2YXIgbCA9IGV2cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBldnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0dXBFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbWUgPSB0aGlzLmN0eDtcbiAgICAgICAgdmFyIGNsaWNrYWJsZUFyZWEgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKHcuZ2xvYmFscy5jaGFydENsYXNzKTtcbiAgICAgICAgdGhpcy5jdHguZXZlbnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgY2xpY2thYmxlQXJlYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB3LCB7XG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiB3Lmdsb2JhbHMuY2FwdHVyZWRTZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IHcuZ2xvYmFscy5jYXB0dXJlZERhdGFQb2ludEluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5tb3VzZU1vdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMubW91c2VNb3ZlKGUsIG1lLCBvcHRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZWxlYXZlJyB8fCBlLnR5cGUgPT09ICd0b3VjaGxlYXZlJykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5tb3VzZUxlYXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLm1vdXNlTGVhdmUoZSwgbWUsIG9wdHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnICYmIGUud2hpY2ggPT09IDEgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLmNsaWNrKGUsIG1lLCBvcHRzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1lLmN0eC5ldmVudHMuZmlyZUV2ZW50KCdjbGljaycsIFtlLCBtZSwgb3B0c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdHguZXZlbnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmRvbS5iYXNlRWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuZG9jdW1lbnRFdmVudCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdHguY29yZS5zZXR1cEJydXNoSGFuZGxlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkb2N1bWVudEV2ZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9jdW1lbnRFdmVudChlKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQuY2xhc3NOYW1lO1xuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICB2YXIgZWxNZW51ID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbWVudScpO1xuXG4gICAgICAgICAgaWYgKGVsTWVudSAmJiBlbE1lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLW1lbnUtb3BlbicpICYmIHRhcmdldCAhPT0gJ2FwZXhjaGFydHMtbWVudS1pY29uJykge1xuICAgICAgICAgICAgZWxNZW51LmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtbWVudS1vcGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLmNsaWVudFggPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50b3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFg7XG4gICAgICAgIHcuZ2xvYmFscy5jbGllbnRZID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudG91Y2hlc1swXS5jbGllbnRZIDogZS5jbGllbnRZO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFdmVudHM7XG4gIH0oKTtcblxuICB2YXIgTG9jYWxpemF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhbGl6YXRpb24oY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9jYWxpemF0aW9uKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTG9jYWxpemF0aW9uLCBbe1xuICAgICAga2V5OiBcInNldEN1cnJlbnRMb2NhbGVWYWx1ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJyZW50TG9jYWxlVmFsdWVzKGxvY2FsZU5hbWUpIHtcbiAgICAgICAgdmFyIGxvY2FsZXMgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmxvY2FsZXM7IC8vIGNoZWNrIGlmIHVzZXIgaGFzIHNwZWNpZmllZCBsb2NhbGVzIGluIGdsb2JhbCBBcGV4IHZhcmlhYmxlXG4gICAgICAgIC8vIGlmIHllcyAtIHRoZW4gZXh0ZW5kIHRob3NlIHdpdGggbG9jYWwgY2hhcnQncyBsb2NhbGVcblxuICAgICAgICBpZiAod2luZG93LkFwZXguY2hhcnQgJiYgd2luZG93LkFwZXguY2hhcnQubG9jYWxlcyAmJiB3aW5kb3cuQXBleC5jaGFydC5sb2NhbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsb2NhbGVzID0gdGhpcy53LmNvbmZpZy5jaGFydC5sb2NhbGVzLmNvbmNhdCh3aW5kb3cuQXBleC5jaGFydC5sb2NhbGVzKTtcbiAgICAgICAgfSAvLyBmaW5kIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXkgb2YgbG9jYWxlcyB3aGljaCB1c2VyIGhhcyBzZXQgKGVpdGhlciBieSBjaGFydC5kZWZhdWx0TG9jYWxlIG9yIGJ5IGNhbGxpbmcgc2V0TG9jYWxlKCkgbWV0aG9kLilcblxuXG4gICAgICAgIHZhciBzZWxlY3RlZExvY2FsZSA9IGxvY2FsZXMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGMubmFtZSA9PT0gbG9jYWxlTmFtZTtcbiAgICAgICAgfSlbMF07XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGEgY29tcGxldGUgbG9jYWxlIG9iamVjdCBieSBleHRlbmRpbmcgZGVmYXVsdHMgc28geW91IGRvbid0IGdldCB1bmRlZmluZWQgZXJyb3JzLlxuICAgICAgICAgIHZhciByZXQgPSBVdGlscyQxLmV4dGVuZChlbiwgc2VsZWN0ZWRMb2NhbGUpOyAvLyBzdG9yZSB0aGVzZSBsb2NhbGUgb3B0aW9ucyBpbiBnbG9iYWwgdmFyIGZvciBlYXNlIGFjY2Vzc1xuXG4gICAgICAgICAgdGhpcy53Lmdsb2JhbHMubG9jYWxlID0gcmV0Lm9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBsb2NhbGUgbmFtZSBwcm92aWRlZC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3Ugc2V0IHRoZSBjb3JyZWN0IGxvY2FsZSBuYW1lIGluIG9wdGlvbnMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMb2NhbGl6YXRpb247XG4gIH0oKTtcblxuICB2YXIgQXhlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXhlcyhjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBeGVzKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXhlcywgW3tcbiAgICAgIGtleTogXCJkcmF3QXhpc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBeGlzKHR5cGUsIGVsZ3JpZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgICAgdmFyIHhBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4LCBlbGdyaWQpO1xuICAgICAgICB2YXIgeUF4aXMgPSBuZXcgWUF4aXModGhpcy5jdHgsIGVsZ3JpZCk7XG5cbiAgICAgICAgaWYgKGdsLmF4aXNDaGFydHMgJiYgdHlwZSAhPT0gJ3JhZGFyJykge1xuICAgICAgICAgIHZhciBlbFhheGlzLCBlbFlheGlzO1xuXG4gICAgICAgICAgaWYgKGdsLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgZWxZYXhpcyA9IHlBeGlzLmRyYXdZYXhpc0ludmVyc2VkKDApO1xuICAgICAgICAgICAgZWxYYXhpcyA9IHhBeGlzLmRyYXdYYXhpc0ludmVyc2VkKDApO1xuICAgICAgICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChlbFhheGlzKTtcbiAgICAgICAgICAgIGdsLmRvbS5lbEdyYXBoaWNhbC5hZGQoZWxZYXhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsWGF4aXMgPSB4QXhpcy5kcmF3WGF4aXMoKTtcbiAgICAgICAgICAgIGdsLmRvbS5lbEdyYXBoaWNhbC5hZGQoZWxYYXhpcyk7XG4gICAgICAgICAgICBjbmYueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoZ2wuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVsWWF4aXMgPSB5QXhpcy5kcmF3WWF4aXMoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGdsLmRvbS5QYXBlci5hZGQoZWxZYXhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudy5jb25maWcuZ3JpZC5wb3NpdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5uZXIgPSBnbC5kb20uUGFwZXIuY2hpbGRyZW4oKVsxXTtcbiAgICAgICAgICAgICAgICAgIGlubmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgZ2wuZG9tLlBhcGVyLmFkZChpbm5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQXhlcztcbiAgfSgpO1xuXG4gIHZhciBDcm9zc2hhaXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDcm9zc2hhaXJzKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3NzaGFpcnMpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDcm9zc2hhaXJzLCBbe1xuICAgICAga2V5OiBcImRyYXdYQ3Jvc3NoYWlyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYQ3Jvc3NoYWlycygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICB2YXIgY3Jvc3NoYWlyR3JhZGllbnQgPSB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLmZpbGwuZ3JhZGllbnQ7XG4gICAgICAgIHZhciBjcm9zc2hhaXJTaGFkb3cgPSB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLmRyb3BTaGFkb3c7XG4gICAgICAgIHZhciBmaWxsVHlwZSA9IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuZmlsbC50eXBlO1xuICAgICAgICB2YXIgZ3JhZGllbnRGcm9tID0gY3Jvc3NoYWlyR3JhZGllbnQuY29sb3JGcm9tO1xuICAgICAgICB2YXIgZ3JhZGllbnRUbyA9IGNyb3NzaGFpckdyYWRpZW50LmNvbG9yVG87XG4gICAgICAgIHZhciBvcGFjaXR5RnJvbSA9IGNyb3NzaGFpckdyYWRpZW50Lm9wYWNpdHlGcm9tO1xuICAgICAgICB2YXIgb3BhY2l0eVRvID0gY3Jvc3NoYWlyR3JhZGllbnQub3BhY2l0eVRvO1xuICAgICAgICB2YXIgc3RvcHMgPSBjcm9zc2hhaXJHcmFkaWVudC5zdG9wcztcbiAgICAgICAgdmFyIHNoYWRvdyA9ICdub25lJztcbiAgICAgICAgdmFyIGRyb3BTaGFkb3cgPSBjcm9zc2hhaXJTaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgdmFyIHNoYWRvd0xlZnQgPSBjcm9zc2hhaXJTaGFkb3cubGVmdDtcbiAgICAgICAgdmFyIHNoYWRvd1RvcCA9IGNyb3NzaGFpclNoYWRvdy50b3A7XG4gICAgICAgIHZhciBzaGFkb3dCbHVyID0gY3Jvc3NoYWlyU2hhZG93LmJsdXI7XG4gICAgICAgIHZhciBzaGFkb3dDb2xvciA9IGNyb3NzaGFpclNoYWRvdy5jb2xvcjtcbiAgICAgICAgdmFyIHNoYWRvd09wYWNpdHkgPSBjcm9zc2hhaXJTaGFkb3cub3BhY2l0eTtcbiAgICAgICAgdmFyIHhjcm9zc2hhaXJzRmlsbCA9IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuZmlsbC5jb2xvcjtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5zaG93KSB7XG4gICAgICAgICAgaWYgKGZpbGxUeXBlID09PSAnZ3JhZGllbnQnKSB7XG4gICAgICAgICAgICB4Y3Jvc3NoYWlyc0ZpbGwgPSBncmFwaGljcy5kcmF3R3JhZGllbnQoJ3ZlcnRpY2FsJywgZ3JhZGllbnRGcm9tLCBncmFkaWVudFRvLCBvcGFjaXR5RnJvbSwgb3BhY2l0eVRvLCBudWxsLCBzdG9wcywgbnVsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHhjcm9zc2hhaXJzID0gZ3JhcGhpY3MuZHJhd1JlY3QoKTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAxKSB7XG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IGRyYXdpbmcgMiBsaW5lcywgY29udmVydCByZWN0IHRvIGxpbmVcbiAgICAgICAgICAgIHhjcm9zc2hhaXJzID0gZ3JhcGhpY3MuZHJhd0xpbmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3JpZEhlaWdodCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKCFVdGlscyQxLmlzTnVtYmVyKGdyaWRIZWlnaHQpIHx8IGdyaWRIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBncmlkSGVpZ2h0ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3Jvc3NoYWlyc1dpZHRoID0gdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aDtcblxuICAgICAgICAgIGlmICghVXRpbHMkMS5pc051bWJlcihjcm9zc2hhaXJzV2lkdGgpIHx8IGNyb3NzaGFpcnNXaWR0aCA8IDApIHtcbiAgICAgICAgICAgIGNyb3NzaGFpcnNXaWR0aCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeGNyb3NzaGFpcnMuYXR0cih7XG4gICAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGNyb3NzaGFpcnMnLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB5MjogZ3JpZEhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBjcm9zc2hhaXJzV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGdyaWRIZWlnaHQsXG4gICAgICAgICAgICBmaWxsOiB4Y3Jvc3NoYWlyc0ZpbGwsXG4gICAgICAgICAgICBmaWx0ZXI6IHNoYWRvdyxcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLm9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2U6IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuc3Ryb2tlLmNvbG9yLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuc3Ryb2tlLndpZHRoLFxuICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLnN0cm9rZS5kYXNoQXJyYXlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChkcm9wU2hhZG93KSB7XG4gICAgICAgICAgICB4Y3Jvc3NoYWlycyA9IGZpbHRlcnMuZHJvcFNoYWRvdyh4Y3Jvc3NoYWlycywge1xuICAgICAgICAgICAgICBsZWZ0OiBzaGFkb3dMZWZ0LFxuICAgICAgICAgICAgICB0b3A6IHNoYWRvd1RvcCxcbiAgICAgICAgICAgICAgYmx1cjogc2hhZG93Qmx1cixcbiAgICAgICAgICAgICAgY29sb3I6IHNoYWRvd0NvbG9yLFxuICAgICAgICAgICAgICBvcGFjaXR5OiBzaGFkb3dPcGFjaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZCh4Y3Jvc3NoYWlycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1lDcm9zc2hhaXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lDcm9zc2hhaXJzKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGNyb3NzaGFpciA9IHcuY29uZmlnLnlheGlzWzBdLmNyb3NzaGFpcnM7XG4gICAgICAgIHZhciBvZmZYID0gdy5nbG9iYWxzLmJhclBhZEZvck51bWVyaWNBeGlzO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS5jcm9zc2hhaXJzLnNob3cpIHtcbiAgICAgICAgICB2YXIgeWNyb3NzaGFpcnMgPSBncmFwaGljcy5kcmF3TGluZSgtb2ZmWCwgMCwgdy5nbG9iYWxzLmdyaWRXaWR0aCArIG9mZlgsIDAsIGNyb3NzaGFpci5zdHJva2UuY29sb3IsIGNyb3NzaGFpci5zdHJva2UuZGFzaEFycmF5LCBjcm9zc2hhaXIuc3Ryb2tlLndpZHRoKTtcbiAgICAgICAgICB5Y3Jvc3NoYWlycy5hdHRyKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15Y3Jvc3NoYWlycydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZCh5Y3Jvc3NoYWlycyk7XG4gICAgICAgIH0gLy8gZHJhdyBhbiBpbnZpc2libGUgY3Jvc3NoYWlyIHRvIGhlbHAgaW4gcG9zaXRpb25pbmcgdGhlIHlheGlzIHRvb2x0aXBcblxuXG4gICAgICAgIHZhciB5Y3Jvc3NoYWlyc0hpZGRlbiA9IGdyYXBoaWNzLmRyYXdMaW5lKC1vZmZYLCAwLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgb2ZmWCwgMCwgY3Jvc3NoYWlyLnN0cm9rZS5jb2xvciwgMCwgMCk7XG4gICAgICAgIHljcm9zc2hhaXJzSGlkZGVuLmF0dHIoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy1oaWRkZW4nXG4gICAgICAgIH0pO1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZCh5Y3Jvc3NoYWlyc0hpZGRlbik7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENyb3NzaGFpcnM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBSZXNwb25zaXZlIENsYXNzIHRvIG92ZXJyaWRlIG9wdGlvbnMgZm9yIGRpZmZlcmVudCBzY3JlZW4gc2l6ZXMuXG4gICAqXG4gICAqIEBtb2R1bGUgUmVzcG9uc2l2ZVxuICAgKiovXG5cbiAgdmFyIFJlc3BvbnNpdmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc3BvbnNpdmUoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZSk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgfSAvLyB0aGUgb3B0cyBwYXJhbWV0ZXIgaWYgbm90IG51bGwgaGFzIHRvIGJlIHNldCBvdmVycmlkaW5nIGV2ZXJ5dGhpbmdcbiAgICAvLyBhcyB0aGUgb3B0cyBpcyBzZXQgYnkgdXNlciBleHRlcm5hbGx5XG5cblxuICAgIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlLCBbe1xuICAgICAga2V5OiBcImNoZWNrUmVzcG9uc2l2ZUNvbmZpZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUmVzcG9uc2l2ZUNvbmZpZyhvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBjbmYgPSB3LmNvbmZpZzsgLy8gY2hlY2sgaWYgcmVzcG9uc2l2ZSBjb25maWcgZXhpc3RzXG5cbiAgICAgICAgaWYgKGNuZi5yZXNwb25zaXZlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICB2YXIgcmVzID0gY25mLnJlc3BvbnNpdmUuc2xpY2UoKTtcbiAgICAgICAgcmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5icmVha3BvaW50ID4gYi5icmVha3BvaW50ID8gMSA6IGIuYnJlYWtwb2ludCA+IGEuYnJlYWtwb2ludCA/IC0xIDogMDtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IENvbmZpZyh7fSk7XG5cbiAgICAgICAgdmFyIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucyA9IGZ1bmN0aW9uIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucygpIHtcbiAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgICAgdmFyIGxhcmdlc3RCcmVha3BvaW50ID0gcmVzWzBdLmJyZWFrcG9pbnQ7XG4gICAgICAgICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPiAwID8gd2luZG93LmlubmVyV2lkdGggOiBzY3JlZW4ud2lkdGg7XG5cbiAgICAgICAgICBpZiAod2lkdGggPiBsYXJnZXN0QnJlYWtwb2ludCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBDb3JlVXRpbHMuZXh0ZW5kQXJyYXlQcm9wcyhjb25maWcsIHcuZ2xvYmFscy5pbml0aWFsQ29uZmlnLCB3KTtcbiAgICAgICAgICAgIG5ld09wdGlvbnMgPSBVdGlscyQxLmV4dGVuZChvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIG5ld09wdGlvbnMgPSBVdGlscyQxLmV4dGVuZCh3LmNvbmZpZywgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgIF90aGlzLm92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh3aWR0aCA8IHJlc1tpXS5icmVha3BvaW50KSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucyA9IENvcmVVdGlscy5leHRlbmRBcnJheVByb3BzKGNvbmZpZywgcmVzW2ldLm9wdGlvbnMsIHcpO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMgPSBVdGlscyQxLmV4dGVuZCh3LmNvbmZpZywgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5vdmVycmlkZVJlc3BvbnNpdmVPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBDb3JlVXRpbHMuZXh0ZW5kQXJyYXlQcm9wcyhjb25maWcsIG9wdHMsIHcpO1xuICAgICAgICAgIG9wdGlvbnMgPSBVdGlscyQxLmV4dGVuZCh3LmNvbmZpZywgb3B0aW9ucyk7XG4gICAgICAgICAgb3B0aW9ucyA9IFV0aWxzJDEuZXh0ZW5kKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRlUmVzcG9uc2l2ZU9wdGlvbnMoe30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVycmlkZVJlc3BvbnNpdmVPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5ld0NvbmZpZyA9IG5ldyBDb25maWcobmV3T3B0aW9ucykuaW5pdCh7XG4gICAgICAgICAgcmVzcG9uc2l2ZU92ZXJyaWRlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLncuY29uZmlnID0gbmV3Q29uZmlnO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSZXNwb25zaXZlO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgVGhlbWUgQ2xhc3MgZm9yIHNldHRpbmcgdGhlIGNvbG9ycyBhbmQgcGFsZXR0ZXMuXG4gICAqXG4gICAqIEBtb2R1bGUgVGhlbWVcbiAgICoqL1xuXG4gIHZhciBUaGVtZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhlbWUoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhlbWUpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMuY29sb3JzID0gW107XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5pc0NvbG9yRm4gPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNIZWF0bWFwRGlzdHJpYnV0ZWQgPSB3LmNvbmZpZy5jaGFydC50eXBlID09PSAndHJlZW1hcCcgJiYgdy5jb25maWcucGxvdE9wdGlvbnMudHJlZW1hcC5kaXN0cmlidXRlZCB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcgJiYgdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5kaXN0cmlidXRlZDtcbiAgICAgIHRoaXMuaXNCYXJEaXN0cmlidXRlZCA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCAmJiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRoZW1lLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB0aGlzLnNldERlZmF1bHRDb2xvcnMoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RGVmYXVsdENvbG9yc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgICAgIHZhciBfdyRjb25maWckY29sb3JzLFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdXRpbHMgPSBuZXcgVXRpbHMkMSgpO1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5jbGFzc0xpc3QuYWRkKFwiYXBleGNoYXJ0cy10aGVtZS1cIi5jb25jYXQody5jb25maWcudGhlbWUubW9kZSkpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jb2xvcnMgPT09IHVuZGVmaW5lZCB8fCAoKF93JGNvbmZpZyRjb2xvcnMgPSB3LmNvbmZpZy5jb2xvcnMpID09PSBudWxsIHx8IF93JGNvbmZpZyRjb2xvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93JGNvbmZpZyRjb2xvcnMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgIHcuZ2xvYmFscy5jb2xvcnMgPSB0aGlzLnByZWRlZmluZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuY29sb3JzID0gdy5jb25maWcuY29sb3JzOyAvLyBpZiB1c2VyIHByb3ZpZGVkIGEgZnVuY3Rpb24gaW4gY29sb3JzLCB3ZSBuZWVkIHRvIGV2YWwgaGVyZVxuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcuY29sb3JzKSAmJiB3LmNvbmZpZy5jb2xvcnMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygdy5jb25maWcuY29sb3JzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuY29sb3JzID0gdy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgICAgICB2YXIgYyA9IHcuY29uZmlnLmNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFjKSBjID0gdy5jb25maWcuY29sb3JzWzBdO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzQ29sb3JGbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHcuZ2xvYmFscy5heGlzQ2hhcnRzID8gdy5nbG9iYWxzLnNlcmllc1tpXVswXSA/IHcuZ2xvYmFscy5zZXJpZXNbaV1bMF0gOiAwIDogdy5nbG9iYWxzLnNlcmllc1tpXSxcbiAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB1c2VyIGRlZmluZWQgY29sb3JzIGluIHNlcmllcyBhcnJheVxuXG5cbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc0NvbG9ycy5tYXAoZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmNvbG9yc1tpXSA9IGM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAody5jb25maWcudGhlbWUubW9ub2Nocm9tZS5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIG1vbm9BcnIgPSBbXTtcbiAgICAgICAgICB2YXIgZ2xzQ250ID0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0JhckRpc3RyaWJ1dGVkIHx8IHRoaXMuaXNIZWF0bWFwRGlzdHJpYnV0ZWQpIHtcbiAgICAgICAgICAgIGdsc0NudCA9IHcuZ2xvYmFscy5zZXJpZXNbMF0ubGVuZ3RoICogdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1haW5Db2xvciA9IHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuY29sb3I7XG4gICAgICAgICAgdmFyIHBhcnQgPSAxIC8gKGdsc0NudCAvIHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuc2hhZGVJbnRlbnNpdHkpO1xuICAgICAgICAgIHZhciBzaGFkZSA9IHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuc2hhZGVUbztcbiAgICAgICAgICB2YXIgcGVyY2VudCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBnc2wgPSAwOyBnc2wgPCBnbHNDbnQ7IGdzbCsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q29sb3IgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChzaGFkZSA9PT0gJ2RhcmsnKSB7XG4gICAgICAgICAgICAgIG5ld0NvbG9yID0gdXRpbHMuc2hhZGVDb2xvcihwZXJjZW50ICogLTEsIG1haW5Db2xvcik7XG4gICAgICAgICAgICAgIHBlcmNlbnQgPSBwZXJjZW50ICsgcGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0NvbG9yID0gdXRpbHMuc2hhZGVDb2xvcihwZXJjZW50LCBtYWluQ29sb3IpO1xuICAgICAgICAgICAgICBwZXJjZW50ID0gcGVyY2VudCArIHBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vbm9BcnIucHVzaChuZXdDb2xvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLmNvbG9ycyA9IG1vbm9BcnIuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0Q29sb3JzID0gdy5nbG9iYWxzLmNvbG9ycy5zbGljZSgpOyAvLyBpZiB1c2VyIHNwZWNpZmllZCBmZXdlciBjb2xvcnMgdGhhbiBuby4gb2Ygc2VyaWVzLCBwdXNoIHRoZSBzYW1lIGNvbG9ycyBhZ2FpblxuXG4gICAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5jb2xvcnMpO1xuICAgICAgICB2YXIgY29sb3JUeXBlcyA9IFsnZmlsbCcsICdzdHJva2UnXTtcbiAgICAgICAgY29sb3JUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnW2NdLmNvbG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHNbY10uY29sb3JzID0gX3RoaXMuaXNDb2xvckZuID8gdy5jb25maWcuY29sb3JzIDogZGVmYXVsdENvbG9ycztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdy5nbG9iYWxzW2NdLmNvbG9ycyA9IHcuY29uZmlnW2NdLmNvbG9ycy5zbGljZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnB1c2hFeHRyYUNvbG9ycyh3Lmdsb2JhbHNbY10uY29sb3JzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuc3R5bGUuY29sb3JzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnMgPSBkZWZhdWx0Q29sb3JzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9ycyA9IHcuY29uZmlnLmRhdGFMYWJlbHMuc3R5bGUuY29sb3JzLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnB1c2hFeHRyYUNvbG9ycyh3Lmdsb2JhbHMuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnMsIDUwKTtcblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkYXIucG9seWdvbnMuZmlsbC5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHcuZ2xvYmFscy5yYWRhclBvbHlnb25zLmZpbGwuY29sb3JzID0gW3cuY29uZmlnLnRoZW1lLm1vZGUgPT09ICdkYXJrJyA/ICcjNDI0MjQyJyA6ICdub25lJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnJhZGFyUG9seWdvbnMuZmlsbC5jb2xvcnMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5wb2x5Z29ucy5maWxsLmNvbG9ycy5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLnJhZGFyUG9seWdvbnMuZmlsbC5jb2xvcnMsIDIwKTsgLy8gVGhlIHBvaW50IGNvbG9yc1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5tYXJrZXJzLmNvbG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLm1hcmtlcnMuY29sb3JzID0gZGVmYXVsdENvbG9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5jb2xvcnMgPSB3LmNvbmZpZy5tYXJrZXJzLmNvbG9ycy5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLm1hcmtlcnMuY29sb3JzKTtcbiAgICAgIH0gLy8gV2hlbiB0aGUgbnVtYmVyIG9mIGNvbG9ycyBwcm92aWRlZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBzZXJpZXMsIHRoaXMgbWV0aG9kXG4gICAgICAvLyB3aWxsIHB1c2ggc2FtZSBjb2xvcnMgdG8gdGhlIGxpc3RcbiAgICAgIC8vIHBhcmFtczpcbiAgICAgIC8vIGRpc3RyaWJ1dGVkIGlzIG9ubHkgdmFsaWQgZm9yIGRpc3RyaWJ1dGVkIGNvbHVtbi9iYXIgY2hhcnRzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHVzaEV4dHJhQ29sb3JzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaEV4dHJhQ29sb3JzKGNvbG9yU2VyaWVzLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRpc3RyaWJ1dGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGxlbiA9IGxlbmd0aCB8fCB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAoZGlzdHJpYnV0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICBkaXN0cmlidXRlZCA9IHRoaXMuaXNCYXJEaXN0cmlidXRlZCB8fCB0aGlzLmlzSGVhdG1hcERpc3RyaWJ1dGVkIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJyAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5oZWF0bWFwLmNvbG9yU2NhbGUuaW52ZXJzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXN0cmlidXRlZCAmJiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCkge1xuICAgICAgICAgIGxlbiA9IHcuZ2xvYmFscy5zZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aCAqIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbG9yU2VyaWVzLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgIHZhciBkaWZmID0gbGVuIC0gY29sb3JTZXJpZXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU2VyaWVzLnB1c2goY29sb3JTZXJpZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cGRhdGVUaGVtZU9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUaGVtZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLmNoYXJ0ID0gb3B0aW9ucy5jaGFydCB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy50b29sdGlwID0gb3B0aW9ucy50b29sdGlwIHx8IHt9O1xuICAgICAgICB2YXIgbW9kZSA9IG9wdGlvbnMudGhlbWUubW9kZSB8fCAnbGlnaHQnO1xuICAgICAgICB2YXIgcGFsZXR0ZSA9IG9wdGlvbnMudGhlbWUucGFsZXR0ZSA/IG9wdGlvbnMudGhlbWUucGFsZXR0ZSA6IG1vZGUgPT09ICdkYXJrJyA/ICdwYWxldHRlNCcgOiAncGFsZXR0ZTEnO1xuICAgICAgICB2YXIgZm9yZUNvbG9yID0gb3B0aW9ucy5jaGFydC5mb3JlQ29sb3IgPyBvcHRpb25zLmNoYXJ0LmZvcmVDb2xvciA6IG1vZGUgPT09ICdkYXJrJyA/ICcjZjZmN2Y4JyA6ICcjMzczZDNmJztcbiAgICAgICAgb3B0aW9ucy50b29sdGlwLnRoZW1lID0gbW9kZTtcbiAgICAgICAgb3B0aW9ucy5jaGFydC5mb3JlQ29sb3IgPSBmb3JlQ29sb3I7XG4gICAgICAgIG9wdGlvbnMudGhlbWUucGFsZXR0ZSA9IHBhbGV0dGU7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmVkZWZpbmVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZGVmaW5lZCgpIHtcbiAgICAgICAgdmFyIHBhbGV0dGUgPSB0aGlzLncuY29uZmlnLnRoZW1lLnBhbGV0dGU7IC8vIEQ2RTNGOCwgRkNFRkVGLCBEQ0UwRDksIEE1OTc4QiwgRUREREQ0LCBENkUzRjgsIEZFRjVFRlxuXG4gICAgICAgIHN3aXRjaCAocGFsZXR0ZSkge1xuICAgICAgICAgIGNhc2UgJ3BhbGV0dGUxJzpcbiAgICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjMDA4RkZCJywgJyMwMEUzOTYnLCAnI0ZFQjAxOScsICcjRkY0NTYwJywgJyM3NzVERDAnXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncGFsZXR0ZTInOlxuICAgICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyMzZjUxYjUnLCAnIzAzYTlmNCcsICcjNGNhZjUwJywgJyNmOWNlMWQnLCAnI0ZGOTgwMCddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwYWxldHRlMyc6XG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzMzYjJkZicsICcjNTQ2RTdBJywgJyNkNDUyNmUnLCAnIzEzZDhhYScsICcjQTU5NzhCJ107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BhbGV0dGU0JzpcbiAgICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjNGVjZGM0JywgJyNjN2Y0NjQnLCAnIzgxRDRGQScsICcjZmQ2YTZhJywgJyM1NDZFN0EnXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncGFsZXR0ZTUnOlxuICAgICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyMyYjkwOGYnLCAnI2Y5YTNhNCcsICcjOTBlZTdlJywgJyNmYTQ0NDMnLCAnIzY5ZDJlNyddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwYWxldHRlNic6XG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzQ0OUREMScsICcjRjg2NjI0JywgJyNFQTM1NDYnLCAnIzY2MkU5QicsICcjQzVEODZEJ107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BhbGV0dGU3JzpcbiAgICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjRDcyNjNEJywgJyMxQjk5OEInLCAnIzJFMjk0RScsICcjRjQ2MDM2JywgJyNFMkMwNDQnXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncGFsZXR0ZTgnOlxuICAgICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyM2NjJFOUInLCAnI0Y4NjYyNCcsICcjRjlDODBFJywgJyNFQTM1NDYnLCAnIzQzQkNDRCddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwYWxldHRlOSc6XG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzVDNDc0MicsICcjQTU5NzhCJywgJyM4RDVCNEMnLCAnIzVBMkEyNycsICcjQzRCQkFGJ107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BhbGV0dGUxMCc6XG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnI0EzMDBENicsICcjN0QwMkVCJywgJyM1NjUzRkUnLCAnIzI5ODNGRicsICcjMDBCMUYyJ107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzAwOEZGQicsICcjMDBFMzk2JywgJyNGRUIwMTknLCAnI0ZGNDU2MCcsICcjNzc1REQwJ107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9ycztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVGhlbWU7XG4gIH0oKTtcblxuICB2YXIgVGl0bGVTdWJ0aXRsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGl0bGVTdWJ0aXRsZShjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaXRsZVN1YnRpdGxlKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGl0bGVTdWJ0aXRsZSwgW3tcbiAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGVTdWJ0aXRsZSgndGl0bGUnKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGVTdWJ0aXRsZSgnc3VidGl0bGUnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1RpdGxlU3VidGl0bGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGl0bGVTdWJ0aXRsZSh0eXBlKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdHNDb25maWcgPSB0eXBlID09PSAndGl0bGUnID8gdy5jb25maWcudGl0bGUgOiB3LmNvbmZpZy5zdWJ0aXRsZTtcbiAgICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuc3ZnV2lkdGggLyAyO1xuICAgICAgICB2YXIgeSA9IHRzQ29uZmlnLm9mZnNldFk7XG4gICAgICAgIHZhciB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG5cbiAgICAgICAgaWYgKHRzQ29uZmlnLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB4ID0gMTA7XG4gICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgIH0gZWxzZSBpZiAodHNDb25maWcuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC0gMTA7XG4gICAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IHggKyB0c0NvbmZpZy5vZmZzZXRYO1xuICAgICAgICB5ID0geSArIHBhcnNlSW50KHRzQ29uZmlnLnN0eWxlLmZvbnRTaXplLCAxMCkgKyB0c0NvbmZpZy5tYXJnaW4gLyAyO1xuXG4gICAgICAgIGlmICh0c0NvbmZpZy50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICAgIHZhciB0aXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHQ6IHRzQ29uZmlnLnRleHQsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgICAgZm9udFNpemU6IHRzQ29uZmlnLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdHNDb25maWcuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHRzQ29uZmlnLnN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICBmb3JlQ29sb3I6IHRzQ29uZmlnLnN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRpdGxlVGV4dC5ub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLXRleHRcIikpO1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uUGFwZXIuYWRkKHRpdGxlVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVGl0bGVTdWJ0aXRsZTtcbiAgfSgpO1xuXG4gIHZhciBIZWxwZXJzJDMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlbHBlcnMoZEN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlbHBlcnMpO1xuXG4gICAgICB0aGlzLncgPSBkQ3R4Lnc7XG4gICAgICB0aGlzLmRDdHggPSBkQ3R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgQ2hhcnQgVGl0bGUvU3VidGl0bGUgRGltZW5zaW9uc1xuICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7e3dpZHRoLCBoZWlnaHR9fVxuICAgICAqKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEhlbHBlcnMsIFt7XG4gICAgICBrZXk6IFwiZ2V0VGl0bGVTdWJ0aXRsZUNvb3Jkc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlU3VidGl0bGVDb29yZHModHlwZSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIHZhciBmbG9hdGluZyA9IHR5cGUgPT09ICd0aXRsZScgPyB3LmNvbmZpZy50aXRsZS5mbG9hdGluZyA6IHcuY29uZmlnLnN1YnRpdGxlLmZsb2F0aW5nO1xuICAgICAgICB2YXIgZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLXRleHRcIikpO1xuXG4gICAgICAgIGlmIChlbCAhPT0gbnVsbCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgICAgICB2YXIgY29vcmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB3aWR0aCA9IGNvb3JkLndpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IHcuZ2xvYmFscy5heGlzQ2hhcnRzID8gY29vcmQuaGVpZ2h0ICsgNSA6IGNvb3JkLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldExlZ2VuZHNSZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVnZW5kc1JlY3QoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZWxMZWdlbmRXcmFwID0gdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXA7XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5sZWdlbmQuaGVpZ2h0ICYmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICd0b3AnIHx8IHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbGVnZW5kIHRvIHRha2UgdXAgYWxsIHRoZSBzcGFjZVxuICAgICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5tYXhIZWlnaHQgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC8gMiArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGdSZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgVXRpbHMkMS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxMZWdlbmRXcmFwKSk7XG5cbiAgICAgICAgaWYgKGVsTGVnZW5kV3JhcCAhPT0gbnVsbCAmJiAhdy5jb25maWcubGVnZW5kLmZsb2F0aW5nICYmIHcuY29uZmlnLmxlZ2VuZC5zaG93KSB7XG4gICAgICAgICAgdGhpcy5kQ3R4LmxnUmVjdCA9IHtcbiAgICAgICAgICAgIHg6IGxnUmVjdC54LFxuICAgICAgICAgICAgeTogbGdSZWN0LnksXG4gICAgICAgICAgICBoZWlnaHQ6IGxnUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogbGdSZWN0LmhlaWdodCA9PT0gMCA/IDAgOiBsZ1JlY3Qud2lkdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZEN0eC5sZ1JlY3QgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBpZiBsZWdlbmQgdGFrZXMgdXAgYWxsIG9mIHRoZSBjaGFydCBzcGFjZSwgd2UgbmVlZCB0byByZXN0cmljdCBpdC5cblxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdsZWZ0JyB8fCB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBpZiAodGhpcy5kQ3R4LmxnUmVjdC53aWR0aCAqIDEuNSA+IHcuZ2xvYmFscy5zdmdXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5kQ3R4LmxnUmVjdC53aWR0aCA9IHcuZ2xvYmFscy5zdmdXaWR0aCAvIDEuNTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kQ3R4LmxnUmVjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TGFyZ2VzdFN0cmluZ0Zyb21NdWx0aUFyclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhcmdlc3RTdHJpbmdGcm9tTXVsdGlBcnIodmFsLCBhcnIpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB2YWxBcnIgPSB2YWw7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc011bHRpTGluZVgpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgeGF4aXMgbGFiZWxzIGhhcyBtdWx0aWxpbmUgdGV4dHMgKGFycmF5KVxuICAgICAgICAgIHZhciBtYXhBcnJzID0gYXJyLm1hcChmdW5jdGlvbiAoeGwsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeGwpID8geGwubGVuZ3RoIDogMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbWF4QXJyTGVuID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KG1heEFycnMpKTtcbiAgICAgICAgICB2YXIgbWF4QXJySW5kZXggPSBtYXhBcnJzLmluZGV4T2YobWF4QXJyTGVuKTtcbiAgICAgICAgICB2YWxBcnIgPSBhcnJbbWF4QXJySW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbEFycjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGVscGVycztcbiAgfSgpO1xuXG4gIHZhciBEaW1YQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGltWEF4aXMoZEN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpbVhBeGlzKTtcblxuICAgICAgdGhpcy53ID0gZEN0eC53O1xuICAgICAgdGhpcy5kQ3R4ID0gZEN0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFggQXhpcyBEaW1lbnNpb25zXG4gICAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICoqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRGltWEF4aXMsIFt7XG4gICAgICBrZXk6IFwiZ2V0eEF4aXNMYWJlbHNDb29yZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR4QXhpc0xhYmVsc0Nvb3JkcygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4YXhpc0xhYmVscyA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKTtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljICYmIHhheGlzTGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHhheGlzTGFiZWxzID0gdy5nbG9iYWxzLmNhdGVnb3J5TGFiZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3Q7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy50aW1lc2NhbGVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldHhBeGlzVGltZVNjYWxlTGFiZWxzQ29vcmRzKCk7XG4gICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBjb29yZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvb3Jkcy5oZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kQ3R4LmxnV2lkdGhGb3JTaWRlTGVnZW5kcyA9ICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdsZWZ0JyB8fCB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcpICYmICF3LmNvbmZpZy5sZWdlbmQuZmxvYXRpbmcgPyB0aGlzLmRDdHgubGdSZWN0LndpZHRoIDogMDsgLy8gZ2V0IHRoZSBsb25nZXN0IHN0cmluZyBmcm9tIHRoZSBsYWJlbHMgYXJyYXkgYW5kIGFsc28gYXBwbHkgbGFiZWwgZm9ybWF0dGVyXG5cbiAgICAgICAgICB2YXIgeGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnhMYWJlbEZvcm1hdHRlcjsgLy8gcHJldmVudCBjaGFuZ2luZyB4YXhpc0xhYmVscyB0byBhdm9pZCBpc3N1ZXMgaW4gbXVsdGkteWF4ZXMgLSBmaXggIzUyMlxuXG4gICAgICAgICAgdmFyIHZhbCA9IFV0aWxzJDEuZ2V0TGFyZ2VzdFN0cmluZ0Zyb21BcnIoeGF4aXNMYWJlbHMpO1xuICAgICAgICAgIHZhciB2YWxBcnIgPSB0aGlzLmRDdHguZGltSGVscGVycy5nZXRMYXJnZXN0U3RyaW5nRnJvbU11bHRpQXJyKHZhbCwgeGF4aXNMYWJlbHMpOyAvLyB0aGUgbGFiZWxzIGdldHMgY2hhbmdlZCBmb3IgYmFyIGNoYXJ0c1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHZhbCA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLnJlc3VsdC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYjtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgdmFsQXJyID0gdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5kQ3R4LmN0eCk7XG4gICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHZhbDtcbiAgICAgICAgICB2YWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh4bGJGb3JtYXR0ZXIsIHZhbCwgdGltZXN0YW1wLCB7XG4gICAgICAgICAgICBpOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRlRm9ybWF0dGVyOiBuZXcgRGF0ZVRpbWUodGhpcy5kQ3R4LmN0eCkuZm9ybWF0RGF0ZSxcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxBcnIgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh4bGJGb3JtYXR0ZXIsIHZhbEFyciwgdGltZXN0YW1wLCB7XG4gICAgICAgICAgICBpOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRlRm9ybWF0dGVyOiBuZXcgRGF0ZVRpbWUodGhpcy5kQ3R4LmN0eCkuZm9ybWF0RGF0ZSxcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMgJiYgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgfHwgU3RyaW5nKHZhbCkudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgdmFsID0gJzEnO1xuICAgICAgICAgICAgdmFsQXJyID0gdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmRDdHguY3R4KTtcbiAgICAgICAgICB2YXIgeExhYmVscmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250U2l6ZSk7XG4gICAgICAgICAgdmFyIHhBcnJMYWJlbHJlY3QgPSB4TGFiZWxyZWN0O1xuXG4gICAgICAgICAgaWYgKHZhbCAhPT0gdmFsQXJyKSB7XG4gICAgICAgICAgICB4QXJyTGFiZWxyZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHZhbEFyciwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgd2lkdGg6IHhMYWJlbHJlY3Qud2lkdGggPj0geEFyckxhYmVscmVjdC53aWR0aCA/IHhMYWJlbHJlY3Qud2lkdGggOiB4QXJyTGFiZWxyZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB4TGFiZWxyZWN0LmhlaWdodCA+PSB4QXJyTGFiZWxyZWN0LmhlaWdodCA/IHhMYWJlbHJlY3QuaGVpZ2h0IDogeEFyckxhYmVscmVjdC5oZWlnaHRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY3Qud2lkdGggKiB4YXhpc0xhYmVscy5sZW5ndGggPiB3Lmdsb2JhbHMuc3ZnV2lkdGggLSB0aGlzLmRDdHgubGdXaWR0aEZvclNpZGVMZWdlbmRzIC0gdGhpcy5kQ3R4LnlBeGlzV2lkdGggLSB0aGlzLmRDdHguZ3JpZFBhZC5sZWZ0IC0gdGhpcy5kQ3R4LmdyaWRQYWQucmlnaHQgJiYgdy5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSAhPT0gMCB8fCB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlQWx3YXlzKSB7XG4gICAgICAgICAgICBpZiAoIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHZhciBnZXRSb3RhdGVkVGV4dFJlY3RzID0gZnVuY3Rpb24gZ2V0Um90YXRlZFRleHRSZWN0cyh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYXBoaWNzLmdldFRleHRSZWN0cyh0ZXh0LCB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemUsIHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250RmFtaWx5LCBcInJvdGF0ZShcIi5jb25jYXQody5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSwgXCIgMCAwKVwiKSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHhMYWJlbHJlY3QgPSBnZXRSb3RhdGVkVGV4dFJlY3RzKHZhbCk7XG5cbiAgICAgICAgICAgICAgaWYgKHZhbCAhPT0gdmFsQXJyKSB7XG4gICAgICAgICAgICAgICAgeEFyckxhYmVscmVjdCA9IGdldFJvdGF0ZWRUZXh0UmVjdHModmFsQXJyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gKHhMYWJlbHJlY3QuaGVpZ2h0ID4geEFyckxhYmVscmVjdC5oZWlnaHQgPyB4TGFiZWxyZWN0LmhlaWdodCA6IHhBcnJMYWJlbHJlY3QuaGVpZ2h0KSAvIDEuNTtcbiAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHhMYWJlbHJlY3Qud2lkdGggPiB4QXJyTGFiZWxyZWN0LndpZHRoID8geExhYmVscmVjdC53aWR0aCA6IHhBcnJMYWJlbHJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogR2V0IFggQXhpcyBMYWJlbCBHcm91cCBoZWlnaHRcbiAgICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXR4QXhpc0dyb3VwTGFiZWxzQ29vcmRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0eEF4aXNHcm91cExhYmVsc0Nvb3JkcygpIHtcbiAgICAgICAgdmFyIF93JGNvbmZpZyR4YXhpcyRncm91cDtcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5oYXNYYXhpc0dyb3Vwcykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9udFNpemUgPSAoKF93JGNvbmZpZyR4YXhpcyRncm91cCA9IHcuY29uZmlnLnhheGlzLmdyb3VwLnN0eWxlKSA9PT0gbnVsbCB8fCBfdyRjb25maWckeGF4aXMkZ3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93JGNvbmZpZyR4YXhpcyRncm91cC5mb250U2l6ZSkgfHwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICB2YXIgeGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMuZ3JvdXBzLm1hcChmdW5jdGlvbiAoZykge1xuICAgICAgICAgIHJldHVybiBnLnRpdGxlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlY3Q7IC8vIHByZXZlbnQgY2hhbmdpbmcgeGF4aXNMYWJlbHMgdG8gYXZvaWQgaXNzdWVzIGluIG11bHRpLXlheGVzIC0gZml4ICM1MjJcblxuICAgICAgICB2YXIgdmFsID0gVXRpbHMkMS5nZXRMYXJnZXN0U3RyaW5nRnJvbUFycih4YXhpc0xhYmVscyk7XG4gICAgICAgIHZhciB2YWxBcnIgPSB0aGlzLmRDdHguZGltSGVscGVycy5nZXRMYXJnZXN0U3RyaW5nRnJvbU11bHRpQXJyKHZhbCwgeGF4aXNMYWJlbHMpO1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5kQ3R4LmN0eCk7XG4gICAgICAgIHZhciB4TGFiZWxyZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHZhbCwgZm9udFNpemUpO1xuICAgICAgICB2YXIgeEFyckxhYmVscmVjdCA9IHhMYWJlbHJlY3Q7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gdmFsQXJyKSB7XG4gICAgICAgICAgeEFyckxhYmVscmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWxBcnIsIGZvbnRTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgd2lkdGg6IHhMYWJlbHJlY3Qud2lkdGggPj0geEFyckxhYmVscmVjdC53aWR0aCA/IHhMYWJlbHJlY3Qud2lkdGggOiB4QXJyTGFiZWxyZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogeExhYmVscmVjdC5oZWlnaHQgPj0geEFyckxhYmVscmVjdC5oZWlnaHQgPyB4TGFiZWxyZWN0LmhlaWdodCA6IHhBcnJMYWJlbHJlY3QuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogR2V0IFggQXhpcyBUaXRsZSBEaW1lbnNpb25zXG4gICAgICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgICAgICogQHJldHVybiB7e3dpZHRoLCBoZWlnaHR9fVxuICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldHhBeGlzVGl0bGVDb29yZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR4QXhpc1RpdGxlQ29vcmRzKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmRDdHguY3R4KTtcbiAgICAgICAgICB2YXIgcmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0LCB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSk7XG4gICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0eEF4aXNUaW1lU2NhbGVMYWJlbHNDb29yZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR4QXhpc1RpbWVTY2FsZUxhYmVsc0Nvb3JkcygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciByZWN0O1xuICAgICAgICB0aGlzLmRDdHgudGltZXNjYWxlTGFiZWxzID0gdy5nbG9iYWxzLnRpbWVzY2FsZUxhYmVscy5zbGljZSgpO1xuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5kQ3R4LnRpbWVzY2FsZUxhYmVscy5tYXAoZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsLnZhbHVlO1xuICAgICAgICB9KTsgLy8gIGdldCB0aGUgbG9uZ2VzdCBzdHJpbmcgZnJvbSB0aGUgbGFiZWxzIGFycmF5IGFuZCBhbHNvIGFwcGx5IGxhYmVsIGZvcm1hdHRlciB0byBpdFxuXG4gICAgICAgIHZhciB2YWwgPSBsYWJlbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgLy8gaWYgdW5kZWZpbmVkLCBtYXliZSB1c2VyIGRpZG4ndCBwYXNzIHRoZSBkYXRldGltZSh4KSB2YWx1ZXNcbiAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdZb3UgaGF2ZSBwb3NzaWJseSBzdXBwbGllZCBpbnZhbGlkIERhdGUgZm9ybWF0LiBQbGVhc2Ugc3VwcGx5IGEgdmFsaWQgSmF2YVNjcmlwdCBEYXRlJyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5kQ3R4LmN0eCk7XG4gICAgICAgIHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModmFsLCB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemUpO1xuICAgICAgICB2YXIgdG90YWxXaWR0aFJvdGF0ZWQgPSByZWN0LndpZHRoICogMS4wNSAqIGxhYmVscy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRvdGFsV2lkdGhSb3RhdGVkID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLm92ZXJsYXBwaW5nWExhYmVscyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgIH0gLy8gSW4gY2VydGFpbiBjYXNlcywgdGhlIGxhc3QgbGFiZWxzIGdldHMgY3JvcHBlZCBpbiB4YXhpcy5cbiAgICAgIC8vIEhlbmNlLCB3ZSBhZGQgc29tZSBhZGRpdGlvbmFsIHBhZGRpbmcgYmFzZWQgb24gdGhlIGxhYmVsIGxlbmd0aCB0byBhdm9pZCB0aGUgbGFzdCBsYWJlbCBiZWluZyBjcm9wcGVkIG9yIHdlIGRvbid0IGRyYXcgaXQgYXQgYWxsXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkaXRpb25hbFBhZGRpbmdYTGFiZWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkaXRpb25hbFBhZGRpbmdYTGFiZWxzKHhheGlzTGFiZWxDb29yZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICAgIHZhciB4dHlwZSA9IGNuZi54YXhpcy50eXBlO1xuICAgICAgICB2YXIgbGJXaWR0aCA9IHhheGlzTGFiZWxDb29yZHMud2lkdGg7XG4gICAgICAgIGdsLnNraXBMYXN0VGltZWxpbmVsYWJlbCA9IGZhbHNlO1xuICAgICAgICBnbC5za2lwRmlyc3RUaW1lbGluZWxhYmVsID0gZmFsc2U7XG4gICAgICAgIHZhciBpc0Jhck9wcG9zaXRlID0gdy5jb25maWcueWF4aXNbMF0ub3Bwb3NpdGUgJiYgdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbDtcblxuICAgICAgICB2YXIgaXNDb2xsYXBzZWQgPSBmdW5jdGlvbiBpc0NvbGxhcHNlZChpKSB7XG4gICAgICAgICAgcmV0dXJuIGdsLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSAhPT0gLTE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJpZ2h0UGFkID0gZnVuY3Rpb24gcmlnaHRQYWQoeWF4ZSkge1xuICAgICAgICAgIGlmIChfdGhpcy5kQ3R4LnRpbWVzY2FsZUxhYmVscyAmJiBfdGhpcy5kQ3R4LnRpbWVzY2FsZUxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZvciB0aW1lbGluZSBsYWJlbHMsIHdlIHRha2UgdGhlIGxhc3QgbGFiZWwgYW5kIGNoZWNrIGlmIGl0IGV4Y2VlZHMgZ3JpZFdpZHRoXG4gICAgICAgICAgICB2YXIgZmlyc3RpbWVzY2FsZUxhYmVsID0gX3RoaXMuZEN0eC50aW1lc2NhbGVMYWJlbHNbMF07XG4gICAgICAgICAgICB2YXIgbGFzdFRpbWVzY2FsZUxhYmVsID0gX3RoaXMuZEN0eC50aW1lc2NhbGVMYWJlbHNbX3RoaXMuZEN0eC50aW1lc2NhbGVMYWJlbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgbGFzdExhYmVsUG9zaXRpb24gPSBsYXN0VGltZXNjYWxlTGFiZWwucG9zaXRpb24gKyBsYldpZHRoIC8gMS43NSAtIF90aGlzLmRDdHgueUF4aXNXaWR0aFJpZ2h0O1xuICAgICAgICAgICAgdmFyIGZpcnN0TGFiZWxQb3NpdGlvbiA9IGZpcnN0aW1lc2NhbGVMYWJlbC5wb3NpdGlvbiAtIGxiV2lkdGggLyAxLjc1ICsgX3RoaXMuZEN0eC55QXhpc1dpZHRoTGVmdDtcbiAgICAgICAgICAgIHZhciBsZ1JpZ2h0UmVjdFdpZHRoID0gdy5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAncmlnaHQnICYmIF90aGlzLmRDdHgubGdSZWN0LndpZHRoID4gMCA/IF90aGlzLmRDdHgubGdSZWN0LndpZHRoIDogMDtcblxuICAgICAgICAgICAgaWYgKGxhc3RMYWJlbFBvc2l0aW9uID4gZ2wuc3ZnV2lkdGggLSBnbC50cmFuc2xhdGVYIC0gbGdSaWdodFJlY3RXaWR0aCkge1xuICAgICAgICAgICAgICBnbC5za2lwTGFzdFRpbWVsaW5lbGFiZWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3RMYWJlbFBvc2l0aW9uIDwgLSgoIXlheGUuc2hvdyB8fCB5YXhlLmZsb2F0aW5nKSAmJiAoY25mLmNoYXJ0LnR5cGUgPT09ICdiYXInIHx8IGNuZi5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IGNuZi5jaGFydC50eXBlID09PSAncmFuZ2VCYXInIHx8IGNuZi5jaGFydC50eXBlID09PSAnYm94UGxvdCcpID8gbGJXaWR0aCAvIDEuNzUgOiAxMCkpIHtcbiAgICAgICAgICAgICAgZ2wuc2tpcEZpcnN0VGltZWxpbmVsYWJlbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh4dHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgLy8gSWYgdXNlciBoYXMgZW5hYmxlZCBEYXRlVGltZSwgYnV0IHVzZXMgb3duJ3MgZm9ybWF0dGVyXG4gICAgICAgICAgICBpZiAoX3RoaXMuZEN0eC5ncmlkUGFkLnJpZ2h0IDwgbGJXaWR0aCAmJiAhZ2wucm90YXRlWExhYmVscykge1xuICAgICAgICAgICAgICBnbC5za2lwTGFzdFRpbWVsaW5lbGFiZWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoeHR5cGUgIT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kQ3R4LmdyaWRQYWQucmlnaHQgPCBsYldpZHRoIC8gMiAtIF90aGlzLmRDdHgueUF4aXNXaWR0aFJpZ2h0ICYmICFnbC5yb3RhdGVYTGFiZWxzICYmICF3LmNvbmZpZy54YXhpcy5sYWJlbHMudHJpbSAmJiAody5jb25maWcueGF4aXMudGlja1BsYWNlbWVudCAhPT0gJ2JldHdlZW4nIHx8IHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpKSB7XG4gICAgICAgICAgICAgIF90aGlzLmRDdHgueFBhZFJpZ2h0ID0gbGJXaWR0aCAvIDIgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFkWUF4ZSA9IGZ1bmN0aW9uIHBhZFlBeGUoeWF4ZSwgaSkge1xuICAgICAgICAgIGlmIChjbmYueWF4aXMubGVuZ3RoID4gMSAmJiBpc0NvbGxhcHNlZChpKSkgcmV0dXJuO1xuICAgICAgICAgIHJpZ2h0UGFkKHlheGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNuZi55YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpKSB7XG4gICAgICAgICAgaWYgKGlzQmFyT3Bwb3NpdGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kQ3R4LmdyaWRQYWQubGVmdCA8IGxiV2lkdGgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuZEN0eC54UGFkTGVmdCA9IGxiV2lkdGggLyAyICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMuZEN0eC54UGFkUmlnaHQgPSBsYldpZHRoIC8gMiArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhZFlBeGUoeWF4ZSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGltWEF4aXM7XG4gIH0oKTtcblxuICB2YXIgRGltWUF4aXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpbVlBeGlzKGRDdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaW1ZQXhpcyk7XG5cbiAgICAgIHRoaXMudyA9IGRDdHgudztcbiAgICAgIHRoaXMuZEN0eCA9IGRDdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBZIEF4aXMgRGltZW5zaW9uc1xuICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7e3dpZHRoLCBoZWlnaHR9fVxuICAgICAqKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERpbVlBeGlzLCBbe1xuICAgICAga2V5OiBcImdldHlBeGlzTGFiZWxzQ29vcmRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0eUF4aXNMYWJlbHNDb29yZHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIHZhciBsYWJlbFBhZCA9IDEwO1xuICAgICAgICB2YXIgYXhlc1V0aWxzID0gbmV3IEF4ZXNVdGlscyh0aGlzLmRDdHguY3R4KTtcbiAgICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBmb3JtYXR0ZXJBcmdzID0ge1xuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IC0xLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHlTID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdO1xuICAgICAgICAgIHZhciB5QXhpc01pbldpZHRoID0gMDtcbiAgICAgICAgICBpZiAoIWF4ZXNVdGlscy5pc1lBeGlzSGlkZGVuKGluZGV4KSAmJiB5YXhlLmxhYmVscy5zaG93ICYmIHlheGUubGFiZWxzLm1pbldpZHRoICE9PSB1bmRlZmluZWQpIHlBeGlzTWluV2lkdGggPSB5YXhlLmxhYmVscy5taW5XaWR0aDtcblxuICAgICAgICAgIGlmICghYXhlc1V0aWxzLmlzWUF4aXNIaWRkZW4oaW5kZXgpICYmIHlheGUubGFiZWxzLnNob3cgJiYgeVMucmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIG1pblYgPSB5Uy5uaWNlTWluID09PSBOdW1iZXIuTUlOX1ZBTFVFID8gMCA6IHlTLm5pY2VNaW47XG4gICAgICAgICAgICB2YXIgdmFsID0geVMucmVzdWx0LnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJyKSB7XG4gICAgICAgICAgICAgIHZhciBfU3RyaW5nLCBfU3RyaW5nMjtcblxuICAgICAgICAgICAgICByZXR1cm4gKChfU3RyaW5nID0gU3RyaW5nKGxiRm9ybWF0dGVyKGFjYywgZm9ybWF0dGVyQXJncykpKSA9PT0gbnVsbCB8fCBfU3RyaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfU3RyaW5nLmxlbmd0aCkgPiAoKF9TdHJpbmcyID0gU3RyaW5nKGxiRm9ybWF0dGVyKGN1cnIsIGZvcm1hdHRlckFyZ3MpKSkgPT09IG51bGwgfHwgX1N0cmluZzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9TdHJpbmcyLmxlbmd0aCkgPyBhY2MgOiBjdXJyO1xuICAgICAgICAgICAgfSwgbWluVik7XG4gICAgICAgICAgICB2YWwgPSBsYkZvcm1hdHRlcih2YWwsIGZvcm1hdHRlckFyZ3MpOyAvLyB0aGUgc2Vjb25kIHBhcmFtZXRlciAtMSBpcyB0aGUgaW5kZXggb2YgdGljayB3aGljaCB1c2VyIGNhbiB1c2UgaW4gdGhlIGZvcm1hdHRlclxuXG4gICAgICAgICAgICB2YXIgdmFsQXJyID0gdmFsOyAvLyBpZiB1c2VyIGhhcyBzcGVjaWZpZWQgYSBjdXN0b20gZm9ybWF0dGVyLCBhbmQgdGhlIHJlc3VsdCBpcyBudWxsIG9yIGVtcHR5LCB3ZSBuZWVkIHRvIGRpc2NhcmQgdGhlIGZvcm1hdHRlciBhbmQgdGFrZSB0aGUgdmFsdWUgYXMgaXQgaXMuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyB8fCB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhbCA9IHlTLm5pY2VNYXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgIGxhYmVsUGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGJhcllheGlzTGFiZWxzID0gdy5nbG9iYWxzLmxhYmVscy5zbGljZSgpOyAvLyAgZ2V0IHRoZSBsb25nZXN0IHN0cmluZyBmcm9tIHRoZSBsYWJlbHMgYXJyYXkgYW5kIGFsc28gYXBwbHkgbGFiZWwgZm9ybWF0dGVyIHRvIGl0XG5cbiAgICAgICAgICAgICAgdmFsID0gVXRpbHMkMS5nZXRMYXJnZXN0U3RyaW5nRnJvbUFycihiYXJZYXhpc0xhYmVscyk7XG4gICAgICAgICAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwge1xuICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFsQXJyID0gX3RoaXMuZEN0eC5kaW1IZWxwZXJzLmdldExhcmdlc3RTdHJpbmdGcm9tTXVsdGlBcnIodmFsLCBiYXJZYXhpc0xhYmVscyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyhfdGhpcy5kQ3R4LmN0eCk7XG4gICAgICAgICAgICB2YXIgcm90YXRlU3RyID0gJ3JvdGF0ZSgnLmNvbmNhdCh5YXhlLmxhYmVscy5yb3RhdGUsICcgMCAwKScpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModmFsLCB5YXhlLmxhYmVscy5zdHlsZS5mb250U2l6ZSwgeWF4ZS5sYWJlbHMuc3R5bGUuZm9udEZhbWlseSwgcm90YXRlU3RyLCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgYXJyTGFiZWxyZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdmFsQXJyKSB7XG4gICAgICAgICAgICAgIGFyckxhYmVscmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWxBcnIsIHlheGUubGFiZWxzLnN0eWxlLmZvbnRTaXplLCB5YXhlLmxhYmVscy5zdHlsZS5mb250RmFtaWx5LCByb3RhdGVTdHIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgICB3aWR0aDogKHlBeGlzTWluV2lkdGggPiBhcnJMYWJlbHJlY3Qud2lkdGggfHwgeUF4aXNNaW5XaWR0aCA+IHJlY3Qud2lkdGggPyB5QXhpc01pbldpZHRoIDogYXJyTGFiZWxyZWN0LndpZHRoID4gcmVjdC53aWR0aCA/IGFyckxhYmVscmVjdC53aWR0aCA6IHJlY3Qud2lkdGgpICsgbGFiZWxQYWQsXG4gICAgICAgICAgICAgIGhlaWdodDogYXJyTGFiZWxyZWN0LmhlaWdodCA+IHJlY3QuaGVpZ2h0ID8gYXJyTGFiZWxyZWN0LmhlaWdodCA6IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgWSBBeGlzIERpbWVuc2lvbnNcbiAgICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0eUF4aXNUaXRsZUNvb3Jkc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldHlBeGlzVGl0bGVDb29yZHMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoeWF4ZS5zaG93ICYmIHlheGUudGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoX3RoaXMyLmRDdHguY3R4KTtcbiAgICAgICAgICAgIHZhciByb3RhdGVTdHIgPSAncm90YXRlKCcuY29uY2F0KHlheGUudGl0bGUucm90YXRlLCAnIDAgMCknKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHlheGUudGl0bGUudGV4dCwgeWF4ZS50aXRsZS5zdHlsZS5mb250U2l6ZSwgeWF4ZS50aXRsZS5zdHlsZS5mb250RmFtaWx5LCByb3RhdGVTdHIsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFRvdGFsWUF4aXNXaWR0aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdGFsWUF4aXNXaWR0aCgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB5QXhpc1dpZHRoID0gMDtcbiAgICAgICAgdmFyIHlBeGlzV2lkdGhMZWZ0ID0gMDtcbiAgICAgICAgdmFyIHlBeGlzV2lkdGhSaWdodCA9IDA7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdy5nbG9iYWxzLnlBeGlzU2NhbGUubGVuZ3RoID4gMSA/IDEwIDogMDtcbiAgICAgICAgdmFyIGF4ZXNVdGlscyA9IG5ldyBBeGVzVXRpbHModGhpcy5kQ3R4LmN0eCk7XG5cbiAgICAgICAgdmFyIGlzSGlkZGVuWUF4aXMgPSBmdW5jdGlvbiBpc0hpZGRlbllBeGlzKGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHcuZ2xvYmFscy5pZ25vcmVZQXhpc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPiAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFkRm9yTGFiZWxUaXRsZSA9IGZ1bmN0aW9uIHBhZEZvckxhYmVsVGl0bGUoY29vcmQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGZsb2F0aW5nID0gdy5jb25maWcueWF4aXNbaW5kZXhdLmZsb2F0aW5nO1xuICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgICAgICBpZiAoY29vcmQud2lkdGggPiAwICYmICFmbG9hdGluZykge1xuICAgICAgICAgICAgd2lkdGggPSBjb29yZC53aWR0aCArIHBhZGRpbmc7XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbllBeGlzKGluZGV4KSkge1xuICAgICAgICAgICAgICB3aWR0aCA9IHdpZHRoIC0gY29vcmQud2lkdGggLSBwYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IGZsb2F0aW5nIHx8IGF4ZXNVdGlscy5pc1lBeGlzSGlkZGVuKGluZGV4KSA/IDAgOiA1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuY29uZmlnLnlheGlzW2luZGV4XS5vcHBvc2l0ZSA/IHlBeGlzV2lkdGhSaWdodCA9IHlBeGlzV2lkdGhSaWdodCArIHdpZHRoIDogeUF4aXNXaWR0aExlZnQgPSB5QXhpc1dpZHRoTGVmdCArIHdpZHRoO1xuICAgICAgICAgIHlBeGlzV2lkdGggPSB5QXhpc1dpZHRoICsgd2lkdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgdy5nbG9iYWxzLnlMYWJlbHNDb29yZHMubWFwKGZ1bmN0aW9uICh5TGFiZWxDb29yZCwgaW5kZXgpIHtcbiAgICAgICAgICBwYWRGb3JMYWJlbFRpdGxlKHlMYWJlbENvb3JkLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB3Lmdsb2JhbHMueVRpdGxlQ29vcmRzLm1hcChmdW5jdGlvbiAoeVRpdGxlQ29vcmQsIGluZGV4KSB7XG4gICAgICAgICAgcGFkRm9yTGFiZWxUaXRsZSh5VGl0bGVDb29yZCwgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiAhdy5jb25maWcueWF4aXNbMF0uZmxvYXRpbmcpIHtcbiAgICAgICAgICB5QXhpc1dpZHRoID0gdy5nbG9iYWxzLnlMYWJlbHNDb29yZHNbMF0ud2lkdGggKyB3Lmdsb2JhbHMueVRpdGxlQ29vcmRzWzBdLndpZHRoICsgMTU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRDdHgueUF4aXNXaWR0aExlZnQgPSB5QXhpc1dpZHRoTGVmdDtcbiAgICAgICAgdGhpcy5kQ3R4LnlBeGlzV2lkdGhSaWdodCA9IHlBeGlzV2lkdGhSaWdodDtcbiAgICAgICAgcmV0dXJuIHlBeGlzV2lkdGg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERpbVlBeGlzO1xuICB9KCk7XG5cbiAgdmFyIERpbUdyaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpbUdyaWQoZEN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpbUdyaWQpO1xuXG4gICAgICB0aGlzLncgPSBkQ3R4Lnc7XG4gICAgICB0aGlzLmRDdHggPSBkQ3R4O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEaW1HcmlkLCBbe1xuICAgICAga2V5OiBcImdyaWRQYWRGb3JDb2x1bW5zSW5OdW1lcmljQXhpc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdyaWRQYWRGb3JDb2x1bW5zSW5OdW1lcmljQXhpcyhncmlkV2lkdGgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5ub0RhdGEgfHwgdy5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhc0JhciA9IGZ1bmN0aW9uIGhhc0Jhcih0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdiYXInIHx8IHR5cGUgPT09ICdyYW5nZUJhcicgfHwgdHlwZSA9PT0gJ2NhbmRsZXN0aWNrJyB8fCB0eXBlID09PSAnYm94UGxvdCc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHR5cGUgPSB3LmNvbmZpZy5jaGFydC50eXBlO1xuICAgICAgICB2YXIgYmFyV2lkdGggPSAwO1xuICAgICAgICB2YXIgc2VyaWVzTGVuID0gaGFzQmFyKHR5cGUpID8gdy5jb25maWcuc2VyaWVzLmxlbmd0aCA6IDE7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb21ib0JhckNvdW50ID4gMCkge1xuICAgICAgICAgIHNlcmllc0xlbiA9IHcuZ2xvYmFscy5jb21ib0JhckNvdW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKGhhc0JhcihjLnR5cGUpKSB7XG4gICAgICAgICAgICBzZXJpZXNMZW4gPSBzZXJpZXNMZW4gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICBzZXJpZXNMZW4gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhcnNQcmVzZW50ID0gaGFzQmFyKHR5cGUpIHx8IHcuZ2xvYmFscy5jb21ib0JhckNvdW50ID4gMDtcblxuICAgICAgICBpZiAoYmFyc1ByZXNlbnQgJiYgdy5nbG9iYWxzLmlzWE51bWVyaWMgJiYgIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwgJiYgc2VyaWVzTGVuID4gMCkge1xuICAgICAgICAgIHZhciB4UmF0aW8gPSAwO1xuICAgICAgICAgIHZhciB4UmFuZ2UgPSBNYXRoLmFicyh3Lmdsb2JhbHMuaW5pdGlhbE1heFggLSB3Lmdsb2JhbHMuaW5pdGlhbE1pblgpO1xuXG4gICAgICAgICAgaWYgKHhSYW5nZSA8PSAzKSB7XG4gICAgICAgICAgICB4UmFuZ2UgPSB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4UmF0aW8gPSB4UmFuZ2UgLyBncmlkV2lkdGg7XG4gICAgICAgICAgdmFyIHhEaXZpc2lvbjsgLy8gbWF4IGJhcndpZHRoIHNob3VsZCBiZSBlcXVhbCB0byBtaW5YRGlmZiB0byBhdm9pZCBvdmVybGFwXG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLm1pblhEaWZmICYmIHcuZ2xvYmFscy5taW5YRGlmZiAvIHhSYXRpbyA+IDApIHtcbiAgICAgICAgICAgIHhEaXZpc2lvbiA9IHcuZ2xvYmFscy5taW5YRGlmZiAvIHhSYXRpbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeERpdmlzaW9uID4gZ3JpZFdpZHRoIC8gMikge1xuICAgICAgICAgICAgeERpdmlzaW9uID0geERpdmlzaW9uIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiYXJXaWR0aCA9IHhEaXZpc2lvbiAvIHNlcmllc0xlbiAqIHBhcnNlSW50KHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2x1bW5XaWR0aCwgMTApIC8gMTAwO1xuXG4gICAgICAgICAgaWYgKGJhcldpZHRoIDwgMSkge1xuICAgICAgICAgICAgYmFyV2lkdGggPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJhcldpZHRoID0gYmFyV2lkdGggLyAoc2VyaWVzTGVuID4gMSA/IDEgOiAxLjUpICsgNTtcbiAgICAgICAgICB3Lmdsb2JhbHMuYmFyUGFkRm9yTnVtZXJpY0F4aXMgPSBiYXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXJXaWR0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ3JpZFBhZEZvcnRpdGxlU3VidGl0bGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBncmlkUGFkRm9ydGl0bGVTdWJ0aXRsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgICB2YXIgZ3JpZFNocmlua09mZnNldCA9IHRoaXMuZEN0eC5pc1NwYXJrbGluZSB8fCAhdy5nbG9iYWxzLmF4aXNDaGFydHMgPyAwIDogMTA7XG4gICAgICAgIHZhciB0aXRsZVN1YnRpdGxlID0gWyd0aXRsZScsICdzdWJ0aXRsZSddO1xuICAgICAgICB0aXRsZVN1YnRpdGxlLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAody5jb25maWdbdF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IHcuY29uZmlnW3RdLm1hcmdpbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZFNocmlua09mZnNldCArPSBfdGhpcy5kQ3R4LmlzU3BhcmtsaW5lIHx8ICF3Lmdsb2JhbHMuYXhpc0NoYXJ0cyA/IDAgOiA1O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5zaG93ICYmIHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgJiYgIXcuY29uZmlnLmxlZ2VuZC5mbG9hdGluZyAmJiAhdy5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpdGxlQ29vcmRzID0gdGhpcy5kQ3R4LmRpbUhlbHBlcnMuZ2V0VGl0bGVTdWJ0aXRsZUNvb3JkcygndGl0bGUnKTtcbiAgICAgICAgdmFyIHN1YnRpdGxlQ29vcmRzID0gdGhpcy5kQ3R4LmRpbUhlbHBlcnMuZ2V0VGl0bGVTdWJ0aXRsZUNvb3Jkcygnc3VidGl0bGUnKTtcbiAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLmdyaWRIZWlnaHQgLSB0aXRsZUNvb3Jkcy5oZWlnaHQgLSBzdWJ0aXRsZUNvb3Jkcy5oZWlnaHQgLSBncmlkU2hyaW5rT2Zmc2V0O1xuICAgICAgICBnbC50cmFuc2xhdGVZID0gZ2wudHJhbnNsYXRlWSArIHRpdGxlQ29vcmRzLmhlaWdodCArIHN1YnRpdGxlQ29vcmRzLmhlaWdodCArIGdyaWRTaHJpbmtPZmZzZXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEdyaWRYUG9zRm9yRHVhbFlBeGlzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R3JpZFhQb3NGb3JEdWFsWUF4aXMoeVRpdGxlQ29vcmRzLCB5YXhpc0xhYmVsQ29vcmRzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgYXhlc1V0aWxzID0gbmV3IEF4ZXNVdGlscyh0aGlzLmRDdHguY3R4KTtcbiAgICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSAmJiAheWF4ZS5mbG9hdGluZyAmJiAhYXhlc1V0aWxzLmlzWUF4aXNIaWRkZW4oaW5kZXgpKSB7XG4gICAgICAgICAgICBpZiAoeWF4ZS5vcHBvc2l0ZSkge1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWCA9IHcuZ2xvYmFscy50cmFuc2xhdGVYIC0gKHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoICsgeVRpdGxlQ29vcmRzW2luZGV4XS53aWR0aCkgLSBwYXJzZUludCh3LmNvbmZpZy55YXhpc1tpbmRleF0ubGFiZWxzLnN0eWxlLmZvbnRTaXplLCAxMCkgLyAxLjIgLSAxMjtcbiAgICAgICAgICAgIH0gLy8gZml4ZXMgYXBleGNoYXJ0cy5qcyMxNTk5XG5cblxuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy50cmFuc2xhdGVYIDwgMikge1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGltR3JpZDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIERpbWVuc2lvbnMgQ2xhc3MgZm9yIGNhbGN1bGF0aW5nIHJlY3RzIG9mIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBkcmF3biBhbmQgd2lsbCBiZSBkcmF3bi5cbiAgICpcbiAgICogQG1vZHVsZSBEaW1lbnNpb25zXG4gICAqKi9cblxuICB2YXIgRGltZW5zaW9ucyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGltZW5zaW9ucyhjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaW1lbnNpb25zKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMubGdSZWN0ID0ge307XG4gICAgICB0aGlzLnlBeGlzV2lkdGggPSAwO1xuICAgICAgdGhpcy55QXhpc1dpZHRoTGVmdCA9IDA7XG4gICAgICB0aGlzLnlBeGlzV2lkdGhSaWdodCA9IDA7XG4gICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgIHRoaXMuaXNTcGFya2xpbmUgPSB0aGlzLncuY29uZmlnLmNoYXJ0LnNwYXJrbGluZS5lbmFibGVkO1xuICAgICAgdGhpcy5kaW1IZWxwZXJzID0gbmV3IEhlbHBlcnMkMyh0aGlzKTtcbiAgICAgIHRoaXMuZGltWUF4aXMgPSBuZXcgRGltWUF4aXModGhpcyk7XG4gICAgICB0aGlzLmRpbVhBeGlzID0gbmV3IERpbVhBeGlzKHRoaXMpO1xuICAgICAgdGhpcy5kaW1HcmlkID0gbmV3IERpbUdyaWQodGhpcyk7XG4gICAgICB0aGlzLmxnV2lkdGhGb3JTaWRlTGVnZW5kcyA9IDA7XG4gICAgICB0aGlzLmdyaWRQYWQgPSB0aGlzLncuY29uZmlnLmdyaWQucGFkZGluZztcbiAgICAgIHRoaXMueFBhZFJpZ2h0ID0gMDtcbiAgICAgIHRoaXMueFBhZExlZnQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB3IC0gY2hhcnQgY29udGV4dFxuICAgICAqKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERpbWVuc2lvbnMsIFt7XG4gICAgICBrZXk6IFwicGxvdENvb3Jkc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBsb3RDb29yZHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgICAgdGhpcy5sZ1JlY3QgPSB0aGlzLmRpbUhlbHBlcnMuZ2V0TGVnZW5kc1JlY3QoKTtcblxuICAgICAgICBpZiAodGhpcy5pc1NwYXJrbGluZSAmJiAody5jb25maWcubWFya2Vycy5kaXNjcmV0ZS5sZW5ndGggPiAwIHx8IHcuY29uZmlnLm1hcmtlcnMuc2l6ZSA+IDApKSB7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5ncmlkUGFkKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgICAgICBrID0gX3JlZjJbMF0sXG4gICAgICAgICAgICAgICAgdiA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgICBfdGhpcy5ncmlkUGFkW2tdID0gTWF0aC5tYXgodiwgX3RoaXMudy5nbG9iYWxzLm1hcmtlcnMubGFyZ2VzdFNpemUgLyAxLjUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAvLyBmb3IgbGluZSAvIGFyZWEgLyBzY2F0dGVyIC8gY29sdW1uXG4gICAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zRm9yQXhpc0NoYXJ0cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZvciBwaWUgLyBkb251dHMgLyBjaXJjbGVcbiAgICAgICAgICB0aGlzLnNldERpbWVuc2lvbnNGb3JOb25BeGlzQ2hhcnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpbUdyaWQuZ3JpZFBhZEZvcnRpdGxlU3VidGl0bGUoKTsgLy8gYWZ0ZXIgY2FsY3VsYXRpbmcgZXZlcnl0aGluZywgYXBwbHkgcGFkZGluZyBzZXQgYnkgdXNlclxuXG4gICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5ncmlkSGVpZ2h0IC0gdGhpcy5ncmlkUGFkLnRvcCAtIHRoaXMuZ3JpZFBhZC5ib3R0b207XG4gICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLmdyaWRXaWR0aCAtIHRoaXMuZ3JpZFBhZC5sZWZ0IC0gdGhpcy5ncmlkUGFkLnJpZ2h0IC0gdGhpcy54UGFkUmlnaHQgLSB0aGlzLnhQYWRMZWZ0O1xuICAgICAgICB2YXIgYmFyV2lkdGggPSB0aGlzLmRpbUdyaWQuZ3JpZFBhZEZvckNvbHVtbnNJbk51bWVyaWNBeGlzKGdsLmdyaWRXaWR0aCk7XG4gICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLmdyaWRXaWR0aCAtIGJhcldpZHRoICogMjtcbiAgICAgICAgZ2wudHJhbnNsYXRlWCA9IGdsLnRyYW5zbGF0ZVggKyB0aGlzLmdyaWRQYWQubGVmdCArIHRoaXMueFBhZExlZnQgKyAoYmFyV2lkdGggPiAwID8gYmFyV2lkdGggKyA0IDogMCk7XG4gICAgICAgIGdsLnRyYW5zbGF0ZVkgPSBnbC50cmFuc2xhdGVZICsgdGhpcy5ncmlkUGFkLnRvcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RGltZW5zaW9uc0ZvckF4aXNDaGFydHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaW1lbnNpb25zRm9yQXhpc0NoYXJ0cygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgICAgdmFyIHlheGlzTGFiZWxDb29yZHMgPSB0aGlzLmRpbVlBeGlzLmdldHlBeGlzTGFiZWxzQ29vcmRzKCk7XG4gICAgICAgIHZhciB5VGl0bGVDb29yZHMgPSB0aGlzLmRpbVlBeGlzLmdldHlBeGlzVGl0bGVDb29yZHMoKTtcbiAgICAgICAgdy5nbG9iYWxzLnlMYWJlbHNDb29yZHMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLnlUaXRsZUNvb3JkcyA9IFtdO1xuICAgICAgICB3LmNvbmZpZy55YXhpcy5tYXAoZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgICAgLy8gc3RvcmUgdGhlIGxhYmVscyBhbmQgdGl0bGVzIGNvb3JkcyBpbiBnbG9iYWwgdmFyc1xuICAgICAgICAgIHcuZ2xvYmFscy55TGFiZWxzQ29vcmRzLnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdy5nbG9iYWxzLnlUaXRsZUNvb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoOiB5VGl0bGVDb29yZHNbaW5kZXhdLndpZHRoLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB0aGlzLmRpbVlBeGlzLmdldFRvdGFsWUF4aXNXaWR0aCgpO1xuICAgICAgICB2YXIgeGF4aXNMYWJlbENvb3JkcyA9IHRoaXMuZGltWEF4aXMuZ2V0eEF4aXNMYWJlbHNDb29yZHMoKTtcbiAgICAgICAgdmFyIHhheGlzR3JvdXBMYWJlbENvb3JkcyA9IHRoaXMuZGltWEF4aXMuZ2V0eEF4aXNHcm91cExhYmVsc0Nvb3JkcygpO1xuICAgICAgICB2YXIgeHRpdGxlQ29vcmRzID0gdGhpcy5kaW1YQXhpcy5nZXR4QXhpc1RpdGxlQ29vcmRzKCk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uYWxDaGVja3NGb3JBeGlzQ29vcmRzKHhheGlzTGFiZWxDb29yZHMsIHh0aXRsZUNvb3JkcywgeGF4aXNHcm91cExhYmVsQ29vcmRzKTtcbiAgICAgICAgZ2wudHJhbnNsYXRlWEF4aXNZID0gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyB0aGlzLnhBeGlzSGVpZ2h0IC8gOCA6IC00O1xuICAgICAgICBnbC50cmFuc2xhdGVYQXhpc1ggPSB3Lmdsb2JhbHMucm90YXRlWExhYmVscyAmJiB3Lmdsb2JhbHMuaXNYTnVtZXJpYyAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlIDw9IC00NSA/IC10aGlzLnhBeGlzV2lkdGggLyA0IDogMDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgIGdsLnJvdGF0ZVhMYWJlbHMgPSBmYWxzZTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYQXhpc1kgPSAtMSAqIChwYXJzZUludCh3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemUsIDEwKSAvIDEuNSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC50cmFuc2xhdGVYQXhpc1kgPSBnbC50cmFuc2xhdGVYQXhpc1kgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WTtcbiAgICAgICAgZ2wudHJhbnNsYXRlWEF4aXNYID0gZ2wudHJhbnNsYXRlWEF4aXNYICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFg7XG4gICAgICAgIHZhciB5QXhpc1dpZHRoID0gdGhpcy55QXhpc1dpZHRoO1xuICAgICAgICB2YXIgeEF4aXNIZWlnaHQgPSB0aGlzLnhBeGlzSGVpZ2h0O1xuICAgICAgICBnbC54QXhpc0xhYmVsc0hlaWdodCA9IHRoaXMueEF4aXNIZWlnaHQgLSB4dGl0bGVDb29yZHMuaGVpZ2h0O1xuICAgICAgICBnbC54QXhpc0dyb3VwTGFiZWxzSGVpZ2h0ID0gZ2wueEF4aXNMYWJlbHNIZWlnaHQgLSB4YXhpc0xhYmVsQ29vcmRzLmhlaWdodDtcbiAgICAgICAgZ2wueEF4aXNMYWJlbHNXaWR0aCA9IHRoaXMueEF4aXNXaWR0aDtcbiAgICAgICAgZ2wueEF4aXNIZWlnaHQgPSB0aGlzLnhBeGlzSGVpZ2h0O1xuICAgICAgICB2YXIgdHJhbnNsYXRlWSA9IDEwO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkYXInIHx8IHRoaXMuaXNTcGFya2xpbmUpIHtcbiAgICAgICAgICB5QXhpc1dpZHRoID0gMDtcbiAgICAgICAgICB4QXhpc0hlaWdodCA9IGdsLmdvbGRlblBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1NwYXJrbGluZSkge1xuICAgICAgICAgIHRoaXMubGdSZWN0ID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTcGFya2xpbmUgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3RyZWVtYXAnKSB7XG4gICAgICAgICAgeUF4aXNXaWR0aCA9IDA7XG4gICAgICAgICAgeEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICAgIHRyYW5zbGF0ZVkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzU3BhcmtsaW5lKSB7XG4gICAgICAgICAgdGhpcy5kaW1YQXhpcy5hZGRpdGlvbmFsUGFkZGluZ1hMYWJlbHMoeGF4aXNMYWJlbENvb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVnZW5kVG9wQm90dG9tID0gZnVuY3Rpb24gbGVnZW5kVG9wQm90dG9tKCkge1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSBfdGhpczIubGdSZWN0LmhlaWdodCAtIHhBeGlzSGVpZ2h0IC0gKCFfdGhpczIuaXNTcGFya2xpbmUgJiYgdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ3RyZWVtYXAnID8gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyAxMCA6IDE1IDogMCk7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSB5QXhpc1dpZHRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHRyYW5zbGF0ZVkgPSBnbC54QXhpc0hlaWdodCAtIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5oZWlnaHQgLSA1O1xuXG4gICAgICAgIHN3aXRjaCAody5jb25maWcubGVnZW5kLnBvc2l0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVZO1xuICAgICAgICAgICAgbGVnZW5kVG9wQm90dG9tKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBnbC50cmFuc2xhdGVZID0gdGhpcy5sZ1JlY3QuaGVpZ2h0ICsgdHJhbnNsYXRlWTtcbiAgICAgICAgICAgIGxlZ2VuZFRvcEJvdHRvbSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVZO1xuICAgICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IHRoaXMubGdSZWN0LndpZHRoICsgeUF4aXNXaWR0aDtcbiAgICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSB4QXhpc0hlaWdodCAtIDEyO1xuICAgICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSB0aGlzLmxnUmVjdC53aWR0aCAtIHlBeGlzV2lkdGg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVZO1xuICAgICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IHlBeGlzV2lkdGg7XG4gICAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0geEF4aXNIZWlnaHQgLSAxMjtcbiAgICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLnN2Z1dpZHRoIC0gdGhpcy5sZ1JlY3Qud2lkdGggLSB5QXhpc1dpZHRoIC0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGVnZW5kIHBvc2l0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGltR3JpZC5zZXRHcmlkWFBvc0ZvckR1YWxZQXhpcyh5VGl0bGVDb29yZHMsIHlheGlzTGFiZWxDb29yZHMpOyAvLyBhZnRlciBkcmF3aW5nIGV2ZXJ5dGhpbmcsIHNldCB0aGUgWSBheGlzIHBvc2l0aW9uc1xuXG4gICAgICAgIHZhciBvYmp5QXhpcyA9IG5ldyBZQXhpcyh0aGlzLmN0eCk7XG4gICAgICAgIG9ianlBeGlzLnNldFlBeGlzWFBvc2l0aW9uKHlheGlzTGFiZWxDb29yZHMsIHlUaXRsZUNvb3Jkcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldERpbWVuc2lvbnNGb3JOb25BeGlzQ2hhcnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGltZW5zaW9uc0Zvck5vbkF4aXNDaGFydHMoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICAgIHZhciBjbmYgPSB3LmNvbmZpZztcbiAgICAgICAgdmFyIHhQYWQgPSAwO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQuc2hvdyAmJiAhdy5jb25maWcubGVnZW5kLmZsb2F0aW5nKSB7XG4gICAgICAgICAgeFBhZCA9IDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSBjbmYuY2hhcnQudHlwZSA9PT0gJ3BpZScgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdwb2xhckFyZWEnIHx8IGNuZi5jaGFydC50eXBlID09PSAnZG9udXQnID8gJ3BpZScgOiAncmFkaWFsQmFyJztcbiAgICAgICAgdmFyIG9mZlkgPSBjbmYucGxvdE9wdGlvbnNbdHlwZV0ub2Zmc2V0WTtcbiAgICAgICAgdmFyIG9mZlggPSBjbmYucGxvdE9wdGlvbnNbdHlwZV0ub2Zmc2V0WDtcblxuICAgICAgICBpZiAoIWNuZi5sZWdlbmQuc2hvdyB8fCBjbmYubGVnZW5kLmZsb2F0aW5nKSB7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIGNuZi5ncmlkLnBhZGRpbmcubGVmdCArIGNuZi5ncmlkLnBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuZ3JpZEhlaWdodDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIChnbC5zdmdXaWR0aCAtIGdsLmdyaWRXaWR0aCkgLyAyO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoY25mLmxlZ2VuZC5wb3NpdGlvbikge1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0gdGhpcy5sZ1JlY3QuaGVpZ2h0IC0gZ2wuZ29sZGVuUGFkZGluZztcbiAgICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLnN2Z1dpZHRoO1xuICAgICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IG9mZlkgLSAxMDtcbiAgICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSBvZmZYICsgKGdsLnN2Z1dpZHRoIC0gZ2wuZ3JpZFdpZHRoKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0gdGhpcy5sZ1JlY3QuaGVpZ2h0IC0gZ2wuZ29sZGVuUGFkZGluZztcbiAgICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLnN2Z1dpZHRoO1xuICAgICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IHRoaXMubGdSZWN0LmhlaWdodCArIG9mZlkgKyAxMDtcbiAgICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSBvZmZYICsgKGdsLnN2Z1dpZHRoIC0gZ2wuZ3JpZFdpZHRoKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSB0aGlzLmxnUmVjdC53aWR0aCAtIHhQYWQ7XG4gICAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gY25mLmNoYXJ0LmhlaWdodCAhPT0gJ2F1dG8nID8gZ2wuc3ZnSGVpZ2h0IDogZ2wuZ3JpZFdpZHRoO1xuICAgICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IG9mZlk7XG4gICAgICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIHRoaXMubGdSZWN0LndpZHRoICsgeFBhZDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSB0aGlzLmxnUmVjdC53aWR0aCAtIHhQYWQgLSA1O1xuICAgICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGNuZi5jaGFydC5oZWlnaHQgIT09ICdhdXRvJyA/IGdsLnN2Z0hlaWdodCA6IGdsLmdyaWRXaWR0aDtcbiAgICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSBvZmZZO1xuICAgICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyAxMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGVnZW5kIHBvc2l0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb25kaXRpb25hbENoZWNrc0ZvckF4aXNDb29yZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25kaXRpb25hbENoZWNrc0ZvckF4aXNDb29yZHMoeGF4aXNMYWJlbENvb3JkcywgeHRpdGxlQ29vcmRzLCB4YXhpc0dyb3VwTGFiZWxDb29yZHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4QXhpc051bSA9IHcuZ2xvYmFscy5oYXNYYXhpc0dyb3VwcyA/IDIgOiAxO1xuICAgICAgICB2YXIgYmFzZVhBeGlzSGVpZ2h0ID0geGF4aXNHcm91cExhYmVsQ29vcmRzLmhlaWdodCArIHhheGlzTGFiZWxDb29yZHMuaGVpZ2h0ICsgeHRpdGxlQ29vcmRzLmhlaWdodDtcbiAgICAgICAgdmFyIHhBeGlzSGVpZ2h0TXVsdGlwbGljYXRlID0gdy5nbG9iYWxzLmlzTXVsdGlMaW5lWCA/IDEuMiA6IHcuZ2xvYmFscy5MSU5FX0hFSUdIVF9SQVRJTztcbiAgICAgICAgdmFyIHJvdGF0ZWRYQXhpc09mZnNldCA9IHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzID8gMjIgOiAxMDtcbiAgICAgICAgdmFyIHJvdGF0ZWRYQXhpc0xlZ2VuZE9mZnNldCA9IHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzICYmIHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsT2Zmc2V0ID0gcm90YXRlZFhBeGlzTGVnZW5kT2Zmc2V0ID8gMTAgOiAwO1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gYmFzZVhBeGlzSGVpZ2h0ICogeEF4aXNIZWlnaHRNdWx0aXBsaWNhdGUgKyB4QXhpc051bSAqIHJvdGF0ZWRYQXhpc09mZnNldCArIGFkZGl0aW9uYWxPZmZzZXQ7XG4gICAgICAgIHRoaXMueEF4aXNXaWR0aCA9IHhheGlzTGFiZWxDb29yZHMud2lkdGg7XG5cbiAgICAgICAgaWYgKHRoaXMueEF4aXNIZWlnaHQgLSB4dGl0bGVDb29yZHMuaGVpZ2h0ID4gdy5jb25maWcueGF4aXMubGFiZWxzLm1heEhlaWdodCkge1xuICAgICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMubWF4SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy5taW5IZWlnaHQgJiYgdGhpcy54QXhpc0hlaWdodCA8IHcuY29uZmlnLnhheGlzLmxhYmVscy5taW5IZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gdy5jb25maWcueGF4aXMubGFiZWxzLm1pbkhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5mbG9hdGluZykge1xuICAgICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbllBeGlzV2lkdGggPSAwO1xuICAgICAgICB2YXIgbWF4WUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIHcuY29uZmlnLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICBtaW5ZQXhpc1dpZHRoICs9IHkubGFiZWxzLm1pbldpZHRoO1xuICAgICAgICAgIG1heFlBeGlzV2lkdGggKz0geS5sYWJlbHMubWF4V2lkdGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLnlBeGlzV2lkdGggPCBtaW5ZQXhpc1dpZHRoKSB7XG4gICAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gbWluWUF4aXNXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnlBeGlzV2lkdGggPiBtYXhZQXhpc1dpZHRoKSB7XG4gICAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gbWF4WUF4aXNXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEaW1lbnNpb25zO1xuICB9KCk7XG5cbiAgdmFyIEhlbHBlcnMkMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVscGVycyhsZ0N0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlbHBlcnMpO1xuXG4gICAgICB0aGlzLncgPSBsZ0N0eC53O1xuICAgICAgdGhpcy5sZ0N0eCA9IGxnQ3R4O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhIZWxwZXJzLCBbe1xuICAgICAga2V5OiBcImdldExlZ2VuZFN0eWxlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlZ2VuZFN0eWxlcygpIHtcbiAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZXNoZWV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgICB2YXIgdGV4dCA9IFwiXFx0XFxuICAgIFxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZCB7XFx0XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcdFxcbiAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFx0XFxuICAgICAgICBwYWRkaW5nOiAwIDEwcHg7XFx0XFxuICAgICAgfVxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5hcHgtbGVnZW5kLXBvc2l0aW9uLWJvdHRvbSwgLmFwZXhjaGFydHMtbGVnZW5kLmFweC1sZWdlbmQtcG9zaXRpb24tdG9wIHtcXHRcXG4gICAgICAgIGZsZXgtd3JhcDogd3JhcFxcdFxcbiAgICAgIH1cXHRcXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQuYXB4LWxlZ2VuZC1wb3NpdGlvbi1yaWdodCwgLmFwZXhjaGFydHMtbGVnZW5kLmFweC1sZWdlbmQtcG9zaXRpb24tbGVmdCB7XFx0XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcdFxcbiAgICAgICAgYm90dG9tOiAwO1xcdFxcbiAgICAgIH1cXHRcXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQuYXB4LWxlZ2VuZC1wb3NpdGlvbi1ib3R0b20uYXBleGNoYXJ0cy1hbGlnbi1sZWZ0LCAuYXBleGNoYXJ0cy1sZWdlbmQuYXB4LWxlZ2VuZC1wb3NpdGlvbi10b3AuYXBleGNoYXJ0cy1hbGlnbi1sZWZ0LCAuYXBleGNoYXJ0cy1sZWdlbmQuYXB4LWxlZ2VuZC1wb3NpdGlvbi1yaWdodCwgLmFwZXhjaGFydHMtbGVnZW5kLmFweC1sZWdlbmQtcG9zaXRpb24tbGVmdCB7XFx0XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFx0XFxuICAgICAgfVxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5hcHgtbGVnZW5kLXBvc2l0aW9uLWJvdHRvbS5hcGV4Y2hhcnRzLWFsaWduLWNlbnRlciwgLmFwZXhjaGFydHMtbGVnZW5kLmFweC1sZWdlbmQtcG9zaXRpb24tdG9wLmFwZXhjaGFydHMtYWxpZ24tY2VudGVyIHtcXHRcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyAgXFx0XFxuICAgICAgfVxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5hcHgtbGVnZW5kLXBvc2l0aW9uLWJvdHRvbS5hcGV4Y2hhcnRzLWFsaWduLXJpZ2h0LCAuYXBleGNoYXJ0cy1sZWdlbmQuYXB4LWxlZ2VuZC1wb3NpdGlvbi10b3AuYXBleGNoYXJ0cy1hbGlnbi1yaWdodCB7XFx0XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcdFxcbiAgICAgIH1cXHRcXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzIHtcXHRcXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXHRcXG4gICAgICAgIGxpbmUtaGVpZ2h0OiBub3JtYWw7XFx0XFxuICAgICAgfVxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5hcHgtbGVnZW5kLXBvc2l0aW9uLWJvdHRvbSAuYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzLCAuYXBleGNoYXJ0cy1sZWdlbmQuYXB4LWxlZ2VuZC1wb3NpdGlvbi10b3AgLmFwZXhjaGFydHMtbGVnZW5kLXNlcmllc3tcXHRcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFx0XFxuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcdFxcbiAgICAgIH1cXHRcXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQtdGV4dCB7XFx0XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFx0XFxuICAgICAgICBmb250LXNpemU6IDE0cHg7XFx0XFxuICAgICAgfVxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0ICosIC5hcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXIgKiB7XFx0XFxuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHRcXG4gICAgICB9XFx0XFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLW1hcmtlciB7XFx0XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFx0XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFx0XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFx0XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXHRcXG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgICAgfVxcdFxcbiAgICAgIFxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5hcGV4Y2hhcnRzLWFsaWduLXJpZ2h0IC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5hcGV4Y2hhcnRzLWFsaWduLWxlZnQgLmFwZXhjaGFydHMtbGVnZW5kLXNlcmllc3tcXHRcXG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHRcXG4gICAgICB9XFx0XFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLXNlcmllcy5hcGV4Y2hhcnRzLW5vLWNsaWNrIHtcXHRcXG4gICAgICAgIGN1cnNvcjogYXV0bztcXHRcXG4gICAgICB9XFx0XFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kIC5hcGV4Y2hhcnRzLWhpZGRlbi16ZXJvLXNlcmllcywgLmFwZXhjaGFydHMtbGVnZW5kIC5hcGV4Y2hhcnRzLWhpZGRlbi1udWxsLXNlcmllcyB7XFx0XFxuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFx0XFxuICAgICAgfVxcdFxcbiAgICAgIC5hcGV4Y2hhcnRzLWluYWN0aXZlLWxlZ2VuZCB7XFx0XFxuICAgICAgICBvcGFjaXR5OiAwLjQ1O1xcdFxcbiAgICAgIH1cIjtcbiAgICAgICAgdmFyIHJ1bGVzID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHN0eWxlc2hlZXQuYXBwZW5kQ2hpbGQocnVsZXMpO1xuICAgICAgICByZXR1cm4gc3R5bGVzaGVldDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TGVnZW5kQkJveFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlZ2VuZEJCb3goKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgY3VyckxlZ2VuZHNXcmFwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbGVnZW5kJyk7XG4gICAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXBSZWN0ID0gY3VyckxlZ2VuZHNXcmFwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY3VyckxlZ2VuZHNXcmFwV2lkdGggPSBjdXJyTGVnZW5kc1dyYXBSZWN0LndpZHRoO1xuICAgICAgICB2YXIgY3VyckxlZ2VuZHNXcmFwSGVpZ2h0ID0gY3VyckxlZ2VuZHNXcmFwUmVjdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2x3aDogY3VyckxlZ2VuZHNXcmFwSGVpZ2h0LFxuICAgICAgICAgIGNsd3c6IGN1cnJMZWdlbmRzV3JhcFdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFwcGVuZFRvRm9yZWlnbk9iamVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFRvRm9yZWlnbk9iamVjdCgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIGdsLmRvbS5lbExlZ2VuZEZvcmVpZ24uYXBwZW5kQ2hpbGQodGhpcy5nZXRMZWdlbmRTdHlsZXMoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRvZ2dsZURhdGFTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVEYXRhU2VyaWVzKHNlcmllc0NudCwgaXNIaWRkZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGlhbEJhcicpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMucmVzaXplZCA9IHRydWU7IC8vIHdlIGRvbid0IHdhbnQgaW5pdGlhbCBhbmltYXRpb25zIGFnYWluXG5cbiAgICAgICAgICB2YXIgc2VyaWVzRWwgPSBudWxsO1xuICAgICAgICAgIHZhciByZWFsSW5kZXggPSBudWxsOyAvLyB5ZXMsIG1ha2UgaXQgbnVsbC4gMSBzZXJpZXMgd2lsbCByaXNlIGF0IGEgdGltZVxuXG4gICAgICAgICAgdy5nbG9iYWxzLnJpc2luZ1NlcmllcyA9IFtdO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICBzZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoc2VyaWVzQ250LCBcIiddXCIpKTtcbiAgICAgICAgICAgIHJlYWxJbmRleCA9IHBhcnNlSW50KHNlcmllc0VsLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSwgMTApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIi5jb25jYXQoc2VyaWVzQ250ICsgMSwgXCInXVwiKSk7XG4gICAgICAgICAgICByZWFsSW5kZXggPSBwYXJzZUludChzZXJpZXNFbC5nZXRBdHRyaWJ1dGUoJ3JlbCcpLCAxMCkgLSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgdmFyIHNlcmllc1RvTWFrZVZpc2libGUgPSBbe1xuICAgICAgICAgICAgICBjczogdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcyxcbiAgICAgICAgICAgICAgY3NpOiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlc1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBjczogdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcyxcbiAgICAgICAgICAgICAgY3NpOiB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlc1xuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBzZXJpZXNUb01ha2VWaXNpYmxlLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgX3RoaXMucmlzZUNvbGxhcHNlZFNlcmllcyhyLmNzLCByLmNzaSwgcmVhbEluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVTZXJpZXMoe1xuICAgICAgICAgICAgICBzZXJpZXNFbDogc2VyaWVzRWwsXG4gICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9yIG5vbi1heGlzIGNoYXJ0cyBpLmUgcGllIC8gZG9udXRzXG4gICAgICAgICAgdmFyIF9zZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiIC5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChzZXJpZXNDbnQgKyAxLCBcIiddIHBhdGhcIikpO1xuXG4gICAgICAgICAgdmFyIHR5cGUgPSB3LmNvbmZpZy5jaGFydC50eXBlO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdwaWUnIHx8IHR5cGUgPT09ICdwb2xhckFyZWEnIHx8IHR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICAgIHZhciBkYXRhTGFiZWxzID0gdy5jb25maWcucGxvdE9wdGlvbnMucGllLmRvbnV0LmxhYmVscztcbiAgICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmxnQ3R4LmN0eCk7XG4gICAgICAgICAgICBncmFwaGljcy5wYXRoTW91c2VEb3duKF9zZXJpZXNFbC5tZW1iZXJzWzBdLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMubGdDdHguY3R4LnBpZS5wcmludERhdGFMYWJlbHNJbm5lcihfc2VyaWVzRWwubWVtYmVyc1swXS5ub2RlLCBkYXRhTGFiZWxzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2VyaWVzRWwuZmlyZSgnY2xpY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoaWRlU2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZVNlcmllcyhfcmVmKSB7XG4gICAgICAgIHZhciBzZXJpZXNFbCA9IF9yZWYuc2VyaWVzRWwsXG4gICAgICAgICAgICByZWFsSW5kZXggPSBfcmVmLnJlYWxJbmRleDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBzZXJpZXMgPSBVdGlscyQxLmNsb25lKHcuY29uZmlnLnNlcmllcyk7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgdmFyIHNob3VsZE5vdEhpZGVZQXhpcyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0gJiYgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5zaG93ICYmIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0uc2hvd0Fsd2F5cykge1xuICAgICAgICAgICAgc2hvdWxkTm90SGlkZVlBeGlzID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YocmVhbEluZGV4KSA8IDApIHtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IHNlcmllc1tyZWFsSW5kZXhdLmRhdGEuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBzZXJpZXNFbC5wYXJlbnROb2RlLmNsYXNzTmFtZS5iYXNlVmFsLnNwbGl0KCctJylbMV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLnB1c2gocmVhbEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXNob3VsZE5vdEhpZGVZQXhpcykge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgaW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgZGF0YTogc2VyaWVzW3JlYWxJbmRleF0uZGF0YS5zbGljZSgpLFxuICAgICAgICAgICAgICB0eXBlOiBzZXJpZXNFbC5wYXJlbnROb2RlLmNsYXNzTmFtZS5iYXNlVmFsLnNwbGl0KCctJylbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4T2ZSaXNpbmcgPSB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzLmluZGV4T2YocmVhbEluZGV4KTtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMuc3BsaWNlKHJlbW92ZUluZGV4T2ZSaXNpbmcsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGRhdGE6IHNlcmllc1tyZWFsSW5kZXhdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlcmllc0NoaWxkcmVuID0gc2VyaWVzRWwuY2hpbGROb2RlcztcblxuICAgICAgICBmb3IgKHZhciBzYyA9IDA7IHNjIDwgc2VyaWVzQ2hpbGRyZW4ubGVuZ3RoOyBzYysrKSB7XG4gICAgICAgICAgaWYgKHNlcmllc0NoaWxkcmVuW3NjXS5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCcpKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzQ2hpbGRyZW5bc2NdLmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1oaWRlJykpIHtcbiAgICAgICAgICAgICAgc2VyaWVzQ2hpbGRyZW5bc2NdLmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtaGlkZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VyaWVzQ2hpbGRyZW5bc2NdLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtaGlkZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA9PT0gdy5jb25maWcuc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgc2VyaWVzID0gdGhpcy5fZ2V0U2VyaWVzQmFzZWRPbkNvbGxhcHNlZFN0YXRlKHNlcmllcyk7XG5cbiAgICAgICAgdGhpcy5sZ0N0eC5jdHgudXBkYXRlSGVscGVycy5fdXBkYXRlU2VyaWVzKHNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyaXNlQ29sbGFwc2VkU2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmlzZUNvbGxhcHNlZFNlcmllcyhjb2xsYXBzZWRTZXJpZXMsIHNlcmllc0luZGljZXMsIHJlYWxJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHNlcmllcyA9IFV0aWxzJDEuY2xvbmUody5jb25maWcuc2VyaWVzKTtcblxuICAgICAgICBpZiAoY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbGxhcHNlZFNlcmllcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgaWYgKGNvbGxhcHNlZFNlcmllc1tjXS5pbmRleCA9PT0gcmVhbEluZGV4KSB7XG4gICAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgICAgIHNlcmllc1tyZWFsSW5kZXhdLmRhdGEgPSBjb2xsYXBzZWRTZXJpZXNbY10uZGF0YS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbGxhcHNlZFNlcmllcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kaWNlcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgICAgdy5nbG9iYWxzLnJpc2luZ1Nlcmllcy5wdXNoKHJlYWxJbmRleCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzW3JlYWxJbmRleF0gPSBjb2xsYXBzZWRTZXJpZXNbY10uZGF0YTtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWRTZXJpZXMuc3BsaWNlKGMsIDEpO1xuICAgICAgICAgICAgICAgIHNlcmllc0luZGljZXMuc3BsaWNlKGMsIDEpO1xuICAgICAgICAgICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VyaWVzID0gdGhpcy5fZ2V0U2VyaWVzQmFzZWRPbkNvbGxhcHNlZFN0YXRlKHNlcmllcyk7XG5cbiAgICAgICAgICB0aGlzLmxnQ3R4LmN0eC51cGRhdGVIZWxwZXJzLl91cGRhdGVTZXJpZXMoc2VyaWVzLCB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldFNlcmllc0Jhc2VkT25Db2xsYXBzZWRTdGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZXJpZXNCYXNlZE9uQ29sbGFwc2VkU3RhdGUoc2VyaWVzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgIHNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBzSSkge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2Yoc0kpID4gLTEpIHtcbiAgICAgICAgICAgICAgc2VyaWVzW3NJXS5kYXRhID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMsIHNJKSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihzSSkgPiAtMSkge1xuICAgICAgICAgICAgICBzZXJpZXNbc0ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXJpZXM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEhlbHBlcnM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBMZWdlbmQgQ2xhc3MgdG8gZHJhdyBsZWdlbmQuXG4gICAqXG4gICAqIEBtb2R1bGUgTGVnZW5kXG4gICAqKi9cblxuICB2YXIgTGVnZW5kID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZWdlbmQoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGVnZW5kKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMub25MZWdlbmRDbGljayA9IHRoaXMub25MZWdlbmRDbGljay5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbkxlZ2VuZEhvdmVyZWQgPSB0aGlzLm9uTGVnZW5kSG92ZXJlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5pc0JhcnNEaXN0cmlidXRlZCA9IHRoaXMudy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGlzdHJpYnV0ZWQgJiYgdGhpcy53LmNvbmZpZy5zZXJpZXMubGVuZ3RoID09PSAxO1xuICAgICAgdGhpcy5sZWdlbmRIZWxwZXJzID0gbmV3IEhlbHBlcnMkMih0aGlzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTGVnZW5kLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICAgIHZhciBzaG93TGVnZW5kQWx3YXlzID0gY25mLmxlZ2VuZC5zaG93Rm9yU2luZ2xlU2VyaWVzICYmIGdsLnNlcmllcy5sZW5ndGggPT09IDEgfHwgdGhpcy5pc0JhcnNEaXN0cmlidXRlZCB8fCBnbC5zZXJpZXMubGVuZ3RoID4gMTtcblxuICAgICAgICBpZiAoKHNob3dMZWdlbmRBbHdheXMgfHwgIWdsLmF4aXNDaGFydHMpICYmIGNuZi5sZWdlbmQuc2hvdykge1xuICAgICAgICAgIHdoaWxlIChnbC5kb20uZWxMZWdlbmRXcmFwLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAucmVtb3ZlQ2hpbGQoZ2wuZG9tLmVsTGVnZW5kV3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRyYXdMZWdlbmRzKCk7XG5cbiAgICAgICAgICBpZiAoIVV0aWxzJDEuaXNJRTExKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kSGVscGVycy5hcHBlbmRUb0ZvcmVpZ25PYmplY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnRzIGZvcmVpZ25PYmplY3QsIGhlbmNlIGFwcGVuZCBpdCB0byA8aGVhZD5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQodGhpcy5sZWdlbmRIZWxwZXJzLmdldExlZ2VuZFN0eWxlcygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kQWxpZ25Ib3Jpem9udGFsKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbmYubGVnZW5kLnBvc2l0aW9uID09PSAncmlnaHQnIHx8IGNuZi5sZWdlbmQucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgdGhpcy5sZWdlbmRBbGlnblZlcnRpY2FsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdMZWdlbmRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xlZ2VuZHMoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZm9udEZhbWlseSA9IHcuY29uZmlnLmxlZ2VuZC5mb250RmFtaWx5O1xuICAgICAgICB2YXIgbGVnZW5kTmFtZXMgPSB3Lmdsb2JhbHMuc2VyaWVzTmFtZXM7XG4gICAgICAgIHZhciBmaWxsY29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICAgIHZhciByYW5nZXMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5oZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzO1xuICAgICAgICAgIGxlZ2VuZE5hbWVzID0gcmFuZ2VzLm1hcChmdW5jdGlvbiAoY29sb3JTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yU2NhbGUubmFtZSA/IGNvbG9yU2NhbGUubmFtZSA6IGNvbG9yU2NhbGUuZnJvbSArICcgLSAnICsgY29sb3JTY2FsZS50bztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmaWxsY29sb3IgPSByYW5nZXMubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmNvbG9yO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNCYXJzRGlzdHJpYnV0ZWQpIHtcbiAgICAgICAgICBsZWdlbmROYW1lcyA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQuY3VzdG9tTGVnZW5kSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbGVnZW5kTmFtZXMgPSB3LmNvbmZpZy5sZWdlbmQuY3VzdG9tTGVnZW5kSXRlbXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVnZW5kRm9ybWF0dGVyID0gdy5nbG9iYWxzLmxlZ2VuZEZvcm1hdHRlcjtcbiAgICAgICAgdmFyIGlzTGVnZW5kSW52ZXJzZWQgPSB3LmNvbmZpZy5sZWdlbmQuaW52ZXJzZU9yZGVyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBpc0xlZ2VuZEludmVyc2VkID8gbGVnZW5kTmFtZXMubGVuZ3RoIC0gMSA6IDA7IGlzTGVnZW5kSW52ZXJzZWQgPyBpID49IDAgOiBpIDw9IGxlZ2VuZE5hbWVzLmxlbmd0aCAtIDE7IGlzTGVnZW5kSW52ZXJzZWQgPyBpLS0gOiBpKyspIHtcbiAgICAgICAgICB2YXIgX3ckY29uZmlnJGxlZ2VuZCRsYWJlO1xuXG4gICAgICAgICAgdmFyIHRleHQgPSBsZWdlbmRGb3JtYXR0ZXIobGVnZW5kTmFtZXNbaV0sIHtcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjb2xsYXBzZWRTZXJpZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNbY10uaW5kZXggPT09IGkpIHtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWRTZXJpZXMgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gMDsgX2MgPCB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzW19jXSA9PT0gaSkge1xuICAgICAgICAgICAgICAgIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZWxNYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgZWxNYXJrZXIuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1sZWdlbmQtbWFya2VyJyk7XG4gICAgICAgICAgdmFyIG1PZmZzZXRYID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMub2Zmc2V0WDtcbiAgICAgICAgICB2YXIgbU9mZnNldFkgPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5vZmZzZXRZO1xuICAgICAgICAgIHZhciBtSGVpZ2h0ID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMuaGVpZ2h0O1xuICAgICAgICAgIHZhciBtV2lkdGggPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy53aWR0aDtcbiAgICAgICAgICB2YXIgbUJvcmRlcldpZHRoID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgdmFyIG1Cb3JkZXJDb2xvciA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLnN0cm9rZUNvbG9yO1xuICAgICAgICAgIHZhciBtQm9yZGVyUmFkaXVzID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMucmFkaXVzO1xuICAgICAgICAgIHZhciBtU3R5bGUgPSBlbE1hcmtlci5zdHlsZTtcbiAgICAgICAgICBtU3R5bGUuYmFja2dyb3VuZCA9IGZpbGxjb2xvcltpXTtcbiAgICAgICAgICBtU3R5bGUuY29sb3IgPSBmaWxsY29sb3JbaV07XG4gICAgICAgICAgbVN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kJywgZmlsbGNvbG9yW2ldLCAnaW1wb3J0YW50Jyk7IC8vIG92ZXJyaWRlIGZpbGwgY29sb3Igd2l0aCBjdXN0b20gbGVnZW5kLm1hcmtlcnMuZmlsbENvbG9yc1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLmZpbGxDb2xvcnMgJiYgdy5jb25maWcubGVnZW5kLm1hcmtlcnMuZmlsbENvbG9yc1tpXSkge1xuICAgICAgICAgICAgbVN0eWxlLmJhY2tncm91bmQgPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5maWxsQ29sb3JzW2ldO1xuICAgICAgICAgIH0gLy8gb3ZlcnJpZGUgd2l0aCBkYXRhIGNvbG9yXG5cblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzQ29sb3JzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1TdHlsZS5iYWNrZ3JvdW5kID0gdy5nbG9iYWxzLnNlcmllc0NvbG9yc1tpXTtcbiAgICAgICAgICAgIG1TdHlsZS5jb2xvciA9IHcuZ2xvYmFscy5zZXJpZXNDb2xvcnNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbVN0eWxlLmhlaWdodCA9IEFycmF5LmlzQXJyYXkobUhlaWdodCkgPyBwYXJzZUZsb2F0KG1IZWlnaHRbaV0pICsgJ3B4JyA6IHBhcnNlRmxvYXQobUhlaWdodCkgKyAncHgnO1xuICAgICAgICAgIG1TdHlsZS53aWR0aCA9IEFycmF5LmlzQXJyYXkobVdpZHRoKSA/IHBhcnNlRmxvYXQobVdpZHRoW2ldKSArICdweCcgOiBwYXJzZUZsb2F0KG1XaWR0aCkgKyAncHgnO1xuICAgICAgICAgIG1TdHlsZS5sZWZ0ID0gKEFycmF5LmlzQXJyYXkobU9mZnNldFgpID8gcGFyc2VGbG9hdChtT2Zmc2V0WFtpXSkgOiBwYXJzZUZsb2F0KG1PZmZzZXRYKSkgKyAncHgnO1xuICAgICAgICAgIG1TdHlsZS50b3AgPSAoQXJyYXkuaXNBcnJheShtT2Zmc2V0WSkgPyBwYXJzZUZsb2F0KG1PZmZzZXRZW2ldKSA6IHBhcnNlRmxvYXQobU9mZnNldFkpKSArICdweCc7XG4gICAgICAgICAgbVN0eWxlLmJvcmRlcldpZHRoID0gQXJyYXkuaXNBcnJheShtQm9yZGVyV2lkdGgpID8gbUJvcmRlcldpZHRoW2ldIDogbUJvcmRlcldpZHRoO1xuICAgICAgICAgIG1TdHlsZS5ib3JkZXJDb2xvciA9IEFycmF5LmlzQXJyYXkobUJvcmRlckNvbG9yKSA/IG1Cb3JkZXJDb2xvcltpXSA6IG1Cb3JkZXJDb2xvcjtcbiAgICAgICAgICBtU3R5bGUuYm9yZGVyUmFkaXVzID0gQXJyYXkuaXNBcnJheShtQm9yZGVyUmFkaXVzKSA/IHBhcnNlRmxvYXQobUJvcmRlclJhZGl1c1tpXSkgKyAncHgnIDogcGFyc2VGbG9hdChtQm9yZGVyUmFkaXVzKSArICdweCc7XG5cbiAgICAgICAgICBpZiAody5jb25maWcubGVnZW5kLm1hcmtlcnMuY3VzdG9tSFRNTCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcubGVnZW5kLm1hcmtlcnMuY3VzdG9tSFRNTCkpIHtcbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLmN1c3RvbUhUTUxbaV0pIHtcbiAgICAgICAgICAgICAgICBlbE1hcmtlci5pbm5lckhUTUwgPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5jdXN0b21IVE1MW2ldKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsTWFya2VyLmlubmVySFRNTCA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLmN1c3RvbUhUTUwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbE1hcmtlciwge1xuICAgICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAgICdkYXRhOmNvbGxhcHNlZCc6IGNvbGxhcHNlZFNlcmllcyB8fCBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjb2xsYXBzZWRTZXJpZXMgfHwgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzKSB7XG4gICAgICAgICAgICBlbE1hcmtlci5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWluYWN0aXZlLWxlZ2VuZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbExlZ2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHZhciBlbExlZ2VuZFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgZWxMZWdlbmRUZXh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbGVnZW5kLXRleHQnKTtcbiAgICAgICAgICBlbExlZ2VuZFRleHQuaW5uZXJIVE1MID0gQXJyYXkuaXNBcnJheSh0ZXh0KSA/IHRleHQuam9pbignICcpIDogdGV4dDtcbiAgICAgICAgICB2YXIgdGV4dENvbG9yID0gdy5jb25maWcubGVnZW5kLmxhYmVscy51c2VTZXJpZXNDb2xvcnMgPyB3Lmdsb2JhbHMuY29sb3JzW2ldIDogQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5sZWdlbmQubGFiZWxzLmNvbG9ycykgPyAoX3ckY29uZmlnJGxlZ2VuZCRsYWJlID0gdy5jb25maWcubGVnZW5kLmxhYmVscy5jb2xvcnMpID09PSBudWxsIHx8IF93JGNvbmZpZyRsZWdlbmQkbGFiZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ckY29uZmlnJGxlZ2VuZCRsYWJlW2ldIDogdy5jb25maWcubGVnZW5kLmxhYmVscy5jb2xvcnM7XG5cbiAgICAgICAgICBpZiAoIXRleHRDb2xvcikge1xuICAgICAgICAgICAgdGV4dENvbG9yID0gdy5jb25maWcuY2hhcnQuZm9yZUNvbG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsTGVnZW5kVGV4dC5zdHlsZS5jb2xvciA9IHRleHRDb2xvcjtcbiAgICAgICAgICBlbExlZ2VuZFRleHQuc3R5bGUuZm9udFNpemUgPSBwYXJzZUZsb2F0KHcuY29uZmlnLmxlZ2VuZC5mb250U2l6ZSkgKyAncHgnO1xuICAgICAgICAgIGVsTGVnZW5kVGV4dC5zdHlsZS5mb250V2VpZ2h0ID0gdy5jb25maWcubGVnZW5kLmZvbnRXZWlnaHQ7XG4gICAgICAgICAgZWxMZWdlbmRUZXh0LnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxMZWdlbmRUZXh0LCB7XG4gICAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICdkYXRhOmRlZmF1bHQtdGV4dCc6IGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSxcbiAgICAgICAgICAgICdkYXRhOmNvbGxhcHNlZCc6IGNvbGxhcHNlZFNlcmllcyB8fCBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbExlZ2VuZC5hcHBlbmRDaGlsZChlbE1hcmtlcik7XG4gICAgICAgICAgZWxMZWdlbmQuYXBwZW5kQ2hpbGQoZWxMZWdlbmRUZXh0KTtcbiAgICAgICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICBpZiAoIXcuY29uZmlnLmxlZ2VuZC5zaG93Rm9yWmVyb1Nlcmllcykge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gY29yZVV0aWxzLmdldFNlcmllc1RvdGFsQnlJbmRleChpKTtcblxuICAgICAgICAgICAgaWYgKHRvdGFsID09PSAwICYmIGNvcmVVdGlscy5zZXJpZXNIYXZlU2FtZVZhbHVlcyhpKSAmJiAhY29yZVV0aWxzLmlzU2VyaWVzTnVsbChpKSAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSAmJiB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgICBlbExlZ2VuZC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWhpZGRlbi16ZXJvLXNlcmllcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdy5jb25maWcubGVnZW5kLnNob3dGb3JOdWxsU2VyaWVzKSB7XG4gICAgICAgICAgICBpZiAoY29yZVV0aWxzLmlzU2VyaWVzTnVsbChpKSAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSAmJiB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgICBlbExlZ2VuZC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWhpZGRlbi1udWxsLXNlcmllcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLmFwcGVuZENoaWxkKGVsTGVnZW5kKTtcbiAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsTGVnZW5kV3JhcC5jbGFzc0xpc3QuYWRkKFwiYXBleGNoYXJ0cy1hbGlnbi1cIi5jb25jYXQody5jb25maWcubGVnZW5kLmhvcml6b250YWxBbGlnbikpO1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLmNsYXNzTGlzdC5hZGQoJ2FweC1sZWdlbmQtcG9zaXRpb24tJyArIHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbik7XG4gICAgICAgICAgZWxMZWdlbmQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzJyk7XG4gICAgICAgICAgZWxMZWdlbmQuc3R5bGUubWFyZ2luID0gXCJcIi5jb25jYXQody5jb25maWcubGVnZW5kLml0ZW1NYXJnaW4udmVydGljYWwsIFwicHggXCIpLmNvbmNhdCh3LmNvbmZpZy5sZWdlbmQuaXRlbU1hcmdpbi5ob3Jpem9udGFsLCBcInB4XCIpO1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLnN0eWxlLndpZHRoID0gdy5jb25maWcubGVnZW5kLndpZHRoID8gdy5jb25maWcubGVnZW5kLndpZHRoICsgJ3B4JyA6ICcnO1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLnN0eWxlLmhlaWdodCA9IHcuY29uZmlnLmxlZ2VuZC5oZWlnaHQgPyB3LmNvbmZpZy5sZWdlbmQuaGVpZ2h0ICsgJ3B4JyA6ICcnO1xuICAgICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsTGVnZW5kLCB7XG4gICAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogVXRpbHMkMS5lc2NhcGVTdHJpbmcobGVnZW5kTmFtZXNbaV0pLFxuICAgICAgICAgICAgJ2RhdGE6Y29sbGFwc2VkJzogY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNvbGxhcHNlZFNlcmllcyB8fCBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMpIHtcbiAgICAgICAgICAgIGVsTGVnZW5kLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtaW5hY3RpdmUtbGVnZW5kJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF3LmNvbmZpZy5sZWdlbmQub25JdGVtQ2xpY2sudG9nZ2xlRGF0YVNlcmllcykge1xuICAgICAgICAgICAgZWxMZWdlbmQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1uby1jbGljaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxXcmFwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbWUub25MZWdlbmRDbGljaywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5vbkl0ZW1Ib3Zlci5oaWdobGlnaHREYXRhU2VyaWVzICYmIHcuY29uZmlnLmxlZ2VuZC5jdXN0b21MZWdlbmRJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtZS5vbkxlZ2VuZEhvdmVyZWQsIHRydWUpO1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxXcmFwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgbWUub25MZWdlbmRIb3ZlcmVkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRMZWdlbmRXcmFwWFlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZWdlbmRXcmFwWFkob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGVsTGVnZW5kV3JhcCA9IHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwO1xuICAgICAgICB2YXIgbGVnZW5kUmVjdCA9IGVsTGVnZW5kV3JhcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB5ID0geSArICh3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC0gbGVnZW5kUmVjdC5oZWlnaHQgLyAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgdmFyIGRpbSA9IG5ldyBEaW1lbnNpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgICB2YXIgdGl0bGVIID0gZGltLmRpbUhlbHBlcnMuZ2V0VGl0bGVTdWJ0aXRsZUNvb3JkcygndGl0bGUnKS5oZWlnaHQ7XG4gICAgICAgICAgdmFyIHN1YnRpdGxlSCA9IGRpbS5kaW1IZWxwZXJzLmdldFRpdGxlU3VidGl0bGVDb29yZHMoJ3N1YnRpdGxlJykuaGVpZ2h0O1xuICAgICAgICAgIHkgPSB5ICsgKHRpdGxlSCA+IDAgPyB0aXRsZUggLSAxMCA6IDApICsgKHN1YnRpdGxlSCA+IDAgPyBzdWJ0aXRsZUggLSAxMCA6IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgeCA9IHggKyBvZmZzZXRYICsgdy5jb25maWcubGVnZW5kLm9mZnNldFg7XG4gICAgICAgIHkgPSB5ICsgb2Zmc2V0WSArIHcuY29uZmlnLmxlZ2VuZC5vZmZzZXRZO1xuICAgICAgICBlbExlZ2VuZFdyYXAuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICBlbExlZ2VuZFdyYXAuc3R5bGUudG9wID0geSArICdweCc7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBlbExlZ2VuZFdyYXAuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5ib3R0b20gPSA1IC0gdy5jb25maWcubGVnZW5kLm9mZnNldFkgKyAncHgnO1xuICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5yaWdodCA9IDI1ICsgdy5jb25maWcubGVnZW5kLm9mZnNldFggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpeGVkSGVpZ3RoV2lkdGggPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuICAgICAgICBmaXhlZEhlaWd0aFdpZHRoLmZvckVhY2goZnVuY3Rpb24gKGh3KSB7XG4gICAgICAgICAgaWYgKGVsTGVnZW5kV3JhcC5zdHlsZVtod10pIHtcbiAgICAgICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZVtod10gPSBwYXJzZUludCh3LmNvbmZpZy5sZWdlbmRbaHddLCAxMCkgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxlZ2VuZEFsaWduSG9yaXpvbnRhbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlZ2VuZEFsaWduSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBlbExlZ2VuZFdyYXAgPSB3Lmdsb2JhbHMuZG9tLmVsTGVnZW5kV3JhcDtcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGxSZWN0ID0gdGhpcy5sZWdlbmRIZWxwZXJzLmdldExlZ2VuZEJCb3goKTtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB0aXRsZVJlY3QgPSBkaW1lbnNpb25zLmRpbUhlbHBlcnMuZ2V0VGl0bGVTdWJ0aXRsZUNvb3JkcygndGl0bGUnKTtcbiAgICAgICAgdmFyIHN1YnRpdGxlUmVjdCA9IGRpbWVuc2lvbnMuZGltSGVscGVycy5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCdzdWJ0aXRsZScpO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IDIwO1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IDA7IC8vIHRoZSB3aG9sZSBsZWdlbmQgYm94IGlzIHNldCB0byBib3R0b21cblxuICAgICAgICBpZiAody5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgIG9mZnNldFkgPSAtbFJlY3QuY2x3aCAvIDEuODtcbiAgICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgb2Zmc2V0WSA9IHRpdGxlUmVjdC5oZWlnaHQgKyBzdWJ0aXRsZVJlY3QuaGVpZ2h0ICsgdy5jb25maWcudGl0bGUubWFyZ2luICsgdy5jb25maWcuc3VidGl0bGUubWFyZ2luIC0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldExlZ2VuZFdyYXBYWShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGVnZW5kQWxpZ25WZXJ0aWNhbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlZ2VuZEFsaWduVmVydGljYWwoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbFJlY3QgPSB0aGlzLmxlZ2VuZEhlbHBlcnMuZ2V0TGVnZW5kQkJveCgpO1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IDIwO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgb2Zmc2V0WCA9IDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIG9mZnNldFggPSB3Lmdsb2JhbHMuc3ZnV2lkdGggLSBsUmVjdC5jbHd3IC0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldExlZ2VuZFdyYXBYWShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib25MZWdlbmRIb3ZlcmVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25MZWdlbmRIb3ZlcmVkKGUpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBob3Zlck92ZXJMZWdlbmQgPSBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLXNlcmllcycpIHx8IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1sZWdlbmQtdGV4dCcpIHx8IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1sZWdlbmQtbWFya2VyJyk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdoZWF0bWFwJyAmJiAhdGhpcy5pc0JhcnNEaXN0cmlidXRlZCkge1xuICAgICAgICAgIGlmICghZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWluYWN0aXZlLWxlZ2VuZCcpICYmIGhvdmVyT3ZlckxlZ2VuZCkge1xuICAgICAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgICAgICAgc2VyaWVzLnRvZ2dsZVNlcmllc09uSG92ZXIoZSwgZS50YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmb3IgaGVhdG1hcCBoYW5kbGluZ1xuICAgICAgICAgIGlmIChob3Zlck92ZXJMZWdlbmQpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlbCcpLCAxMCkgLSAxO1xuICAgICAgICAgICAgdGhpcy5jdHguZXZlbnRzLmZpcmVFdmVudCgnbGVnZW5kSG92ZXInLCBbdGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53XSk7XG5cbiAgICAgICAgICAgIHZhciBfc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgIF9zZXJpZXMuaGlnaGxpZ2h0UmFuZ2VJblNlcmllcyhlLCBlLnRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm9uTGVnZW5kQ2xpY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxlZ2VuZENsaWNrKGUpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQuY3VzdG9tTGVnZW5kSXRlbXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzJykgfHwgZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0JykgfHwgZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXInKSkge1xuICAgICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlbCcpLCAxMCkgLSAxO1xuICAgICAgICAgIHZhciBpc0hpZGRlbiA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YTpjb2xsYXBzZWQnKSA9PT0gJ3RydWUnO1xuICAgICAgICAgIHZhciBsZWdlbmRDbGljayA9IHRoaXMudy5jb25maWcuY2hhcnQuZXZlbnRzLmxlZ2VuZENsaWNrO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBsZWdlbmRDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGVnZW5kQ2xpY2sodGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmN0eC5ldmVudHMuZmlyZUV2ZW50KCdsZWdlbmRDbGljaycsIFt0aGlzLmN0eCwgc2VyaWVzQ250LCB0aGlzLnddKTtcbiAgICAgICAgICB2YXIgbWFya2VyQ2xpY2sgPSB0aGlzLncuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLm9uQ2xpY2s7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG1hcmtlckNsaWNrID09PSAnZnVuY3Rpb24nICYmIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1sZWdlbmQtbWFya2VyJykpIHtcbiAgICAgICAgICAgIG1hcmtlckNsaWNrKHRoaXMuY3R4LCBzZXJpZXNDbnQsIHRoaXMudyk7XG4gICAgICAgICAgICB0aGlzLmN0eC5ldmVudHMuZmlyZUV2ZW50KCdsZWdlbmRNYXJrZXJDbGljaycsIFt0aGlzLmN0eCwgc2VyaWVzQ250LCB0aGlzLnddKTtcbiAgICAgICAgICB9IC8vIGZvciBub3cgLSBqdXN0IHByZXZlbnQgY2xpY2sgb24gaGVhdG1hcCBsZWdlbmQgLSBhbmQgYWxsb3cgaG92ZXIgb25seVxuXG5cbiAgICAgICAgICB2YXIgY2xpY2tBbGxvd2VkID0gdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ3RyZWVtYXAnICYmIHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdoZWF0bWFwJyAmJiAhdGhpcy5pc0JhcnNEaXN0cmlidXRlZDtcblxuICAgICAgICAgIGlmIChjbGlja0FsbG93ZWQgJiYgdy5jb25maWcubGVnZW5kLm9uSXRlbUNsaWNrLnRvZ2dsZURhdGFTZXJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kSGVscGVycy50b2dnbGVEYXRhU2VyaWVzKHNlcmllc0NudCwgaXNIaWRkZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMZWdlbmQ7XG4gIH0oKTtcblxuICB2YXIgaWNvUGFuID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIGZpbGw9XFxcIiMwMDAwMDBcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgd2lkdGg9XFxcIjI0XFxcIj5cXG4gICAgPGRlZnM+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMCAwaDI0djI0SDB6XFxcIiBpZD1cXFwiYVxcXCIvPlxcbiAgICA8L2RlZnM+XFxuICAgIDxjbGlwUGF0aCBpZD1cXFwiYlxcXCI+XFxuICAgICAgICA8dXNlIG92ZXJmbG93PVxcXCJ2aXNpYmxlXFxcIiB4bGluazpocmVmPVxcXCIjYVxcXCIvPlxcbiAgICA8L2NsaXBQYXRoPlxcbiAgICA8cGF0aCBjbGlwLXBhdGg9XFxcInVybCgjYilcXFwiIGQ9XFxcIk0yMyA1LjVWMjBjMCAyLjItMS44IDQtNCA0aC03LjNjLTEuMDggMC0yLjEtLjQzLTIuODUtMS4xOUwxIDE0LjgzczEuMjYtMS4yMyAxLjMtMS4yNWMuMjItLjE5LjQ5LS4yOS43OS0uMjkuMjIgMCAuNDIuMDYuNi4xNi4wNC4wMSA0LjMxIDIuNDYgNC4zMSAyLjQ2VjRjMC0uODMuNjctMS41IDEuNS0xLjVTMTEgMy4xNyAxMSA0djdoMVYxLjVjMC0uODMuNjctMS41IDEuNS0xLjVTMTUgLjY3IDE1IDEuNVYxMWgxVjIuNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNVYxMWgxVjUuNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNXpcXFwiLz5cXG48L3N2Zz5cIjtcblxuICB2YXIgaWNvWm9vbSA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIGZpbGw9XFxcIiMwMDAwMDBcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgd2lkdGg9XFxcIjI0XFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6XFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMFYwelxcXCIgZmlsbD1cXFwibm9uZVxcXCIvPlxcbiAgICA8cGF0aCBkPVxcXCJNMTIgMTBoLTJ2Mkg5di0ySDdWOWgyVjdoMXYyaDJ2MXpcXFwiLz5cXG48L3N2Zz5cIjtcblxuICB2YXIgaWNvUmVzZXQgPSBcIjxzdmcgZmlsbD1cXFwiIzAwMDAwMFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6XFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG48L3N2Zz5cIjtcblxuICB2YXIgaWNvWm9vbUluID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcbiAgICA8cGF0aCBkPVxcXCJNMCAwaDI0djI0SDB6XFxcIiBmaWxsPVxcXCJub25lXFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0xMyA3aC0ydjRIN3YyaDR2NGgydi00aDR2LTJoLTRWN3ptLTEtNUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6XFxcIi8+XFxuPC9zdmc+XFxuXCI7XG5cbiAgdmFyIGljb1pvb21PdXQgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTcgMTF2MmgxMHYtMkg3em01LTlDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4elxcXCIvPlxcbjwvc3ZnPlxcblwiO1xuXG4gIHZhciBpY29TZWxlY3QgPSBcIjxzdmcgZmlsbD1cXFwiIzZFODE5MlxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTMgNWgyVjNjLTEuMSAwLTIgLjktMiAyem0wIDhoMnYtMkgzdjJ6bTQgOGgydi0ySDd2MnpNMyA5aDJWN0gzdjJ6bTEwLTZoLTJ2MmgyVjN6bTYgMHYyaDJjMC0xLjEtLjktMi0yLTJ6TTUgMjF2LTJIM2MwIDEuMS45IDIgMiAyem0tMi00aDJ2LTJIM3Yyek05IDNIN3YyaDJWM3ptMiAxOGgydi0yaC0ydjJ6bTgtOGgydi0yaC0ydjJ6bTAgOGMxLjEgMCAyLS45IDItMmgtMnYyem0wLTEyaDJWN2gtMnYyem0wIDhoMnYtMmgtMnYyem0tNCA0aDJ2LTJoLTJ2MnptMC0xNmgyVjNoLTJ2MnpcXFwiLz5cXG48L3N2Zz5cIjtcblxuICB2YXIgaWNvTWVudSA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBkPVxcXCJNMCAwaDI0djI0SDBWMHpcXFwiLz48cGF0aCBkPVxcXCJNMyAxOGgxOHYtMkgzdjJ6bTAtNWgxOHYtMkgzdjJ6bTAtN3YyaDE4VjZIM3pcXFwiLz48L3N2Zz5cIjtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBUb29sYmFyIENsYXNzIGZvciBjcmVhdGluZyB0b29sYmFyIGluIGF4aXMgYmFzZWQgY2hhcnRzLlxuICAgKlxuICAgKiBAbW9kdWxlIFRvb2xiYXJcbiAgICoqL1xuXG4gIHZhciBUb29sYmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sYmFyKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2xiYXIpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLmV2ID0gdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHM7XG4gICAgICB0aGlzLnNlbGVjdGVkQ2xhc3MgPSAnYXBleGNoYXJ0cy1zZWxlY3RlZCc7XG4gICAgICB0aGlzLmxvY2FsZVZhbHVlcyA9IHRoaXMudy5nbG9iYWxzLmxvY2FsZS50b29sYmFyO1xuICAgICAgdGhpcy5taW5YID0gdy5nbG9iYWxzLm1pblg7XG4gICAgICB0aGlzLm1heFggPSB3Lmdsb2JhbHMubWF4WDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVG9vbGJhciwgW3tcbiAgICAgIGtleTogXCJjcmVhdGVUb29sYmFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVG9vbGJhcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICB2YXIgY3JlYXRlRGl2ID0gZnVuY3Rpb24gY3JlYXRlRGl2KCkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZWxUb29sYmFyV3JhcCA9IGNyZWF0ZURpdigpO1xuICAgICAgICBlbFRvb2xiYXJXcmFwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYXBleGNoYXJ0cy10b29sYmFyJyk7XG4gICAgICAgIGVsVG9vbGJhcldyYXAuc3R5bGUudG9wID0gdy5jb25maWcuY2hhcnQudG9vbGJhci5vZmZzZXRZICsgJ3B4JztcbiAgICAgICAgZWxUb29sYmFyV3JhcC5zdHlsZS5yaWdodCA9IC13LmNvbmZpZy5jaGFydC50b29sYmFyLm9mZnNldFggKyAzICsgJ3B4JztcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbFdyYXAuYXBwZW5kQ2hpbGQoZWxUb29sYmFyV3JhcCk7XG4gICAgICAgIHRoaXMuZWxab29tID0gY3JlYXRlRGl2KCk7XG4gICAgICAgIHRoaXMuZWxab29tSW4gPSBjcmVhdGVEaXYoKTtcbiAgICAgICAgdGhpcy5lbFpvb21PdXQgPSBjcmVhdGVEaXYoKTtcbiAgICAgICAgdGhpcy5lbFBhbiA9IGNyZWF0ZURpdigpO1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uID0gY3JlYXRlRGl2KCk7XG4gICAgICAgIHRoaXMuZWxab29tUmVzZXQgPSBjcmVhdGVEaXYoKTtcbiAgICAgICAgdGhpcy5lbE1lbnVJY29uID0gY3JlYXRlRGl2KCk7XG4gICAgICAgIHRoaXMuZWxNZW51ID0gY3JlYXRlRGl2KCk7XG4gICAgICAgIHRoaXMuZWxDdXN0b21JY29ucyA9IFtdO1xuICAgICAgICB0aGlzLnQgPSB3LmNvbmZpZy5jaGFydC50b29sYmFyLnRvb2xzO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudC5jdXN0b21JY29ucykpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudC5jdXN0b21JY29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5lbEN1c3RvbUljb25zLnB1c2goY3JlYXRlRGl2KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b29sYmFyQ29udHJvbHMgPSBbXTtcblxuICAgICAgICB2YXIgYXBwZW5kWm9vbUNvbnRyb2wgPSBmdW5jdGlvbiBhcHBlbmRab29tQ29udHJvbCh0eXBlLCBlbCwgaWNvKSB7XG4gICAgICAgICAgdmFyIHRvb2wgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMudFt0b29sXSAmJiB3LmNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICBpY29uOiB0eXBlb2YgX3RoaXMudFt0b29sXSA9PT0gJ3N0cmluZycgPyBfdGhpcy50W3Rvb2xdIDogaWNvLFxuICAgICAgICAgICAgICB0aXRsZTogX3RoaXMubG9jYWxlVmFsdWVzW3R5cGVdLFxuICAgICAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh0b29sLCBcIi1pY29uXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgYXBwZW5kWm9vbUNvbnRyb2woJ3pvb21JbicsIHRoaXMuZWxab29tSW4sIGljb1pvb21Jbik7XG4gICAgICAgIGFwcGVuZFpvb21Db250cm9sKCd6b29tT3V0JywgdGhpcy5lbFpvb21PdXQsIGljb1pvb21PdXQpO1xuXG4gICAgICAgIHZhciB6b29tU2VsZWN0aW9uQ3RybHMgPSBmdW5jdGlvbiB6b29tU2VsZWN0aW9uQ3RybHMoeikge1xuICAgICAgICAgIGlmIChfdGhpcy50W3pdICYmIHcuY29uZmlnLmNoYXJ0W3pdLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICAgICAgZWw6IHogPT09ICd6b29tJyA/IF90aGlzLmVsWm9vbSA6IF90aGlzLmVsU2VsZWN0aW9uLFxuICAgICAgICAgICAgICBpY29uOiB0eXBlb2YgX3RoaXMudFt6XSA9PT0gJ3N0cmluZycgPyBfdGhpcy50W3pdIDogeiA9PT0gJ3pvb20nID8gaWNvWm9vbSA6IGljb1NlbGVjdCxcbiAgICAgICAgICAgICAgdGl0bGU6IF90aGlzLmxvY2FsZVZhbHVlc1t6ID09PSAnem9vbScgPyAnc2VsZWN0aW9uWm9vbScgOiAnc2VsZWN0aW9uJ10sXG4gICAgICAgICAgICAgIGNsYXNzOiB3Lmdsb2JhbHMuaXNUb3VjaERldmljZSA/ICdhcGV4Y2hhcnRzLWVsZW1lbnQtaGlkZGVuJyA6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQoeiwgXCItaWNvblwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHpvb21TZWxlY3Rpb25DdHJscygnem9vbScpO1xuICAgICAgICB6b29tU2VsZWN0aW9uQ3RybHMoJ3NlbGVjdGlvbicpO1xuXG4gICAgICAgIGlmICh0aGlzLnQucGFuICYmIHcuY29uZmlnLmNoYXJ0Lnpvb20uZW5hYmxlZCkge1xuICAgICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICAgIGVsOiB0aGlzLmVsUGFuLFxuICAgICAgICAgICAgaWNvbjogdHlwZW9mIHRoaXMudC5wYW4gPT09ICdzdHJpbmcnID8gdGhpcy50LnBhbiA6IGljb1BhbixcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5wYW4sXG4gICAgICAgICAgICBjbGFzczogdy5nbG9iYWxzLmlzVG91Y2hEZXZpY2UgPyAnYXBleGNoYXJ0cy1lbGVtZW50LWhpZGRlbicgOiAnYXBleGNoYXJ0cy1wYW4taWNvbidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZFpvb21Db250cm9sKCdyZXNldCcsIHRoaXMuZWxab29tUmVzZXQsIGljb1Jlc2V0KTtcblxuICAgICAgICBpZiAodGhpcy50LmRvd25sb2FkKSB7XG4gICAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgICAgZWw6IHRoaXMuZWxNZW51SWNvbixcbiAgICAgICAgICAgIGljb246IHR5cGVvZiB0aGlzLnQuZG93bmxvYWQgPT09ICdzdHJpbmcnID8gdGhpcy50LmRvd25sb2FkIDogaWNvTWVudSxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5tZW51LFxuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLW1lbnUtaWNvbidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmVsQ3VzdG9tSWNvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgICAgZWw6IHRoaXMuZWxDdXN0b21JY29uc1tfaV0sXG4gICAgICAgICAgICBpY29uOiB0aGlzLnQuY3VzdG9tSWNvbnNbX2ldLmljb24sXG4gICAgICAgICAgICB0aXRsZTogdGhpcy50LmN1c3RvbUljb25zW19pXS50aXRsZSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLnQuY3VzdG9tSWNvbnNbX2ldLmluZGV4LFxuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXRvb2xiYXItY3VzdG9tLWljb24gJyArIHRoaXMudC5jdXN0b21JY29uc1tfaV0uY2xhc3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvb2xiYXJDb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uICh0LCBpbmRleCkge1xuICAgICAgICAgIGlmICh0LmluZGV4KSB7XG4gICAgICAgICAgICBVdGlscyQxLm1vdmVJbmRleEluQXJyYXkodG9vbGJhckNvbnRyb2xzLCBpbmRleCwgdC5pbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0b29sYmFyQ29udHJvbHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHRvb2xiYXJDb250cm9sc1tfaTJdLmVsLCB7XG4gICAgICAgICAgICBjbGFzczogdG9vbGJhckNvbnRyb2xzW19pMl0uY2xhc3MsXG4gICAgICAgICAgICB0aXRsZTogdG9vbGJhckNvbnRyb2xzW19pMl0udGl0bGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b29sYmFyQ29udHJvbHNbX2kyXS5lbC5pbm5lckhUTUwgPSB0b29sYmFyQ29udHJvbHNbX2kyXS5pY29uO1xuICAgICAgICAgIGVsVG9vbGJhcldyYXAuYXBwZW5kQ2hpbGQodG9vbGJhckNvbnRyb2xzW19pMl0uZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlSGFtYnVyZ2VyTWVudShlbFRvb2xiYXJXcmFwKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5lbFpvb20uY2xhc3NMaXN0LmFkZCh0aGlzLnNlbGVjdGVkQ2xhc3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5wYW5FbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5lbFBhbi5jbGFzc0xpc3QuYWRkKHRoaXMuc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5hZGQodGhpcy5zZWxlY3RlZENsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkVG9vbGJhckV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jcmVhdGVIYW1idXJnZXJNZW51XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUhhbWJ1cmdlck1lbnUocGFyZW50KSB7XG4gICAgICAgIHRoaXMuZWxNZW51SXRlbXMgPSBbXTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWxNZW51KTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnModGhpcy5lbE1lbnUsIHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtbWVudSdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtZW51SXRlbXMgPSBbe1xuICAgICAgICAgIG5hbWU6ICdleHBvcnRTVkcnLFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5leHBvcnRUb1NWR1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ2V4cG9ydFBORycsXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLmV4cG9ydFRvUE5HXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnZXhwb3J0Q1NWJyxcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMuZXhwb3J0VG9DU1ZcbiAgICAgICAgfV07XG5cbiAgICAgICAgaWYgKCF0aGlzLncuZ2xvYmFscy5hbGxTZXJpZXNIYXNFcXVhbFgpIHtcbiAgICAgICAgICAvLyBpZiBpdCBpcyBhIG11bHRpIHNlcmllcywgYW5kIGFsbCBzZXJpZXMgaGF2ZSB2YXJpYWJsZSB4IHZhbHVlcywgZXhwb3J0IENTViB3b24ndCB3b3JrXG4gICAgICAgICAgbWVudUl0ZW1zLnNwbGljZSgyLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVudUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5lbE1lbnVJdGVtcy5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgICB0aGlzLmVsTWVudUl0ZW1zW2ldLmlubmVySFRNTCA9IG1lbnVJdGVtc1tpXS50aXRsZTtcbiAgICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh0aGlzLmVsTWVudUl0ZW1zW2ldLCB7XG4gICAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLW1lbnUtaXRlbSBcIi5jb25jYXQobWVudUl0ZW1zW2ldLm5hbWUpLFxuICAgICAgICAgICAgdGl0bGU6IG1lbnVJdGVtc1tpXS50aXRsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZWxNZW51LmFwcGVuZENoaWxkKHRoaXMuZWxNZW51SXRlbXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFRvb2xiYXJFdmVudExpc3RlbmVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvb2xiYXJFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5lbFpvb21SZXNldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbVJlc2V0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVab29tU2VsZWN0aW9uLmJpbmQodGhpcywgJ3NlbGVjdGlvbicpKTtcbiAgICAgICAgdGhpcy5lbFpvb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZVpvb21TZWxlY3Rpb24uYmluZCh0aGlzLCAnem9vbScpKTtcbiAgICAgICAgdGhpcy5lbFpvb21Jbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbUluLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsWm9vbU91dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbU91dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbFBhbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlUGFubmluZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbE1lbnVJY29uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsTWVudUl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBpZiAobS5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cG9ydFNWRycpKSB7XG4gICAgICAgICAgICBtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMyLmhhbmRsZURvd25sb2FkLmJpbmQoX3RoaXMyLCAnc3ZnJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobS5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cG9ydFBORycpKSB7XG4gICAgICAgICAgICBtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMyLmhhbmRsZURvd25sb2FkLmJpbmQoX3RoaXMyLCAncG5nJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobS5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cG9ydENTVicpKSB7XG4gICAgICAgICAgICBtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMyLmhhbmRsZURvd25sb2FkLmJpbmQoX3RoaXMyLCAnY3N2JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQuY3VzdG9tSWNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmVsQ3VzdG9tSWNvbnNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnQuY3VzdG9tSWNvbnNbaV0uY2xpY2suYmluZCh0aGlzLCB0aGlzLmN0eCwgdGhpcy5jdHgudykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRvZ2dsZVpvb21TZWxlY3Rpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVab29tU2VsZWN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIGNoYXJ0cyA9IHRoaXMuY3R4LmdldFN5bmNlZENoYXJ0cygpO1xuICAgICAgICBjaGFydHMuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgICBjaC5jdHgudG9vbGJhci50b2dnbGVPdGhlckNvbnRyb2xzKCk7XG4gICAgICAgICAgdmFyIGVsID0gdHlwZSA9PT0gJ3NlbGVjdGlvbicgPyBjaC5jdHgudG9vbGJhci5lbFNlbGVjdGlvbiA6IGNoLmN0eC50b29sYmFyLmVsWm9vbTtcbiAgICAgICAgICB2YXIgZW5hYmxlZFR5cGUgPSB0eXBlID09PSAnc2VsZWN0aW9uJyA/ICdzZWxlY3Rpb25FbmFibGVkJyA6ICd6b29tRW5hYmxlZCc7XG4gICAgICAgICAgY2gudy5nbG9iYWxzW2VuYWJsZWRUeXBlXSA9ICFjaC53Lmdsb2JhbHNbZW5hYmxlZFR5cGVdO1xuXG4gICAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoY2guY3R4LnRvb2xiYXIuc2VsZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2guY3R4LnRvb2xiYXIuc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2guY3R4LnRvb2xiYXIuc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0VG9vbGJhckljb25zUmVmZXJlbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbGJhckljb25zUmVmZXJlbmNlKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAoIXRoaXMuZWxab29tKSB7XG4gICAgICAgICAgdGhpcy5lbFpvb20gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy16b29tLWljb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lbFBhbikge1xuICAgICAgICAgIHRoaXMuZWxQYW4gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1wYW4taWNvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmVsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5lbFNlbGVjdGlvbiA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5hYmxlWm9vbVBhbkZyb21Ub29sYmFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlWm9vbVBhbkZyb21Ub29sYmFyKHR5cGUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVPdGhlckNvbnRyb2xzKCk7XG4gICAgICAgIHR5cGUgPT09ICdwYW4nID8gdGhpcy53Lmdsb2JhbHMucGFuRW5hYmxlZCA9IHRydWUgOiB0aGlzLncuZ2xvYmFscy56b29tRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHZhciBlbCA9IHR5cGUgPT09ICdwYW4nID8gdGhpcy5lbFBhbiA6IHRoaXMuZWxab29tO1xuICAgICAgICB2YXIgZWwyID0gdHlwZSA9PT0gJ3BhbicgPyB0aGlzLmVsWm9vbSA6IHRoaXMuZWxQYW47XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLnNlbGVjdGVkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsMikge1xuICAgICAgICAgIGVsMi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9nZ2xlUGFubmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVBhbm5pbmcoKSB7XG4gICAgICAgIHZhciBjaGFydHMgPSB0aGlzLmN0eC5nZXRTeW5jZWRDaGFydHMoKTtcbiAgICAgICAgY2hhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgY2guY3R4LnRvb2xiYXIudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgICAgIGNoLncuZ2xvYmFscy5wYW5FbmFibGVkID0gIWNoLncuZ2xvYmFscy5wYW5FbmFibGVkO1xuXG4gICAgICAgICAgaWYgKCFjaC5jdHgudG9vbGJhci5lbFBhbi5jbGFzc0xpc3QuY29udGFpbnMoY2guY3R4LnRvb2xiYXIuc2VsZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgICAgIGNoLmN0eC50b29sYmFyLmVsUGFuLmNsYXNzTGlzdC5hZGQoY2guY3R4LnRvb2xiYXIuc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoLmN0eC50b29sYmFyLmVsUGFuLmNsYXNzTGlzdC5yZW1vdmUoY2guY3R4LnRvb2xiYXIuc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9nZ2xlT3RoZXJDb250cm9sc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU90aGVyQ29udHJvbHMoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB3Lmdsb2JhbHMucGFuRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB3Lmdsb2JhbHMuem9vbUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nZXRUb29sYmFySWNvbnNSZWZlcmVuY2UoKTtcbiAgICAgICAgdmFyIHRvZ2dsZUVscyA9IFt0aGlzLmVsUGFuLCB0aGlzLmVsU2VsZWN0aW9uLCB0aGlzLmVsWm9vbV07XG4gICAgICAgIHRvZ2dsZUVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShfdGhpczMuc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlWm9vbUluXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlWm9vbUluKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzUmFuZ2VCYXIpIHtcbiAgICAgICAgICB0aGlzLm1pblggPSB3Lmdsb2JhbHMubWluWTtcbiAgICAgICAgICB0aGlzLm1heFggPSB3Lmdsb2JhbHMubWF4WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZW50ZXJYID0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgLyAyO1xuICAgICAgICB2YXIgbmV3TWluWCA9ICh0aGlzLm1pblggKyBjZW50ZXJYKSAvIDI7XG4gICAgICAgIHZhciBuZXdNYXhYID0gKHRoaXMubWF4WCArIGNlbnRlclgpIC8gMjtcblxuICAgICAgICB2YXIgbmV3TWluWE1heFggPSB0aGlzLl9nZXROZXdNaW5YTWF4WChuZXdNaW5YLCBuZXdNYXhYKTtcblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5kaXNhYmxlWm9vbUluKSB7XG4gICAgICAgICAgdGhpcy56b29tVXBkYXRlT3B0aW9ucyhuZXdNaW5YTWF4WC5taW5YLCBuZXdNaW5YTWF4WC5tYXhYKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVab29tT3V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlWm9vbU91dCgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1JhbmdlQmFyKSB7XG4gICAgICAgICAgdGhpcy5taW5YID0gdy5nbG9iYWxzLm1pblk7XG4gICAgICAgICAgdGhpcy5tYXhYID0gdy5nbG9iYWxzLm1heFk7XG4gICAgICAgIH0gLy8gYXZvaWQgem9vbWluZyBvdXQgYmV5b25kIDEwMDAgd2hpY2ggbWF5IHJlc3VsdCBpbiBOYU4gdmFsdWVzIGJlaW5nIHByaW50ZWQgb24geC1heGlzXG5cblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiBuZXcgRGF0ZSh0aGlzLm1pblgpLmdldFVUQ0Z1bGxZZWFyKCkgPCAxMDAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlclggPSAodGhpcy5taW5YICsgdGhpcy5tYXhYKSAvIDI7XG4gICAgICAgIHZhciBuZXdNaW5YID0gdGhpcy5taW5YIC0gKGNlbnRlclggLSB0aGlzLm1pblgpO1xuICAgICAgICB2YXIgbmV3TWF4WCA9IHRoaXMubWF4WCAtIChjZW50ZXJYIC0gdGhpcy5tYXhYKTtcblxuICAgICAgICB2YXIgbmV3TWluWE1heFggPSB0aGlzLl9nZXROZXdNaW5YTWF4WChuZXdNaW5YLCBuZXdNYXhYKTtcblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5kaXNhYmxlWm9vbU91dCkge1xuICAgICAgICAgIHRoaXMuem9vbVVwZGF0ZU9wdGlvbnMobmV3TWluWE1heFgubWluWCwgbmV3TWluWE1heFgubWF4WCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldE5ld01pblhNYXhYXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE5ld01pblhNYXhYKG5ld01pblgsIG5ld01heFgpIHtcbiAgICAgICAgdmFyIHNob3VsZEZsb29yID0gdGhpcy53LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluWDogc2hvdWxkRmxvb3IgPyBNYXRoLmZsb29yKG5ld01pblgpIDogbmV3TWluWCxcbiAgICAgICAgICBtYXhYOiBzaG91bGRGbG9vciA/IE1hdGguZmxvb3IobmV3TWF4WCkgOiBuZXdNYXhYXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInpvb21VcGRhdGVPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gem9vbVVwZGF0ZU9wdGlvbnMobmV3TWluWCwgbmV3TWF4WCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAobmV3TWluWCA9PT0gdW5kZWZpbmVkICYmIG5ld01heFggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlWm9vbVJlc2V0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYykge1xuICAgICAgICAgIC8vIGluIGNhdGVnb3J5IGNoYXJ0cywgYXZvaWQgem9vbWluZyBvdXQgYmV5b25kIG1pbiBhbmQgbWF4XG4gICAgICAgICAgaWYgKG5ld01pblggPCAxKSB7XG4gICAgICAgICAgICBuZXdNaW5YID0gMTtcbiAgICAgICAgICAgIG5ld01heFggPSB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3TWF4WCAtIG5ld01pblggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhheGlzID0ge1xuICAgICAgICAgIG1pbjogbmV3TWluWCxcbiAgICAgICAgICBtYXg6IG5ld01heFhcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJlZm9yZVpvb21SYW5nZSA9IHRoaXMuZ2V0QmVmb3JlWm9vbVJhbmdlKHhheGlzKTtcblxuICAgICAgICBpZiAoYmVmb3JlWm9vbVJhbmdlKSB7XG4gICAgICAgICAgeGF4aXMgPSBiZWZvcmVab29tUmFuZ2UueGF4aXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHlheGlzID0gVXRpbHMkMS5jbG9uZSh3Lmdsb2JhbHMuaW5pdGlhbENvbmZpZy55YXhpcyk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lnpvb20uYXV0b1NjYWxlWWF4aXMpIHtcbiAgICAgICAgICB2YXIgc2NhbGUgPSBuZXcgUmFuZ2UkMSh0aGlzLmN0eCk7XG4gICAgICAgICAgeWF4aXMgPSBzY2FsZS5hdXRvU2NhbGVZKHRoaXMuY3R4LCB5YXhpcywge1xuICAgICAgICAgICAgeGF4aXM6IHhheGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgICAgLy8gaWYgY2hhcnQgaW4gYSBncm91cCwgcHJldmVudCB5YXhpcyB1cGRhdGUgaGVyZVxuICAgICAgICAgIC8vIGZpeCBpc3N1ZSAjNjUwXG4gICAgICAgICAgb3B0aW9ucy55YXhpcyA9IHlheGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53Lmdsb2JhbHMuem9vbWVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmN0eC51cGRhdGVIZWxwZXJzLl91cGRhdGVPcHRpb25zKG9wdGlvbnMsIGZhbHNlLCB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcblxuICAgICAgICB0aGlzLnpvb21DYWxsYmFjayh4YXhpcywgeWF4aXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ6b29tQ2FsbGJhY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tQ2FsbGJhY2soeGF4aXMsIHlheGlzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ldi56b29tZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmV2Lnpvb21lZCh0aGlzLmN0eCwge1xuICAgICAgICAgICAgeGF4aXM6IHhheGlzLFxuICAgICAgICAgICAgeWF4aXM6IHlheGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0QmVmb3JlWm9vbVJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmVmb3JlWm9vbVJhbmdlKHhheGlzLCB5YXhpcykge1xuICAgICAgICB2YXIgbmV3UmFuZ2UgPSBudWxsO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ldi5iZWZvcmVab29tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbmV3UmFuZ2UgPSB0aGlzLmV2LmJlZm9yZVpvb20odGhpcywge1xuICAgICAgICAgICAgeGF4aXM6IHhheGlzLFxuICAgICAgICAgICAgeWF4aXM6IHlheGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRvZ2dsZU1lbnVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzNC5lbE1lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLW1lbnUtb3BlbicpKSB7XG4gICAgICAgICAgICBfdGhpczQuZWxNZW51LmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtbWVudS1vcGVuJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNC5lbE1lbnUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1tZW51LW9wZW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVEb3dubG9hZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURvd25sb2FkKHR5cGUpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBleHBydCA9IG5ldyBFeHBvcnRzKHRoaXMuY3R4KTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgZXhwcnQuZXhwb3J0VG9TVkcodGhpcy5jdHgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwbmcnOlxuICAgICAgICAgICAgZXhwcnQuZXhwb3J0VG9QbmcodGhpcy5jdHgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjc3YnOlxuICAgICAgICAgICAgZXhwcnQuZXhwb3J0VG9DU1Yoe1xuICAgICAgICAgICAgICBzZXJpZXM6IHcuY29uZmlnLnNlcmllcyxcbiAgICAgICAgICAgICAgY29sdW1uRGVsaW1pdGVyOiB3LmNvbmZpZy5jaGFydC50b29sYmFyLmV4cG9ydC5jc3YuY29sdW1uRGVsaW1pdGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZVpvb21SZXNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21SZXNldChlKSB7XG4gICAgICAgIHZhciBjaGFydHMgPSB0aGlzLmN0eC5nZXRTeW5jZWRDaGFydHMoKTtcbiAgICAgICAgY2hhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgdmFyIHcgPSBjaC53OyAvLyBmb3JnZXQgbGFzdFhBeGlzIG1pbi9tYXggYXMgcmVzZXQgYnV0dG9uIGlzbid0IHJlc2V0dGluZyB0aGUgeC1heGlzIGNvbXBsZXRlbHkgaWYgem9vbVggaXMgY2FsbGVkIGJlZm9yZVxuXG4gICAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpcy5taW4gPSB3Lmdsb2JhbHMuaW5pdGlhbENvbmZpZy54YXhpcy5taW47XG4gICAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpcy5tYXggPSB3Lmdsb2JhbHMuaW5pdGlhbENvbmZpZy54YXhpcy5tYXg7XG4gICAgICAgICAgY2gudXBkYXRlSGVscGVycy5yZXZlcnREZWZhdWx0QXhpc01pbk1heCgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuYmVmb3JlUmVzZXRab29tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBoZXJlLCB1c2VyIGdldCBhbiBvcHRpb24gdG8gY29udHJvbCB4YXhpcyBhbmQgeWF4aXMgd2hlbiByZXNldFpvb20gaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB3aGF0ZXZlciBpcyByZXR1cm5lZCBmcm9tIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5iZWZvcmVSZXNldFpvb21cbiAgICAgICAgICAgIC8vIGlzIHNldCBhcyB0aGUgbmV3IHhheGlzL3lheGlzIG1pbi9tYXhcbiAgICAgICAgICAgIHZhciByZXNldFpvb21SYW5nZSA9IHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5iZWZvcmVSZXNldFpvb20oY2gsIHcpO1xuXG4gICAgICAgICAgICBpZiAocmVzZXRab29tUmFuZ2UpIHtcbiAgICAgICAgICAgICAgY2gudXBkYXRlSGVscGVycy5yZXZlcnREZWZhdWx0QXhpc01pbk1heChyZXNldFpvb21SYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjaC5jdHgudG9vbGJhci56b29tQ2FsbGJhY2soe1xuICAgICAgICAgICAgICBtaW46IHcuY29uZmlnLnhheGlzLm1pbixcbiAgICAgICAgICAgICAgbWF4OiB3LmNvbmZpZy54YXhpcy5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy56b29tZWQgPSBmYWxzZTsgLy8gaWYgdXNlciBoYXMgc29tZSBzZXJpZXMgY29sbGFwc2VkIGJlZm9yZSBoaXR0aW5nIHpvb20gcmVzZXQgYnV0dG9uLFxuICAgICAgICAgIC8vIHRob3NlIHNlcmllcyBzaG91bGQgc3RheSBjb2xsYXBzZWRcblxuICAgICAgICAgIHZhciBzZXJpZXMgPSBjaC5jdHguc2VyaWVzLmVtcHR5Q29sbGFwc2VkU2VyaWVzKFV0aWxzJDEuY2xvbmUody5nbG9iYWxzLmluaXRpYWxTZXJpZXMpKTtcblxuICAgICAgICAgIGNoLnVwZGF0ZUhlbHBlcnMuX3VwZGF0ZVNlcmllcyhzZXJpZXMsIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmVsWm9vbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxab29tSW4gPSBudWxsO1xuICAgICAgICB0aGlzLmVsWm9vbU91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxQYW4gPSBudWxsO1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbFpvb21SZXNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxNZW51SWNvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRvb2xiYXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBab29tIENsYXNzIGZvciBoYW5kbGluZyB6b29taW5nIGFuZCBwYW5uaW5nIG9uIGF4ZXMgYmFzZWQgY2hhcnRzLlxuICAgKlxuICAgKiBAbW9kdWxlIFpvb21QYW5TZWxlY3Rpb25cbiAgICoqL1xuXG4gIHZhciBab29tUGFuU2VsZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVG9vbGJhcikge1xuICAgIF9pbmhlcml0cyhab29tUGFuU2VsZWN0aW9uLCBfVG9vbGJhcik7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFpvb21QYW5TZWxlY3Rpb24pO1xuXG4gICAgZnVuY3Rpb24gWm9vbVBhblNlbGVjdGlvbihjdHgpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpvb21QYW5TZWxlY3Rpb24pO1xuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICBfdGhpcy5jdHggPSBjdHg7XG4gICAgICBfdGhpcy53ID0gY3R4Lnc7XG4gICAgICBfdGhpcy5kcmFnZ2VkID0gZmFsc2U7XG4gICAgICBfdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyhfdGhpcy5jdHgpO1xuICAgICAgX3RoaXMuZXZlbnRMaXN0ID0gWydtb3VzZWRvd24nLCAnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAnbW91c2V1cCcsICd0b3VjaGVuZCddO1xuICAgICAgX3RoaXMuY2xpZW50WCA9IDA7XG4gICAgICBfdGhpcy5jbGllbnRZID0gMDtcbiAgICAgIF90aGlzLnN0YXJ0WCA9IDA7XG4gICAgICBfdGhpcy5lbmRYID0gMDtcbiAgICAgIF90aGlzLmRyYWdYID0gMDtcbiAgICAgIF90aGlzLnN0YXJ0WSA9IDA7XG4gICAgICBfdGhpcy5lbmRZID0gMDtcbiAgICAgIF90aGlzLmRyYWdZID0gMDtcbiAgICAgIF90aGlzLm1vdmVEaXJlY3Rpb24gPSAnbm9uZSc7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFpvb21QYW5TZWxlY3Rpb24sIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoX3JlZikge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgeHlSYXRpb3MgPSBfcmVmLnh5UmF0aW9zO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdGhpcy54eVJhdGlvcyA9IHh5UmF0aW9zO1xuICAgICAgICB0aGlzLnpvb21SZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5ncmlkUmVjdCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWdyaWQnKTtcbiAgICAgICAgdGhpcy56b29tUmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtem9vbS1yZWN0Jyk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtc2VsZWN0aW9uLXJlY3QnKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQodGhpcy56b29tUmVjdCk7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHRoaXMuc2VsZWN0aW9uUmVjdCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi50eXBlID09PSAneCcpIHtcbiAgICAgICAgICB0aGlzLnNsRHJhZ2dhYmxlUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdC5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgICBtYXhYOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoLFxuICAgICAgICAgICAgbWF4WTogdy5nbG9iYWxzLmdyaWRIZWlnaHRcbiAgICAgICAgICB9KS5vbignZHJhZ21vdmUnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ2RyYWdnaW5nJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi50eXBlID09PSAneScpIHtcbiAgICAgICAgICB0aGlzLnNsRHJhZ2dhYmxlUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdC5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICAgIG1heFg6IHcuZ2xvYmFscy5ncmlkV2lkdGhcbiAgICAgICAgICB9KS5vbignZHJhZ21vdmUnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ2RyYWdnaW5nJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0LmRyYWdnYWJsZSgpLm9uKCdkcmFnbW92ZScsIHRoaXMuc2VsZWN0aW9uRHJhZ2dpbmcuYmluZCh0aGlzLCAnZHJhZ2dpbmcnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXNlbGVjdGVkU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuaG92ZXJBcmVhID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIlwiLmNvbmNhdCh3Lmdsb2JhbHMuY2hhcnRDbGFzcywgXCIgLmFwZXhjaGFydHMtc3ZnXCIpKTtcbiAgICAgICAgdGhpcy5ob3ZlckFyZWEuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy16b29tYWJsZScpO1xuICAgICAgICB0aGlzLmV2ZW50TGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMi5ob3ZlckFyZWEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbWUuc3ZnTW91c2VFdmVudHMuYmluZChtZSwgeHlSYXRpb3MpLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIHdoaWNoIHdlcmUgcHJldmlvdXNseSBhZGRlZCBvbiBob3ZlciBhcmVhXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNsRHJhZ2dhYmxlUmVjdCkge1xuICAgICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0LmRyYWdnYWJsZShmYWxzZSk7XG4gICAgICAgICAgdGhpcy5zbERyYWdnYWJsZVJlY3Qub2ZmKCk7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25SZWN0Lm9mZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy56b29tUmVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JpZFJlY3QgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdmdNb3VzZUV2ZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN2Z01vdXNlRXZlbnRzKHh5UmF0aW9zLCBlKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdG9vbGJhciA9IHRoaXMuY3R4LnRvb2xiYXI7XG4gICAgICAgIHZhciB6b29tdHlwZSA9IHcuZ2xvYmFscy56b29tRW5hYmxlZCA/IHcuY29uZmlnLmNoYXJ0Lnpvb20udHlwZSA6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi50eXBlO1xuICAgICAgICB2YXIgYXV0b1NlbGVjdGVkID0gdy5jb25maWcuY2hhcnQudG9vbGJhci5hdXRvU2VsZWN0ZWQ7XG5cbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICB0aGlzLnNoaWZ0V2FzUHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgdG9vbGJhci5lbmFibGVab29tUGFuRnJvbVRvb2xiYXIoYXV0b1NlbGVjdGVkID09PSAncGFuJyA/ICd6b29tJyA6ICdwYW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5zaGlmdFdhc1ByZXNzZWQpIHtcbiAgICAgICAgICAgIHRvb2xiYXIuZW5hYmxlWm9vbVBhbkZyb21Ub29sYmFyKGF1dG9TZWxlY3RlZCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0V2FzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZS50YXJnZXQpIHJldHVybjtcbiAgICAgICAgdmFyIHRjID0gZS50YXJnZXQuY2xhc3NMaXN0O1xuICAgICAgICB2YXIgcGM7XG5cbiAgICAgICAgaWYgKGUudGFyZ2V0LnBhcmVudE5vZGUgJiYgZS50YXJnZXQucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHBjID0gZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFsc2VQb3NpdGl2ZXMgPSB0Yy5jb250YWlucygnYXBleGNoYXJ0cy1zZWxlY3Rpb24tcmVjdCcpIHx8IHRjLmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXInKSB8fCB0Yy5jb250YWlucygnYXBleGNoYXJ0cy1sZWdlbmQtdGV4dCcpIHx8IHBjICYmIHBjLmNvbnRhaW5zKCdhcGV4Y2hhcnRzLXRvb2xiYXInKTtcbiAgICAgICAgaWYgKGZhbHNlUG9zaXRpdmVzKSByZXR1cm47XG4gICAgICAgIG1lLmNsaWVudFggPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50b3VjaGVzWzBdLmNsaWVudFggOiBlLnR5cGUgPT09ICd0b3VjaGVuZCcgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFg7XG4gICAgICAgIG1lLmNsaWVudFkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50b3VjaGVzWzBdLmNsaWVudFkgOiBlLnR5cGUgPT09ICd0b3VjaGVuZCcgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFk7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZS53aGljaCA9PT0gMSkge1xuICAgICAgICAgIHZhciBncmlkUmVjdERpbSA9IG1lLmdyaWRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIG1lLnN0YXJ0WCA9IG1lLmNsaWVudFggLSBncmlkUmVjdERpbS5sZWZ0O1xuICAgICAgICAgIG1lLnN0YXJ0WSA9IG1lLmNsaWVudFkgLSBncmlkUmVjdERpbS50b3A7XG4gICAgICAgICAgbWUuZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgIG1lLncuZ2xvYmFscy5tb3VzZWRvd24gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgZS53aGljaCA9PT0gMSB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgICAgbWUuZHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLnBhbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5zZWxlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAobWUudy5nbG9iYWxzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgICBtZS5wYW5EcmFnZ2luZyh7XG4gICAgICAgICAgICAgICAgY29udGV4dDogbWUsXG4gICAgICAgICAgICAgICAgem9vbXR5cGU6IHpvb210eXBlLFxuICAgICAgICAgICAgICAgIHh5UmF0aW9zOiB4eVJhdGlvc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1lLncuZ2xvYmFscy5tb3VzZWRvd24gJiYgdy5nbG9iYWxzLnpvb21FbmFibGVkIHx8IG1lLncuZ2xvYmFscy5tb3VzZWRvd24gJiYgdy5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uID0gbWUuc2VsZWN0aW9uRHJhd2luZyh7XG4gICAgICAgICAgICAgICAgY29udGV4dDogbWUsXG4gICAgICAgICAgICAgICAgem9vbXR5cGU6IHpvb210eXBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICd0b3VjaGVuZCcgfHwgZS50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICAvLyB3ZSB3aWxsIGJlIGNhbGxpbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGVhY2ggbW91c2Vkb3duL21vdXNlbW92ZS9tb3VzZXVwXG4gICAgICAgICAgdmFyIF9ncmlkUmVjdERpbSA9IG1lLmdyaWRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgaWYgKG1lLncuZ2xvYmFscy5tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIC8vIHVzZXIgcmVsZWFzZWQgdGhlIGRyYWcsIG5vdyBkbyBhbGwgdGhlIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgbWUuZW5kWCA9IG1lLmNsaWVudFggLSBfZ3JpZFJlY3REaW0ubGVmdDtcbiAgICAgICAgICAgIG1lLmVuZFkgPSBtZS5jbGllbnRZIC0gX2dyaWRSZWN0RGltLnRvcDtcbiAgICAgICAgICAgIG1lLmRyYWdYID0gTWF0aC5hYnMobWUuZW5kWCAtIG1lLnN0YXJ0WCk7XG4gICAgICAgICAgICBtZS5kcmFnWSA9IE1hdGguYWJzKG1lLmVuZFkgLSBtZS5zdGFydFkpO1xuXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkIHx8IHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgICAgIG1lLnNlbGVjdGlvbkRyYXduKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBtZSxcbiAgICAgICAgICAgICAgICB6b29tdHlwZTogem9vbXR5cGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMucGFuRW5hYmxlZCAmJiB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgICAgICAgbWUuZGVsYXllZFBhblNjcm9sbGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tRW5hYmxlZCkge1xuICAgICAgICAgICAgbWUuaGlkZVNlbGVjdGlvblJlY3QodGhpcy5zZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgICAgbWUudy5nbG9iYWxzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWtlU2VsZWN0aW9uUmVjdERyYWdnYWJsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYWtlU2VsZWN0aW9uUmVjdERyYWdnYWJsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvblJlY3QpIHJldHVybjtcbiAgICAgICAgdmFyIHJlY3REaW0gPSB0aGlzLnNlbGVjdGlvblJlY3Qubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpZiAocmVjdERpbS53aWR0aCA+IDAgJiYgcmVjdERpbS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zbERyYWdnYWJsZVJlY3Quc2VsZWN0aXplKHtcbiAgICAgICAgICAgIHBvaW50czogJ2wsIHInLFxuICAgICAgICAgICAgcG9pbnRTaXplOiA4LFxuICAgICAgICAgICAgcG9pbnRUeXBlOiAncmVjdCdcbiAgICAgICAgICB9KS5yZXNpemUoe1xuICAgICAgICAgICAgY29uc3RyYWludDoge1xuICAgICAgICAgICAgICBtaW5YOiAwLFxuICAgICAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgICAgICBtYXhYOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoLFxuICAgICAgICAgICAgICBtYXhZOiB3Lmdsb2JhbHMuZ3JpZEhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLm9uKCdyZXNpemluZycsIHRoaXMuc2VsZWN0aW9uRHJhZ2dpbmcuYmluZCh0aGlzLCAncmVzaXppbmcnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJlc2VsZWN0ZWRTZWxlY3Rpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVzZWxlY3RlZFNlbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4eVJhdGlvcyA9IHRoaXMueHlSYXRpb3M7XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZWxlY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIHcuZ2xvYmFscy5zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NlbGVjdGlvblJlY3Qody5nbG9iYWxzLnNlbGVjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWluICE9PSB1bmRlZmluZWQgJiYgdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnhheGlzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciB4ID0gKHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi54YXhpcy5taW4gLSB3Lmdsb2JhbHMubWluWCkgLyB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSAody5nbG9iYWxzLm1heFggLSB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWF4KSAvIHh5UmF0aW9zLnhSYXRpbyAtIHg7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SZWN0ID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0aGlzLmRyYXdTZWxlY3Rpb25SZWN0KHNlbGVjdGlvblJlY3QpO1xuICAgICAgICAgICAgICB0aGlzLm1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbih0aGlzLmN0eCwge1xuICAgICAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWluLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi54YXhpcy5tYXhcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB5YXhpczoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3U2VsZWN0aW9uUmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SZWN0KF9yZWYyKSB7XG4gICAgICAgIHZhciB4ID0gX3JlZjIueCxcbiAgICAgICAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgICAgICAgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcbiAgICAgICAgICAgIF9yZWYyJHRyYW5zbGF0ZVggPSBfcmVmMi50cmFuc2xhdGVYLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IF9yZWYyJHRyYW5zbGF0ZVggPT09IHZvaWQgMCA/IDAgOiBfcmVmMiR0cmFuc2xhdGVYLFxuICAgICAgICAgICAgX3JlZjIkdHJhbnNsYXRlWSA9IF9yZWYyLnRyYW5zbGF0ZVksXG4gICAgICAgICAgICB0cmFuc2xhdGVZID0gX3JlZjIkdHJhbnNsYXRlWSA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJHRyYW5zbGF0ZVk7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgem9vbVJlY3QgPSB0aGlzLnpvb21SZWN0O1xuICAgICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdDtcblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkIHx8IHcuZ2xvYmFscy5zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgc2NhbGluZ0F0dHJzID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVYICsgJywgJyArIHRyYW5zbGF0ZVkgKyAnKSdcbiAgICAgICAgICB9OyAvLyBjaGFuZ2Ugc3R5bGVzIGJhc2VkIG9uIHpvb20gb3Igc2VsZWN0aW9uXG4gICAgICAgICAgLy8gem9vbSBpcyBFbmFibGVkIGFuZCB1c2VyIGhhcyBkcmFnZ2VkLCBzbyBkcmF3IGJsdWUgcmVjdFxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tRW5hYmxlZCAmJiB0aGlzLmRyYWdnZWQpIHtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHdpZHRoID0gMTsgLy8gZml4ZXMgYXBleGNoYXJ0cy5qcyMxMTY4XG5cbiAgICAgICAgICAgIHpvb21SZWN0LmF0dHIoe1xuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5jaGFydC56b29tLnpvb21lZEFyZWEuZmlsbC5jb2xvcixcbiAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHcuY29uZmlnLmNoYXJ0Lnpvb20uem9vbWVkQXJlYS5maWxsLm9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZTogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLnN0cm9rZS5jb2xvcixcbiAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLmNoYXJ0Lnpvb20uem9vbWVkQXJlYS5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IHcuY29uZmlnLmNoYXJ0Lnpvb20uem9vbWVkQXJlYS5zdHJva2Uub3BhY2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh6b29tUmVjdC5ub2RlLCBzY2FsaW5nQXR0cnMpO1xuICAgICAgICAgIH0gLy8gc2VsZWN0aW9uIGlzIGVuYWJsZWRcblxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25SZWN0LmF0dHIoe1xuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPiAwID8gd2lkdGggOiAwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA+IDAgPyBoZWlnaHQgOiAwLFxuICAgICAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZmlsbC5jb2xvcixcbiAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5maWxsLm9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZTogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnN0cm9rZS5jb2xvcixcbiAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5Jzogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnN0cm9rZS5kYXNoQXJyYXksXG4gICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zdHJva2Uub3BhY2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhzZWxlY3Rpb25SZWN0Lm5vZGUsIHNjYWxpbmdBdHRycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhpZGVTZWxlY3Rpb25SZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZVNlbGVjdGlvblJlY3QocmVjdCkge1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2VsZWN0aW9uRHJhd2luZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdGlvbkRyYXdpbmcoX3JlZjMpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBfcmVmMy5jb250ZXh0LFxuICAgICAgICAgICAgem9vbXR5cGUgPSBfcmVmMy56b29tdHlwZTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICAgIHZhciBncmlkUmVjdERpbSA9IHRoaXMuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzdGFydFggPSBtZS5zdGFydFggLSAxO1xuICAgICAgICB2YXIgc3RhcnRZID0gbWUuc3RhcnRZO1xuICAgICAgICB2YXIgaW52ZXJzZWRYID0gZmFsc2U7XG4gICAgICAgIHZhciBpbnZlcnNlZFkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbldpZHRoID0gbWUuY2xpZW50WCAtIGdyaWRSZWN0RGltLmxlZnQgLSBzdGFydFg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25IZWlnaHQgPSBtZS5jbGllbnRZIC0gZ3JpZFJlY3REaW0udG9wIC0gc3RhcnRZO1xuICAgICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhzZWxlY3Rpb25XaWR0aCArIHN0YXJ0WCkgPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgLy8gdXNlciBkcmFnZ2VkIHRoZSBtb3VzZSBvdXRzaWRlIGRyYXdpbmcgYXJlYSB0byB0aGUgcmlnaHRcbiAgICAgICAgICBzZWxlY3Rpb25XaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSBzdGFydFg7XG4gICAgICAgIH0gZWxzZSBpZiAobWUuY2xpZW50WCAtIGdyaWRSZWN0RGltLmxlZnQgPCAwKSB7XG4gICAgICAgICAgLy8gdXNlciBkcmFnZ2VkIHRoZSBtb3VzZSBvdXRzaWRlIGRyYXdpbmcgYXJlYSB0byB0aGUgbGVmdFxuICAgICAgICAgIHNlbGVjdGlvbldpZHRoID0gc3RhcnRYO1xuICAgICAgICB9IC8vIGludmVyc2Ugc2VsZWN0aW9uIFhcblxuXG4gICAgICAgIGlmIChzdGFydFggPiBtZS5jbGllbnRYIC0gZ3JpZFJlY3REaW0ubGVmdCkge1xuICAgICAgICAgIGludmVyc2VkWCA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0aW9uV2lkdGggPSBNYXRoLmFicyhzZWxlY3Rpb25XaWR0aCk7XG4gICAgICAgIH0gLy8gaW52ZXJzZSBzZWxlY3Rpb24gWVxuXG5cbiAgICAgICAgaWYgKHN0YXJ0WSA+IG1lLmNsaWVudFkgLSBncmlkUmVjdERpbS50b3ApIHtcbiAgICAgICAgICBpbnZlcnNlZFkgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdGlvbkhlaWdodCA9IE1hdGguYWJzKHNlbGVjdGlvbkhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoem9vbXR5cGUgPT09ICd4Jykge1xuICAgICAgICAgIHNlbGVjdGlvblJlY3QgPSB7XG4gICAgICAgICAgICB4OiBpbnZlcnNlZFggPyBzdGFydFggLSBzZWxlY3Rpb25XaWR0aCA6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogc2VsZWN0aW9uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh6b29tdHlwZSA9PT0gJ3knKSB7XG4gICAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiBpbnZlcnNlZFkgPyBzdGFydFkgLSBzZWxlY3Rpb25IZWlnaHQgOiBzdGFydFksXG4gICAgICAgICAgICB3aWR0aDogdy5nbG9iYWxzLmdyaWRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogc2VsZWN0aW9uSGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3Rpb25SZWN0ID0ge1xuICAgICAgICAgICAgeDogaW52ZXJzZWRYID8gc3RhcnRYIC0gc2VsZWN0aW9uV2lkdGggOiBzdGFydFgsXG4gICAgICAgICAgICB5OiBpbnZlcnNlZFkgPyBzdGFydFkgLSBzZWxlY3Rpb25IZWlnaHQgOiBzdGFydFksXG4gICAgICAgICAgICB3aWR0aDogc2VsZWN0aW9uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNlbGVjdGlvbkhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtZS5kcmF3U2VsZWN0aW9uUmVjdChzZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgbWUuc2VsZWN0aW9uRHJhZ2dpbmcoJ3Jlc2l6aW5nJyk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25SZWN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZWxlY3Rpb25EcmFnZ2luZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdGlvbkRyYWdnaW5nKHR5cGUsIGUpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4eVJhdGlvcyA9IHRoaXMueHlSYXRpb3M7XG4gICAgICAgIHZhciBzZWxSZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0O1xuICAgICAgICB2YXIgdGltZXJJbnRlcnZhbCA9IDA7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdyZXNpemluZycpIHtcbiAgICAgICAgICB0aW1lckludGVydmFsID0gMzA7XG4gICAgICAgIH0gLy8gdXBkYXRlIHNlbGVjdGlvbiB3aGVuIHNlbGVjdGlvbiByZWN0IGlzIGRyYWdnZWRcblxuXG4gICAgICAgIHZhciBnZXRTZWxBdHRyID0gZnVuY3Rpb24gZ2V0U2VsQXR0cihhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc2VsUmVjdC5ub2RlLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRyYWdnZWRQcm9wcyA9IHtcbiAgICAgICAgICB4OiBnZXRTZWxBdHRyKCd4JyksXG4gICAgICAgICAgeTogZ2V0U2VsQXR0cigneScpLFxuICAgICAgICAgIHdpZHRoOiBnZXRTZWxBdHRyKCd3aWR0aCcpLFxuICAgICAgICAgIGhlaWdodDogZ2V0U2VsQXR0cignaGVpZ2h0JylcbiAgICAgICAgfTtcbiAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGlvbiA9IGRyYWdnZWRQcm9wczsgLy8gdXBkYXRlIHNlbGVjdGlvbiBlbmRzXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uID09PSAnZnVuY3Rpb24nICYmIHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgLy8gYSBzbWFsbCBkZWJvdW5jZXIgaXMgcmVxdWlyZWQgd2hlbiByZXNpemluZyB0byBhdm9pZCBmcmVlemluZyB0aGUgY2hhcnRcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53Lmdsb2JhbHMuc2VsZWN0aW9uUmVzaXplVGltZXIpO1xuICAgICAgICAgIHRoaXMudy5nbG9iYWxzLnNlbGVjdGlvblJlc2l6ZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdyaWRSZWN0RGltID0gX3RoaXMzLmdyaWRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHNlbFJlY3Qubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBtaW5YID0gdy5nbG9iYWxzLnhBeGlzU2NhbGUubmljZU1pbiArIChzZWxlY3Rpb25SZWN0LmxlZnQgLSBncmlkUmVjdERpbS5sZWZ0KSAqIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgICAgIHZhciBtYXhYID0gdy5nbG9iYWxzLnhBeGlzU2NhbGUubmljZU1pbiArIChzZWxlY3Rpb25SZWN0LnJpZ2h0IC0gZ3JpZFJlY3REaW0ubGVmdCkgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgICAgICB2YXIgbWluWSA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLm5pY2VNaW4gKyAoZ3JpZFJlY3REaW0uYm90dG9tIC0gc2VsZWN0aW9uUmVjdC5ib3R0b20pICogeHlSYXRpb3MueVJhdGlvWzBdO1xuICAgICAgICAgICAgdmFyIG1heFkgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5uaWNlTWF4IC0gKHNlbGVjdGlvblJlY3QudG9wIC0gZ3JpZFJlY3REaW0udG9wKSAqIHh5UmF0aW9zLnlSYXRpb1swXTtcbiAgICAgICAgICAgIHZhciB4eUF4aXMgPSB7XG4gICAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgICAgbWluOiBtaW5YLFxuICAgICAgICAgICAgICAgIG1heDogbWF4WFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB5YXhpczoge1xuICAgICAgICAgICAgICAgIG1pbjogbWluWSxcbiAgICAgICAgICAgICAgICBtYXg6IG1heFlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24oX3RoaXMzLmN0eCwgeHlBeGlzKTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmJydXNoLmVuYWJsZWQgJiYgdy5jb25maWcuY2hhcnQuZXZlbnRzLmJydXNoU2Nyb2xsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuYnJ1c2hTY3JvbGxlZChfdGhpczMuY3R4LCB4eUF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVySW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNlbGVjdGlvbkRyYXduXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0aW9uRHJhd24oX3JlZjQpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBfcmVmNC5jb250ZXh0LFxuICAgICAgICAgICAgem9vbXR5cGUgPSBfcmVmNC56b29tdHlwZTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICAgIHZhciB4eVJhdGlvcyA9IHRoaXMueHlSYXRpb3M7XG4gICAgICAgIHZhciB0b29sYmFyID0gdGhpcy5jdHgudG9vbGJhcjtcblxuICAgICAgICBpZiAobWUuc3RhcnRYID4gbWUuZW5kWCkge1xuICAgICAgICAgIHZhciB0ZW1wWCA9IG1lLnN0YXJ0WDtcbiAgICAgICAgICBtZS5zdGFydFggPSBtZS5lbmRYO1xuICAgICAgICAgIG1lLmVuZFggPSB0ZW1wWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5zdGFydFkgPiBtZS5lbmRZKSB7XG4gICAgICAgICAgdmFyIHRlbXBZID0gbWUuc3RhcnRZO1xuICAgICAgICAgIG1lLnN0YXJ0WSA9IG1lLmVuZFk7XG4gICAgICAgICAgbWUuZW5kWSA9IHRlbXBZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhMb3dlc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHhIaWdoZXN0VmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNSYW5nZUJhcikge1xuICAgICAgICAgIHhMb3dlc3RWYWx1ZSA9IHcuZ2xvYmFscy54QXhpc1NjYWxlLm5pY2VNaW4gKyBtZS5zdGFydFggKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgICAgeEhpZ2hlc3RWYWx1ZSA9IHcuZ2xvYmFscy54QXhpc1NjYWxlLm5pY2VNaW4gKyBtZS5lbmRYICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhMb3dlc3RWYWx1ZSA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLm5pY2VNaW4gKyBtZS5zdGFydFggKiB4eVJhdGlvcy5pbnZlcnRlZFlSYXRpbztcbiAgICAgICAgICB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1pbiArIG1lLmVuZFggKiB4eVJhdGlvcy5pbnZlcnRlZFlSYXRpbztcbiAgICAgICAgfSAvLyBUT0RPOiB3ZSB3aWxsIGNvbnNpZGVyIHRoZSAxc3QgeSBheGlzIHZhbHVlcyBoZXJlIGZvciBnZXR0aW5nIGhpZ2hlc3QgYW5kIGxvd2VzdCB5XG5cblxuICAgICAgICB2YXIgeUhpZ2hlc3RWYWx1ZSA9IFtdO1xuICAgICAgICB2YXIgeUxvd2VzdFZhbHVlID0gW107XG4gICAgICAgIHcuY29uZmlnLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgICAgeUhpZ2hlc3RWYWx1ZS5wdXNoKHcuZ2xvYmFscy55QXhpc1NjYWxlW2luZGV4XS5uaWNlTWF4IC0geHlSYXRpb3MueVJhdGlvW2luZGV4XSAqIG1lLnN0YXJ0WSk7XG4gICAgICAgICAgeUxvd2VzdFZhbHVlLnB1c2gody5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLm5pY2VNYXggLSB4eVJhdGlvcy55UmF0aW9baW5kZXhdICogbWUuZW5kWSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtZS5kcmFnZ2VkICYmIChtZS5kcmFnWCA+IDEwIHx8IG1lLmRyYWdZID4gMTApICYmIHhMb3dlc3RWYWx1ZSAhPT0geEhpZ2hlc3RWYWx1ZSkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciB5YXhpcyA9IFV0aWxzJDEuY2xvbmUody5nbG9iYWxzLmluaXRpYWxDb25maWcueWF4aXMpO1xuICAgICAgICAgICAgdmFyIHhheGlzID0gVXRpbHMkMS5jbG9uZSh3Lmdsb2JhbHMuaW5pdGlhbENvbmZpZy54YXhpcyk7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuem9vbWVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYykge1xuICAgICAgICAgICAgICB4TG93ZXN0VmFsdWUgPSBNYXRoLmZsb29yKHhMb3dlc3RWYWx1ZSk7XG4gICAgICAgICAgICAgIHhIaWdoZXN0VmFsdWUgPSBNYXRoLmZsb29yKHhIaWdoZXN0VmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmICh4TG93ZXN0VmFsdWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgeExvd2VzdFZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoeEhpZ2hlc3RWYWx1ZSAtIHhMb3dlc3RWYWx1ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICB4SGlnaGVzdFZhbHVlID0geExvd2VzdFZhbHVlICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoem9vbXR5cGUgPT09ICd4eScgfHwgem9vbXR5cGUgPT09ICd4Jykge1xuICAgICAgICAgICAgICB4YXhpcyA9IHtcbiAgICAgICAgICAgICAgICBtaW46IHhMb3dlc3RWYWx1ZSxcbiAgICAgICAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHpvb210eXBlID09PSAneHknIHx8IHpvb210eXBlID09PSAneScpIHtcbiAgICAgICAgICAgICAgeWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB5YXhpc1tpbmRleF0ubWluID0geUxvd2VzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgICB5YXhpc1tpbmRleF0ubWF4ID0geUhpZ2hlc3RWYWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuem9vbS5hdXRvU2NhbGVZYXhpcykge1xuICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBuZXcgUmFuZ2UkMShtZS5jdHgpO1xuICAgICAgICAgICAgICB5YXhpcyA9IHNjYWxlLmF1dG9TY2FsZVkobWUuY3R4LCB5YXhpcywge1xuICAgICAgICAgICAgICAgIHhheGlzOiB4YXhpc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvb2xiYXIpIHtcbiAgICAgICAgICAgICAgdmFyIGJlZm9yZVpvb21SYW5nZSA9IHRvb2xiYXIuZ2V0QmVmb3JlWm9vbVJhbmdlKHhheGlzLCB5YXhpcyk7XG5cbiAgICAgICAgICAgICAgaWYgKGJlZm9yZVpvb21SYW5nZSkge1xuICAgICAgICAgICAgICAgIHhheGlzID0gYmVmb3JlWm9vbVJhbmdlLnhheGlzID8gYmVmb3JlWm9vbVJhbmdlLnhheGlzIDogeGF4aXM7XG4gICAgICAgICAgICAgICAgeWF4aXMgPSBiZWZvcmVab29tUmFuZ2UueWF4aXMgPyBiZWZvcmVab29tUmFuZ2UueWF4aXMgOiB5YXhpcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgeGF4aXM6IHhheGlzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGNoYXJ0IGluIGEgZ3JvdXAsIHByZXZlbnQgeWF4aXMgdXBkYXRlIGhlcmVcbiAgICAgICAgICAgICAgLy8gZml4IGlzc3VlICM2NTBcbiAgICAgICAgICAgICAgb3B0aW9ucy55YXhpcyA9IHlheGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5jdHgudXBkYXRlSGVscGVycy5fdXBkYXRlT3B0aW9ucyhvcHRpb25zLCBmYWxzZSwgbWUudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy56b29tZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdG9vbGJhci56b29tQ2FsbGJhY2soeGF4aXMsIHlheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgX3lheGlzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBfeGF4aXMgPSBudWxsO1xuICAgICAgICAgICAgX3hheGlzID0ge1xuICAgICAgICAgICAgICBtaW46IHhMb3dlc3RWYWx1ZSxcbiAgICAgICAgICAgICAgbWF4OiB4SGlnaGVzdFZhbHVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoem9vbXR5cGUgPT09ICd4eScgfHwgem9vbXR5cGUgPT09ICd5Jykge1xuICAgICAgICAgICAgICBfeWF4aXMgPSBVdGlscyQxLmNsb25lKHcuY29uZmlnLnlheGlzKTtcblxuICAgICAgICAgICAgICBfeWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfeWF4aXNbaW5kZXhdLm1pbiA9IHlMb3dlc3RWYWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgICAgX3lheGlzW2luZGV4XS5tYXggPSB5SGlnaGVzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHcuZ2xvYmFscy5zZWxlY3Rpb24gPSBtZS5zZWxlY3Rpb247XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uKG1lLmN0eCwge1xuICAgICAgICAgICAgICAgIHhheGlzOiBfeGF4aXMsXG4gICAgICAgICAgICAgICAgeWF4aXM6IF95YXhpc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGFuRHJhZ2dpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5EcmFnZ2luZyhfcmVmNSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IF9yZWY1LmNvbnRleHQ7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbWUgPSBjb250ZXh0OyAvLyBjaGVjayB0byBtYWtlIHN1cmUgdGhlcmUgaXMgZGF0YSB0byBjb21wYXJlIGFnYWluc3RcblxuICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5sYXN0Q2xpZW50UG9zaXRpb24ueCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGNoYW5nZSBmcm9tIGxhc3QgcG9zaXRpb24gdG8gdGhpcyBwb3NpdGlvblxuICAgICAgICAgIHZhciBkZWx0YVggPSB3Lmdsb2JhbHMubGFzdENsaWVudFBvc2l0aW9uLnggLSBtZS5jbGllbnRYO1xuICAgICAgICAgIHZhciBkZWx0YVkgPSB3Lmdsb2JhbHMubGFzdENsaWVudFBvc2l0aW9uLnkgLSBtZS5jbGllbnRZOyAvLyBjaGVjayB3aGljaCBkaXJlY3Rpb24gaGFkIHRoZSBoaWdoZXN0IGFtcGxpdHVkZSBhbmQgdGhlbiBmaWd1cmUgb3V0IGRpcmVjdGlvbiBieSBjaGVja2luZyBpZiB0aGUgdmFsdWUgaXMgZ3JlYXRlciBvciBsZXNzIHRoYW4gemVyb1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhWCkgPiBNYXRoLmFicyhkZWx0YVkpICYmIGRlbHRhWCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZURpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlbHRhWCkgPiBNYXRoLmFicyhkZWx0YVkpICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZURpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZWx0YVkpID4gTWF0aC5hYnMoZGVsdGFYKSAmJiBkZWx0YVkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSAndXAnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGVsdGFZKSA+IE1hdGguYWJzKGRlbHRhWCkgJiYgZGVsdGFZIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uID0gJ2Rvd24nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBzZXQgdGhlIG5ldyBsYXN0IHBvc2l0aW9uIHRvIHRoZSBjdXJyZW50IGZvciBuZXh0IHRpbWUgKHRvIGdldCB0aGUgcG9zaXRpb24gb2YgZHJhZylcblxuXG4gICAgICAgIHcuZ2xvYmFscy5sYXN0Q2xpZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogbWUuY2xpZW50WCxcbiAgICAgICAgICB5OiBtZS5jbGllbnRZXG4gICAgICAgIH07XG4gICAgICAgIHZhciB4TG93ZXN0VmFsdWUgPSB3Lmdsb2JhbHMuaXNSYW5nZUJhciA/IHcuZ2xvYmFscy5taW5ZIDogdy5nbG9iYWxzLm1pblg7XG4gICAgICAgIHZhciB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLmlzUmFuZ2VCYXIgPyB3Lmdsb2JhbHMubWF4WSA6IHcuZ2xvYmFscy5tYXhYOyAvLyBvbiBhIGNhdGVnb3J5LCB3ZSBkb24ndCBwYW4gY29udGludW9zbHkgYXMgaXQgY2F1c2VzIGJ1Z3NcblxuICAgICAgICBpZiAoIXcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYykge1xuICAgICAgICAgIG1lLnBhblNjcm9sbGVkKHhMb3dlc3RWYWx1ZSwgeEhpZ2hlc3RWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVsYXllZFBhblNjcm9sbGVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsYXllZFBhblNjcm9sbGVkKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIG5ld01pblggPSB3Lmdsb2JhbHMubWluWDtcbiAgICAgICAgdmFyIG5ld01heFggPSB3Lmdsb2JhbHMubWF4WDtcbiAgICAgICAgdmFyIGNlbnRlclggPSAody5nbG9iYWxzLm1heFggLSB3Lmdsb2JhbHMubWluWCkgLyAyO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdmVEaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIG5ld01pblggPSB3Lmdsb2JhbHMubWluWCArIGNlbnRlclg7XG4gICAgICAgICAgbmV3TWF4WCA9IHcuZ2xvYmFscy5tYXhYICsgY2VudGVyWDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vdmVEaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBuZXdNaW5YID0gdy5nbG9iYWxzLm1pblggLSBjZW50ZXJYO1xuICAgICAgICAgIG5ld01heFggPSB3Lmdsb2JhbHMubWF4WCAtIGNlbnRlclg7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNaW5YID0gTWF0aC5mbG9vcihuZXdNaW5YKTtcbiAgICAgICAgbmV3TWF4WCA9IE1hdGguZmxvb3IobmV3TWF4WCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsZWRDaGFydCh7XG4gICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgIG1pbjogbmV3TWluWCxcbiAgICAgICAgICAgIG1heDogbmV3TWF4WFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgbmV3TWluWCwgbmV3TWF4WCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhblNjcm9sbGVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFuU2Nyb2xsZWQoeExvd2VzdFZhbHVlLCB4SGlnaGVzdFZhbHVlKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLnh5UmF0aW9zO1xuICAgICAgICB2YXIgeWF4aXMgPSBVdGlscyQxLmNsb25lKHcuZ2xvYmFscy5pbml0aWFsQ29uZmlnLnlheGlzKTtcbiAgICAgICAgdmFyIHhSYXRpbyA9IHh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgdmFyIG1pblggPSB3Lmdsb2JhbHMubWluWDtcbiAgICAgICAgdmFyIG1heFggPSB3Lmdsb2JhbHMubWF4WDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzUmFuZ2VCYXIpIHtcbiAgICAgICAgICB4UmF0aW8gPSB4eVJhdGlvcy5pbnZlcnRlZFlSYXRpbztcbiAgICAgICAgICBtaW5YID0gdy5nbG9iYWxzLm1pblk7XG4gICAgICAgICAgbWF4WCA9IHcuZ2xvYmFscy5tYXhZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW92ZURpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgeExvd2VzdFZhbHVlID0gbWluWCArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyAxNSAqIHhSYXRpbztcbiAgICAgICAgICB4SGlnaGVzdFZhbHVlID0gbWF4WCArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyAxNSAqIHhSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vdmVEaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB4TG93ZXN0VmFsdWUgPSBtaW5YIC0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDE1ICogeFJhdGlvO1xuICAgICAgICAgIHhIaWdoZXN0VmFsdWUgPSBtYXhYIC0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDE1ICogeFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNSYW5nZUJhcikge1xuICAgICAgICAgIGlmICh4TG93ZXN0VmFsdWUgPCB3Lmdsb2JhbHMuaW5pdGlhbE1pblggfHwgeEhpZ2hlc3RWYWx1ZSA+IHcuZ2xvYmFscy5pbml0aWFsTWF4WCkge1xuICAgICAgICAgICAgeExvd2VzdFZhbHVlID0gbWluWDtcbiAgICAgICAgICAgIHhIaWdoZXN0VmFsdWUgPSBtYXhYO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4YXhpcyA9IHtcbiAgICAgICAgICBtaW46IHhMb3dlc3RWYWx1ZSxcbiAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuem9vbS5hdXRvU2NhbGVZYXhpcykge1xuICAgICAgICAgIHZhciBzY2FsZSA9IG5ldyBSYW5nZSQxKHRoaXMuY3R4KTtcbiAgICAgICAgICB5YXhpcyA9IHNjYWxlLmF1dG9TY2FsZVkodGhpcy5jdHgsIHlheGlzLCB7XG4gICAgICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBtaW46IHhMb3dlc3RWYWx1ZSxcbiAgICAgICAgICAgIG1heDogeEhpZ2hlc3RWYWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgICAgLy8gaWYgY2hhcnQgaW4gYSBncm91cCwgcHJldmVudCB5YXhpcyB1cGRhdGUgaGVyZVxuICAgICAgICAgIC8vIGZpeCBpc3N1ZSAjNjUwXG4gICAgICAgICAgb3B0aW9ucy55YXhpcyA9IHlheGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxlZENoYXJ0KG9wdGlvbnMsIHhMb3dlc3RWYWx1ZSwgeEhpZ2hlc3RWYWx1ZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVwZGF0ZVNjcm9sbGVkQ2hhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTY3JvbGxlZENoYXJ0KG9wdGlvbnMsIHhMb3dlc3RWYWx1ZSwgeEhpZ2hlc3RWYWx1ZSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICB0aGlzLmN0eC51cGRhdGVIZWxwZXJzLl91cGRhdGVPcHRpb25zKG9wdGlvbnMsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2Nyb2xsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2Nyb2xsZWQodGhpcy5jdHgsIHtcbiAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgIG1pbjogeExvd2VzdFZhbHVlLFxuICAgICAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBab29tUGFuU2VsZWN0aW9uO1xuICB9KFRvb2xiYXIpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIFRvb2x0aXAuVXRpbHMgQ2xhc3MgdG8gc3VwcG9ydCBUb29sdGlwIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtb2R1bGUgVG9vbHRpcC5VdGlsc1xuICAgKiovXG5cbiAgdmFyIFV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVdGlscyh0b29sdGlwQ29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWxzKTtcblxuICAgICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICAgIHRoaXMuY3R4ID0gdG9vbHRpcENvbnRleHQuY3R4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiogV2hlbiBob3ZlcmluZyBvdmVyIHNlcmllcywgeW91IG5lZWQgdG8gY2FwdHVyZSB3aGljaCBzZXJpZXMgaXMgYmVpbmcgaG92ZXJlZCBvbi5cbiAgICAgKiogVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBib3RoIGNhcHR1cmVkc2VyaWVzIGluZGV4IGFzIHdlbGwgYXMgaW5uZXIgaW5kZXggb2YgdGhhdCBzZXJpZXNcbiAgICAgKiBAbWVtYmVyb2YgVXRpbHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH1cbiAgICAgKiAtIGhvdmVyQXJlYSA9IHRoZSByZWN0IG9uIHdoaWNoIHVzZXIgaG92ZXJzXG4gICAgICogLSBlbEdyaWQgPSBkaW1lbnNpb25zIG9mIHRoZSBob3ZlciByZWN0IChpdCBjYW4gYmUgZGlmZmVyZW50IHRoYW4gaG92ZXJhcmVhKVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVXRpbHMsIFt7XG4gICAgICBrZXk6IFwiZ2V0TmVhcmVzdFZhbHVlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5lYXJlc3RWYWx1ZXMoX3JlZikge1xuICAgICAgICB2YXIgaG92ZXJBcmVhID0gX3JlZi5ob3ZlckFyZWEsXG4gICAgICAgICAgICBlbEdyaWQgPSBfcmVmLmVsR3JpZCxcbiAgICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgaG92ZXJXaWR0aCA9IHNlcmllc0JvdW5kLndpZHRoO1xuICAgICAgICB2YXIgaG92ZXJIZWlnaHQgPSBzZXJpZXNCb3VuZC5oZWlnaHQ7XG4gICAgICAgIHZhciB4RGl2aXNvciA9IGhvdmVyV2lkdGggLyAody5nbG9iYWxzLmRhdGFQb2ludHMgLSAxKTtcbiAgICAgICAgdmFyIHlEaXZpc29yID0gaG92ZXJIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgdmFyIGhhc0JhcnMgPSB0aGlzLmhhc0JhcnMoKTtcblxuICAgICAgICBpZiAoKHcuZ2xvYmFscy5jb21ib0NoYXJ0cyB8fCBoYXNCYXJzKSAmJiAhdy5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgeERpdmlzb3IgPSBob3ZlcldpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaG92ZXJYID0gY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnQgLSB3Lmdsb2JhbHMuYmFyUGFkRm9yTnVtZXJpY0F4aXM7XG4gICAgICAgIHZhciBob3ZlclkgPSBjbGllbnRZIC0gc2VyaWVzQm91bmQudG9wO1xuICAgICAgICB2YXIgbm90SW5SZWN0ID0gaG92ZXJYIDwgMCB8fCBob3ZlclkgPCAwIHx8IGhvdmVyWCA+IGhvdmVyV2lkdGggfHwgaG92ZXJZID4gaG92ZXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKG5vdEluUmVjdCkge1xuICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcmluZy16b29tJyk7XG4gICAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyaW5nLXBhbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcmluZy1wYW4nKTtcbiAgICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QuYWRkKCdob3ZlcmluZy16b29tJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3Lmdsb2JhbHMucGFuRW5hYmxlZCkge1xuICAgICAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyaW5nLXpvb20nKTtcbiAgICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QuYWRkKCdob3ZlcmluZy1wYW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IE1hdGgucm91bmQoaG92ZXJYIC8geERpdmlzb3IpO1xuICAgICAgICB2YXIgakhvcnogPSBNYXRoLmZsb29yKGhvdmVyWSAvIHlEaXZpc29yKTtcblxuICAgICAgICBpZiAoaGFzQmFycyAmJiAhdy5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgaiA9IE1hdGguY2VpbChob3ZlclggLyB4RGl2aXNvcik7XG4gICAgICAgICAgaiA9IGogLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhcHR1cmVkU2VyaWVzID0gbnVsbDtcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSBudWxsO1xuICAgICAgICB2YXIgc2VyaWVzWFZhbEFyciA9IHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzLm1hcChmdW5jdGlvbiAoc2VyaWVzWFZhbCkge1xuICAgICAgICAgIHJldHVybiBzZXJpZXNYVmFsLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzJDEuaXNOdW1iZXIocyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VyaWVzWVZhbEFyciA9IHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzLm1hcChmdW5jdGlvbiAoc2VyaWVzWVZhbCkge1xuICAgICAgICAgIHJldHVybiBzZXJpZXNZVmFsLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzJDEuaXNOdW1iZXIocyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pOyAvLyBpZiBYIGF4aXMgdHlwZSBpcyBub3QgY2F0ZWdvcnkgYW5kIHRvb2x0aXAgaXMgbm90IHNoYXJlZCwgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgdGhlIGN1cnNvciBwb3NpdGlvbiBhbmQgZ2V0IHRoZSBuZWFyZXN0IHZhbHVlXG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgLy8gQ2hhbmdlIG9yaWdpbiBvZiBjdXJzb3IgcG9zaXRpb24gc28gdGhhdCB3ZSBjYW4gY29tcHV0ZSB0aGUgcmVsYXRpdmUgbmVhcmVzdCBwb2ludCB0byB0aGUgY3Vyc29yIG9uIG91ciBjaGFydFxuICAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byBzY2FsZSBiZWNhdXNlIGFsbCBwb2ludHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMubGVmdCBhbmQgYm91bmRzLnRvcCA9PiBvcmlnaW4gaXMgdmlydHVhbGx5ICgwLCAwKVxuICAgICAgICAgIHZhciBjaGFydEdyaWRFbCA9IHRoaXMudHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICAgICAgdmFyIGNoYXJ0R3JpZEVsQm91bmRpbmdSZWN0ID0gY2hhcnRHcmlkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkSG92ZXJYID0gaG92ZXJYICogKGNoYXJ0R3JpZEVsQm91bmRpbmdSZWN0LndpZHRoIC8gaG92ZXJXaWR0aCk7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkSG92ZXJZID0gaG92ZXJZICogKGNoYXJ0R3JpZEVsQm91bmRpbmdSZWN0LmhlaWdodCAvIGhvdmVySGVpZ2h0KTtcbiAgICAgICAgICBjbG9zZXN0ID0gdGhpcy5jbG9zZXN0SW5NdWx0aUFycmF5KHRyYW5zZm9ybWVkSG92ZXJYLCB0cmFuc2Zvcm1lZEhvdmVyWSwgc2VyaWVzWFZhbEFyciwgc2VyaWVzWVZhbEFycik7XG4gICAgICAgICAgY2FwdHVyZWRTZXJpZXMgPSBjbG9zZXN0LmluZGV4O1xuICAgICAgICAgIGogPSBjbG9zZXN0Lmo7XG5cbiAgICAgICAgICBpZiAoY2FwdHVyZWRTZXJpZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWwgcHVzaCwgaXQgc2hvdWxkIGJlIGEgbGl0dGxlIHNtYWxsZXIgdGhhbiB0aGUgMXN0IHZhbFxuICAgICAgICAgICAgc2VyaWVzWFZhbEFyciA9IHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW2NhcHR1cmVkU2VyaWVzXTtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSB0aGlzLmNsb3Nlc3RJbkFycmF5KHRyYW5zZm9ybWVkSG92ZXJYLCBzZXJpZXNYVmFsQXJyKTtcbiAgICAgICAgICAgIGogPSBjbG9zZXN0LmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5jYXB0dXJlZFNlcmllc0luZGV4ID0gY2FwdHVyZWRTZXJpZXMgPT09IG51bGwgPyAtMSA6IGNhcHR1cmVkU2VyaWVzO1xuICAgICAgICBpZiAoIWogfHwgaiA8IDEpIGogPSAwO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmNhcHR1cmVkRGF0YVBvaW50SW5kZXggPSBqSG9yejtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuY2FwdHVyZWREYXRhUG9pbnRJbmRleCA9IGo7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhcHR1cmVkU2VyaWVzOiBjYXB0dXJlZFNlcmllcyxcbiAgICAgICAgICBqOiB3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsID8gakhvcnogOiBqLFxuICAgICAgICAgIGhvdmVyWDogaG92ZXJYLFxuICAgICAgICAgIGhvdmVyWTogaG92ZXJZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3Nlc3RJbk11bHRpQXJyYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0SW5NdWx0aUFycmF5KGhvdmVyWCwgaG92ZXJZLCBYYXJyYXlzLCBZYXJyYXlzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSAwO1xuICAgICAgICB2YXIgY3VyckluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGogPSAtMTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgYWN0aXZlSW5kZXggPSB0aGlzLmdldEZpcnN0QWN0aXZlWEFycmF5KFhhcnJheXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJJbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VyclggPSBYYXJyYXlzW2FjdGl2ZUluZGV4XVswXTtcbiAgICAgICAgdmFyIGRpZmZYID0gTWF0aC5hYnMoaG92ZXJYIC0gY3VyclgpOyAvLyBmaW5kIG5lYXJlc3QgcG9pbnQgb24geC1heGlzXG5cbiAgICAgICAgWGFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uIChhcnJYKSB7XG4gICAgICAgICAgYXJyWC5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpWCkge1xuICAgICAgICAgICAgdmFyIG5ld0RpZmYgPSBNYXRoLmFicyhob3ZlclggLSB4KTtcblxuICAgICAgICAgICAgaWYgKG5ld0RpZmYgPD0gZGlmZlgpIHtcbiAgICAgICAgICAgICAgZGlmZlggPSBuZXdEaWZmO1xuICAgICAgICAgICAgICBqID0gaVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgIC8vIGZpbmQgbmVhcmVzdCBncmFwaCBvbiB5LWF4aXMgcmVsZXZhbnRlZCB0byBuZWFyZXN0IHBvaW50IG9uIHgtYXhpc1xuICAgICAgICAgIHZhciBjdXJyWSA9IFlhcnJheXNbYWN0aXZlSW5kZXhdW2pdO1xuICAgICAgICAgIHZhciBkaWZmWSA9IE1hdGguYWJzKGhvdmVyWSAtIGN1cnJZKTtcbiAgICAgICAgICBjdXJySW5kZXggPSBhY3RpdmVJbmRleDtcbiAgICAgICAgICBZYXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGFyclksIGlBWSkge1xuICAgICAgICAgICAgdmFyIG5ld0RpZmYgPSBNYXRoLmFicyhob3ZlclkgLSBhcnJZW2pdKTtcblxuICAgICAgICAgICAgaWYgKG5ld0RpZmYgPD0gZGlmZlkpIHtcbiAgICAgICAgICAgICAgZGlmZlkgPSBuZXdEaWZmO1xuICAgICAgICAgICAgICBjdXJySW5kZXggPSBpQVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGV4OiBjdXJySW5kZXgsXG4gICAgICAgICAgajogalxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRGaXJzdEFjdGl2ZVhBcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpcnN0QWN0aXZlWEFycmF5KFhhcnJheXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBhY3RpdmVJbmRleCA9IDA7XG4gICAgICAgIHZhciBmaXJzdEFjdGl2ZVNlcmllc0luZGV4ID0gWGFycmF5cy5tYXAoZnVuY3Rpb24gKHhhcnIsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHhhcnIubGVuZ3RoID4gMCA/IGluZGV4IDogLTE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgZmlyc3RBY3RpdmVTZXJpZXNJbmRleC5sZW5ndGg7IGErKykge1xuICAgICAgICAgIGlmIChmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdICE9PSAtMSAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGEpID09PSAtMSAmJiB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGEpID09PSAtMSkge1xuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGl2ZUluZGV4O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9zZXN0SW5BcnJheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3Nlc3RJbkFycmF5KHZhbCwgYXJyKSB7XG4gICAgICAgIHZhciBjdXJyID0gYXJyWzBdO1xuICAgICAgICB2YXIgY3VyckluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh2YWwgLSBjdXJyKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuZXdkaWZmID0gTWF0aC5hYnModmFsIC0gYXJyW2ldKTtcblxuICAgICAgICAgIGlmIChuZXdkaWZmIDwgZGlmZikge1xuICAgICAgICAgICAgZGlmZiA9IG5ld2RpZmY7XG4gICAgICAgICAgICBjdXJySW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXg6IGN1cnJJbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBzZXJpZXMsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgZGlmZmVyZW50IHggdmFsdWVzIGZvciBlYWNoIHNlcmllcy5cbiAgICAgICAqIEJ1dCBpdCBtYXkgYmUgcG9zc2libGUgaW4gdGhvc2UgbXVsdGlwbGUgc2VyaWVzLCB0aGF0IHRoZXJlIGlzIHNhbWUgeCB2YWx1ZSBmb3IgMiBvciBtb3JlXG4gICAgICAgKiBzZXJpZXMuXG4gICAgICAgKiBAbWVtYmVyb2YgVXRpbHNcbiAgICAgICAqIEBwYXJhbSB7aW50fVxuICAgICAgICogLSBqID0gaXMgdGhlIGlubmVyIGluZGV4IG9mIHNlcmllcyAtPiAoc2VyaWVzW2ldW2pdKVxuICAgICAgICogQHJldHVybiB7Ym9vbH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImlzWG92ZXJsYXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1hvdmVybGFwKGopIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4U2FtZUZvckFsbFNlcmllc0pBcnIgPSBbXTtcbiAgICAgICAgdmFyIHNlcmllc1ggPSB3Lmdsb2JhbHMuc2VyaWVzWC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHNbMF0gIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VyaWVzWC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXNYLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNYW2ldW2pdICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc2VyaWVzWFtpICsgMV1bal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGlmIChzZXJpZXNYW2ldW2pdICE9PSBzZXJpZXNYW2kgKyAxXVtqXSkge1xuICAgICAgICAgICAgICAgIHhTYW1lRm9yQWxsU2VyaWVzSkFyci5wdXNoKCd1bkVxdWFsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeFNhbWVGb3JBbGxTZXJpZXNKQXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc0luaXRpYWxTZXJpZXNTYW1lTGVuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbml0aWFsU2VyaWVzU2FtZUxlbigpIHtcbiAgICAgICAgdmFyIHNhbWVMZW4gPSB0cnVlO1xuICAgICAgICB2YXIgaW5pdGlhbFNlcmllcyA9IHRoaXMudy5nbG9iYWxzLmluaXRpYWxTZXJpZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsU2VyaWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGlmIChpbml0aWFsU2VyaWVzW2ldLmRhdGEubGVuZ3RoICE9PSBpbml0aWFsU2VyaWVzW2kgKyAxXS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgc2FtZUxlbiA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNhbWVMZW47XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEJhcnNIZWlnaHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXJzSGVpZ2h0KGFsbGJhcnMpIHtcbiAgICAgICAgdmFyIGJhcnMgPSBfdG9Db25zdW1hYmxlQXJyYXkoYWxsYmFycyk7XG5cbiAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gYmFycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYmFyKSB7XG4gICAgICAgICAgcmV0dXJuIGFjYyArIGJhci5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRFbE1hcmtlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbE1hcmtlcnMoY2FwdHVyZWRTZXJpZXMpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIC5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzLXdyYXAgPiAqIGluY2x1ZGVzIG1hcmtlciBncm91cHMgZm9yIHdoaWNoIHRoZVxuICAgICAgICAvLyAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyBjbGFzcyBpcyBub3QgYWRkZWQgZHVlIHRvIG51bGwgdmFsdWVzIG9yIGRpc2NyZXRlIG1hcmtlcnNcbiAgICAgICAgaWYgKHR5cGVvZiBjYXB0dXJlZFNlcmllcyA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoY2FwdHVyZWRTZXJpZXMsIFwiJ10gLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCA+ICpcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCA+IConKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0QWxsTWFya2Vyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbE1hcmtlcnMoKSB7XG4gICAgICAgIC8vIGZpcnN0IGdldCBhbGwgbWFya2VyIHBhcmVudHMuIFRoaXMgcGFyZW50IGNsYXNzIGNvbnRhaW5zIHNlcmllcy1pbmRleFxuICAgICAgICAvLyB3aGljaCBoZWxwcyB0byBzb3J0IHRoZSBtYXJrZXJzIGFzIHRoZXkgYXJlIGR5bmFtaWNcbiAgICAgICAgdmFyIG1hcmtlcnNXcmFwcyA9IHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCcpO1xuICAgICAgICBtYXJrZXJzV3JhcHMgPSBfdG9Db25zdW1hYmxlQXJyYXkobWFya2Vyc1dyYXBzKTtcbiAgICAgICAgbWFya2Vyc1dyYXBzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICB2YXIgaW5kZXhBID0gTnVtYmVyKGEuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgICB2YXIgaW5kZXhCID0gTnVtYmVyKGIuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgICByZXR1cm4gaW5kZXhCIDwgaW5kZXhBID8gMSA6IGluZGV4QiA+IGluZGV4QSA/IC0xIDogMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICAgIG1hcmtlcnNXcmFwcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKG0ucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbWFya2VyJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhc01hcmtlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNNYXJrZXJzKGNhcHR1cmVkU2VyaWVzKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gdGhpcy5nZXRFbE1hcmtlcnMoY2FwdHVyZWRTZXJpZXMpO1xuICAgICAgICByZXR1cm4gbWFya2Vycy5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRFbEJhcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbEJhcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWJhci1zZXJpZXMsICAuYXBleGNoYXJ0cy1jYW5kbGVzdGljay1zZXJpZXMsIC5hcGV4Y2hhcnRzLWJveFBsb3Qtc2VyaWVzLCAuYXBleGNoYXJ0cy1yYW5nZWJhci1zZXJpZXMnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzQmFyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0JhcnMoKSB7XG4gICAgICAgIHZhciBiYXJzID0gdGhpcy5nZXRFbEJhcnMoKTtcbiAgICAgICAgcmV0dXJuIGJhcnMubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SG92ZXJNYXJrZXJTaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SG92ZXJNYXJrZXJTaXplKGluZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgaG92ZXJTaXplID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplO1xuXG4gICAgICAgIGlmIChob3ZlclNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGhvdmVyU2l6ZSA9IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaW5kZXhdICsgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhvdmVyU2l6ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9nZ2xlQWxsVG9vbHRpcFNlcmllc0dyb3Vwc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUFsbFRvb2x0aXBTZXJpZXNHcm91cHMoc3RhdGUpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgICAgaWYgKHR0Q3R4LmFsbFRvb2x0aXBTZXJpZXNHcm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdHRDdHguYWxsVG9vbHRpcFNlcmllc0dyb3VwcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtc2VyaWVzLWdyb3VwJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWxsVG9vbHRpcFNlcmllc0dyb3VwcyA9IHR0Q3R4LmFsbFRvb2x0aXBTZXJpZXNHcm91cHM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxUb29sdGlwU2VyaWVzR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSAnZW5hYmxlJykge1xuICAgICAgICAgICAgYWxsVG9vbHRpcFNlcmllc0dyb3Vwc1tpXS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWFjdGl2ZScpO1xuICAgICAgICAgICAgYWxsVG9vbHRpcFNlcmllc0dyb3Vwc1tpXS5zdHlsZS5kaXNwbGF5ID0gdy5jb25maWcudG9vbHRpcC5pdGVtcy5kaXNwbGF5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxUb29sdGlwU2VyaWVzR3JvdXBzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtYWN0aXZlJyk7XG4gICAgICAgICAgICBhbGxUb29sdGlwU2VyaWVzR3JvdXBzW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFV0aWxzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgVG9vbHRpcC5MYWJlbHMgQ2xhc3MgdG8gZHJhdyB0ZXh0cyBvbiB0aGUgdG9vbHRpcC5cbiAgICogVGhpcyBmaWxlIGRlYWxzIHdpdGggcHJpbnRpbmcgYWN0dWFsIHRleHQgb24gdGhlIHRvb2x0aXAuXG4gICAqXG4gICAqIEBtb2R1bGUgVG9vbHRpcC5MYWJlbHNcbiAgICoqL1xuXG4gIHZhciBMYWJlbHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhYmVscyh0b29sdGlwQ29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVscyk7XG5cbiAgICAgIHRoaXMudyA9IHRvb2x0aXBDb250ZXh0Lnc7XG4gICAgICB0aGlzLmN0eCA9IHRvb2x0aXBDb250ZXh0LmN0eDtcbiAgICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICAgIHRoaXMudG9vbHRpcFV0aWwgPSBuZXcgVXRpbHModG9vbHRpcENvbnRleHQpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMYWJlbHMsIFt7XG4gICAgICBrZXk6IFwiZHJhd1Nlcmllc1RleHRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1Nlcmllc1RleHRzKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYkc2hhcmVkID0gX3JlZi5zaGFyZWQsXG4gICAgICAgICAgICBzaGFyZWQgPSBfcmVmJHNoYXJlZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkc2hhcmVkLFxuICAgICAgICAgICAgdHRJdGVtcyA9IF9yZWYudHRJdGVtcyxcbiAgICAgICAgICAgIF9yZWYkaSA9IF9yZWYuaSxcbiAgICAgICAgICAgIGkgPSBfcmVmJGkgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGksXG4gICAgICAgICAgICBfcmVmJGogPSBfcmVmLmosXG4gICAgICAgICAgICBqID0gX3JlZiRqID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRqLFxuICAgICAgICAgICAgeTEgPSBfcmVmLnkxLFxuICAgICAgICAgICAgeTIgPSBfcmVmLnkyLFxuICAgICAgICAgICAgZSA9IF9yZWYuZTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuY3VzdG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUN1c3RvbVRvb2x0aXAoe1xuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICB3OiB3XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50b2dnbGVBY3RpdmVJbmFjdGl2ZVNlcmllcyhzaGFyZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzVG9QcmludCh7XG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByaW50TGFiZWxzKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgdHRJdGVtczogdHRJdGVtcyxcbiAgICAgICAgICBzaGFyZWQ6IHNoYXJlZCxcbiAgICAgICAgICBlOiBlXG4gICAgICAgIH0pOyAvLyBSZS1jYWxjdWxhdGUgdG9vbHRpcCBkaW1lbnNpb25zIG5vdyB0aGF0IHdlIGhhdmUgZHJhd24gdGhlIHRleHRcblxuICAgICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy50dEN0eC5nZXRFbFRvb2x0aXAoKTtcbiAgICAgICAgdGhpcy50dEN0eC50b29sdGlwUmVjdC50dFdpZHRoID0gdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICB0aGlzLnR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0ID0gdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJpbnRMYWJlbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludExhYmVscyhfcmVmMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpID0gX3JlZjIuaSxcbiAgICAgICAgICAgIGogPSBfcmVmMi5qLFxuICAgICAgICAgICAgdmFsdWVzID0gX3JlZjIudmFsdWVzLFxuICAgICAgICAgICAgdHRJdGVtcyA9IF9yZWYyLnR0SXRlbXMsXG4gICAgICAgICAgICBzaGFyZWQgPSBfcmVmMi5zaGFyZWQsXG4gICAgICAgICAgICBlID0gX3JlZjIuZTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIHZhciBnb2FsVmFscyA9IFtdO1xuXG4gICAgICAgIHZhciBoYXNHb2FsVmFsdWVzID0gZnVuY3Rpb24gaGFzR29hbFZhbHVlcyhnaSkge1xuICAgICAgICAgIHJldHVybiB3Lmdsb2JhbHMuc2VyaWVzR29hbHNbZ2ldICYmIHcuZ2xvYmFscy5zZXJpZXNHb2Fsc1tnaV1bal0gJiYgQXJyYXkuaXNBcnJheSh3Lmdsb2JhbHMuc2VyaWVzR29hbHNbZ2ldW2pdKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgeFZhbCA9IHZhbHVlcy54VmFsLFxuICAgICAgICAgICAgelZhbCA9IHZhbHVlcy56VmFsLFxuICAgICAgICAgICAgeEF4aXNUVFZhbCA9IHZhbHVlcy54QXhpc1RUVmFsO1xuICAgICAgICB2YXIgc2VyaWVzTmFtZSA9ICcnO1xuICAgICAgICB2YXIgcENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tpXTsgLy8gVGhlIHBDb2xvciBoZXJlIGlzIGZvciB0aGUgbWFya2VycyBpbnNpZGUgdG9vbHRpcFxuXG4gICAgICAgIGlmIChqICE9PSBudWxsICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCkge1xuICAgICAgICAgIHBDb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbal07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCh0LCBpbnZlcnNldCkge1xuICAgICAgICAgIHZhciBmID0gX3RoaXMuZ2V0Rm9ybWF0dGVycyhpKTtcblxuICAgICAgICAgIHNlcmllc05hbWUgPSBfdGhpcy5nZXRTZXJpZXNOYW1lKHtcbiAgICAgICAgICAgIGZuOiBmLnlMYlRpdGxlRm9ybWF0dGVyLFxuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGo6IGpcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAndHJlZW1hcCcpIHtcbiAgICAgICAgICAgIHNlcmllc05hbWUgPSBmLnlMYlRpdGxlRm9ybWF0dGVyKFN0cmluZyh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXS54KSwge1xuICAgICAgICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRJbmRleCA9IHcuY29uZmlnLnRvb2x0aXAuaW52ZXJzZU9yZGVyID8gaW52ZXJzZXQgOiB0O1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICB2YXIgZ2V0VmFsQnlTZXJpZXNJbmRleCA9IGZ1bmN0aW9uIGdldFZhbEJ5U2VyaWVzSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1JhbmdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBfdyRnbG9iYWxzJHNlcmllc1JhbmcsIF93JGdsb2JhbHMkc2VyaWVzUmFuZzIsIF93JGdsb2JhbHMkc2VyaWVzUmFuZzMsIF93JGdsb2JhbHMkc2VyaWVzUmFuZzQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZi55TGJGb3JtYXR0ZXIoKF93JGdsb2JhbHMkc2VyaWVzUmFuZyA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZVN0YXJ0KSA9PT0gbnVsbCB8fCBfdyRnbG9iYWxzJHNlcmllc1JhbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdyRnbG9iYWxzJHNlcmllc1JhbmcyID0gX3ckZ2xvYmFscyRzZXJpZXNSYW5nW2luZGV4XSkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ckZ2xvYmFscyRzZXJpZXNSYW5nMltqXSwge1xuICAgICAgICAgICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICAgIH0pICsgJyAtICcgKyBmLnlMYkZvcm1hdHRlcigoX3ckZ2xvYmFscyRzZXJpZXNSYW5nMyA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZUVuZCkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzQgPSBfdyRnbG9iYWxzJHNlcmllc1JhbmczW2luZGV4XSkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ckZ2xvYmFscyRzZXJpZXNSYW5nNFtqXSwge1xuICAgICAgICAgICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VFbmQsXG4gICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmLnlMYkZvcm1hdHRlcih3Lmdsb2JhbHMuc2VyaWVzW2luZGV4XVtqXSwge1xuICAgICAgICAgICAgICAgIHNlcmllczogdy5nbG9iYWxzLnNlcmllcyxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzaGFyZWQpIHtcbiAgICAgICAgICAgICAgZiA9IF90aGlzLmdldEZvcm1hdHRlcnModEluZGV4KTtcbiAgICAgICAgICAgICAgc2VyaWVzTmFtZSA9IF90aGlzLmdldFNlcmllc05hbWUoe1xuICAgICAgICAgICAgICAgIGZuOiBmLnlMYlRpdGxlRm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0SW5kZXgsXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICAgICAgajogalxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1t0SW5kZXhdO1xuICAgICAgICAgICAgICB2YWwgPSBnZXRWYWxCeVNlcmllc0luZGV4KHRJbmRleCk7XG5cbiAgICAgICAgICAgICAgaWYgKGhhc0dvYWxWYWx1ZXModEluZGV4KSkge1xuICAgICAgICAgICAgICAgIGdvYWxWYWxzID0gdy5nbG9iYWxzLnNlcmllc0dvYWxzW3RJbmRleF1bal0ubWFwKGZ1bmN0aW9uIChnb2FsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhdHRyczogZ29hbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBmLnlMYkZvcm1hdHRlcihnb2FsLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2UkdGFyZ2V0O1xuXG4gICAgICAgICAgICAgIC8vIGdldCBhIGNvbG9yIGZyb20gYSBob3ZlciBhcmVhIChpZiBpdCdzIGEgbGluZSBwYXR0ZXJuIHRoZW4gZ2V0IGZyb20gYSBmaXJzdCBsaW5lKVxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0RmlsbCA9IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9lJHRhcmdldCA9IGUudGFyZ2V0KSA9PT0gbnVsbCB8fCBfZSR0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcblxuICAgICAgICAgICAgICBpZiAodGFyZ2V0RmlsbCkge1xuICAgICAgICAgICAgICAgIHBDb2xvciA9IHRhcmdldEZpbGwuaW5kZXhPZigndXJsJykgIT09IC0xID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRGaWxsLnN1YnN0cig0KS5zbGljZSgwLCAtMSkpLmNoaWxkTm9kZXNbMF0uZ2V0QXR0cmlidXRlKCdzdHJva2UnKSA6IHRhcmdldEZpbGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWwgPSBnZXRWYWxCeVNlcmllc0luZGV4KGkpO1xuXG4gICAgICAgICAgICAgIGlmIChoYXNHb2FsVmFsdWVzKGkpICYmIEFycmF5LmlzQXJyYXkody5nbG9iYWxzLnNlcmllc0dvYWxzW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgIGdvYWxWYWxzID0gdy5nbG9iYWxzLnNlcmllc0dvYWxzW2ldW2pdLm1hcChmdW5jdGlvbiAoZ29hbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IGdvYWwsXG4gICAgICAgICAgICAgICAgICAgIHZhbDogZi55TGJGb3JtYXR0ZXIoZ29hbC52YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGZvciBwaWUgLyBkb251dHNcblxuXG4gICAgICAgICAgaWYgKGogPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbCA9IGYueUxiRm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbaV0sIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB3KSwge30sIHtcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuRE9NSGFuZGxpbmcoe1xuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIHQ6IHRJbmRleCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICB0dEl0ZW1zOiB0dEl0ZW1zLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIHZhbDogdmFsLFxuICAgICAgICAgICAgICBnb2FsVmFsczogZ29hbFZhbHMsXG4gICAgICAgICAgICAgIHhWYWw6IHhWYWwsXG4gICAgICAgICAgICAgIHhBeGlzVFRWYWw6IHhBeGlzVFRWYWwsXG4gICAgICAgICAgICAgIHpWYWw6IHpWYWxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJpZXNOYW1lOiBzZXJpZXNOYW1lLFxuICAgICAgICAgICAgc2hhcmVkOiBzaGFyZWQsXG4gICAgICAgICAgICBwQ29sb3I6IHBDb2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHQgPSAwLCBpbnZlcnNldCA9IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoIC0gMTsgdCA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyB0KyssIGludmVyc2V0LS0pIHtcbiAgICAgICAgICBfbG9vcCh0LCBpbnZlcnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0Rm9ybWF0dGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRlcnMoaSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzW2ldO1xuICAgICAgICB2YXIgeUxiVGl0bGVGb3JtYXR0ZXI7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy50dFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5nbG9iYWxzLnR0VmFsKSkge1xuICAgICAgICAgICAgeUxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnR0VmFsW2ldICYmIHcuZ2xvYmFscy50dFZhbFtpXS5mb3JtYXR0ZXI7XG4gICAgICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IHcuZ2xvYmFscy50dFZhbFtpXSAmJiB3Lmdsb2JhbHMudHRWYWxbaV0udGl0bGUgJiYgdy5nbG9iYWxzLnR0VmFsW2ldLnRpdGxlLmZvcm1hdHRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeUxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnR0VmFsLmZvcm1hdHRlcjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMudHRWYWwudGl0bGUuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHlMYlRpdGxlRm9ybWF0dGVyID0gdy5nbG9iYWxzLnR0VmFsLnRpdGxlLmZvcm1hdHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeUxiVGl0bGVGb3JtYXR0ZXIgPSB3LmNvbmZpZy50b29sdGlwLnkudGl0bGUuZm9ybWF0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB5TGJGb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbMF0pIHtcbiAgICAgICAgICAgIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5TGJGb3JtYXR0ZXIgPSBmdW5jdGlvbiB5TGJGb3JtYXR0ZXIobGFiZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHlMYlRpdGxlRm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgeUxiVGl0bGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiB5TGJUaXRsZUZvcm1hdHRlcihsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHlMYkZvcm1hdHRlcjogeUxiRm9ybWF0dGVyLFxuICAgICAgICAgIHlMYlRpdGxlRm9ybWF0dGVyOiB5TGJUaXRsZUZvcm1hdHRlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTZXJpZXNOYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzTmFtZShfcmVmMykge1xuICAgICAgICB2YXIgZm4gPSBfcmVmMy5mbixcbiAgICAgICAgICAgIGluZGV4ID0gX3JlZjMuaW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNJbmRleCA9IF9yZWYzLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgaiA9IF9yZWYzLmo7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICByZXR1cm4gZm4oU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpbmRleF0pLCB7XG4gICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzLFxuICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJET01IYW5kbGluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIERPTUhhbmRsaW5nKF9yZWY0KSB7XG4gICAgICAgIF9yZWY0Lmk7XG4gICAgICAgICAgICB2YXIgdCA9IF9yZWY0LnQsXG4gICAgICAgICAgICBqID0gX3JlZjQuaixcbiAgICAgICAgICAgIHR0SXRlbXMgPSBfcmVmNC50dEl0ZW1zLFxuICAgICAgICAgICAgdmFsdWVzID0gX3JlZjQudmFsdWVzLFxuICAgICAgICAgICAgc2VyaWVzTmFtZSA9IF9yZWY0LnNlcmllc05hbWUsXG4gICAgICAgICAgICBzaGFyZWQgPSBfcmVmNC5zaGFyZWQsXG4gICAgICAgICAgICBwQ29sb3IgPSBfcmVmNC5wQ29sb3I7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgICB2YXIgdmFsID0gdmFsdWVzLnZhbCxcbiAgICAgICAgICAgIGdvYWxWYWxzID0gdmFsdWVzLmdvYWxWYWxzLFxuICAgICAgICAgICAgeFZhbCA9IHZhbHVlcy54VmFsLFxuICAgICAgICAgICAgeEF4aXNUVFZhbCA9IHZhbHVlcy54QXhpc1RUVmFsLFxuICAgICAgICAgICAgelZhbCA9IHZhbHVlcy56VmFsO1xuICAgICAgICB2YXIgdHRJdGVtc0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdHRJdGVtc0NoaWxkcmVuID0gdHRJdGVtc1t0XS5jaGlsZHJlbjtcblxuICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5maWxsU2VyaWVzQ29sb3IpIHtcbiAgICAgICAgICB0dEl0ZW1zW3RdLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBDb2xvcjtcbiAgICAgICAgICB0dEl0ZW1zQ2hpbGRyZW5bMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dEN0eC5zaG93VG9vbHRpcFRpdGxlKSB7XG4gICAgICAgICAgaWYgKHR0Q3R4LnRvb2x0aXBUaXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZ2V0IGl0IG9uY2UgaWYgbnVsbCwgYW5kIHN0b3JlIGl0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICB0dEN0eC50b29sdGlwVGl0bGUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHRDdHgudG9vbHRpcFRpdGxlLmlubmVySFRNTCA9IHhWYWw7XG4gICAgICAgIH0gLy8gaWYgeGF4aXMgdG9vbHRpcCBpcyBjb25zdHJ1Y3RlZCwgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBpbm5lckhUTUxcblxuXG4gICAgICAgIGlmICh0dEN0eC5pc1hBeGlzVG9vbHRpcEVuYWJsZWQpIHtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LmlubmVySFRNTCA9IHhBeGlzVFRWYWwgIT09ICcnID8geEF4aXNUVFZhbCA6IHhWYWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHRZTGFiZWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC15LWxhYmVsJyk7XG5cbiAgICAgICAgaWYgKHR0WUxhYmVsKSB7XG4gICAgICAgICAgdHRZTGFiZWwuaW5uZXJIVE1MID0gc2VyaWVzTmFtZSA/IHNlcmllc05hbWUgOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0dFlWYWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC15LXZhbHVlJyk7XG5cbiAgICAgICAgaWYgKHR0WVZhbCkge1xuICAgICAgICAgIHR0WVZhbC5pbm5lckhUTUwgPSB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyA/IHZhbCA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR0SXRlbXNDaGlsZHJlblswXSAmJiB0dEl0ZW1zQ2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyJykpIHtcbiAgICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5tYXJrZXIuZmlsbENvbG9ycyAmJiBBcnJheS5pc0FycmF5KHcuY29uZmlnLnRvb2x0aXAubWFya2VyLmZpbGxDb2xvcnMpKSB7XG4gICAgICAgICAgICBwQ29sb3IgPSB3LmNvbmZpZy50b29sdGlwLm1hcmtlci5maWxsQ29sb3JzW3RdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHR0SXRlbXNDaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuY29uZmlnLnRvb2x0aXAubWFya2VyLnNob3cpIHtcbiAgICAgICAgICB0dEl0ZW1zQ2hpbGRyZW5bMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0dEdMYWJlbCA9IHR0SXRlbXNbdF0ucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LWdvYWxzLWxhYmVsJyk7XG4gICAgICAgIHZhciB0dEdWYWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1nb2Fscy12YWx1ZScpO1xuXG4gICAgICAgIGlmIChnb2FsVmFscy5sZW5ndGggJiYgdy5nbG9iYWxzLnNlcmllc0dvYWxzW3RdKSB7XG4gICAgICAgICAgdmFyIGNyZWF0ZUdvYWxzSHRtbCA9IGZ1bmN0aW9uIGNyZWF0ZUdvYWxzSHRtbCgpIHtcbiAgICAgICAgICAgIHZhciBnTGFiZWxzID0gJzxkaXYgPic7XG4gICAgICAgICAgICB2YXIgZ1ZhbHMgPSAnPGRpdj4nO1xuICAgICAgICAgICAgZ29hbFZhbHMuZm9yRWFjaChmdW5jdGlvbiAoZ29hbCwgZ2kpIHtcbiAgICAgICAgICAgICAgZ0xhYmVscyArPSBcIiA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OiBmbGV4XFxcIj48c3BhbiBjbGFzcz1cXFwiYXBleGNoYXJ0cy10b29sdGlwLW1hcmtlclxcXCIgc3R5bGU9XFxcImJhY2tncm91bmQtY29sb3I6IFwiLmNvbmNhdChnb2FsLmF0dHJzLnN0cm9rZUNvbG9yLCBcIjsgaGVpZ2h0OiAzcHg7IGJvcmRlci1yYWRpdXM6IDA7IHRvcDogNXB4O1xcXCI+PC9zcGFuPiBcIikuY29uY2F0KGdvYWwuYXR0cnMubmFtZSwgXCI8L2Rpdj5cIik7XG4gICAgICAgICAgICAgIGdWYWxzICs9IFwiPGRpdj5cIi5jb25jYXQoZ29hbC52YWwsIFwiPC9kaXY+XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0dEdMYWJlbC5pbm5lckhUTUwgPSBnTGFiZWxzICsgXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgIHR0R1ZhbC5pbm5lckhUTUwgPSBnVmFscyArIFwiPC9kaXY+XCI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChzaGFyZWQpIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzR29hbHNbdF1bal0gJiYgQXJyYXkuaXNBcnJheSh3Lmdsb2JhbHMuc2VyaWVzR29hbHNbdF1bal0pKSB7XG4gICAgICAgICAgICAgIGNyZWF0ZUdvYWxzSHRtbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHRHTGFiZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgIHR0R1ZhbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3JlYXRlR29hbHNIdG1sKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR0R0xhYmVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgIHR0R1ZhbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6VmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHR0WkxhYmVsID0gdHRJdGVtc1t0XS5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei1sYWJlbCcpO1xuICAgICAgICAgIHR0WkxhYmVsLmlubmVySFRNTCA9IHcuY29uZmlnLnRvb2x0aXAuei50aXRsZTtcbiAgICAgICAgICB2YXIgdHRaVmFsID0gdHRJdGVtc1t0XS5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei12YWx1ZScpO1xuICAgICAgICAgIHR0WlZhbC5pbm5lckhUTUwgPSB0eXBlb2YgelZhbCAhPT0gJ3VuZGVmaW5lZCcgPyB6VmFsIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcmVkICYmIHR0SXRlbXNDaGlsZHJlblswXSkge1xuICAgICAgICAgIC8vIGhpZGUgd2hlbiBubyBWYWwgb3Igc2VyaWVzIGNvbGxhcHNlZFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyB8fCB2YWwgPT09IG51bGwgfHwgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZih0KSA+IC0xIHx8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YodCkgPiAtMSkge1xuICAgICAgICAgICAgdHRJdGVtc0NoaWxkcmVuWzBdLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHRJdGVtc0NoaWxkcmVuWzBdLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSA9IHcuY29uZmlnLnRvb2x0aXAuaXRlbXMuZGlzcGxheTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9nZ2xlQWN0aXZlSW5hY3RpdmVTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVBY3RpdmVJbmFjdGl2ZVNlcmllcyhzaGFyZWQpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAgIC8vIG1ha2UgYWxsIHRvb2x0aXBzIGFjdGl2ZVxuICAgICAgICAgIHRoaXMudG9vbHRpcFV0aWwudG9nZ2xlQWxsVG9vbHRpcFNlcmllc0dyb3VwcygnZW5hYmxlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGlzYWJsZSBhbGwgdG9vbHRpcCB0ZXh0IGdyb3Vwc1xuICAgICAgICAgIHRoaXMudG9vbHRpcFV0aWwudG9nZ2xlQWxsVG9vbHRpcFNlcmllc0dyb3VwcygnZGlzYWJsZScpOyAvLyBlbmFibGUgdGhlIGZpcnN0IHRvb2x0aXAgdGV4dCBncm91cFxuXG4gICAgICAgICAgdmFyIGZpcnN0VG9vbHRpcFNlcmllc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAnKTtcblxuICAgICAgICAgIGlmIChmaXJzdFRvb2x0aXBTZXJpZXNHcm91cCkge1xuICAgICAgICAgICAgZmlyc3RUb29sdGlwU2VyaWVzR3JvdXAuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgICAgIGZpcnN0VG9vbHRpcFNlcmllc0dyb3VwLnN0eWxlLmRpc3BsYXkgPSB3LmNvbmZpZy50b29sdGlwLml0ZW1zLmRpc3BsYXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFZhbHVlc1RvUHJpbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZXNUb1ByaW50KF9yZWY1KSB7XG4gICAgICAgIHZhciBpID0gX3JlZjUuaSxcbiAgICAgICAgICAgIGogPSBfcmVmNS5qO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGZpbHRlcmVkU2VyaWVzWCA9IHRoaXMuY3R4LnNlcmllcy5maWx0ZXJlZFNlcmllc1goKTtcbiAgICAgICAgdmFyIHhWYWwgPSAnJztcbiAgICAgICAgdmFyIHhBeGlzVFRWYWwgPSAnJztcbiAgICAgICAgdmFyIHpWYWwgPSBudWxsO1xuICAgICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgICAgdmFyIGN1c3RvbUZvcm1hdHRlck9wdHMgPSB7XG4gICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzLFxuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHpGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMudHRaRm9ybWF0dGVyO1xuXG4gICAgICAgIGlmIChqID09PSBudWxsKSB7XG4gICAgICAgICAgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ3RyZWVtYXAnKSB7XG4gICAgICAgICAgICB4VmFsID0gZmlsdGVyZWRTZXJpZXNYW2ldW2pdO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRTZXJpZXNYW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBhIHNlcmllcyAocG9zc2libHkgdGhlIGZpcnN0IG9uZSkgbWlnaHQgYmUgY29sbGFwc2VkLCBzbyBnZXQgdGhlIG5leHQgYWN0aXZlIGluZGV4XG4gICAgICAgICAgICAgIHZhciBmaXJzdEFjdGl2ZVNlcmllc0luZGV4ID0gdGhpcy50b29sdGlwVXRpbC5nZXRGaXJzdEFjdGl2ZVhBcnJheShmaWx0ZXJlZFNlcmllc1gpO1xuICAgICAgICAgICAgICB4VmFsID0gZmlsdGVyZWRTZXJpZXNYW2ZpcnN0QWN0aXZlU2VyaWVzSW5kZXhdW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4VmFsID0gdHlwZW9mIHcuZ2xvYmFscy5sYWJlbHNbal0gIT09ICd1bmRlZmluZWQnID8gdy5nbG9iYWxzLmxhYmVsc1tqXSA6ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZmZXJYVmFsID0geFZhbDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5jdHgpO1xuICAgICAgICAgIHhWYWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh3Lmdsb2JhbHMudHRLZXlGb3JtYXR0ZXIsIGJ1ZmZlclhWYWwsIGJ1ZmZlclhWYWwsIHtcbiAgICAgICAgICAgIGk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGVGb3JtYXR0ZXI6IG5ldyBEYXRlVGltZSh0aGlzLmN0eCkuZm9ybWF0RGF0ZSxcbiAgICAgICAgICAgIHc6IHRoaXMud1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB4VmFsID0gdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbMF0oYnVmZmVyWFZhbCwgY3VzdG9tRm9ybWF0dGVyT3B0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhWYWwgPSB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyKGJ1ZmZlclhWYWwsIGN1c3RvbUZvcm1hdHRlck9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBvdmVycmlkZSBkZWZhdWx0IHgtYXhpcyBmb3JtYXR0ZXIgd2l0aCB0b29sdGlwIGZvcm1hdHRlclxuXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHhWYWwgPSB3Lmdsb2JhbHMudHRLZXlGb3JtYXR0ZXIoYnVmZmVyWFZhbCwgY3VzdG9tRm9ybWF0dGVyT3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLnNlcmllc1oubGVuZ3RoID4gMCAmJiB3Lmdsb2JhbHMuc2VyaWVzWltpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgelZhbCA9IHpGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1pbaV1bal0sIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy54YXhpcy50b29sdGlwLmZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHhBeGlzVFRWYWwgPSB3Lmdsb2JhbHMueGF4aXNUb29sdGlwRm9ybWF0dGVyKGJ1ZmZlclhWYWwsIGN1c3RvbUZvcm1hdHRlck9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhBeGlzVFRWYWwgPSB4VmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWw6IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5qb2luKCcgJykgOiB2YWwsXG4gICAgICAgICAgeFZhbDogQXJyYXkuaXNBcnJheSh4VmFsKSA/IHhWYWwuam9pbignICcpIDogeFZhbCxcbiAgICAgICAgICB4QXhpc1RUVmFsOiBBcnJheS5pc0FycmF5KHhBeGlzVFRWYWwpID8geEF4aXNUVFZhbC5qb2luKCcgJykgOiB4QXhpc1RUVmFsLFxuICAgICAgICAgIHpWYWw6IHpWYWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlQ3VzdG9tVG9vbHRpcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUN1c3RvbVRvb2x0aXAoX3JlZjYpIHtcbiAgICAgICAgdmFyIGkgPSBfcmVmNi5pLFxuICAgICAgICAgICAgaiA9IF9yZWY2LmosXG4gICAgICAgICAgICB5MSA9IF9yZWY2LnkxLFxuICAgICAgICAgICAgeTIgPSBfcmVmNi55MixcbiAgICAgICAgICAgIHcgPSBfcmVmNi53O1xuICAgICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy50dEN0eC5nZXRFbFRvb2x0aXAoKTtcbiAgICAgICAgdmFyIGZuID0gdy5jb25maWcudG9vbHRpcC5jdXN0b207XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm4pICYmIGZuW2ldKSB7XG4gICAgICAgICAgZm4gPSBmbltpXTtcbiAgICAgICAgfSAvLyBvdmVycmlkZSBldmVyeXRoaW5nIHdpdGggYSBjdXN0b20gaHRtbCB0b29sdGlwIGFuZCByZXBsYWNlIGl0XG5cblxuICAgICAgICB0b29sdGlwRWwuaW5uZXJIVE1MID0gZm4oe1xuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzLFxuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgdzogd1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGFiZWxzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgVG9vbHRpcC5Qb3NpdGlvbiBDbGFzcyB0byBtb3ZlIHRoZSB0b29sdGlwIGJhc2VkIG9uIHggYW5kIHkgcG9zaXRpb24uXG4gICAqXG4gICAqIEBtb2R1bGUgVG9vbHRpcC5Qb3NpdGlvblxuICAgKiovXG5cbiAgdmFyIFBvc2l0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3NpdGlvbih0b29sdGlwQ29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc2l0aW9uKTtcblxuICAgICAgdGhpcy50dEN0eCA9IHRvb2x0aXBDb250ZXh0O1xuICAgICAgdGhpcy5jdHggPSB0b29sdGlwQ29udGV4dC5jdHg7XG4gICAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgbW92ZSB0aGUgY3Jvc3NoYWlyICh0aGUgdmVydGljYWwvaG9yeiBsaW5lIHRoYXQgbW92ZXMgYWxvbmcgd2l0aCBtb3VzZSlcbiAgICAgKiBBbG9uZyB3aXRoIHRoaXMsIHRoaXMgZnVuY3Rpb24gYWxzbyBjYWxscyB0aGUgeGF4aXNNb3ZlIGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtpbnR9IC0gY3ggPSBwb2ludCdzIHggcG9zaXRpb24sIHdoZXJldmVyIHBvaW50J3MgeCBpcywgeW91IG5lZWQgdG8gbW92ZSBjcm9zc2hhaXJcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFBvc2l0aW9uLCBbe1xuICAgICAga2V5OiBcIm1vdmVYQ3Jvc3NoYWlyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVYQ3Jvc3NoYWlycyhjeCkge1xuICAgICAgICB2YXIgaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4Y3Jvc3NoYWlycyA9IHR0Q3R4LmdldEVsWENyb3NzaGFpcnMoKTtcbiAgICAgICAgdmFyIHggPSBjeCAtIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggLyAyO1xuICAgICAgICB2YXIgdGlja0Ftb3VudCA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGogIT09IG51bGwpIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHRpY2tBbW91bnQgKiBqO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHhjcm9zc2hhaXJzICE9PSBudWxsICYmICF3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4JywgeCk7XG4gICAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4MScsIHgpO1xuICAgICAgICAgIHhjcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgneDInLCB4KTtcbiAgICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3kyJywgdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICAgIHhjcm9zc2hhaXJzLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtYWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4ID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICAgIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR0Q3R4LmlzWEF4aXNUb29sdGlwRW5hYmxlZCkge1xuICAgICAgICAgIHZhciB0eCA9IHg7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ3RpY2tXaWR0aCcgfHwgdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICAgICAgdHggPSB4ICsgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5tb3ZlWEF4aXNUb29sdGlwKHR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIHdpbGwgbW92ZSB0aGUgY3Jvc3NoYWlyICh0aGUgdmVydGljYWwvaG9yeiBsaW5lIHRoYXQgbW92ZXMgYWxvbmcgd2l0aCBtb3VzZSlcbiAgICAgICAqIEFsb25nIHdpdGggdGhpcywgdGhpcyBmdW5jdGlvbiBhbHNvIGNhbGxzIHRoZSB4YXhpc01vdmUgZnVuY3Rpb25cbiAgICAgICAqIEBtZW1iZXJvZiBQb3NpdGlvblxuICAgICAgICogQHBhcmFtIHtpbnR9IC0gY3ggPSBwb2ludCdzIHggcG9zaXRpb24sIHdoZXJldmVyIHBvaW50J3MgeCBpcywgeW91IG5lZWQgdG8gbW92ZSBjcm9zc2hhaXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1vdmVZQ3Jvc3NoYWlyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVZQ3Jvc3NoYWlycyhjeSkge1xuICAgICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICAgIGlmICh0dEN0eC55Y3Jvc3NoYWlycyAhPT0gbnVsbCkge1xuICAgICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHR0Q3R4Lnljcm9zc2hhaXJzLCB7XG4gICAgICAgICAgICB5MTogY3ksXG4gICAgICAgICAgICB5MjogY3lcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dEN0eC55Y3Jvc3NoYWlyc0hpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHR0Q3R4Lnljcm9zc2hhaXJzSGlkZGVuLCB7XG4gICAgICAgICAgICB5MTogY3ksXG4gICAgICAgICAgICB5MjogY3lcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiogQXhpc1Rvb2x0aXAgaXMgdGhlIHNtYWxsIHJlY3RhbmdsZSB3aGljaCBhcHBlYXJzIG9uIHggYXhpcyB3aXRoIHggdmFsdWUsIHdoZW4gdXNlciBtb3Zlc1xuICAgICAgICogQG1lbWJlcm9mIFBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0ge2ludH0gLSBjeCA9IHBvaW50J3MgeCBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB4IGlzLCB5b3UgbmVlZCB0byBtb3ZlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3ZlWEF4aXNUb29sdGlwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVhBeGlzVG9vbHRpcChjeCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcblxuICAgICAgICBpZiAodHRDdHgueGF4aXNUb29sdGlwICE9PSBudWxsICYmIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggIT09IDApIHtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXAuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgICB2YXIgY3kgPSB0dEN0eC54YXhpc09mZlkgKyB3LmNvbmZpZy54YXhpcy50b29sdGlwLm9mZnNldFkgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSArIDEgKyB3LmNvbmZpZy54YXhpcy5vZmZzZXRZO1xuICAgICAgICAgIHZhciB4YXhpc1RUVGV4dCA9IHR0Q3R4LnhheGlzVG9vbHRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgeGF4aXNUVFRleHRXaWR0aCA9IHhheGlzVFRUZXh0LndpZHRoO1xuICAgICAgICAgIGN4ID0gY3ggLSB4YXhpc1RUVGV4dFdpZHRoIC8gMjtcblxuICAgICAgICAgIGlmICghaXNOYU4oY3gpKSB7XG4gICAgICAgICAgICBjeCA9IGN4ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVg7XG4gICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSAwO1xuICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgICAgIHRleHRSZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuc3R5bGUubWluV2lkdGggPSB0ZXh0UmVjdC53aWR0aCArICdweCc7XG4gICAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXAuc3R5bGUubGVmdCA9IGN4ICsgJ3B4JztcbiAgICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5zdHlsZS50b3AgPSBjeSArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1vdmVZQXhpc1Rvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlWUF4aXNUb29sdGlwKGluZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICAgIGlmICh0dEN0eC55YXhpc1RURWxzID09PSBudWxsKSB7XG4gICAgICAgICAgdHRDdHgueWF4aXNUVEVscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHljcm9zc2hhaXJzSGlkZGVuUmVjdFkxID0gcGFyc2VJbnQodHRDdHgueWNyb3NzaGFpcnNIaWRkZW4uZ2V0QXR0cmlidXRlKCd5MScpLCAxMCk7XG4gICAgICAgIHZhciBjeSA9IHcuZ2xvYmFscy50cmFuc2xhdGVZICsgeWNyb3NzaGFpcnNIaWRkZW5SZWN0WTE7XG4gICAgICAgIHZhciB5QXhpc1RUUmVjdCA9IHR0Q3R4LnlheGlzVFRFbHNbaW5kZXhdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgeUF4aXNUVEhlaWdodCA9IHlBeGlzVFRSZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIGN4ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gLSAyO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tpbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICBjeCA9IGN4IC0gMjY7XG4gICAgICAgIH1cblxuICAgICAgICBjeSA9IGN5IC0geUF4aXNUVEhlaWdodCAvIDI7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pZ25vcmVZQXhpc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgICB0dEN0eC55YXhpc1RURWxzW2luZGV4XS5zdHlsZS50b3AgPSBjeSArICdweCc7XG4gICAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uc3R5bGUubGVmdCA9IGN4ICsgdy5jb25maWcueWF4aXNbaW5kZXhdLnRvb2x0aXAub2Zmc2V0WCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uY2xhc3NMaXN0LnJlbW92ZSgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiogbW92ZXMgdGhlIHdob2xlIHRvb2x0aXAgYnkgY2hhbmdpbmcgeCwgeSBhdHRyc1xuICAgICAgICogQG1lbWJlcm9mIFBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0ge2ludH0gLSBjeCA9IHBvaW50J3MgeCBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB4IGlzLCB5b3UgbmVlZCB0byBtb3ZlIHRvb2x0aXBcbiAgICAgICAqIEBwYXJhbSB7aW50fSAtIGN5ID0gcG9pbnQncyB5IHBvc2l0aW9uLCB3aGVyZXZlciBwb2ludCdzIHkgaXMsIHlvdSBuZWVkIHRvIG1vdmUgdG9vbHRpcFxuICAgICAgICogQHBhcmFtIHtpbnR9IC0gciA9IHBvaW50J3MgcmFkaXVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3ZlVG9vbHRpcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUb29sdGlwKGN4LCBjeSkge1xuICAgICAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICAgIHZhciB0b29sdGlwRWwgPSB0dEN0eC5nZXRFbFRvb2x0aXAoKTtcbiAgICAgICAgdmFyIHRvb2x0aXBSZWN0ID0gdHRDdHgudG9vbHRpcFJlY3Q7XG4gICAgICAgIHZhciBwb2ludFIgPSByICE9PSBudWxsID8gcGFyc2VGbG9hdChyKSA6IDE7XG4gICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChjeCkgKyBwb2ludFIgKyA1O1xuICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQoY3kpICsgcG9pbnRSIC8gMjsgLy8gLSB0b29sdGlwUmVjdC50dEhlaWdodCAvIDJcblxuICAgICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyKSB7XG4gICAgICAgICAgeCA9IHggLSB0b29sdGlwUmVjdC50dFdpZHRoIC0gcG9pbnRSIC0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggLSB0b29sdGlwUmVjdC50dFdpZHRoIC0gMTApIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAtIHRvb2x0aXBSZWN0LnR0V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IC0yMCkge1xuICAgICAgICAgIHggPSAtMjA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICB2YXIgZWxHcmlkID0gdHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHggPSB0dEN0eC5lLmNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0O1xuXG4gICAgICAgICAgaWYgKHggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMikge1xuICAgICAgICAgICAgeCA9IHggLSB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHkgPSB0dEN0eC5lLmNsaWVudFkgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSAtIHNlcmllc0JvdW5kLnRvcDtcblxuICAgICAgICAgIGlmICh5ID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICB5ID0geSAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGlmICh0b29sdGlwUmVjdC50dEhlaWdodCAvIDIgKyB5ID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgeSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gdG9vbHRpcFJlY3QudHRIZWlnaHQgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKHgpKSB7XG4gICAgICAgICAgeCA9IHggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWDtcbiAgICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3ZlTWFya2Vyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVNYXJrZXJzKGksIGopIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaV0gPiAwKSB7XG4gICAgICAgICAgdmFyIGFsbFBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIgLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KGksIFwiJ10gLmFwZXhjaGFydHMtbWFya2VyXCIpKTtcblxuICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgYWxsUG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VJbnQoYWxsUG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgncmVsJyksIDEwKSA9PT0gaikge1xuICAgICAgICAgICAgICB0dEN0eC5tYXJrZXIucmVzZXRQb2ludHNTaXplKCk7XG4gICAgICAgICAgICAgIHR0Q3R4Lm1hcmtlci5lbmxhcmdlQ3VycmVudFBvaW50KGosIGFsbFBvaW50c1twXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR0Q3R4Lm1hcmtlci5yZXNldFBvaW50c1NpemUoKTtcbiAgICAgICAgICB0aGlzLm1vdmVEeW5hbWljUG9pbnRPbkhvdmVyKGosIGkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIHNob3cgbWFya2Vycy9wb2ludHMgb25seSBvbiBob3ZlciAtXG4gICAgICAvLyBESUZGRVJFTlQgWCBWQUxVRVMgaW4gbXVsdGlwbGUgc2VyaWVzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibW92ZUR5bmFtaWNQb2ludE9uSG92ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlRHluYW1pY1BvaW50T25Ib3ZlcihqLCBjYXB0dXJlZFNlcmllcykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgICAgdmFyIGN4ID0gMDtcbiAgICAgICAgdmFyIGN5ID0gMDtcbiAgICAgICAgdmFyIHBvaW50c0FyciA9IHcuZ2xvYmFscy5wb2ludHNBcnJheTtcbiAgICAgICAgdmFyIGhvdmVyU2l6ZSA9IHR0Q3R4LnRvb2x0aXBVdGlsLmdldEhvdmVyTWFya2VyU2l6ZShjYXB0dXJlZFNlcmllcyk7XG4gICAgICAgIHZhciBzZXJUeXBlID0gdy5jb25maWcuc2VyaWVzW2NhcHR1cmVkU2VyaWVzXS50eXBlO1xuXG4gICAgICAgIGlmIChzZXJUeXBlICYmIChzZXJUeXBlID09PSAnY29sdW1uJyB8fCBzZXJUeXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHNlclR5cGUgPT09ICdib3hQbG90JykpIHtcbiAgICAgICAgICAvLyBmaXggZXJyb3IgbWVudGlvbmVkIGluICM4MTFcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjeCA9IHBvaW50c0FycltjYXB0dXJlZFNlcmllc11bal1bMF07XG4gICAgICAgIGN5ID0gcG9pbnRzQXJyW2NhcHR1cmVkU2VyaWVzXVtqXVsxXSA/IHBvaW50c0FycltjYXB0dXJlZFNlcmllc11bal1bMV0gOiAwO1xuICAgICAgICB2YXIgcG9pbnQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KGNhcHR1cmVkU2VyaWVzLCBcIiddIC5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIGNpcmNsZVwiKSk7XG5cbiAgICAgICAgaWYgKHBvaW50ICYmIGN5IDwgdy5nbG9iYWxzLmdyaWRIZWlnaHQgJiYgY3kgPiAwKSB7XG4gICAgICAgICAgcG9pbnQuc2V0QXR0cmlidXRlKCdyJywgaG92ZXJTaXplKTtcbiAgICAgICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ2N4JywgY3gpO1xuICAgICAgICAgIHBvaW50LnNldEF0dHJpYnV0ZSgnY3knLCBjeSk7XG4gICAgICAgIH0gLy8gcG9pbnQuc3R5bGUub3BhY2l0eSA9IHcuY29uZmlnLm1hcmtlcnMuaG92ZXIub3BhY2l0eVxuXG5cbiAgICAgICAgdGhpcy5tb3ZlWENyb3NzaGFpcnMoY3gpO1xuXG4gICAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlVG9vbHRpcChjeCwgY3ksIGhvdmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4geW91IG5lZWQgdG8gc2hvdyBtYXJrZXJzL3BvaW50cyBvbmx5IG9uIGhvdmVyIC1cbiAgICAgIC8vIFNBTUUgWCBWQUxVRVMgaW4gbXVsdGlwbGUgc2VyaWVzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibW92ZUR5bmFtaWNQb2ludHNPbkhvdmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUR5bmFtaWNQb2ludHNPbkhvdmVyKGopIHtcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgICAgdmFyIHcgPSB0dEN0eC53O1xuICAgICAgICB2YXIgY3ggPSAwO1xuICAgICAgICB2YXIgY3kgPSAwO1xuICAgICAgICB2YXIgYWN0aXZlU2VyaWVzID0gMDtcbiAgICAgICAgdmFyIHBvaW50c0FyciA9IHcuZ2xvYmFscy5wb2ludHNBcnJheTtcbiAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgICBhY3RpdmVTZXJpZXMgPSBzZXJpZXMuZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXgoJ2FzYycsIFsnbGluZScsICdhcmVhJywgJ3NjYXR0ZXInLCAnYnViYmxlJ10pO1xuICAgICAgICB2YXIgaG92ZXJTaXplID0gdHRDdHgudG9vbHRpcFV0aWwuZ2V0SG92ZXJNYXJrZXJTaXplKGFjdGl2ZVNlcmllcyk7XG5cbiAgICAgICAgaWYgKHBvaW50c0FyclthY3RpdmVTZXJpZXNdKSB7XG4gICAgICAgICAgY3ggPSBwb2ludHNBcnJbYWN0aXZlU2VyaWVzXVtqXVswXTtcbiAgICAgICAgICBjeSA9IHBvaW50c0FyclthY3RpdmVTZXJpZXNdW2pdWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHR0Q3R4LnRvb2x0aXBVdGlsLmdldEFsbE1hcmtlcnMoKTtcblxuICAgICAgICBpZiAocG9pbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRBcnIgPSBwb2ludHNBcnJbcF07XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuY29tYm9DaGFydHMpIHtcbiAgICAgICAgICAgICAgLy8gaW4gYSBjb21ibyBjaGFydCwgaWYgY29sdW1uIGNoYXJ0cyBhcmUgcHJlc2VudCwgbWFya2VycyB3aWxsIG5vdCBtYXRjaCB3aXRoIHRoZSBudW1iZXIgb2Ygc2VyaWVzLCBoZW5jZSB0aGlzIHBhdGNoIHRvIHB1c2ggYSBudWxsIHZhbHVlIGluIHBvaW50cyBhcnJheVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50QXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIG5vZGVsaXN0IHRvIGFycmF5XG4gICAgICAgICAgICAgICAgcG9pbnRzLnNwbGljZShwLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9pbnRBcnIgJiYgcG9pbnRBcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBwY3kgPSBwb2ludHNBcnJbcF1bal1bMV07XG4gICAgICAgICAgICAgIHZhciBwY3kyID0gdm9pZCAwO1xuICAgICAgICAgICAgICBwb2ludHNbcF0uc2V0QXR0cmlidXRlKCdjeCcsIGN4KTtcblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQXJlYScgJiYgIXcuZ2xvYmFscy5jb21ib0NoYXJ0cykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZVN0YXJ0SW5kZXggPSBqICsgdy5nbG9iYWxzLnNlcmllc1twXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGN5MiA9IHBvaW50c0FycltwXVtyYW5nZVN0YXJ0SW5kZXhdWzFdO1xuICAgICAgICAgICAgICAgIHZhciBwY3lEaWZmID0gTWF0aC5hYnMocGN5IC0gcGN5MikgLyAyO1xuICAgICAgICAgICAgICAgIHBjeSA9IHBjeSAtIHBjeURpZmY7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocGN5ICE9PSBudWxsICYmICFpc05hTihwY3kpICYmIHBjeSA8IHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgaG92ZXJTaXplICYmIHBjeSArIGhvdmVyU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbcF0gJiYgcG9pbnRzW3BdLnNldEF0dHJpYnV0ZSgncicsIGhvdmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzW3BdICYmIHBvaW50c1twXS5zZXRBdHRyaWJ1dGUoJ2N5JywgcGN5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbcF0gJiYgcG9pbnRzW3BdLnNldEF0dHJpYnV0ZSgncicsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3ZlWENyb3NzaGFpcnMoY3gpO1xuXG4gICAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlVG9vbHRpcChjeCwgY3kgfHwgdy5nbG9iYWxzLmdyaWRIZWlnaHQsIGhvdmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibW92ZVN0aWNreVRvb2x0aXBPdmVyQmFyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVTdGlja3lUb29sdGlwT3ZlckJhcnMoaiwgY2FwdHVyZWRTZXJpZXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICAgIHZhciBiYXJMZW4gPSB3Lmdsb2JhbHMuY29sdW1uU2VyaWVzID8gdy5nbG9iYWxzLmNvbHVtblNlcmllcy5sZW5ndGggOiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSBiYXJMZW4gPj0gMiAmJiBiYXJMZW4gJSAyID09PSAwID8gTWF0aC5mbG9vcihiYXJMZW4gLyAyKSA6IE1hdGguZmxvb3IoYmFyTGVuIC8gMikgKyAxO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgICAgIGkgPSBzZXJpZXMuZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXgoJ2Rlc2MnKSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgakJhciA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1iYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChpLCBcIiddIHBhdGhbaj0nXCIpLmNvbmNhdChqLCBcIiddLCAuYXBleGNoYXJ0cy1jYW5kbGVzdGljay1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzW3JlbD0nXCIpLmNvbmNhdChpLCBcIiddIHBhdGhbaj0nXCIpLmNvbmNhdChqLCBcIiddLCAuYXBleGNoYXJ0cy1ib3hQbG90LXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIikuY29uY2F0KGksIFwiJ10gcGF0aFtqPSdcIikuY29uY2F0KGosIFwiJ10sIC5hcGV4Y2hhcnRzLXJhbmdlYmFyLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIikuY29uY2F0KGksIFwiJ10gcGF0aFtqPSdcIikuY29uY2F0KGosIFwiJ11cIikpO1xuXG4gICAgICAgIGlmICghakJhciAmJiB0eXBlb2YgY2FwdHVyZWRTZXJpZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gVHJ5IHdpdGggY2FwdHVyZWQgc2VyaWVzIGluZGV4XG4gICAgICAgICAgakJhciA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1iYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChjYXB0dXJlZFNlcmllcywgXCInXSBwYXRoW2o9J1wiKS5jb25jYXQoaiwgXCInXSxcXG4gICAgICAgIC5hcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIikuY29uY2F0KGNhcHR1cmVkU2VyaWVzLCBcIiddIHBhdGhbaj0nXCIpLmNvbmNhdChqLCBcIiddLFxcbiAgICAgICAgLmFwZXhjaGFydHMtYm94UGxvdC1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIpLmNvbmNhdChjYXB0dXJlZFNlcmllcywgXCInXSBwYXRoW2o9J1wiKS5jb25jYXQoaiwgXCInXSxcXG4gICAgICAgIC5hcGV4Y2hhcnRzLXJhbmdlYmFyLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIikuY29uY2F0KGNhcHR1cmVkU2VyaWVzLCBcIiddIHBhdGhbaj0nXCIpLmNvbmNhdChqLCBcIiddXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiY3ggPSBqQmFyID8gcGFyc2VGbG9hdChqQmFyLmdldEF0dHJpYnV0ZSgnY3gnKSkgOiAwO1xuICAgICAgICB2YXIgYmN5ID0gakJhciA/IHBhcnNlRmxvYXQoakJhci5nZXRBdHRyaWJ1dGUoJ2N5JykpIDogMDtcbiAgICAgICAgdmFyIGJ3ID0gakJhciA/IHBhcnNlRmxvYXQoakJhci5nZXRBdHRyaWJ1dGUoJ2JhcldpZHRoJykpIDogMDtcbiAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBpc0JveE9yQ2FuZGxlID0gakJhciAmJiAoakJhci5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtY2FuZGxlc3RpY2stYXJlYScpIHx8IGpCYXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWJveFBsb3QtYXJlYScpKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICBpZiAoakJhciAmJiAhaXNCb3hPckNhbmRsZSkge1xuICAgICAgICAgICAgYmN4ID0gYmN4IC0gKGJhckxlbiAlIDIgIT09IDAgPyBidyAvIDIgOiAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoakJhciAmJiAvLyBmaXhlcyBhcGV4Y2hhcnRzLmpzIzIzNTRcbiAgICAgICAgICBpc0JveE9yQ2FuZGxlICYmIHcuZ2xvYmFscy5jb21ib0NoYXJ0cykge1xuICAgICAgICAgICAgYmN4ID0gYmN4IC0gYncgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGJjeCA9IHR0Q3R4LnhBeGlzVGlja3NQb3NpdGlvbnNbaiAtIDFdICsgdHRDdHguZGF0YVBvaW50c0RpdmlkZWRXaWR0aCAvIDI7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihiY3gpKSB7XG4gICAgICAgICAgICAgIGJjeCA9IHR0Q3R4LnhBeGlzVGlja3NQb3NpdGlvbnNbal0gLSB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICAgIGJjeSA9IHR0Q3R4LmUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJjeSArIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0ICsgMTUgPiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkge1xuICAgICAgICAgICAgICBiY3kgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmN5ID0gYmN5IC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICB0aGlzLm1vdmVYQ3Jvc3NoYWlycyhiY3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dEN0eC5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgICB0aGlzLm1vdmVUb29sdGlwKGJjeCwgYmN5IHx8IHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQb3NpdGlvbjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIFRvb2x0aXAuTWFya2VyIENsYXNzIHRvIGRyYXcgdGV4dHMgb24gdGhlIHRvb2x0aXAuXG4gICAqIFRoaXMgZmlsZSBkZWFscyB3aXRoIHRoZSBtYXJrZXJzIHRoYXQgYXBwZWFyIG5lYXIgdG9vbHRpcCBpbiBsaW5lL2FyZWEgY2hhcnRzLlxuICAgKiBUaGVzZSBtYXJrZXJzIGhlbHBzIHRoZSB1c2VyIHRvIGFzc29jaWF0ZSB0aGUgZGF0YS1wb2ludHMgYW5kIHRoZSB2YWx1ZXNcbiAgICogdGhhdCBhcmUgc2hvd24gaW4gdGhlIHRvb2x0aXBcbiAgICpcbiAgICogQG1vZHVsZSBUb29sdGlwLk1hcmtlclxuICAgKiovXG5cbiAgdmFyIE1hcmtlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFya2VyKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFya2VyKTtcblxuICAgICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICAgIHRoaXMuY3R4ID0gdG9vbHRpcENvbnRleHQuY3R4O1xuICAgICAgdGhpcy50b29sdGlwUG9zaXRpb24gPSBuZXcgUG9zaXRpb24odG9vbHRpcENvbnRleHQpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhNYXJrZXIsIFt7XG4gICAgICBrZXk6IFwiZHJhd0R5bmFtaWNQb2ludHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3RHluYW1pY1BvaW50cygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgTWFya2Vycyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBlbHNTZXJpZXMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMnKTtcbiAgICAgICAgZWxzU2VyaWVzID0gX3RvQ29uc3VtYWJsZUFycmF5KGVsc1Nlcmllcyk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICBlbHNTZXJpZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpIC0gcGFyc2VGbG9hdChiLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsc1Nlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwb2ludHNNYWluID0gZWxzU2VyaWVzW2ldLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2Vycy13cmFwXCIpO1xuXG4gICAgICAgICAgaWYgKHBvaW50c01haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGl0IGNhbiBiZSBudWxsIGFzIHdlIGhhdmUgdG9vbHRpcHMgaW4gZG9udXQvYmFyIGNoYXJ0c1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIFBvaW50Q2xhc3NlcyA9IFwiYXBleGNoYXJ0cy1tYXJrZXIgd1wiLmNvbmNhdCgoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNCkpO1xuXG4gICAgICAgICAgICBpZiAoKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdsaW5lJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYXJlYScpICYmICF3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgIXcuY29uZmlnLnRvb2x0aXAuaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICAgIFBvaW50Q2xhc3NlcyArPSAnIG5vLXBvaW50ZXItZXZlbnRzJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsUG9pbnRPcHRpb25zID0gbWFya2VyLmdldE1hcmtlckNvbmZpZyh7XG4gICAgICAgICAgICAgIGNzc0NsYXNzOiBQb2ludENsYXNzZXMsXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBOdW1iZXIocG9pbnRzTWFpbi5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpIC8vIGZpeGVzIGFwZXhjaGFydHMvYXBleGNoYXJ0cy5qcyAjMTQyN1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvaW50ID0gZ3JhcGhpY3MuZHJhd01hcmtlcigwLCAwLCBlbFBvaW50T3B0aW9ucyk7XG4gICAgICAgICAgICBwb2ludC5ub2RlLnNldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScsIDApO1xuICAgICAgICAgICAgdmFyIGVsUG9pbnRzRyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh3Lmdsb2JhbHMuU1ZHTlMsICdnJyk7XG4gICAgICAgICAgICBlbFBvaW50c0cuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycycpO1xuICAgICAgICAgICAgZWxQb2ludHNHLmFwcGVuZENoaWxkKHBvaW50Lm5vZGUpO1xuICAgICAgICAgICAgcG9pbnRzTWFpbi5hcHBlbmRDaGlsZChlbFBvaW50c0cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmxhcmdlQ3VycmVudFBvaW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5sYXJnZUN1cnJlbnRQb2ludChyZWwsIHBvaW50KSB7XG4gICAgICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdidWJibGUnKSB7XG4gICAgICAgICAgdGhpcy5uZXdQb2ludFNpemUocmVsLCBwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3ggPSBwb2ludC5nZXRBdHRyaWJ1dGUoJ2N4Jyk7XG4gICAgICAgIHZhciBjeSA9IHBvaW50LmdldEF0dHJpYnV0ZSgnY3knKTtcblxuICAgICAgICBpZiAoeCAhPT0gbnVsbCAmJiB5ICE9PSBudWxsKSB7XG4gICAgICAgICAgY3ggPSB4O1xuICAgICAgICAgIGN5ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9vbHRpcFBvc2l0aW9uLm1vdmVYQ3Jvc3NoYWlycyhjeCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZpeGVkVG9vbHRpcCkge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkYXInKSB7XG4gICAgICAgICAgICB2YXIgZWxHcmlkID0gdGhpcy50dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGN4ID0gdGhpcy50dEN0eC5lLmNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudG9vbHRpcFBvc2l0aW9uLm1vdmVUb29sdGlwKGN4LCBjeSwgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmxhcmdlUG9pbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5sYXJnZVBvaW50cyhqKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgICB2YXIgY29sID0gajtcbiAgICAgICAgdmFyIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllczpub3QoLmFwZXhjaGFydHMtc2VyaWVzLWNvbGxhcHNlZCkgLmFwZXhjaGFydHMtbWFya2VyJyk7XG4gICAgICAgIHZhciBuZXdTaXplID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIHJlbCA9IHBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ3JlbCcpO1xuICAgICAgICAgIHZhciBpbmRleCA9IHBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ2luZGV4Jyk7XG5cbiAgICAgICAgICBpZiAobmV3U2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtpbmRleF0gKyB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemVPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbCA9PT0gcGFyc2VJbnQocmVsLCAxMCkpIHtcbiAgICAgICAgICAgIG1lLm5ld1BvaW50U2l6ZShjb2wsIHBvaW50c1twXSk7XG4gICAgICAgICAgICB2YXIgY3ggPSBwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdjeCcpO1xuICAgICAgICAgICAgdmFyIGN5ID0gcG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnY3knKTtcbiAgICAgICAgICAgIG1lLnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoY3gpO1xuXG4gICAgICAgICAgICBpZiAoIXR0Q3R4LmZpeGVkVG9vbHRpcCkge1xuICAgICAgICAgICAgICBtZS50b29sdGlwUG9zaXRpb24ubW92ZVRvb2x0aXAoY3gsIGN5LCBuZXdTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUub2xkUG9pbnRTaXplKHBvaW50c1twXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm5ld1BvaW50U2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5ld1BvaW50U2l6ZShyZWwsIHBvaW50KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbmV3U2l6ZSA9IHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZTtcbiAgICAgICAgdmFyIGVsUG9pbnQgPSByZWwgPT09IDAgPyBwb2ludC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQgOiBwb2ludC5wYXJlbnROb2RlLmxhc3RDaGlsZDtcblxuICAgICAgICBpZiAoZWxQb2ludC5nZXRBdHRyaWJ1dGUoJ2RlZmF1bHQtbWFya2VyLXNpemUnKSAhPT0gJzAnKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoZWxQb2ludC5nZXRBdHRyaWJ1dGUoJ2luZGV4JyksIDEwKTtcblxuICAgICAgICAgIGlmIChuZXdTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1NpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2luZGV4XSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3U2l6ZSA8IDApIG5ld1NpemUgPSAwO1xuICAgICAgICAgIGVsUG9pbnQuc2V0QXR0cmlidXRlKCdyJywgbmV3U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib2xkUG9pbnRTaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb2xkUG9pbnRTaXplKHBvaW50KSB7XG4gICAgICAgIHZhciBzaXplID0gcGFyc2VGbG9hdChwb2ludC5nZXRBdHRyaWJ1dGUoJ2RlZmF1bHQtbWFya2VyLXNpemUnKSk7XG4gICAgICAgIHBvaW50LnNldEF0dHJpYnV0ZSgncicsIHNpemUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXNldFBvaW50c1NpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFBvaW50c1NpemUoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzOm5vdCguYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkKSAuYXBleGNoYXJ0cy1tYXJrZXInKTtcblxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBvaW50cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgIHZhciBzaXplID0gcGFyc2VGbG9hdChwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdkZWZhdWx0LW1hcmtlci1zaXplJykpO1xuXG4gICAgICAgICAgaWYgKFV0aWxzJDEuaXNOdW1iZXIoc2l6ZSkgJiYgc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICBwb2ludHNbcF0uc2V0QXR0cmlidXRlKCdyJywgc2l6ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50c1twXS5zZXRBdHRyaWJ1dGUoJ3InLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTWFya2VyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgVG9vbHRpcC5JbnRlcnNlY3QgQ2xhc3MuXG4gICAqIFRoaXMgZmlsZSBkZWFscyB3aXRoIGZ1bmN0aW9ucyByZWxhdGVkIHRvIGludGVyc2VjdGluZyB0b29sdGlwc1xuICAgKiAodG9vbHRpcHMgdGhhdCBhcHBlYXIgd2hlbiB1c2VyIGhvdmVycyBkaXJlY3RseSBvdmVyIGEgZGF0YS1wb2ludCB3aGV0aGVyKVxuICAgKlxuICAgKiBAbW9kdWxlIFRvb2x0aXAuSW50ZXJzZWN0XG4gICAqKi9cblxuICB2YXIgSW50ZXJzZWN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcnNlY3QodG9vbHRpcENvbnRleHQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcnNlY3QpO1xuXG4gICAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLnR0Q3R4ID0gdG9vbHRpcENvbnRleHQ7XG4gICAgICB0aGlzLmlzVmVydGljYWxHcm91cGVkUmFuZ2VCYXIgPSAhdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFuZ2VCYXInICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5yYW5nZUJhckdyb3VwUm93cztcbiAgICB9IC8vIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhbiBlbGVtZW50J3MgYXR0cmlidXRlIHZhbHVlXG5cblxuICAgIF9jcmVhdGVDbGFzcyhJbnRlcnNlY3QsIFt7XG4gICAgICBrZXk6IFwiZ2V0QXR0clwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHIoZSwgYXR0cikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfSAvLyBoYW5kbGUgdG9vbHRpcCBmb3IgaGVhdG1hcHMgYW5kIHRyZWVtYXBzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlSGVhdFRyZWVUb29sdGlwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlSGVhdFRyZWVUb29sdGlwKF9yZWYpIHtcbiAgICAgICAgdmFyIGUgPSBfcmVmLmUsXG4gICAgICAgICAgICBvcHQgPSBfcmVmLm9wdCxcbiAgICAgICAgICAgIHggPSBfcmVmLngsXG4gICAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgICAgdHlwZSA9IF9yZWYudHlwZTtcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLXJlY3RcIikpKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHIoZSwgJ2knKTtcbiAgICAgICAgICB2YXIgaiA9IHRoaXMuZ2V0QXR0cihlLCAnaicpO1xuICAgICAgICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cihlLCAnY3gnKTtcbiAgICAgICAgICB2YXIgY3kgPSB0aGlzLmdldEF0dHIoZSwgJ2N5Jyk7XG4gICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRBdHRyKGUsICd3aWR0aCcpO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEF0dHIoZSwgJ2hlaWdodCcpO1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKHtcbiAgICAgICAgICAgIHR0SXRlbXM6IG9wdC50dEl0ZW1zLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZTogZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHcuZ2xvYmFscy5jYXB0dXJlZFNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICB3Lmdsb2JhbHMuY2FwdHVyZWREYXRhUG9pbnRJbmRleCA9IGo7XG4gICAgICAgICAgeCA9IGN4ICsgdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aCAvIDIgKyB3aWR0aDtcbiAgICAgICAgICB5ID0gY3kgKyB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAvIDIgLSBoZWlnaHQgLyAyO1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoY3ggKyB3aWR0aCAvIDIpO1xuXG4gICAgICAgICAgaWYgKHggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMikge1xuICAgICAgICAgICAgeCA9IGN4IC0gdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aCAvIDIgKyB3aWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHRDdHgudy5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IHcuZ2xvYmFscy5kb20uZWxXcmFwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgeCA9IHcuZ2xvYmFscy5jbGllbnRYIC0gc2VyaWVzQm91bmQubGVmdCAtICh4ID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIgPyB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoIDogMCk7XG4gICAgICAgICAgICB5ID0gdy5nbG9iYWxzLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3AgLSAoeSA+IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gMiA/IHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IDogMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIHRvb2x0aXBzIGZvciBsaW5lL2FyZWEvc2NhdHRlciBjaGFydHMgd2hlcmUgdG9vbHRpcC5pbnRlcnNlY3QgaXMgdHJ1ZVxuICAgICAgICogd2hlbiB1c2VyIGhvdmVycyBvdmVyIHRoZSBtYXJrZXIgZGlyZWN0bHksIHRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZU1hcmtlclRvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNYXJrZXJUb29sdGlwKF9yZWYyKSB7XG4gICAgICAgIHZhciBlID0gX3JlZjIuZSxcbiAgICAgICAgICAgIG9wdCA9IF9yZWYyLm9wdCxcbiAgICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgICAgeSA9IF9yZWYyLnk7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGo7XG5cbiAgICAgICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1tYXJrZXInKSkge1xuICAgICAgICAgIHZhciBjeCA9IHBhcnNlSW50KG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ2N4JyksIDEwKTtcbiAgICAgICAgICB2YXIgY3kgPSBwYXJzZUludChvcHQucGF0aHMuZ2V0QXR0cmlidXRlKCdjeScpLCAxMCk7XG4gICAgICAgICAgdmFyIHZhbCA9IHBhcnNlRmxvYXQob3B0LnBhdGhzLmdldEF0dHJpYnV0ZSgndmFsJykpO1xuICAgICAgICAgIGogPSBwYXJzZUludChvcHQucGF0aHMuZ2V0QXR0cmlidXRlKCdyZWwnKSwgMTApO1xuICAgICAgICAgIGkgPSBwYXJzZUludChvcHQucGF0aHMucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdyZWwnKSwgMTApIC0gMTtcblxuICAgICAgICAgIGlmICh0dEN0eC5pbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFV0aWxzJDEuZmluZEFuY2VzdG9yKG9wdC5wYXRocywgJ2FwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBpID0gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHRDdHgudG9vbHRpcExhYmVscy5kcmF3U2VyaWVzVGV4dHMoe1xuICAgICAgICAgICAgdHRJdGVtczogb3B0LnR0SXRlbXMsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgIHNoYXJlZDogdHRDdHguc2hvd09uSW50ZXJzZWN0ID8gZmFsc2UgOiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZCxcbiAgICAgICAgICAgIGU6IGVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgdHRDdHgubWFya2VyQ2xpY2soZSwgaSwgaik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLmNhcHR1cmVkU2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgIHcuZ2xvYmFscy5jYXB0dXJlZERhdGFQb2ludEluZGV4ID0gajtcbiAgICAgICAgICB4ID0gY3g7XG4gICAgICAgICAgeSA9IGN5ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVkgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAqIDEuNDtcblxuICAgICAgICAgIGlmICh0dEN0eC53LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgeSA9IHR0Q3R4LmUuY2xpZW50WSArIHcuZ2xvYmFscy50cmFuc2xhdGVZIC0gc2VyaWVzQm91bmQudG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICB5ID0gY3k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHRDdHgubWFya2VyLmVubGFyZ2VDdXJyZW50UG9pbnQoaiwgb3B0LnBhdGhzLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSB0b29sdGlwcyBmb3IgYmFyL2NvbHVtbiBjaGFydHNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZUJhclRvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVCYXJUb29sdGlwKF9yZWYzKSB7XG4gICAgICAgIHZhciBlID0gX3JlZjMuZSxcbiAgICAgICAgICAgIG9wdCA9IF9yZWYzLm9wdDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICAgIHZhciB0b29sdGlwRWwgPSB0dEN0eC5nZXRFbFRvb2x0aXAoKTtcbiAgICAgICAgdmFyIGJ4ID0gMDtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgYmFyWFkgPSB0aGlzLmdldEJhclRvb2x0aXBYWSh7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBvcHQ6IG9wdFxuICAgICAgICB9KTtcbiAgICAgICAgaSA9IGJhclhZLmk7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSBiYXJYWS5iYXJIZWlnaHQ7XG4gICAgICAgIHZhciBqID0gYmFyWFkuajtcbiAgICAgICAgdy5nbG9iYWxzLmNhcHR1cmVkU2VyaWVzSW5kZXggPSBpO1xuICAgICAgICB3Lmdsb2JhbHMuY2FwdHVyZWREYXRhUG9pbnRJbmRleCA9IGo7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwgJiYgdHRDdHgudG9vbHRpcFV0aWwuaGFzQmFycygpIHx8ICF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgIHggPSBiYXJYWS54O1xuICAgICAgICAgIHkgPSBiYXJYWS55O1xuICAgICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpID8gdy5jb25maWcuc3Ryb2tlLndpZHRoW2ldIDogdy5jb25maWcuc3Ryb2tlLndpZHRoO1xuICAgICAgICAgIGJ4ID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHJlLWNoZWNrIHRoaXMgY29uZGl0aW9uIGFzIGl0J3MgYWx3YXlzIDBcbiAgICAgICAgICAgIGJ4ID0gYnggLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB5IGlzIE5hTiwgbWFrZSBpdCB0b3VjaCB0aGUgYm90dG9tIG9mIGdyaWQgYXJlYVxuXG5cbiAgICAgICAgaWYgKGlzTmFOKHkpKSB7XG4gICAgICAgICAgeSA9IHcuZ2xvYmFscy5zdmdIZWlnaHQgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IHBhcnNlSW50KG9wdC5wYXRocy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSwgMTApO1xuICAgICAgICB2YXIgaXNSZXZlcnNlZCA9IHcuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMgPyB3LmNvbmZpZy55YXhpc1tzZXJpZXNJbmRleF0gJiYgdy5jb25maWcueWF4aXNbc2VyaWVzSW5kZXhdLnJldmVyc2VkIDogdy5jb25maWcueWF4aXNbMF0ucmV2ZXJzZWQ7XG5cbiAgICAgICAgaWYgKHggKyB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAmJiAhaXNSZXZlcnNlZCkge1xuICAgICAgICAgIHggPSB4IC0gdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgMCkge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR0Q3R4LncuY29uZmlnLnRvb2x0aXAuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB5ID0gdHRDdHguZS5jbGllbnRZIC0gc2VyaWVzQm91bmQudG9wO1xuICAgICAgICB9IC8vIGlmIHRvb2x0aXAgaXMgc3RpbGwgbnVsbCwgcXVlcnlTZWxlY3RvclxuXG5cbiAgICAgICAgaWYgKHR0Q3R4LnRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICB0dEN0eC50b29sdGlwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuY29tYm9CYXJDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoYnggKyBzdHJva2VXaWR0aCAvIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVhDcm9zc2hhaXJzKGJ4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gbW92ZSB0b29sdGlwIGhlcmVcblxuXG4gICAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwICYmICghdy5jb25maWcudG9vbHRpcC5zaGFyZWQgfHwgdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB0dEN0eC50b29sdGlwVXRpbC5oYXNCYXJzKCkpKSB7XG4gICAgICAgICAgaWYgKGlzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIHggPSB4IC0gdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aDtcblxuICAgICAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1JldmVyc2VkICYmICEody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB0dEN0eC50b29sdGlwVXRpbC5oYXNCYXJzKCkpKSB7XG4gICAgICAgICAgICB5ID0geSArIGJhckhlaWdodCAtICh3Lmdsb2JhbHMuc2VyaWVzW2ldW2pdIDwgMCA/IGJhckhlaWdodCA6IDApICogMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5ID0geSArIHcuZ2xvYmFscy50cmFuc2xhdGVZIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyO1xuICAgICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArIHcuZ2xvYmFscy50cmFuc2xhdGVYICsgJ3B4JztcbiAgICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0QmFyVG9vbHRpcFhZXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFyVG9vbHRpcFhZKF9yZWY0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGUgPSBfcmVmNC5lLFxuICAgICAgICAgICAgb3B0ID0gX3JlZjQub3B0O1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGogPSBudWxsO1xuICAgICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICB2YXIgYmFyV2lkdGggPSAwO1xuICAgICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGNsID0gZS50YXJnZXQuY2xhc3NMaXN0O1xuXG4gICAgICAgIGlmIChjbC5jb250YWlucygnYXBleGNoYXJ0cy1iYXItYXJlYScpIHx8IGNsLmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLWFyZWEnKSB8fCBjbC5jb250YWlucygnYXBleGNoYXJ0cy1ib3hQbG90LWFyZWEnKSB8fCBjbC5jb250YWlucygnYXBleGNoYXJ0cy1yYW5nZWJhci1hcmVhJykpIHtcbiAgICAgICAgICB2YXIgYmFyID0gZS50YXJnZXQ7XG4gICAgICAgICAgdmFyIGJhclJlY3QgPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gb3B0LmVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgYmggPSBiYXJSZWN0LmhlaWdodDtcbiAgICAgICAgICBiYXJIZWlnaHQgPSBiYXJSZWN0LmhlaWdodDtcbiAgICAgICAgICB2YXIgYncgPSBiYXJSZWN0LndpZHRoO1xuICAgICAgICAgIHZhciBjeCA9IHBhcnNlSW50KGJhci5nZXRBdHRyaWJ1dGUoJ2N4JyksIDEwKTtcbiAgICAgICAgICB2YXIgY3kgPSBwYXJzZUludChiYXIuZ2V0QXR0cmlidXRlKCdjeScpLCAxMCk7XG4gICAgICAgICAgYmFyV2lkdGggPSBwYXJzZUZsb2F0KGJhci5nZXRBdHRyaWJ1dGUoJ2JhcldpZHRoJykpO1xuICAgICAgICAgIHZhciBjbGllbnRYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYO1xuICAgICAgICAgIGogPSBwYXJzZUludChiYXIuZ2V0QXR0cmlidXRlKCdqJyksIDEwKTtcbiAgICAgICAgICBpID0gcGFyc2VJbnQoYmFyLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdyZWwnKSwgMTApIC0gMTtcbiAgICAgICAgICB2YXIgeTEgPSBiYXIuZ2V0QXR0cmlidXRlKCdkYXRhLXJhbmdlLXkxJyk7XG4gICAgICAgICAgdmFyIHkyID0gYmFyLmdldEF0dHJpYnV0ZSgnZGF0YS1yYW5nZS15MicpO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5jb21ib0NoYXJ0cykge1xuICAgICAgICAgICAgaSA9IHBhcnNlSW50KGJhci5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSwgMTApO1xuICAgICAgICAgIH0gLy8gaWYgKHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgICAgLy8gdGhpcyBjaGVjayBub3QgbmVlZGVkICBhdCB0aGUgbW9tZW50XG4gICAgICAgICAgLy8gICBjb25zdCB5RGl2aXNvciA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoKVxuICAgICAgICAgIC8vICAgY29uc3QgaG92ZXJZID0gdHRDdHguY2xpZW50WSAtIHR0Q3R4LnNlcmllc0JvdW5kLnRvcFxuICAgICAgICAgIC8vICAgaiA9IE1hdGguY2VpbChob3ZlclkgLyB5RGl2aXNvcilcbiAgICAgICAgICAvLyB9XG5cblxuICAgICAgICAgIHZhciBoYW5kbGVYRm9yQ29sdW1ucyA9IGZ1bmN0aW9uIGhhbmRsZVhGb3JDb2x1bW5zKHgpIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgICB4ID0gY3ggLSBidyAvIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNWZXJ0aWNhbEdyb3VwZWRSYW5nZUJhcikge1xuICAgICAgICAgICAgICAgIHggPSBjeCArIGJ3IC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gY3ggLSB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoICsgYncgLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgaGFuZGxlWUZvckJhcnMgPSBmdW5jdGlvbiBoYW5kbGVZRm9yQmFycygpIHtcbiAgICAgICAgICAgIHJldHVybiBjeSAtIHR0Q3R4LmRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ICsgYmggLyAyIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0dEN0eC50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgICB0dEl0ZW1zOiBvcHQudHRJdGVtcyxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgeTE6IHkxID8gcGFyc2VJbnQoeTEsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICB5MjogeTIgPyBwYXJzZUludCh5MiwgMTApIDogbnVsbCxcbiAgICAgICAgICAgIHNoYXJlZDogdHRDdHguc2hvd09uSW50ZXJzZWN0ID8gZmFsc2UgOiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZCxcbiAgICAgICAgICAgIGU6IGVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgeCA9IGNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0ICsgMTU7XG4gICAgICAgICAgICAgIHkgPSBoYW5kbGVZRm9yQmFycygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9IGhhbmRsZVhGb3JDb2x1bW5zKHgpO1xuICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZIC0gc2VyaWVzQm91bmQudG9wIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyIC0gMTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgIHggPSBjeDtcblxuICAgICAgICAgICAgICBpZiAoeCA8IHR0Q3R4Lnh5UmF0aW9zLmJhc2VMaW5lSW52ZXJ0ZWRZKSB7XG4gICAgICAgICAgICAgICAgeCA9IGN4IC0gdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHkgPSBoYW5kbGVZRm9yQmFycygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9IGhhbmRsZVhGb3JDb2x1bW5zKHgpO1xuICAgICAgICAgICAgICB5ID0gY3k7IC8vIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyICsgMTBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEludGVyc2VjdDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIFRvb2x0aXAuQXhlc1Rvb2x0aXAgQ2xhc3MuXG4gICAqIFRoaXMgZmlsZSBkZWFscyB3aXRoIHRoZSB4LWF4aXMgYW5kIHktYXhpcyB0b29sdGlwcy5cbiAgICpcbiAgICogQG1vZHVsZSBUb29sdGlwLkF4ZXNUb29sdGlwXG4gICAqKi9cbiAgdmFyIEF4ZXNUb29sdGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBeGVzVG9vbHRpcCh0b29sdGlwQ29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF4ZXNUb29sdGlwKTtcblxuICAgICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYWRkcyB0aGUgc2Vjb25kYXJ5IHRvb2x0aXAgd2hpY2ggYXBwZWFycyBiZWxvdyB4IGF4aXNcbiAgICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgICAqKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEF4ZXNUb29sdGlwLCBbe1xuICAgICAga2V5OiBcImRyYXdYYXhpc1Rvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WGF4aXNUb29sdGlwKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgICAgdmFyIGlzQm90dG9tID0gdy5jb25maWcueGF4aXMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICAgICAgICB0dEN0eC54YXhpc09mZlkgPSBpc0JvdHRvbSA/IHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgMSA6IC13Lmdsb2JhbHMueEF4aXNIZWlnaHQgLSB3LmNvbmZpZy54YXhpcy5heGlzVGlja3MuaGVpZ2h0ICsgMztcbiAgICAgICAgdmFyIHRvb2x0aXBDc3NDbGFzcyA9IGlzQm90dG9tID8gJ2FwZXhjaGFydHMteGF4aXN0b29sdGlwIGFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbScgOiAnYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdG9wJztcbiAgICAgICAgdmFyIHJlbmRlclRvID0gdy5nbG9iYWxzLmRvbS5lbFdyYXA7XG5cbiAgICAgICAgaWYgKHR0Q3R4LmlzWEF4aXNUb29sdGlwRW5hYmxlZCkge1xuICAgICAgICAgIHZhciB4YXhpc1Rvb2x0aXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAnKTtcblxuICAgICAgICAgIGlmICh4YXhpc1Rvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0b29sdGlwQ3NzQ2xhc3MgKyAnIGFwZXhjaGFydHMtdGhlbWUtJyArIHcuY29uZmlnLnRvb2x0aXAudGhlbWUpO1xuICAgICAgICAgICAgcmVuZGVyVG8uYXBwZW5kQ2hpbGQodHRDdHgueGF4aXNUb29sdGlwKTtcbiAgICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdGV4dCcpO1xuICAgICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwVGV4dC5zdHlsZS5mb250RmFtaWx5ID0gdy5jb25maWcueGF4aXMudG9vbHRpcC5zdHlsZS5mb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LnN0eWxlLmZvbnRTaXplID0gdy5jb25maWcueGF4aXMudG9vbHRpcC5zdHlsZS5mb250U2l6ZTtcbiAgICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5hcHBlbmRDaGlsZCh0dEN0eC54YXhpc1Rvb2x0aXBUZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgYWRkcyB0aGUgc2Vjb25kYXJ5IHRvb2x0aXAgd2hpY2ggYXBwZWFycyBiZWxvdyB4IGF4aXNcbiAgICAgICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1lheGlzVG9vbHRpcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZYXhpc1Rvb2x0aXAoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICB2YXIgaXNSaWdodCA9IHcuY29uZmlnLnlheGlzW2ldLm9wcG9zaXRlIHx8IHcuY29uZmlnLnlheGlzW2ldLmNyb3NzaGFpcnMub3Bwb3NpdGU7XG4gICAgICAgICAgdHRDdHgueWF4aXNPZmZYID0gaXNSaWdodCA/IHcuZ2xvYmFscy5ncmlkV2lkdGggKyAxIDogMTtcbiAgICAgICAgICB2YXIgdG9vbHRpcENzc0NsYXNzID0gaXNSaWdodCA/IFwiYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtXCIuY29uY2F0KGksIFwiIGFwZXhjaGFydHMteWF4aXN0b29sdGlwLXJpZ2h0XCIpIDogXCJhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCBhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1cIi5jb25jYXQoaSwgXCIgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtbGVmdFwiKTtcbiAgICAgICAgICB3Lmdsb2JhbHMueUF4aXNTYW1lU2NhbGVJbmRpY2VzLm1hcChmdW5jdGlvbiAoc2FtZXNjYWxlcywgc3NpKSB7XG4gICAgICAgICAgICBzYW1lc2NhbGVzLm1hcChmdW5jdGlvbiAocywgc2kpIHtcbiAgICAgICAgICAgICAgaWYgKHNpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcENzc0NsYXNzICs9IHcuY29uZmlnLnlheGlzW3NpXS5zaG93ID8gXCIgXCIgOiBcIiBhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1oaWRkZW5cIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHJlbmRlclRvID0gdy5nbG9iYWxzLmRvbS5lbFdyYXA7XG4gICAgICAgICAgdmFyIHlheGlzVG9vbHRpcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtXCIuY29uY2F0KGkpKTtcblxuICAgICAgICAgIGlmICh5YXhpc1Rvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0b29sdGlwQ3NzQ2xhc3MgKyAnIGFwZXhjaGFydHMtdGhlbWUtJyArIHcuY29uZmlnLnRvb2x0aXAudGhlbWUpO1xuICAgICAgICAgICAgcmVuZGVyVG8uYXBwZW5kQ2hpbGQodHRDdHgueWF4aXNUb29sdGlwKTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB0dEN0eC55YXhpc1Rvb2x0aXBUZXh0ID0gW107XG4gICAgICAgICAgICB0dEN0eC55YXhpc1Rvb2x0aXBUZXh0W2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0dEN0eC55YXhpc1Rvb2x0aXBUZXh0W2ldLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMteWF4aXN0b29sdGlwLXRleHQnKTtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcC5hcHBlbmRDaGlsZCh0dEN0eC55YXhpc1Rvb2x0aXBUZXh0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3LmNvbmZpZy55YXhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0WENyb3NzaGFpcldpZHRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WENyb3NzaGFpcldpZHRoKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDsgLy8gc2V0IHhjcm9zc2hhaXJzIHdpZHRoXG5cbiAgICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdHRDdHguZ2V0RWxYQ3Jvc3NoYWlycygpO1xuICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gcGFyc2VJbnQody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCwgMTApO1xuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICd0aWNrV2lkdGgnKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB3Lmdsb2JhbHMubGFiZWxzLmxlbmd0aDtcbiAgICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gY291bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAnYmFyV2lkdGgnKSB7XG4gICAgICAgICAgICB2YXIgYmFyID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtYmFyLWFyZWEnKTtcblxuICAgICAgICAgICAgaWYgKGJhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgYmFyV2lkdGggPSBwYXJzZUZsb2F0KGJhci5nZXRBdHRyaWJ1dGUoJ2JhcldpZHRoJykpO1xuICAgICAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gYmFyV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9iYXIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1iYXItYXJlYScpO1xuXG4gICAgICAgICAgaWYgKF9iYXIgIT09IG51bGwgJiYgdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICAgICAgdmFyIF9iYXJXaWR0aCA9IHBhcnNlRmxvYXQoX2Jhci5nZXRBdHRyaWJ1dGUoJ2JhcldpZHRoJykpO1xuXG4gICAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gX2JhcldpZHRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ3RpY2tXaWR0aCcpIHtcbiAgICAgICAgICAgICAgdmFyIF9jb3VudCA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuICAgICAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIF9jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHhjcm9zc2hhaXJzICE9PSBudWxsICYmIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPiAwKSB7XG4gICAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZVlDcm9zc2hhaXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVZQ3Jvc3NoYWlyKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDsgLy8gc2V0IHljcm9zc2hhaXJzIGhlaWdodFxuXG4gICAgICAgIHR0Q3R4Lnljcm9zc2hhaXJzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteWNyb3NzaGFpcnMnKTtcbiAgICAgICAgdHRDdHgueWNyb3NzaGFpcnNIaWRkZW4gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy1oaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1lheGlzVG9vbHRpcFRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WWF4aXNUb29sdGlwVGV4dChpbmRleCwgY2xpZW50WSwgeHlSYXRpb3MpIHtcbiAgICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzW2luZGV4XTtcblxuICAgICAgICBpZiAodHRDdHgueWF4aXNUb29sdGlwc1tpbmRleF0pIHtcbiAgICAgICAgICB2YXIgZWxHcmlkID0gdHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHZhciBob3ZlclkgPSAoY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCkgKiB4eVJhdGlvcy55UmF0aW9baW5kZXhdO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSB3Lmdsb2JhbHMubWF4WUFycltpbmRleF0gLSB3Lmdsb2JhbHMubWluWUFycltpbmRleF07XG4gICAgICAgICAgdmFyIHZhbCA9IHcuZ2xvYmFscy5taW5ZQXJyW2luZGV4XSArIChoZWlnaHQgLSBob3ZlclkpO1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWUNyb3NzaGFpcnMoY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCk7XG4gICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwVGV4dFtpbmRleF0uaW5uZXJIVE1MID0gbGJGb3JtYXR0ZXIodmFsKTtcbiAgICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVlBeGlzVG9vbHRpcChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQXhlc1Rvb2x0aXA7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBDb3JlIFRvb2x0aXAgQ2xhc3MgdG8gaGFuZGxlIHRoZSB0b29sdGlwIGdlbmVyYXRpb24uXG4gICAqXG4gICAqIEBtb2R1bGUgVG9vbHRpcFxuICAgKiovXG5cbiAgdmFyIFRvb2x0aXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvb2x0aXAoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMudENvbmZpZyA9IHcuY29uZmlnLnRvb2x0aXA7XG4gICAgICB0aGlzLnRvb2x0aXBVdGlsID0gbmV3IFV0aWxzKHRoaXMpO1xuICAgICAgdGhpcy50b29sdGlwTGFiZWxzID0gbmV3IExhYmVscyh0aGlzKTtcbiAgICAgIHRoaXMudG9vbHRpcFBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHRoaXMpO1xuICAgICAgdGhpcy5tYXJrZXIgPSBuZXcgTWFya2VyKHRoaXMpO1xuICAgICAgdGhpcy5pbnRlcnNlY3QgPSBuZXcgSW50ZXJzZWN0KHRoaXMpO1xuICAgICAgdGhpcy5heGVzVG9vbHRpcCA9IG5ldyBBeGVzVG9vbHRpcCh0aGlzKTtcbiAgICAgIHRoaXMuc2hvd09uSW50ZXJzZWN0ID0gdGhpcy50Q29uZmlnLmludGVyc2VjdDtcbiAgICAgIHRoaXMuc2hvd1Rvb2x0aXBUaXRsZSA9IHRoaXMudENvbmZpZy54LnNob3c7XG4gICAgICB0aGlzLmZpeGVkVG9vbHRpcCA9IHRoaXMudENvbmZpZy5maXhlZC5lbmFibGVkO1xuICAgICAgdGhpcy54YXhpc1Rvb2x0aXAgPSBudWxsO1xuICAgICAgdGhpcy55YXhpc1RURWxzID0gbnVsbDtcbiAgICAgIHRoaXMuaXNCYXJTaGFyZWQgPSAhdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB0aGlzLnRDb25maWcuc2hhcmVkO1xuICAgICAgdGhpcy5sYXN0SG92ZXJUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgW3tcbiAgICAgIGtleTogXCJnZXRFbFRvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbFRvb2x0aXAoY3R4KSB7XG4gICAgICAgIGlmICghY3R4KSBjdHggPSB0aGlzO1xuICAgICAgICBpZiAoIWN0eC53Lmdsb2JhbHMuZG9tLmJhc2VFbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBjdHgudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcCcpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRFbFhDcm9zc2hhaXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxYQ3Jvc3NoYWlycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGNyb3NzaGFpcnMnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RWxHcmlkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxHcmlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1ncmlkJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdUb29sdGlwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1Rvb2x0aXAoeHlSYXRpb3MpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcbiAgICAgICAgdGhpcy5pc1hBeGlzVG9vbHRpcEVuYWJsZWQgPSB3LmNvbmZpZy54YXhpcy50b29sdGlwLmVuYWJsZWQgJiYgdy5nbG9iYWxzLmF4aXNDaGFydHM7XG4gICAgICAgIHRoaXMueWF4aXNUb29sdGlwcyA9IHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeSwgaSkge1xuICAgICAgICAgIHJldHVybiB5LnNob3cgJiYgeS50b29sdGlwLmVuYWJsZWQgJiYgdy5nbG9iYWxzLmF4aXNDaGFydHMgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFsbFRvb2x0aXBTZXJpZXNHcm91cHMgPSBbXTtcblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgdGhpcy5zaG93VG9vbHRpcFRpdGxlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9vbHRpcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAnKTtcblxuICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5jc3NDbGFzcykge1xuICAgICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKHcuY29uZmlnLnRvb2x0aXAuY3NzQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQoXCJhcGV4Y2hhcnRzLXRoZW1lLVwiLmNvbmNhdCh0aGlzLnRDb25maWcudGhlbWUpKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbFdyYXAuYXBwZW5kQ2hpbGQodG9vbHRpcEVsKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICB0aGlzLmF4ZXNUb29sdGlwLmRyYXdYYXhpc1Rvb2x0aXAoKTtcbiAgICAgICAgICB0aGlzLmF4ZXNUb29sdGlwLmRyYXdZYXhpc1Rvb2x0aXAoKTtcbiAgICAgICAgICB0aGlzLmF4ZXNUb29sdGlwLnNldFhDcm9zc2hhaXJXaWR0aCgpO1xuICAgICAgICAgIHRoaXMuYXhlc1Rvb2x0aXAuaGFuZGxlWUNyb3NzaGFpcigpO1xuICAgICAgICAgIHZhciB4QXhpcyA9IG5ldyBYQXhpcyh0aGlzLmN0eCk7XG4gICAgICAgICAgdGhpcy54QXhpc1RpY2tzUG9zaXRpb25zID0geEF4aXMuZ2V0WEF4aXNUaWNrc1Bvc2l0aW9ucygpO1xuICAgICAgICB9IC8vIHdlIGZvcmNlZnVsbHkgc2V0IGludGVyc2VjdCB0cnVlIGZvciB0aGVzZSBjb25kaXRpb25zXG5cblxuICAgICAgICBpZiAoKHcuZ2xvYmFscy5jb21ib0NoYXJ0cyB8fCB0aGlzLnRDb25maWcuaW50ZXJzZWN0IHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYW5nZUJhcicpICYmICF0aGlzLnRDb25maWcuc2hhcmVkKSB7XG4gICAgICAgICAgdGhpcy5zaG93T25JbnRlcnNlY3QgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLm1hcmtlcnMuc2l6ZSA9PT0gMCB8fCB3Lmdsb2JhbHMubWFya2Vycy5sYXJnZXN0U2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIHdoZW4gdXNlciBkb24ndCB3YW50IHRvIHNob3cgcG9pbnRzIGFsbCB0aGUgdGltZSwgYnV0IG9ubHkgb24gd2hlbiBob3ZlcmluZyBvbiBzZXJpZXNcbiAgICAgICAgICB0aGlzLm1hcmtlci5kcmF3RHluYW1pY1BvaW50cyh0aGlzKTtcbiAgICAgICAgfSAvLyBubyB2aXNpYmxlIHNlcmllcywgZXhpdFxuXG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoID09PSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgdGhpcy5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3dUb29sdGlwVGl0bGUpIHtcbiAgICAgICAgICB0aGlzLnRvb2x0aXBUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRoaXMudG9vbHRpcFRpdGxlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10aXRsZScpO1xuICAgICAgICAgIHRoaXMudG9vbHRpcFRpdGxlLnN0eWxlLmZvbnRGYW1pbHkgPSB0aGlzLnRDb25maWcuc3R5bGUuZm9udEZhbWlseSB8fCB3LmNvbmZpZy5jaGFydC5mb250RmFtaWx5O1xuICAgICAgICAgIHRoaXMudG9vbHRpcFRpdGxlLnN0eWxlLmZvbnRTaXplID0gdGhpcy50Q29uZmlnLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgIHRvb2x0aXBFbC5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBUaXRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHRJdGVtc0NudCA9IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyAvLyB3aGV0aGVyIHNoYXJlZCBvciBub3QsIGRlZmF1bHQgaXMgc2hhcmVkXG5cbiAgICAgICAgaWYgKCh3Lmdsb2JhbHMueHlDaGFydHMgfHwgdy5nbG9iYWxzLmNvbWJvQ2hhcnRzKSAmJiB0aGlzLnRDb25maWcuc2hhcmVkKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnNob3dPbkludGVyc2VjdCkge1xuICAgICAgICAgICAgdHRJdGVtc0NudCA9IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dEl0ZW1zQ250ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlZ2VuZExhYmVscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0Jyk7XG4gICAgICAgIHRoaXMudHRJdGVtcyA9IHRoaXMuY3JlYXRlVFRFbGVtZW50cyh0dEl0ZW1zQ250KTtcbiAgICAgICAgdGhpcy5hZGRTVkdFdmVudHMoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3JlYXRlVFRFbGVtZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRURWxlbWVudHModHRJdGVtc0NudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdHRJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgICAgdmFyIGdUeHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBnVHh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAnKTtcbiAgICAgICAgICBnVHh0LnN0eWxlLm9yZGVyID0gdy5jb25maWcudG9vbHRpcC5pbnZlcnNlT3JkZXIgPyB0dEl0ZW1zQ250IC0gaSA6IGkgKyAxO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnRDb25maWcuc2hhcmVkICYmIF90aGlzLnRDb25maWcuZW5hYmxlZE9uU2VyaWVzICYmIEFycmF5LmlzQXJyYXkoX3RoaXMudENvbmZpZy5lbmFibGVkT25TZXJpZXMpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudENvbmZpZy5lbmFibGVkT25TZXJpZXMuaW5kZXhPZihpKSA8IDApIHtcbiAgICAgICAgICAgICAgZ1R4dC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtc2VyaWVzLWdyb3VwLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwb2ludCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICBwb2ludC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyJyk7XG4gICAgICAgICAgcG9pbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tpXTtcbiAgICAgICAgICBnVHh0LmFwcGVuZENoaWxkKHBvaW50KTtcbiAgICAgICAgICB2YXIgZ1laID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgZ1laLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10ZXh0Jyk7XG4gICAgICAgICAgZ1laLnN0eWxlLmZvbnRGYW1pbHkgPSBfdGhpcy50Q29uZmlnLnN0eWxlLmZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgICAgICBnWVouc3R5bGUuZm9udFNpemUgPSBfdGhpcy50Q29uZmlnLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgIFsneScsICdnb2FscycsICd6J10uZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICAgICAgdmFyIGdWYWxUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBnVmFsVGV4dC5jbGFzc0xpc3QuYWRkKFwiYXBleGNoYXJ0cy10b29sdGlwLVwiLmNvbmNhdChnLCBcIi1ncm91cFwiKSk7XG4gICAgICAgICAgICB2YXIgdHh0TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICB0eHRMYWJlbC5jbGFzc0xpc3QuYWRkKFwiYXBleGNoYXJ0cy10b29sdGlwLXRleHQtXCIuY29uY2F0KGcsIFwiLWxhYmVsXCIpKTtcbiAgICAgICAgICAgIGdWYWxUZXh0LmFwcGVuZENoaWxkKHR4dExhYmVsKTtcbiAgICAgICAgICAgIHZhciB0eHRWYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHR4dFZhbHVlLmNsYXNzTGlzdC5hZGQoXCJhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1cIi5jb25jYXQoZywgXCItdmFsdWVcIikpO1xuICAgICAgICAgICAgZ1ZhbFRleHQuYXBwZW5kQ2hpbGQodHh0VmFsdWUpO1xuICAgICAgICAgICAgZ1laLmFwcGVuZENoaWxkKGdWYWxUZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnVHh0LmFwcGVuZENoaWxkKGdZWik7XG4gICAgICAgICAgdG9vbHRpcEVsLmFwcGVuZENoaWxkKGdUeHQpO1xuICAgICAgICAgIHR0SXRlbXMucHVzaChnVHh0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR0SXRlbXNDbnQ7IGkrKykge1xuICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR0SXRlbXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFNWR0V2ZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNWR0V2ZW50cygpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB0eXBlID0gdy5jb25maWcuY2hhcnQudHlwZTtcbiAgICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG4gICAgICAgIHZhciBjb21tb25CYXIgPSAhISh0eXBlID09PSAnYmFyJyB8fCB0eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHR5cGUgPT09ICdib3hQbG90JyB8fCB0eXBlID09PSAncmFuZ2VCYXInKTtcbiAgICAgICAgdmFyIGNoYXJ0V2l0aG1hcmtlcnMgPSB0eXBlID09PSAnYXJlYScgfHwgdHlwZSA9PT0gJ2xpbmUnIHx8IHR5cGUgPT09ICdzY2F0dGVyJyB8fCB0eXBlID09PSAnYnViYmxlJyB8fCB0eXBlID09PSAncmFkYXInO1xuICAgICAgICB2YXIgaG92ZXJBcmVhID0gdy5nbG9iYWxzLmRvbS5QYXBlci5ub2RlO1xuICAgICAgICB2YXIgZWxHcmlkID0gdGhpcy5nZXRFbEdyaWQoKTtcblxuICAgICAgICBpZiAoZWxHcmlkKSB7XG4gICAgICAgICAgdGhpcy5zZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b29sdGlwWSA9IFtdO1xuICAgICAgICB2YXIgdG9vbHRpcFggPSBbXTtcbiAgICAgICAgdmFyIHNlcmllc0hvdmVyUGFyYW1zID0ge1xuICAgICAgICAgIGhvdmVyQXJlYTogaG92ZXJBcmVhLFxuICAgICAgICAgIGVsR3JpZDogZWxHcmlkLFxuICAgICAgICAgIHRvb2x0aXBFbDogdG9vbHRpcEVsLFxuICAgICAgICAgIHRvb2x0aXBZOiB0b29sdGlwWSxcbiAgICAgICAgICB0b29sdGlwWDogdG9vbHRpcFgsXG4gICAgICAgICAgdHRJdGVtczogdGhpcy50dEl0ZW1zXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb2ludHM7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgaWYgKGNoYXJ0V2l0aG1hcmtlcnMpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6bG9uZ2VzdFNlcmllcz0ndHJ1ZSddIC5hcGV4Y2hhcnRzLW1hcmtlclwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1vbkJhcikge1xuICAgICAgICAgICAgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzIC5hcGV4Y2hhcnRzLWJhci1hcmVhLCAuYXBleGNoYXJ0cy1zZXJpZXMgLmFwZXhjaGFydHMtY2FuZGxlc3RpY2stYXJlYSwgLmFwZXhjaGFydHMtc2VyaWVzIC5hcGV4Y2hhcnRzLWJveFBsb3QtYXJlYSwgLmFwZXhjaGFydHMtc2VyaWVzIC5hcGV4Y2hhcnRzLXJhbmdlYmFyLWFyZWEnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdoZWF0bWFwJyB8fCB0eXBlID09PSAndHJlZW1hcCcpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcyAuYXBleGNoYXJ0cy1oZWF0bWFwLCAuYXBleGNoYXJ0cy1zZXJpZXMgLmFwZXhjaGFydHMtdHJlZW1hcCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwb2ludHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgdG9vbHRpcFkucHVzaChwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdjeScpKTtcbiAgICAgICAgICAgICAgdG9vbHRpcFgucHVzaChwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdjeCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWRTaGFyZWRDaGFydFR5cGVzID0gdy5nbG9iYWxzLnh5Q2hhcnRzICYmICF0aGlzLnNob3dPbkludGVyc2VjdCB8fCB3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgIXRoaXMuc2hvd09uSW50ZXJzZWN0IHx8IGNvbW1vbkJhciAmJiB0aGlzLnRvb2x0aXBVdGlsLmhhc0JhcnMoKSAmJiB0aGlzLnRDb25maWcuc2hhcmVkO1xuXG4gICAgICAgIGlmICh2YWxpZFNoYXJlZENoYXJ0VHlwZXMpIHtcbiAgICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMoW2hvdmVyQXJlYV0sIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21tb25CYXIgJiYgIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyB8fCBjaGFydFdpdGhtYXJrZXJzICYmIHRoaXMuc2hvd09uSW50ZXJzZWN0KSB7XG4gICAgICAgICAgdGhpcy5hZGREYXRhcG9pbnRFdmVudHNMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCF3Lmdsb2JhbHMuYXhpc0NoYXJ0cyB8fCB0eXBlID09PSAnaGVhdG1hcCcgfHwgdHlwZSA9PT0gJ3RyZWVtYXAnKSB7XG4gICAgICAgICAgdmFyIHNlcmllc0FsbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcycpO1xuICAgICAgICAgIHRoaXMuYWRkUGF0aHNFdmVudExpc3RlbmVycyhzZXJpZXNBbGwsIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dPbkludGVyc2VjdCkge1xuICAgICAgICAgIHZhciBsaW5lQXJlYVBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWxpbmUtc2VyaWVzIC5hcGV4Y2hhcnRzLW1hcmtlciwgLmFwZXhjaGFydHMtYXJlYS1zZXJpZXMgLmFwZXhjaGFydHMtbWFya2VyJyk7XG5cbiAgICAgICAgICBpZiAobGluZUFyZWFQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZmluZCBhbnkgbGluZVNlcmllcywgYWRkRXZlbnRMaXN0ZW5lcnMgZm9yIHRoZW1cbiAgICAgICAgICAgIHRoaXMuYWRkUGF0aHNFdmVudExpc3RlbmVycyhsaW5lQXJlYVBvaW50cywgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICAgIH0gLy8gY29tYm8gY2hhcnRzIG1heSBoYXZlIGJhcnMsIHNvIGFkZCBldmVudCBsaXN0ZW5lcnMgaGVyZSB0b29cblxuXG4gICAgICAgICAgaWYgKHRoaXMudG9vbHRpcFV0aWwuaGFzQmFycygpICYmICF0aGlzLnRDb25maWcuc2hhcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGFwb2ludEV2ZW50c0xpc3RlbmVycyhzZXJpZXNIb3ZlclBhcmFtcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdGaXhlZFRvb2x0aXBSZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ZpeGVkVG9vbHRpcFJlY3QoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgICAgdmFyIHRvb2x0aXBSZWN0ID0gdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgdHRXaWR0aCA9IHRvb2x0aXBSZWN0LndpZHRoICsgMTA7XG4gICAgICAgIHZhciB0dEhlaWdodCA9IHRvb2x0aXBSZWN0LmhlaWdodCArIDEwO1xuICAgICAgICB2YXIgeCA9IHRoaXMudENvbmZpZy5maXhlZC5vZmZzZXRYO1xuICAgICAgICB2YXIgeSA9IHRoaXMudENvbmZpZy5maXhlZC5vZmZzZXRZO1xuICAgICAgICB2YXIgZml4ZWQgPSB0aGlzLnRDb25maWcuZml4ZWQucG9zaXRpb24udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoZml4ZWQuaW5kZXhPZigncmlnaHQnKSA+IC0xKSB7XG4gICAgICAgICAgeCA9IHggKyB3Lmdsb2JhbHMuc3ZnV2lkdGggLSB0dFdpZHRoICsgMTA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZml4ZWQuaW5kZXhPZignYm90dG9tJykgPiAtMSkge1xuICAgICAgICAgIHkgPSB5ICsgdy5nbG9iYWxzLnN2Z0hlaWdodCAtIHR0SGVpZ2h0IC0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHR0V2lkdGg6IHR0V2lkdGgsXG4gICAgICAgICAgdHRIZWlnaHQ6IHR0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZERhdGFwb2ludEV2ZW50c0xpc3RlbmVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERhdGFwb2ludEV2ZW50c0xpc3RlbmVycyhzZXJpZXNIb3ZlclBhcmFtcykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIC5hcGV4Y2hhcnRzLW1hcmtlciwgLmFwZXhjaGFydHMtYmFyLWFyZWEsIC5hcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLWFyZWEsIC5hcGV4Y2hhcnRzLWJveFBsb3QtYXJlYSwgLmFwZXhjaGFydHMtcmFuZ2ViYXItYXJlYScpO1xuICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMocG9pbnRzLCBzZXJpZXNIb3ZlclBhcmFtcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFBhdGhzRXZlbnRMaXN0ZW5lcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQYXRoc0V2ZW50TGlzdGVuZXJzKHBhdGhzLCBvcHRzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKHApIHtcbiAgICAgICAgICB2YXIgZXh0ZW5kZWRPcHRzID0ge1xuICAgICAgICAgICAgcGF0aHM6IHBhdGhzW3BdLFxuICAgICAgICAgICAgdG9vbHRpcEVsOiBvcHRzLnRvb2x0aXBFbCxcbiAgICAgICAgICAgIHRvb2x0aXBZOiBvcHRzLnRvb2x0aXBZLFxuICAgICAgICAgICAgdG9vbHRpcFg6IG9wdHMudG9vbHRpcFgsXG4gICAgICAgICAgICBlbEdyaWQ6IG9wdHMuZWxHcmlkLFxuICAgICAgICAgICAgaG92ZXJBcmVhOiBvcHRzLmhvdmVyQXJlYSxcbiAgICAgICAgICAgIHR0SXRlbXM6IG9wdHMudHRJdGVtc1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGV2ZW50cyA9IFsnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAndG91Y2htb3ZlJywgJ21vdXNlb3V0JywgJ3RvdWNoZW5kJ107XG4gICAgICAgICAgZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoc1twXS5hZGRFdmVudExpc3RlbmVyKGV2LCBzZWxmLm9uU2VyaWVzSG92ZXIuYmluZChzZWxmLCBleHRlbmRlZE9wdHMpLCB7XG4gICAgICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgX2xvb3AyKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICoqIENoZWNrIHRvIHNlZSBpZiB0aGUgdG9vbHRpcHMgc2hvdWxkIGJlIHVwZGF0ZWQgYmFzZWQgb24gYSBtb3VzZSAvIHRvdWNoIGV2ZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvblNlcmllc0hvdmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25TZXJpZXNIb3ZlcihvcHQsIGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gSWYgYSB1c2VyIGlzIG1vdmluZyB0aGVpciBtb3VzZSBxdWlja2x5LCBkb24ndCBib3RoZXIgdXBkYXRpbmcgdGhlIHRvb2x0aXAgZXZlcnkgc2luZ2xlIGZyYW1lXG4gICAgICAgIHZhciB0YXJnZXREZWxheSA9IDEwMDtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RVcGRhdGUgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0SG92ZXJUaW1lO1xuXG4gICAgICAgIGlmICh0aW1lU2luY2VMYXN0VXBkYXRlID49IHRhcmdldERlbGF5KSB7XG4gICAgICAgICAgLy8gVGhlIHRvb2x0aXAgd2FzIGxhc3QgdXBkYXRlZCBvdmVyIDEwMG1zIGFnbyAtIHJlZHJhdyBpdCBldmVuIGlmIHRoZSB1c2VyIGlzIHN0aWxsIG1vdmluZyB0aGVpclxuICAgICAgICAgIC8vIG1vdXNlIHNvIHRoZXkgZ2V0IHNvbWUgZmVlZGJhY2sgdGhhdCB0aGVpciBtb3ZlcyBhcmUgYmVpbmcgcmVnaXN0ZXJlZFxuICAgICAgICAgIHRoaXMuc2VyaWVzSG92ZXIob3B0LCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgdG9vbHRpcCB3YXMgbGFzdCB1cGRhdGVkIGxlc3MgdGhhbiAxMDBtcyBhZ29cbiAgICAgICAgICAvLyBDYW5jZWwgYW55IG90aGVyIGRlbGF5ZWQgZHJhdywgc28gd2UgZG9uJ3Qgc2hvdyBzdGFsZSBkYXRhXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2VyaWVzSG92ZXJUaW1lb3V0KTsgLy8gU2NoZWR1bGUgdGhlIG5leHQgZHJhdyBzbyB0aGF0IGl0IGhhcHBlbnMgYWJvdXQgMTAwbXMgYWZ0ZXIgdGhlIGxhc3QgdXBkYXRlXG5cbiAgICAgICAgICB0aGlzLnNlcmllc0hvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnNlcmllc0hvdmVyKG9wdCwgZSk7XG4gICAgICAgICAgfSwgdGFyZ2V0RGVsYXkgLSB0aW1lU2luY2VMYXN0VXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqKiBUaGUgYWN0dWFsIHNlcmllcyBob3ZlciBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2VyaWVzSG92ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpZXNIb3ZlcihvcHQsIGUpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5sYXN0SG92ZXJUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGNoYXJ0R3JvdXBzID0gW107XG4gICAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBpZiB1c2VyIGhhcyBtb3JlIHRoYW4gb25lIGNoYXJ0cyBpbiBncm91cCwgd2UgbmVlZCB0byBzeW5jXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgICAgY2hhcnRHcm91cHMgPSB0aGlzLmN0eC5nZXRHcm91cGVkQ2hhcnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMgJiYgKHcuZ2xvYmFscy5taW5YID09PSAtSW5maW5pdHkgJiYgdy5nbG9iYWxzLm1heFggPT09IEluZmluaXR5IHx8IHcuZ2xvYmFscy5kYXRhUG9pbnRzID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFydEdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFydEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBFbCA9IF90aGlzMy5nZXRFbFRvb2x0aXAoY2gpO1xuXG4gICAgICAgICAgICB2YXIgbmV3T3B0cyA9IHtcbiAgICAgICAgICAgICAgcGF0aHM6IG9wdC5wYXRocyxcbiAgICAgICAgICAgICAgdG9vbHRpcEVsOiB0b29sdGlwRWwsXG4gICAgICAgICAgICAgIHRvb2x0aXBZOiBvcHQudG9vbHRpcFksXG4gICAgICAgICAgICAgIHRvb2x0aXBYOiBvcHQudG9vbHRpcFgsXG4gICAgICAgICAgICAgIGVsR3JpZDogb3B0LmVsR3JpZCxcbiAgICAgICAgICAgICAgaG92ZXJBcmVhOiBvcHQuaG92ZXJBcmVhLFxuICAgICAgICAgICAgICB0dEl0ZW1zOiBjaC53Lmdsb2JhbHMudG9vbHRpcC50dEl0ZW1zXG4gICAgICAgICAgICB9OyAvLyBhbGwgdGhlIGNoYXJ0cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBtaW5YIGFuZCBtYXhYIChzYW1lIHhheGlzKSBmb3IgbXVsdGlwbGUgdG9vbHRpcHMgdG8gd29yayBjb3JyZWN0bHlcblxuICAgICAgICAgICAgaWYgKGNoLncuZ2xvYmFscy5taW5YID09PSBfdGhpczMudy5nbG9iYWxzLm1pblggJiYgY2gudy5nbG9iYWxzLm1heFggPT09IF90aGlzMy53Lmdsb2JhbHMubWF4WCkge1xuICAgICAgICAgICAgICBjaC53Lmdsb2JhbHMudG9vbHRpcC5zZXJpZXNIb3ZlckJ5Q29udGV4dCh7XG4gICAgICAgICAgICAgICAgY2hhcnRDdHg6IGNoLFxuICAgICAgICAgICAgICAgIHR0Q3R4OiBjaC53Lmdsb2JhbHMudG9vbHRpcCxcbiAgICAgICAgICAgICAgICBvcHQ6IG5ld09wdHMsXG4gICAgICAgICAgICAgICAgZTogZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlcmllc0hvdmVyQnlDb250ZXh0KHtcbiAgICAgICAgICAgIGNoYXJ0Q3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICAgIHR0Q3R4OiB0aGlzLncuZ2xvYmFscy50b29sdGlwLFxuICAgICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgICBlOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2VyaWVzSG92ZXJCeUNvbnRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpZXNIb3ZlckJ5Q29udGV4dChfcmVmKSB7XG4gICAgICAgIHZhciBjaGFydEN0eCA9IF9yZWYuY2hhcnRDdHgsXG4gICAgICAgICAgICB0dEN0eCA9IF9yZWYudHRDdHgsXG4gICAgICAgICAgICBvcHQgPSBfcmVmLm9wdCxcbiAgICAgICAgICAgIGUgPSBfcmVmLmU7XG4gICAgICAgIHZhciB3ID0gY2hhcnRDdHgudztcbiAgICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG4gICAgICAgIGlmICghdG9vbHRpcEVsKSByZXR1cm47IC8vIHRvb2x0aXBSZWN0IGlzIGNhbGN1bGF0ZWQgb24gZXZlcnkgbW91c2Vtb3ZlLCBiZWNhdXNlIHRoZSB0ZXh0IGlzIGR5bmFtaWNcblxuICAgICAgICB0dEN0eC50b29sdGlwUmVjdCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdHRXaWR0aDogdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLFxuICAgICAgICAgIHR0SGVpZ2h0OiB0b29sdGlwRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHR0Q3R4LmUgPSBlOyAvLyBoaWdobGlnaHQgdGhlIGN1cnJlbnQgaG92ZXJlZCBiYXJzXG5cbiAgICAgICAgaWYgKHR0Q3R4LnRvb2x0aXBVdGlsLmhhc0JhcnMoKSAmJiAhdy5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF0dEN0eC5pc0JhclNoYXJlZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRDb25maWcub25EYXRhc2V0SG92ZXIuaGlnaGxpZ2h0RGF0YVNlcmllcykge1xuICAgICAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXMoY2hhcnRDdHgpO1xuICAgICAgICAgICAgc2VyaWVzLnRvZ2dsZVNlcmllc09uSG92ZXIoZSwgZS50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR0Q3R4LmZpeGVkVG9vbHRpcCkge1xuICAgICAgICAgIHR0Q3R4LmRyYXdGaXhlZFRvb2x0aXBSZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICB0dEN0eC5heGlzQ2hhcnRzVG9vbHRpcHMoe1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIG9wdDogb3B0LFxuICAgICAgICAgICAgdG9vbHRpcFJlY3Q6IHR0Q3R4LnRvb2x0aXBSZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm9uLXBsb3QgY2hhcnRzIGkuZSBwaWUvZG9udXQvY2lyY2xlXG4gICAgICAgICAgdHRDdHgubm9uQXhpc0NoYXJ0c1Rvb2x0aXBzKHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICBvcHQ6IG9wdCxcbiAgICAgICAgICAgIHRvb2x0aXBSZWN0OiB0dEN0eC50b29sdGlwUmVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIHRvb2x0aXAgaGFuZGxpbmcgZm9yIGxpbmUvYXJlYS9iYXIvY29sdW1ucy9zY2F0dGVyXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXhpc0NoYXJ0c1Rvb2x0aXBzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXhpc0NoYXJ0c1Rvb2x0aXBzKF9yZWYyKSB7XG4gICAgICAgIHZhciBlID0gX3JlZjIuZSxcbiAgICAgICAgICAgIG9wdCA9IF9yZWYyLm9wdDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4LCB5O1xuICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBvcHQuZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY2xpZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgICAgdmFyIGNsaWVudFkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50b3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFk7XG4gICAgICAgIHRoaXMuY2xpZW50WSA9IGNsaWVudFk7XG4gICAgICAgIHRoaXMuY2xpZW50WCA9IGNsaWVudFg7XG4gICAgICAgIHcuZ2xvYmFscy5jYXB0dXJlZFNlcmllc0luZGV4ID0gLTE7XG4gICAgICAgIHcuZ2xvYmFscy5jYXB0dXJlZERhdGFQb2ludEluZGV4ID0gLTE7XG5cbiAgICAgICAgaWYgKGNsaWVudFkgPCBzZXJpZXNCb3VuZC50b3AgfHwgY2xpZW50WSA+IHNlcmllc0JvdW5kLnRvcCArIHNlcmllc0JvdW5kLmhlaWdodCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VPdXQob3B0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnRDb25maWcuZW5hYmxlZE9uU2VyaWVzKSAmJiAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChvcHQucGF0aHMuZ2V0QXR0cmlidXRlKCdpbmRleCcpLCAxMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy50Q29uZmlnLmVuYWJsZWRPblNlcmllcy5pbmRleE9mKGluZGV4KSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VPdXQob3B0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdGhpcy5nZXRFbFhDcm9zc2hhaXJzKCk7XG4gICAgICAgIHZhciBpc1N0aWNreVRvb2x0aXAgPSB3Lmdsb2JhbHMueHlDaGFydHMgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwgJiYgdGhpcy50b29sdGlwVXRpbC5oYXNCYXJzKCkgJiYgdGhpcy50Q29uZmlnLnNoYXJlZCB8fCB3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgdGhpcy50b29sdGlwVXRpbC5oYXNCYXJzKCk7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHNlcmllcyB0byBob3ZlciBvdmVyXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoICsgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcy5sZW5ndGggPT09IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHhjcm9zc2hhaXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB4Y3Jvc3NoYWlycy5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWFjdGl2ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYXNZQXhpc1Rvb2x0aXAgPSB0aGlzLnlheGlzVG9vbHRpcHMuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiA9PT0gdHJ1ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLnljcm9zc2hhaXJzICE9PSBudWxsICYmIGhhc1lBeGlzVG9vbHRpcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMueWNyb3NzaGFpcnMuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTdGlja3lUb29sdGlwICYmICF0aGlzLnNob3dPbkludGVyc2VjdCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGlja3lUb29sdGlwKGUsIGNsaWVudFgsIGNsaWVudFksIG9wdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3RyZWVtYXAnKSB7XG4gICAgICAgICAgICAgIHZhciBtYXJrZXJYWSA9IHRoaXMuaW50ZXJzZWN0LmhhbmRsZUhlYXRUcmVlVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgICBvcHQ6IG9wdCxcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgdHlwZTogdy5jb25maWcuY2hhcnQudHlwZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgeCA9IG1hcmtlclhZLng7XG4gICAgICAgICAgICAgIHkgPSBtYXJrZXJYWS55O1xuICAgICAgICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy50b29sdGlwVXRpbC5oYXNCYXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdC5oYW5kbGVCYXJUb29sdGlwKHtcbiAgICAgICAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICAgICAgICBvcHQ6IG9wdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbHRpcFV0aWwuaGFzTWFya2VycygpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0IC0gbGluZS9hcmVhL3NjYXR0ZXIvYnViYmxlXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3QuaGFuZGxlTWFya2VyVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMueWF4aXNUb29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHl0ID0gMDsgeXQgPCB3LmNvbmZpZy55YXhpcy5sZW5ndGg7IHl0KyspIHtcbiAgICAgICAgICAgICAgdGhpcy5heGVzVG9vbHRpcC5kcmF3WWF4aXNUb29sdGlwVGV4dCh5dCwgY2xpZW50WSwgdGhpcy54eVJhdGlvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0LnRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWFjdGl2ZScpO1xuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0JyB8fCBlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlT3V0KG9wdCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdG9vbHRpcCBoYW5kbGluZyBmb3IgcGllL2RvbnV0c1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm5vbkF4aXNDaGFydHNUb29sdGlwc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5vbkF4aXNDaGFydHNUb29sdGlwcyhfcmVmMykge1xuICAgICAgICB2YXIgZSA9IF9yZWYzLmUsXG4gICAgICAgICAgICBvcHQgPSBfcmVmMy5vcHQsXG4gICAgICAgICAgICB0b29sdGlwUmVjdCA9IF9yZWYzLnRvb2x0aXBSZWN0O1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHJlbCA9IG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ3JlbCcpO1xuICAgICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gdy5nbG9iYWxzLmRvbS5lbFdyYXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWFjdGl2ZScpO1xuICAgICAgICAgIHRoaXMudG9vbHRpcExhYmVscy5kcmF3U2VyaWVzVGV4dHMoe1xuICAgICAgICAgICAgdHRJdGVtczogb3B0LnR0SXRlbXMsXG4gICAgICAgICAgICBpOiBwYXJzZUludChyZWwsIDEwKSAtIDEsXG4gICAgICAgICAgICBzaGFyZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnQgLSB0b29sdGlwUmVjdC50dFdpZHRoIC8gMjtcbiAgICAgICAgICB2YXIgeSA9IHcuZ2xvYmFscy5jbGllbnRZIC0gc2VyaWVzQm91bmQudG9wIC0gdG9vbHRpcFJlY3QudHRIZWlnaHQgLSAxMDtcbiAgICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQudG9vbHRpcEhvdmVyRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB2YXIgbGVnZW5kRm9ybWF0dGVyID0gdy5jb25maWcubGVnZW5kLnRvb2x0aXBIb3ZlckZvcm1hdHRlcjtcbiAgICAgICAgICAgIHZhciBpID0gcmVsIC0gMTtcbiAgICAgICAgICAgIHZhciBsZWdlbmROYW1lID0gdGhpcy5sZWdlbmRMYWJlbHNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhOmRlZmF1bHQtdGV4dCcpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBsZWdlbmRGb3JtYXR0ZXIobGVnZW5kTmFtZSwge1xuICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sZWdlbmRMYWJlbHNbaV0uaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnIHx8IGUudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QucmVtb3ZlKCdhcGV4Y2hhcnRzLWFjdGl2ZScpO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC50b29sdGlwSG92ZXJGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTGFiZWxzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgdmFyIGRlZmF1bHRUZXh0ID0gbC5nZXRBdHRyaWJ1dGUoJ2RhdGE6ZGVmYXVsdC10ZXh0Jyk7XG4gICAgICAgICAgICAgIGwuaW5uZXJIVE1MID0gZGVjb2RlVVJJQ29tcG9uZW50KGRlZmF1bHRUZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVTdGlja3lUb29sdGlwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU3RpY2t5VG9vbHRpcChlLCBjbGllbnRYLCBjbGllbnRZLCBvcHQpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBjYXBqID0gdGhpcy50b29sdGlwVXRpbC5nZXROZWFyZXN0VmFsdWVzKHtcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgICAgIGhvdmVyQXJlYTogb3B0LmhvdmVyQXJlYSxcbiAgICAgICAgICBlbEdyaWQ6IG9wdC5lbEdyaWQsXG4gICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiBjbGllbnRZXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaiA9IGNhcGouajtcbiAgICAgICAgdmFyIGNhcHR1cmVkU2VyaWVzID0gY2Fwai5jYXB0dXJlZFNlcmllcztcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluY2x1ZGVzKGNhcHR1cmVkU2VyaWVzKSkgY2FwdHVyZWRTZXJpZXMgPSBudWxsO1xuICAgICAgICB2YXIgYm91bmRzID0gb3B0LmVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpZiAoY2Fwai5ob3ZlclggPCAwIHx8IGNhcGouaG92ZXJYID4gYm91bmRzLndpZHRoKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZU91dChvcHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYXB0dXJlZFNlcmllcyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlU3RpY2t5Q2FwdHVyZWRTZXJpZXMoZSwgY2FwdHVyZWRTZXJpZXMsIG9wdCwgaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY291bGRuJ3QgY2FwdHVyZSBhbnkgc2VyaWVzLiBjaGVjayBpZiBzaGFyZWQgWCBpcyBzYW1lLFxuICAgICAgICAgIC8vIGlmIHllcywgZHJhdyBhIGdyb3VwZWQgdG9vbHRpcFxuICAgICAgICAgIGlmICh0aGlzLnRvb2x0aXBVdGlsLmlzWG92ZXJsYXAoaikgfHwgdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0VmlzaWJsZVNlcmllcyA9IHcuZ2xvYmFscy5zZXJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5jbHVkZXMoaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlKGUsIHRoaXMsIGZpcnN0VmlzaWJsZVNlcmllcywgaiwgb3B0LnR0SXRlbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVTdGlja3lDYXB0dXJlZFNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVN0aWNreUNhcHR1cmVkU2VyaWVzKGUsIGNhcHR1cmVkU2VyaWVzLCBvcHQsIGopIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRDb25maWcuc2hhcmVkKSB7XG4gICAgICAgICAgdmFyIGlnbm9yZU51bGwgPSB3Lmdsb2JhbHMuc2VyaWVzW2NhcHR1cmVkU2VyaWVzXVtqXSA9PT0gbnVsbDtcblxuICAgICAgICAgIGlmIChpZ25vcmVOdWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlT3V0KG9wdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VyaWVzW2NhcHR1cmVkU2VyaWVzXVtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAodGhpcy50Q29uZmlnLnNoYXJlZCAmJiB0aGlzLnRvb2x0aXBVdGlsLmlzWG92ZXJsYXAoaikgJiYgdGhpcy50b29sdGlwVXRpbC5pc0luaXRpYWxTZXJpZXNTYW1lTGVuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlKGUsIHRoaXMsIGNhcHR1cmVkU2VyaWVzLCBqLCBvcHQudHRJdGVtcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlKGUsIHRoaXMsIGNhcHR1cmVkU2VyaWVzLCBqLCBvcHQudHRJdGVtcywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy50b29sdGlwVXRpbC5pc1hvdmVybGFwKGopKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RWaXNpYmxlU2VyaWVzID0gdy5nbG9iYWxzLnNlcmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICF3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmNsdWRlcyhpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGUoZSwgdGhpcywgZmlyc3RWaXNpYmxlU2VyaWVzLCBqLCBvcHQudHRJdGVtcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlYWN0aXZhdGVIb3ZlckZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlYWN0aXZhdGVIb3ZlckZpbHRlcigpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBhbGxQYXRocyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiLmFwZXhjaGFydHMtYmFyLWFyZWFcIik7XG5cbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBhbGxQYXRocy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgIGdyYXBoaWNzLnBhdGhNb3VzZUxlYXZlKGFsbFBhdGhzW2JdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVNb3VzZU91dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlT3V0KG9wdCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdGhpcy5nZXRFbFhDcm9zc2hhaXJzKCk7XG4gICAgICAgIG9wdC50b29sdGlwRWwuY2xhc3NMaXN0LnJlbW92ZSgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlSG92ZXJGaWx0ZXIoKTtcblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2J1YmJsZScpIHtcbiAgICAgICAgICB0aGlzLm1hcmtlci5yZXNldFBvaW50c1NpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4Y3Jvc3NoYWlycyAhPT0gbnVsbCkge1xuICAgICAgICAgIHhjcm9zc2hhaXJzLmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtYWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy55Y3Jvc3NoYWlycyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMueWNyb3NzaGFpcnMuY2xhc3NMaXN0LnJlbW92ZSgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzWEF4aXNUb29sdGlwRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMueGF4aXNUb29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtYWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy55YXhpc1Rvb2x0aXBzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0aGlzLnlheGlzVFRFbHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMueWF4aXNUVEVscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55YXhpc1RURWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnlheGlzVFRFbHNbaV0uY2xhc3NMaXN0LnJlbW92ZSgnYXBleGNoYXJ0cy1hY3RpdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcubGVnZW5kLnRvb2x0aXBIb3ZlckZvcm1hdHRlcikge1xuICAgICAgICAgIHRoaXMubGVnZW5kTGFiZWxzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VGV4dCA9IGwuZ2V0QXR0cmlidXRlKCdkYXRhOmRlZmF1bHQtdGV4dCcpO1xuICAgICAgICAgICAgbC5pbm5lckhUTUwgPSBkZWNvZGVVUklDb21wb25lbnQoZGVmYXVsdFRleHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hcmtlckNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFya2VyQ2xpY2soZSwgc2VyaWVzSW5kZXgsIGRhdGFQb2ludEluZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLm1hcmtlckNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLm1hcmtlckNsaWNrKGUsIHRoaXMuY3R4LCB7XG4gICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICB3OiB3XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eC5ldmVudHMuZmlyZUV2ZW50KCdtYXJrZXJDbGljaycsIFtlLCB0aGlzLmN0eCwge1xuICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgdzogd1xuICAgICAgICB9XSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNyZWF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShlLCBjb250ZXh0LCBjYXB0dXJlZFNlcmllcywgaiwgdHRJdGVtcykge1xuICAgICAgICB2YXIgX3ckZ2xvYmFscyRzZXJpZXNSYW5nLCBfdyRnbG9iYWxzJHNlcmllc1JhbmcyLCBfdyRnbG9iYWxzJHNlcmllc1JhbmczLCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc0LCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc1LCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc2LCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc3LCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc4LCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc5LCBfdyRnbG9iYWxzJHNlcmllc1JhbmcxMCwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTEsIF93JGdsb2JhbHMkc2VyaWVzUmFuZzEyLCBfdyRnbG9iYWxzJHNlcmllc1JhbmcxMywgX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTQsIF93JGdsb2JhbHMkc2VyaWVzUmFuZzE1LCBfdyRnbG9iYWxzJHNlcmllc1JhbmcxNjtcblxuICAgICAgICB2YXIgc2hhcmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHR0Q3R4ID0gY29udGV4dDtcblxuICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2V1cCcpIHtcbiAgICAgICAgICB0aGlzLm1hcmtlckNsaWNrKGUsIGNhcHR1cmVkU2VyaWVzLCBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFyZWQgPT09IG51bGwpIHNoYXJlZCA9IHRoaXMudENvbmZpZy5zaGFyZWQ7XG4gICAgICAgIHZhciBoYXNNYXJrZXJzID0gdGhpcy50b29sdGlwVXRpbC5oYXNNYXJrZXJzKGNhcHR1cmVkU2VyaWVzKTtcbiAgICAgICAgdmFyIGJhcnMgPSB0aGlzLnRvb2x0aXBVdGlsLmdldEVsQmFycygpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQudG9vbHRpcEhvdmVyRm9ybWF0dGVyKSB7XG4gICAgICAgICAgdmFyIGxlZ2VuZEZvcm1hdHRlciA9IHcuY29uZmlnLmxlZ2VuZC50b29sdGlwSG92ZXJGb3JtYXR0ZXI7XG4gICAgICAgICAgdmFyIGVscyA9IEFycmF5LmZyb20odGhpcy5sZWdlbmRMYWJlbHMpOyAvLyByZXNldCBhbGwgbGVnZW5kIHZhbHVlcyBmaXJzdFxuXG4gICAgICAgICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHZhciBsZWdlbmROYW1lID0gbC5nZXRBdHRyaWJ1dGUoJ2RhdGE6ZGVmYXVsdC10ZXh0Jyk7XG4gICAgICAgICAgICBsLmlubmVySFRNTCA9IGRlY29kZVVSSUNvbXBvbmVudChsZWdlbmROYW1lKTtcbiAgICAgICAgICB9KTsgLy8gZm9yIGlycmVndWxhciB0aW1lIHNlcmllc1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsID0gZWxzW2ldO1xuICAgICAgICAgICAgdmFyIGxzSW5kZXggPSBwYXJzZUludChsLmdldEF0dHJpYnV0ZSgnaScpLCAxMCk7XG4gICAgICAgICAgICB2YXIgbGVnZW5kTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChsLmdldEF0dHJpYnV0ZSgnZGF0YTpkZWZhdWx0LXRleHQnKSk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGxlZ2VuZEZvcm1hdHRlcihsZWdlbmROYW1lLCB7XG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzaGFyZWQgPyBsc0luZGV4IDogY2FwdHVyZWRTZXJpZXMsXG4gICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFzaGFyZWQpIHtcbiAgICAgICAgICAgICAgbC5pbm5lckhUTUwgPSBsc0luZGV4ID09PSBjYXB0dXJlZFNlcmllcyA/IHRleHQgOiBsZWdlbmROYW1lO1xuXG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlZFNlcmllcyA9PT0gbHNJbmRleCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsLmlubmVySFRNTCA9IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YobHNJbmRleCkgPCAwID8gdGV4dCA6IGxlZ2VuZE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbW1vblNlcmllc1RleHRzUGFyYW1zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHR0SXRlbXM6IHR0SXRlbXMsXG4gICAgICAgICAgaTogY2FwdHVyZWRTZXJpZXMsXG4gICAgICAgICAgajogalxuICAgICAgICB9LCB0eXBlb2YgKChfdyRnbG9iYWxzJHNlcmllc1JhbmcgPSB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2UpID09PSBudWxsIHx8IF93JGdsb2JhbHMkc2VyaWVzUmFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzIgPSBfdyRnbG9iYWxzJHNlcmllc1JhbmdbY2FwdHVyZWRTZXJpZXNdKSA9PT0gbnVsbCB8fCBfdyRnbG9iYWxzJHNlcmllc1JhbmcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3ckZ2xvYmFscyRzZXJpZXNSYW5nMyA9IF93JGdsb2JhbHMkc2VyaWVzUmFuZzJbal0pID09PSBudWxsIHx8IF93JGdsb2JhbHMkc2VyaWVzUmFuZzMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdyRnbG9iYWxzJHNlcmllc1Jhbmc0ID0gX3ckZ2xvYmFscyRzZXJpZXNSYW5nMy55WzBdKSA9PT0gbnVsbCB8fCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdyRnbG9iYWxzJHNlcmllc1Jhbmc0LnkxKSAhPT0gJ3VuZGVmaW5lZCcgJiYge1xuICAgICAgICAgIHkxOiAoX3ckZ2xvYmFscyRzZXJpZXNSYW5nNSA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZSkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzYgPSBfdyRnbG9iYWxzJHNlcmllc1Jhbmc1W2NhcHR1cmVkU2VyaWVzXSkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzcgPSBfdyRnbG9iYWxzJHNlcmllc1Jhbmc2W2pdKSA9PT0gbnVsbCB8fCBfdyRnbG9iYWxzJHNlcmllc1Jhbmc3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3ckZ2xvYmFscyRzZXJpZXNSYW5nOCA9IF93JGdsb2JhbHMkc2VyaWVzUmFuZzcueVswXSkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ckZ2xvYmFscyRzZXJpZXNSYW5nOC55MVxuICAgICAgICB9KSwgdHlwZW9mICgoX3ckZ2xvYmFscyRzZXJpZXNSYW5nOSA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZSkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nOSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzEwID0gX3ckZ2xvYmFscyRzZXJpZXNSYW5nOVtjYXB0dXJlZFNlcmllc10pID09PSBudWxsIHx8IF93JGdsb2JhbHMkc2VyaWVzUmFuZzEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTEgPSBfdyRnbG9iYWxzJHNlcmllc1JhbmcxMFtqXSkgPT09IG51bGwgfHwgX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdyRnbG9iYWxzJHNlcmllc1JhbmcxMiA9IF93JGdsb2JhbHMkc2VyaWVzUmFuZzExLnlbMF0pID09PSBudWxsIHx8IF93JGdsb2JhbHMkc2VyaWVzUmFuZzEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdyRnbG9iYWxzJHNlcmllc1JhbmcxMi55MikgIT09ICd1bmRlZmluZWQnICYmIHtcbiAgICAgICAgICB5MjogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzEzID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlKSA9PT0gbnVsbCB8fCBfdyRnbG9iYWxzJHNlcmllc1JhbmcxMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzE0ID0gX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTNbY2FwdHVyZWRTZXJpZXNdKSA9PT0gbnVsbCB8fCBfdyRnbG9iYWxzJHNlcmllc1JhbmcxNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93JGdsb2JhbHMkc2VyaWVzUmFuZzE1ID0gX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTRbal0pID09PSBudWxsIHx8IF93JGdsb2JhbHMkc2VyaWVzUmFuZzE1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTYgPSBfdyRnbG9iYWxzJHNlcmllc1JhbmcxNS55WzBdKSA9PT0gbnVsbCB8fCBfdyRnbG9iYWxzJHNlcmllc1JhbmcxNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ckZ2xvYmFscyRzZXJpZXNSYW5nMTYueTJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb21tb25TZXJpZXNUZXh0c1BhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICBzaGFyZWQ6IHRoaXMuc2hvd09uSW50ZXJzZWN0ID8gZmFsc2UgOiB0aGlzLnRDb25maWcuc2hhcmVkXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMubWFya2Vycy5sYXJnZXN0U2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgdHRDdHgubWFya2VyLmVubGFyZ2VQb2ludHMoaik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZUR5bmFtaWNQb2ludHNPbkhvdmVyKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b29sdGlwVXRpbC5oYXNCYXJzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyU2VyaWVzSGVpZ2h0ID0gdGhpcy50b29sdGlwVXRpbC5nZXRCYXJzSGVpZ2h0KGJhcnMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5iYXJTZXJpZXNIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGhvdmVyIHN0YXRlLCBhY3RpdmF0ZSBzbmFwIGZpbHRlclxuICAgICAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICAgICAgICB2YXIgcGF0aHMgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdChcIi5hcGV4Y2hhcnRzLWJhci1hcmVhW2o9J1wiLmNvbmNhdChqLCBcIiddXCIpKTsgLy8gZGUtYWN0aXZhdGUgZmlyc3RcblxuICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVIb3ZlckZpbHRlcigpO1xuICAgICAgICAgICAgICB0aGlzLnRvb2x0aXBQb3NpdGlvbi5tb3ZlU3RpY2t5VG9vbHRpcE92ZXJCYXJzKGosIGNhcHR1cmVkU2VyaWVzKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IHBhdGhzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MucGF0aE1vdXNlRW50ZXIocGF0aHNbYl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgIHNoYXJlZDogZmFsc2VcbiAgICAgICAgICB9LCBjb21tb25TZXJpZXNUZXh0c1BhcmFtcykpO1xuXG4gICAgICAgICAgaWYgKHRoaXMudG9vbHRpcFV0aWwuaGFzQmFycygpKSB7XG4gICAgICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVN0aWNreVRvb2x0aXBPdmVyQmFycyhqLCBjYXB0dXJlZFNlcmllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlTWFya2VycyhjYXB0dXJlZFNlcmllcywgaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRvb2x0aXA7XG4gIH0oKTtcblxuICB2YXIgQmFyRGF0YUxhYmVscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFyRGF0YUxhYmVscyhiYXJDdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXJEYXRhTGFiZWxzKTtcblxuICAgICAgdGhpcy53ID0gYmFyQ3R4Lnc7XG4gICAgICB0aGlzLmJhckN0eCA9IGJhckN0eDtcbiAgICAgIHRoaXMudG90YWxGb3JtYXR0ZXIgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kYXRhTGFiZWxzLnRvdGFsLmZvcm1hdHRlcjtcblxuICAgICAgaWYgKCF0aGlzLnRvdGFsRm9ybWF0dGVyKSB7XG4gICAgICAgIHRoaXMudG90YWxGb3JtYXR0ZXIgPSB0aGlzLncuY29uZmlnLmRhdGFMYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogaGFuZGxlQmFyRGF0YUxhYmVscyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGZvciB0aGUgZGF0YS1sYWJlbHNcbiAgICAgKiBJdCBhbHNvIHNldHMgdGhlIGVsZW1lbnQncyBkYXRhIGF0dHIgZm9yIGJhcnMgYW5kIGNhbGxzIGRyYXdDYWxjdWxhdGVkQmFyRGF0YUxhYmVscygpXG4gICAgICogQWZ0ZXIgY2FsY3VsYXRpbmcsIGl0IGFsc28gY2FsbHMgdGhlIGZ1bmN0aW9uIHRvIGRyYXcgZGF0YSBsYWJlbHNcbiAgICAgKiBAbWVtYmVyb2YgQmFyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHtiYXJQcm9wc30gbW9zdCBvZiB0aGUgYmFyIHByb3BlcnRpZXMgdXNlZCB0aHJvdWdob3V0IHRoZSBiYXJcbiAgICAgKiBkcmF3aW5nIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBkYXRhTGFiZWxzIG5vZGUtZWxlbWVudCB3aGljaCB5b3UgY2FuIGFwcGVuZCBsYXRlclxuICAgICAqKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEJhckRhdGFMYWJlbHMsIFt7XG4gICAgICBrZXk6IFwiaGFuZGxlQmFyRGF0YUxhYmVsc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUJhckRhdGFMYWJlbHMob3B0cykge1xuICAgICAgICB2YXIgeCA9IG9wdHMueCxcbiAgICAgICAgICAgIHkgPSBvcHRzLnksXG4gICAgICAgICAgICB5MSA9IG9wdHMueTEsXG4gICAgICAgICAgICB5MiA9IG9wdHMueTIsXG4gICAgICAgICAgICBpID0gb3B0cy5pLFxuICAgICAgICAgICAgaiA9IG9wdHMuaixcbiAgICAgICAgICAgIHJlYWxJbmRleCA9IG9wdHMucmVhbEluZGV4LFxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IG9wdHMuZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIHNlcmllcyA9IG9wdHMuc2VyaWVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0ID0gb3B0cy5iYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aCA9IG9wdHMuYmFyV2lkdGgsXG4gICAgICAgICAgICBiYXJYUG9zaXRpb24gPSBvcHRzLmJhclhQb3NpdGlvbixcbiAgICAgICAgICAgIGJhcllQb3NpdGlvbiA9IG9wdHMuYmFyWVBvc2l0aW9uLFxuICAgICAgICAgICAgdmlzaWJsZVNlcmllcyA9IG9wdHMudmlzaWJsZVNlcmllcyxcbiAgICAgICAgICAgIHJlbmRlcmVkUGF0aCA9IG9wdHMucmVuZGVyZWRQYXRoO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuYmFyQ3R4LmN0eCk7XG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkodGhpcy5iYXJDdHguc3Ryb2tlV2lkdGgpID8gdGhpcy5iYXJDdHguc3Ryb2tlV2lkdGhbcmVhbEluZGV4XSA6IHRoaXMuYmFyQ3R4LnN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgYmN4ID0geCArIHBhcnNlRmxvYXQoYmFyV2lkdGggKiB2aXNpYmxlU2VyaWVzKTtcbiAgICAgICAgdmFyIGJjeSA9IHkgKyBwYXJzZUZsb2F0KGJhckhlaWdodCAqIHZpc2libGVTZXJpZXMpO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYyAmJiAhdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgIGJjeCA9IHggKyBwYXJzZUZsb2F0KGJhcldpZHRoICogKHZpc2libGVTZXJpZXMgKyAxKSk7XG4gICAgICAgICAgYmN5ID0geSArIHBhcnNlRmxvYXQoYmFySGVpZ2h0ICogKHZpc2libGVTZXJpZXMgKyAxKSkgLSBzdHJva2VXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhTGFiZWxzID0gbnVsbDtcbiAgICAgICAgdmFyIHRvdGFsRGF0YUxhYmVscyA9IG51bGw7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzWCA9IHg7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzWSA9IHk7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzUG9zID0ge307XG4gICAgICAgIHZhciBkYXRhTGFiZWxzQ29uZmlnID0gdy5jb25maWcuZGF0YUxhYmVscztcbiAgICAgICAgdmFyIGJhckRhdGFMYWJlbHNDb25maWcgPSB0aGlzLmJhckN0eC5iYXJPcHRpb25zLmRhdGFMYWJlbHM7XG4gICAgICAgIHZhciBiYXJUb3RhbERhdGFMYWJlbHNDb25maWcgPSB0aGlzLmJhckN0eC5iYXJPcHRpb25zLmRhdGFMYWJlbHMudG90YWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBiYXJZUG9zaXRpb24gIT09ICd1bmRlZmluZWQnICYmIHRoaXMuYmFyQ3R4LmlzUmFuZ2VCYXIpIHtcbiAgICAgICAgICBiY3kgPSBiYXJZUG9zaXRpb247XG4gICAgICAgICAgZGF0YUxhYmVsc1kgPSBiYXJZUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJhclhQb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5iYXJDdHguaXNWZXJ0aWNhbEdyb3VwZWRSYW5nZUJhcikge1xuICAgICAgICAgIGJjeCA9IGJhclhQb3NpdGlvbjtcbiAgICAgICAgICBkYXRhTGFiZWxzWCA9IGJhclhQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZYID0gZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRYO1xuICAgICAgICB2YXIgb2ZmWSA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WTtcbiAgICAgICAgdmFyIHRleHRSZWN0cyA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHlMYWJlbCA9IHRoaXMuYmFyQ3R4LnNlcmllc1tpXVtqXTtcbiAgICAgICAgICB0ZXh0UmVjdHMgPSBncmFwaGljcy5nZXRUZXh0UmVjdHMody5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbMF0oeUxhYmVsKSwgcGFyc2VGbG9hdChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgZ3JvdXBJbmRleDogISFncm91cEluZGV4ID8gZ3JvdXBJbmRleCA6IC0xLFxuICAgICAgICAgIHJlbmRlcmVkUGF0aDogcmVuZGVyZWRQYXRoLFxuICAgICAgICAgIGJjeDogYmN4LFxuICAgICAgICAgIGJjeTogYmN5LFxuICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICB0ZXh0UmVjdHM6IHRleHRSZWN0cyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZGF0YUxhYmVsc1g6IGRhdGFMYWJlbHNYLFxuICAgICAgICAgIGRhdGFMYWJlbHNZOiBkYXRhTGFiZWxzWSxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIGJhckRhdGFMYWJlbHNDb25maWc6IGJhckRhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnOiBiYXJUb3RhbERhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgb2ZmWDogb2ZmWCxcbiAgICAgICAgICBvZmZZOiBvZmZZXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuYmFyQ3R4LmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIGRhdGFMYWJlbHNQb3MgPSB0aGlzLmNhbGN1bGF0ZUJhcnNEYXRhTGFiZWxzUG9zaXRpb24ocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhTGFiZWxzUG9zID0gdGhpcy5jYWxjdWxhdGVDb2x1bW5zRGF0YUxhYmVsc1Bvc2l0aW9uKHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlZFBhdGguYXR0cih7XG4gICAgICAgICAgY3k6IGRhdGFMYWJlbHNQb3MuYmN5LFxuICAgICAgICAgIGN4OiBkYXRhTGFiZWxzUG9zLmJjeCxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHZhbDogc2VyaWVzW2ldW2pdLFxuICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YUxhYmVscyA9IHRoaXMuZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzKHtcbiAgICAgICAgICB4OiBkYXRhTGFiZWxzUG9zLmRhdGFMYWJlbHNYLFxuICAgICAgICAgIHk6IGRhdGFMYWJlbHNQb3MuZGF0YUxhYmVsc1ksXG4gICAgICAgICAgdmFsOiB0aGlzLmJhckN0eC5pc1JhbmdlQmFyID8gW3kxLCB5Ml0gOiBzZXJpZXNbaV1bal0sXG4gICAgICAgICAgaTogcmVhbEluZGV4LFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgIHRleHRSZWN0czogdGV4dFJlY3RzLFxuICAgICAgICAgIGRhdGFMYWJlbHNDb25maWc6IGRhdGFMYWJlbHNDb25maWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQgJiYgYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgICAgICB0b3RhbERhdGFMYWJlbHMgPSB0aGlzLmRyYXdUb3RhbERhdGFMYWJlbHMoe1xuICAgICAgICAgICAgeDogZGF0YUxhYmVsc1Bvcy50b3RhbERhdGFMYWJlbHNYLFxuICAgICAgICAgICAgeTogZGF0YUxhYmVsc1Bvcy50b3RhbERhdGFMYWJlbHNZLFxuICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiBkYXRhTGFiZWxzUG9zLnRvdGFsRGF0YUxhYmVsc0FuY2hvcixcbiAgICAgICAgICAgIHZhbDogdGhpcy5nZXRTdGFja2VkVG90YWxEYXRhTGFiZWwoe1xuICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgajogalxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgICAgYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnOiBiYXJUb3RhbERhdGFMYWJlbHNDb25maWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YUxhYmVsczogZGF0YUxhYmVscyxcbiAgICAgICAgICB0b3RhbERhdGFMYWJlbHM6IHRvdGFsRGF0YUxhYmVsc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTdGFja2VkVG90YWxEYXRhTGFiZWxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGFja2VkVG90YWxEYXRhTGFiZWwoX3JlZikge1xuICAgICAgICB2YXIgcmVhbEluZGV4ID0gX3JlZi5yZWFsSW5kZXgsXG4gICAgICAgICAgICBqID0gX3JlZi5qO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYmFyQ3R4LnN0YWNrZWRTZXJpZXNUb3RhbHNbal07XG5cbiAgICAgICAgaWYgKHRoaXMudG90YWxGb3JtYXR0ZXIpIHtcbiAgICAgICAgICB2YWwgPSB0aGlzLnRvdGFsRm9ybWF0dGVyKHZhbCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHcpLCB7fSwge1xuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbGN1bGF0ZUNvbHVtbnNEYXRhTGFiZWxzUG9zaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVDb2x1bW5zRGF0YUxhYmVsc1Bvc2l0aW9uKG9wdHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBpID0gb3B0cy5pLFxuICAgICAgICAgICAgaiA9IG9wdHMuaixcbiAgICAgICAgICAgIHJlYWxJbmRleCA9IG9wdHMucmVhbEluZGV4LFxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IG9wdHMuZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIHkgPSBvcHRzLnksXG4gICAgICAgICAgICBiY3ggPSBvcHRzLmJjeCxcbiAgICAgICAgICAgIGJhcldpZHRoID0gb3B0cy5iYXJXaWR0aCxcbiAgICAgICAgICAgIGJhckhlaWdodCA9IG9wdHMuYmFySGVpZ2h0LFxuICAgICAgICAgICAgdGV4dFJlY3RzID0gb3B0cy50ZXh0UmVjdHMsXG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IG9wdHMuZGF0YUxhYmVsc1gsXG4gICAgICAgICAgICBkYXRhTGFiZWxzWSA9IG9wdHMuZGF0YUxhYmVsc1ksXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnID0gb3B0cy5kYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgICAgYmFyRGF0YUxhYmVsc0NvbmZpZyA9IG9wdHMuYmFyRGF0YUxhYmVsc0NvbmZpZyxcbiAgICAgICAgICAgIGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZyA9IG9wdHMuYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgb2ZmWCA9IG9wdHMub2ZmWCxcbiAgICAgICAgICAgIG9mZlkgPSBvcHRzLm9mZlk7XG4gICAgICAgIHZhciB0b3RhbERhdGFMYWJlbHNZO1xuICAgICAgICB2YXIgdG90YWxEYXRhTGFiZWxzWDtcbiAgICAgICAgdmFyIHRvdGFsRGF0YUxhYmVsc0FuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICBiYXJIZWlnaHQgPSBNYXRoLmFicyhiYXJIZWlnaHQpO1xuICAgICAgICB2YXIgdmVydGljYWwgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGF0YUxhYmVscy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcblxuICAgICAgICB2YXIgX3RoaXMkYmFyQ3R4JGJhckhlbHBlID0gdGhpcy5iYXJDdHguYmFySGVscGVycy5nZXRaZXJvVmFsdWVFbmNvdW50ZXJzKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGpcbiAgICAgICAgfSksXG4gICAgICAgICAgICB6ZXJvRW5jb3VudGVycyA9IF90aGlzJGJhckN0eCRiYXJIZWxwZS56ZXJvRW5jb3VudGVycztcblxuICAgICAgICBiY3ggPSBiY3ggLSBzdHJva2VXaWR0aCAvIDIgKyAoZ3JvdXBJbmRleCAhPT0gLTEgPyBncm91cEluZGV4ICogYmFyV2lkdGggOiAwKTtcbiAgICAgICAgdmFyIGRhdGFQb2ludHNEaXZpZGVkV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFyQ3R4LmlzVmVydGljYWxHcm91cGVkUmFuZ2VCYXIpIHtcbiAgICAgICAgICBkYXRhTGFiZWxzWCA9IGRhdGFMYWJlbHNYICsgYmFyV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1ggPSBiY3ggLSBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IGJjeCAtIGRhdGFQb2ludHNEaXZpZGVkV2lkdGggKyBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh6ZXJvRW5jb3VudGVycyA+IDAgJiYgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhpZGVaZXJvQmFyc1doZW5Hcm91cGVkKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IGRhdGFMYWJlbHNYIC0gYmFyV2lkdGggKiB6ZXJvRW5jb3VudGVycztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0RExYID0gMjtcbiAgICAgICAgICBkYXRhTGFiZWxzWCA9IGRhdGFMYWJlbHNYICsgdGV4dFJlY3RzLmhlaWdodCAvIDIgLSBzdHJva2VXaWR0aCAvIDIgLSBvZmZzZXRETFg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsSXNOZWdhdGl2ZSA9IHRoaXMuYmFyQ3R4LnNlcmllc1tpXVtqXSA8IDA7XG4gICAgICAgIHZhciBuZXdZID0geTtcblxuICAgICAgICBpZiAodGhpcy5iYXJDdHguaXNSZXZlcnNlZCkge1xuICAgICAgICAgIG5ld1kgPSB5IC0gYmFySGVpZ2h0ICsgKHZhbElzTmVnYXRpdmUgPyBiYXJIZWlnaHQgKiAyIDogMCk7XG4gICAgICAgICAgeSA9IHkgLSBiYXJIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGJhckRhdGFMYWJlbHNDb25maWcucG9zaXRpb24pIHtcbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSBuZXdZIC0gYmFySGVpZ2h0IC8gMiArIG9mZlk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSBuZXdZICsgYmFySGVpZ2h0IC8gMiAtIG9mZlk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSBuZXdZIC0gYmFySGVpZ2h0IC8gMiArIHRleHRSZWN0cy5oZWlnaHQgLyAyICsgb2ZmWTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhTGFiZWxzWSA9IG5ld1kgKyBiYXJIZWlnaHQgLyAyICsgdGV4dFJlY3RzLmhlaWdodCAvIDIgLSBvZmZZO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRhdGFMYWJlbHNZID0gbmV3WSAtIGJhckhlaWdodCArIG9mZlk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSBuZXdZICsgYmFySGVpZ2h0IC0gb2ZmWTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBkYXRhTGFiZWxzWSA9IG5ld1kgLSBiYXJIZWlnaHQgKyB0ZXh0UmVjdHMuaGVpZ2h0ICsgc3Ryb2tlV2lkdGggKyBvZmZZO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFMYWJlbHNZID0gbmV3WSArIGJhckhlaWdodCAtIHRleHRSZWN0cy5oZWlnaHQgLyAyICsgc3Ryb2tlV2lkdGggLSBvZmZZO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRhdGFMYWJlbHNZID0gbmV3WSArIG9mZlk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSBuZXdZIC0gb2ZmWTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBkYXRhTGFiZWxzWSA9IG5ld1kgLSB0ZXh0UmVjdHMuaGVpZ2h0IC8gMiAtIG9mZlk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSBuZXdZICsgdGV4dFJlY3RzLmhlaWdodCArIG9mZlk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5iYXJDdHgubGFzdEFjdGl2ZUJhclNlcmllSW5kZXggPT09IHJlYWxJbmRleCAmJiBiYXJUb3RhbERhdGFMYWJlbHNDb25maWcuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBBRERJVElPTkFMX09GRlggPSAxODtcbiAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5iYXJDdHguY3R4KTtcbiAgICAgICAgICB2YXIgdG90YWxMYWJlbHRleHRSZWN0cyA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh0aGlzLmdldFN0YWNrZWRUb3RhbERhdGFMYWJlbCh7XG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGo6IGpcbiAgICAgICAgICB9KSwgZGF0YUxhYmVsc0NvbmZpZy5mb250U2l6ZSk7XG5cbiAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgdG90YWxEYXRhTGFiZWxzWSA9IG5ld1kgLSB0b3RhbExhYmVsdGV4dFJlY3RzLmhlaWdodCAvIDIgLSBvZmZZIC0gYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLm9mZnNldFkgKyBBRERJVElPTkFMX09GRlg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvdGFsRGF0YUxhYmVsc1kgPSBuZXdZICsgdG90YWxMYWJlbHRleHRSZWN0cy5oZWlnaHQgKyBvZmZZICsgYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLm9mZnNldFkgLSBBRERJVElPTkFMX09GRlg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG90YWxEYXRhTGFiZWxzWCA9IGRhdGFMYWJlbHNYICsgYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLm9mZnNldFg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICBpZiAoZGF0YUxhYmVsc1kgPCAwKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWSA9IDAgKyBzdHJva2VXaWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFMYWJlbHNZICsgdGV4dFJlY3RzLmhlaWdodCAvIDMgPiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIHN0cm9rZVdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmN4OiBiY3gsXG4gICAgICAgICAgYmN5OiB5LFxuICAgICAgICAgIGRhdGFMYWJlbHNYOiBkYXRhTGFiZWxzWCxcbiAgICAgICAgICBkYXRhTGFiZWxzWTogZGF0YUxhYmVsc1ksXG4gICAgICAgICAgdG90YWxEYXRhTGFiZWxzWDogdG90YWxEYXRhTGFiZWxzWCxcbiAgICAgICAgICB0b3RhbERhdGFMYWJlbHNZOiB0b3RhbERhdGFMYWJlbHNZLFxuICAgICAgICAgIHRvdGFsRGF0YUxhYmVsc0FuY2hvcjogdG90YWxEYXRhTGFiZWxzQW5jaG9yXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbGN1bGF0ZUJhcnNEYXRhTGFiZWxzUG9zaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVCYXJzRGF0YUxhYmVsc1Bvc2l0aW9uKG9wdHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciB4ID0gb3B0cy54LFxuICAgICAgICAgICAgaSA9IG9wdHMuaSxcbiAgICAgICAgICAgIGogPSBvcHRzLmosXG4gICAgICAgICAgICByZWFsSW5kZXggPSBvcHRzLnJlYWxJbmRleCxcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSBvcHRzLmdyb3VwSW5kZXgsXG4gICAgICAgICAgICBiY3kgPSBvcHRzLmJjeSxcbiAgICAgICAgICAgIGJhckhlaWdodCA9IG9wdHMuYmFySGVpZ2h0LFxuICAgICAgICAgICAgYmFyV2lkdGggPSBvcHRzLmJhcldpZHRoLFxuICAgICAgICAgICAgdGV4dFJlY3RzID0gb3B0cy50ZXh0UmVjdHMsXG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IG9wdHMuZGF0YUxhYmVsc1gsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnID0gb3B0cy5kYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgICAgYmFyRGF0YUxhYmVsc0NvbmZpZyA9IG9wdHMuYmFyRGF0YUxhYmVsc0NvbmZpZyxcbiAgICAgICAgICAgIGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZyA9IG9wdHMuYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgICAgb2ZmWCA9IG9wdHMub2ZmWCxcbiAgICAgICAgICAgIG9mZlkgPSBvcHRzLm9mZlk7XG4gICAgICAgIHZhciBkYXRhUG9pbnRzRGl2aWRlZEhlaWdodCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGJhcldpZHRoID0gTWF0aC5hYnMoYmFyV2lkdGgpO1xuICAgICAgICBiY3kgPSBiY3kgKyAoZ3JvdXBJbmRleCAhPT0gLTEgPyBncm91cEluZGV4ICogYmFySGVpZ2h0IDogMCk7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzWSA9IGJjeSAtICh0aGlzLmJhckN0eC5pc1JhbmdlQmFyID8gMCA6IGRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0KSArIGJhckhlaWdodCAvIDIgKyB0ZXh0UmVjdHMuaGVpZ2h0IC8gMiArIG9mZlkgLSAzO1xuICAgICAgICB2YXIgdG90YWxEYXRhTGFiZWxzWDtcbiAgICAgICAgdmFyIHRvdGFsRGF0YUxhYmVsc1k7XG4gICAgICAgIHZhciB0b3RhbERhdGFMYWJlbHNBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICB2YXIgdmFsSXNOZWdhdGl2ZSA9IHRoaXMuYmFyQ3R4LnNlcmllc1tpXVtqXSA8IDA7XG4gICAgICAgIHZhciBuZXdYID0geDtcblxuICAgICAgICBpZiAodGhpcy5iYXJDdHguaXNSZXZlcnNlZCkge1xuICAgICAgICAgIG5ld1ggPSB4ICsgYmFyV2lkdGggLSAodmFsSXNOZWdhdGl2ZSA/IGJhcldpZHRoICogMiA6IDApO1xuICAgICAgICAgIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC0gYmFyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGJhckRhdGFMYWJlbHNDb25maWcucG9zaXRpb24pIHtcbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgZGF0YUxhYmVsc1ggPSBuZXdYICsgYmFyV2lkdGggLyAyIC0gb2ZmWDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGFMYWJlbHNYID0gTWF0aC5tYXgodGV4dFJlY3RzLndpZHRoIC8gMiwgbmV3WCAtIGJhcldpZHRoIC8gMikgKyBvZmZYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICBkYXRhTGFiZWxzWCA9IG5ld1ggKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoIC0gTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSAtIG9mZlg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhTGFiZWxzWCA9IG5ld1ggLSBiYXJXaWR0aCArIHN0cm9rZVdpZHRoICsgTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSArIG9mZlg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgIGRhdGFMYWJlbHNYID0gbmV3WCAtIHN0cm9rZVdpZHRoICsgTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSAtIG9mZlg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhTGFiZWxzWCA9IG5ld1ggLSBzdHJva2VXaWR0aCAtIE1hdGgucm91bmQodGV4dFJlY3RzLndpZHRoIC8gMikgKyBvZmZYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJhckN0eC5sYXN0QWN0aXZlQmFyU2VyaWVJbmRleCA9PT0gcmVhbEluZGV4ICYmIGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIEFERElUSU9OQUxfT0ZGWCA9IDE1O1xuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmJhckN0eC5jdHgpO1xuICAgICAgICAgIHZhciB0b3RhbExhYmVsdGV4dFJlY3RzID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHRoaXMuZ2V0U3RhY2tlZFRvdGFsRGF0YUxhYmVsKHtcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgajogalxuICAgICAgICAgIH0pLCBkYXRhTGFiZWxzQ29uZmlnLmZvbnRTaXplKTtcblxuICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICB0b3RhbERhdGFMYWJlbHNYID0gbmV3WCAtIHN0cm9rZVdpZHRoICsgTWF0aC5yb3VuZCh0b3RhbExhYmVsdGV4dFJlY3RzLndpZHRoIC8gMikgLSBvZmZYIC0gYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLm9mZnNldFggLSBBRERJVElPTkFMX09GRlg7XG4gICAgICAgICAgICB0b3RhbERhdGFMYWJlbHNBbmNob3IgPSAnZW5kJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG90YWxEYXRhTGFiZWxzWCA9IG5ld1ggLSBzdHJva2VXaWR0aCAtIE1hdGgucm91bmQodG90YWxMYWJlbHRleHRSZWN0cy53aWR0aCAvIDIpICsgb2ZmWCArIGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRYICsgQURESVRJT05BTF9PRkZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvdGFsRGF0YUxhYmVsc1kgPSBkYXRhTGFiZWxzWSArIGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgaWYgKGRhdGFMYWJlbHNYIDwgMCkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1ggPSBkYXRhTGFiZWxzWCArIHRleHRSZWN0cy53aWR0aCArIHN0cm9rZVdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YUxhYmVsc1ggKyB0ZXh0UmVjdHMud2lkdGggLyAyID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1ggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC0gdGV4dFJlY3RzLndpZHRoIC0gc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiY3g6IHgsXG4gICAgICAgICAgYmN5OiBiY3ksXG4gICAgICAgICAgZGF0YUxhYmVsc1g6IGRhdGFMYWJlbHNYLFxuICAgICAgICAgIGRhdGFMYWJlbHNZOiBkYXRhTGFiZWxzWSxcbiAgICAgICAgICB0b3RhbERhdGFMYWJlbHNYOiB0b3RhbERhdGFMYWJlbHNYLFxuICAgICAgICAgIHRvdGFsRGF0YUxhYmVsc1k6IHRvdGFsRGF0YUxhYmVsc1ksXG4gICAgICAgICAgdG90YWxEYXRhTGFiZWxzQW5jaG9yOiB0b3RhbERhdGFMYWJlbHNBbmNob3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzKF9yZWYyKSB7XG4gICAgICAgIHZhciB4ID0gX3JlZjIueCxcbiAgICAgICAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgICAgICAgdmFsID0gX3JlZjIudmFsLFxuICAgICAgICAgICAgaSA9IF9yZWYyLmksXG4gICAgICAgICAgICBqID0gX3JlZjIuaixcbiAgICAgICAgICAgIHRleHRSZWN0cyA9IF9yZWYyLnRleHRSZWN0cyxcbiAgICAgICAgICAgIGJhckhlaWdodCA9IF9yZWYyLmJhckhlaWdodCxcbiAgICAgICAgICAgIGJhcldpZHRoID0gX3JlZjIuYmFyV2lkdGgsXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnID0gX3JlZjIuZGF0YUxhYmVsc0NvbmZpZztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciByb3RhdGUgPSAncm90YXRlKDApJztcbiAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kYXRhTGFiZWxzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSByb3RhdGUgPSBcInJvdGF0ZSgtOTAsIFwiLmNvbmNhdCh4LCBcIiwgXCIpLmNvbmNhdCh5LCBcIilcIik7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzID0gbmV3IERhdGFMYWJlbHModGhpcy5iYXJDdHguY3R4KTtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuYmFyQ3R4LmN0eCk7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBkYXRhTGFiZWxzQ29uZmlnLmZvcm1hdHRlcjtcbiAgICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBudWxsO1xuICAgICAgICB2YXIgaXNTZXJpZXNOb3RDb2xsYXBzZWQgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID4gLTE7XG5cbiAgICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcuZW5hYmxlZCAmJiAhaXNTZXJpZXNOb3RDb2xsYXBzZWQpIHtcbiAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGEtbGFiZWxzJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHRleHQgPSAnJztcblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGV4dCA9IGZvcm1hdHRlcih2YWwsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB3KSwge30sIHtcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF2YWwgJiYgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhpZGVaZXJvQmFyc1doZW5Hcm91cGVkKSB7XG4gICAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbElzTmVnYXRpdmUgPSB3Lmdsb2JhbHMuc2VyaWVzW2ldW2pdIDwgMDtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGF0YUxhYmVscy5wb3NpdGlvbjtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGF0YUxhYmVscy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkgZGF0YUxhYmVsc0NvbmZpZy50ZXh0QW5jaG9yID0gJ2VuZCc7ZWxzZSBkYXRhTGFiZWxzQ29uZmlnLnRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgIGRhdGFMYWJlbHNDb25maWcudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSBkYXRhTGFiZWxzQ29uZmlnLnRleHRBbmNob3IgPSAnZW5kJztlbHNlIGRhdGFMYWJlbHNDb25maWcudGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuYmFyQ3R4LmlzUmFuZ2VCYXIgJiYgdGhpcy5iYXJDdHguYmFyT3B0aW9ucy5kYXRhTGFiZWxzLmhpZGVPdmVyZmxvd2luZ0xhYmVscykge1xuICAgICAgICAgICAgLy8gaGlkZSB0aGUgZGF0YWxhYmVsIGlmIGl0IGNhbm5vdCBmaXQgaW50byB0aGUgcmVjdFxuICAgICAgICAgICAgdmFyIHR4UmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh0ZXh0LCBwYXJzZUZsb2F0KGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udFNpemUpKTtcblxuICAgICAgICAgICAgaWYgKGJhcldpZHRoIDwgdHhSZWN0LndpZHRoKSB7XG4gICAgICAgICAgICAgIHRleHQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tlZCAmJiB0aGlzLmJhckN0eC5iYXJPcHRpb25zLmRhdGFMYWJlbHMuaGlkZU92ZXJmbG93aW5nTGFiZWxzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIHRvIGRyYXcgdGhlIGxhYmVsIGluIHRoZSBiYXIvY29sdW1uIHJlY3QsIGNoZWNrIGhpZGVPdmVyZmxvd2luZ0xhYmVscyBwcm9wZXJ0eSB0byBwcmV2ZW50IG92ZXJmbG93aW5nIG9uIHdyb25nIHJlY3RcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgaXNzdWUgaXMgb25seSBzZWVuIGluIHN0YWNrZWQgY2hhcnRzXG4gICAgICAgICAgICBpZiAodGhpcy5iYXJDdHguaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0UmVjdHMud2lkdGggLyAxLjYgPiBNYXRoLmFicyhiYXJXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0UmVjdHMuaGVpZ2h0IC8gMS42ID4gTWF0aC5hYnMoYmFySGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtb2RpZmllZERhdGFMYWJlbHNDb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgZGF0YUxhYmVsc0NvbmZpZyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5iYXJDdHguaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy50ZXh0QW5jaG9yID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWREYXRhTGFiZWxzQ29uZmlnLnRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhTGFiZWxzQ29uZmlnLnRleHRBbmNob3IgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWREYXRhTGFiZWxzQ29uZmlnLnRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YUxhYmVscy5wbG90RGF0YUxhYmVsc1RleHQoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBwYXJlbnQ6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBtb2RpZmllZERhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgICBhbHdheXNEcmF3RGF0YUxhYmVsOiB0cnVlLFxuICAgICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsRGF0YUxhYmVsc1dyYXA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdUb3RhbERhdGFMYWJlbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VG90YWxEYXRhTGFiZWxzKF9yZWYzKSB7XG4gICAgICAgIHZhciB4ID0gX3JlZjMueCxcbiAgICAgICAgICAgIHkgPSBfcmVmMy55LFxuICAgICAgICAgICAgdmFsID0gX3JlZjMudmFsLFxuICAgICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjMucmVhbEluZGV4LFxuICAgICAgICAgICAgdGV4dEFuY2hvciA9IF9yZWYzLnRleHRBbmNob3IsXG4gICAgICAgICAgICBiYXJUb3RhbERhdGFMYWJlbHNDb25maWcgPSBfcmVmMy5iYXJUb3RhbERhdGFMYWJlbHNDb25maWc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmJhckN0eC5jdHgpO1xuICAgICAgICB2YXIgdG90YWxEYXRhTGFiZWxUZXh0O1xuXG4gICAgICAgIGlmIChiYXJUb3RhbERhdGFMYWJlbHNDb25maWcuZW5hYmxlZCAmJiB0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHkgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuYmFyQ3R4Lmxhc3RBY3RpdmVCYXJTZXJpZUluZGV4ID09PSByZWFsSW5kZXgpIHtcbiAgICAgICAgICB0b3RhbERhdGFMYWJlbFRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogYmFyVG90YWxEYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgdGV4dDogdmFsLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvcixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgICAgZm9udFNpemU6IGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGJhclRvdGFsRGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250V2VpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWxEYXRhTGFiZWxUZXh0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCYXJEYXRhTGFiZWxzO1xuICB9KCk7XG5cbiAgdmFyIEhlbHBlcnMkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVscGVycyhiYXJDdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWxwZXJzKTtcblxuICAgICAgdGhpcy53ID0gYmFyQ3R4Lnc7XG4gICAgICB0aGlzLmJhckN0eCA9IGJhckN0eDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGVscGVycywgW3tcbiAgICAgIGtleTogXCJpbml0VmFyaWFibGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFZhcmlhYmxlcyhzZXJpZXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHRoaXMuYmFyQ3R4LnNlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy5iYXJDdHgudG90YWxJdGVtcyA9IDA7XG4gICAgICAgIHRoaXMuYmFyQ3R4LnNlcmllc0xlbiA9IDA7XG4gICAgICAgIHRoaXMuYmFyQ3R4LnZpc2libGVJID0gLTE7IC8vIHZpc2libGUgU2VyaWVzXG5cbiAgICAgICAgdGhpcy5iYXJDdHgudmlzaWJsZUl0ZW1zID0gMTsgLy8gbnVtYmVyIG9mIHZpc2libGUgYmFycyBhZnRlciB1c2VyIHpvb21lZCBpbi9vdXRcblxuICAgICAgICBmb3IgKHZhciBzbCA9IDA7IHNsIDwgc2VyaWVzLmxlbmd0aDsgc2wrKykge1xuICAgICAgICAgIGlmIChzZXJpZXNbc2xdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYmFyQ3R4LnNlcmllc0xlbiA9IHRoaXMuYmFyQ3R4LnNlcmllc0xlbiArIDE7XG4gICAgICAgICAgICB0aGlzLmJhckN0eC50b3RhbEl0ZW1zICs9IHNlcmllc1tzbF0ubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgLy8gZ2V0IG1heCB2aXNpYmxlIGl0ZW1zXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcmllc1tzbF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXNYW3NsXVtqXSA+IHcuZ2xvYmFscy5taW5YICYmIHcuZ2xvYmFscy5zZXJpZXNYW3NsXVtqXSA8IHcuZ2xvYmFscy5tYXhYKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXJDdHgudmlzaWJsZUl0ZW1zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXJDdHgudmlzaWJsZUl0ZW1zID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYmFyQ3R4LnNlcmllc0xlbiA9PT0gMCkge1xuICAgICAgICAgIC8vIEEgc21hbGwgYWRqdXN0bWVudCB3aGVuIGNvbWJvIGNoYXJ0cyBhcmUgdXNlZFxuICAgICAgICAgIHRoaXMuYmFyQ3R4LnNlcmllc0xlbiA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhckN0eC56ZXJvU2VyaWVzZXMgPSBbXTtcblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5jb21ib0NoYXJ0cykge1xuICAgICAgICAgIHRoaXMuY2hlY2taZXJvU2VyaWVzKHtcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5pdGlhbFBvc2l0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxQb3NpdGlvbnMoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgeCwgeSwgeURpdmlzaW9uLCB4RGl2aXNpb24sIGJhckhlaWdodCwgYmFyV2lkdGgsIHplcm9ILCB6ZXJvVztcbiAgICAgICAgdmFyIGRhdGFQb2ludHMgPSB3Lmdsb2JhbHMuZGF0YVBvaW50cztcblxuICAgICAgICBpZiAodGhpcy5iYXJDdHguaXNSYW5nZUJhcikge1xuICAgICAgICAgIC8vIHRpbWVsaW5lIHJhbmdlYmFyIGNoYXJ0XG4gICAgICAgICAgZGF0YVBvaW50cyA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlcmllc0xlbiA9IHRoaXMuYmFyQ3R4LnNlcmllc0xlbjtcblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMuYmFyLnJhbmdlQmFyR3JvdXBSb3dzKSB7XG4gICAgICAgICAgc2VyaWVzTGVuID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJhckN0eC5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAvLyBoZWlnaHQgZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgICAgeURpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyBkYXRhUG9pbnRzO1xuICAgICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbiAvIHNlcmllc0xlbjtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgeURpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB0aGlzLmJhckN0eC50b3RhbEl0ZW1zO1xuICAgICAgICAgICAgYmFySGVpZ2h0ID0geURpdmlzaW9uIC8gdGhpcy5iYXJDdHguc2VyaWVzTGVuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJhckhlaWdodCA9IGJhckhlaWdodCAqIHBhcnNlSW50KHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuYmFySGVpZ2h0LCAxMCkgLyAxMDA7XG5cbiAgICAgICAgICBpZiAoU3RyaW5nKHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuYmFySGVpZ2h0KS5pbmRleE9mKCclJykgPT09IC0xKSB7XG4gICAgICAgICAgICBiYXJIZWlnaHQgPSBwYXJzZUludCh0aGlzLmJhckN0eC5iYXJPcHRpb25zLmJhckhlaWdodCwgMTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHplcm9XID0gdGhpcy5iYXJDdHguYmFzZUxpbmVJbnZlcnRlZFkgKyB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArICh0aGlzLmJhckN0eC5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRXaWR0aCA6IDApIC0gKHRoaXMuYmFyQ3R4LmlzUmV2ZXJzZWQgPyB0aGlzLmJhckN0eC5iYXNlTGluZUludmVydGVkWSAqIDIgOiAwKTtcblxuICAgICAgICAgIGlmICh0aGlzLmJhckN0eC5pc0Z1bm5lbCkge1xuICAgICAgICAgICAgemVyb1cgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5ID0gKHlEaXZpc2lvbiAtIGJhckhlaWdodCAqIHRoaXMuYmFyQ3R4LnNlcmllc0xlbikgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdpZHRoIGRpdmlkZWQgaW50byBlcXVhbCBwYXJ0c1xuICAgICAgICAgIHhEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyB0aGlzLmJhckN0eC52aXNpYmxlSXRlbXM7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgICB4RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmFyV2lkdGggPSB4RGl2aXNpb24gLyBzZXJpZXNMZW4gKiBwYXJzZUludCh0aGlzLmJhckN0eC5iYXJPcHRpb25zLmNvbHVtbldpZHRoLCAxMCkgLyAxMDA7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgIC8vIG1heCBiYXJ3aWR0aCBzaG91bGQgYmUgZXF1YWwgdG8gbWluWERpZmYgdG8gYXZvaWQgb3ZlcmxhcFxuICAgICAgICAgICAgdmFyIHhSYXRpbyA9IHRoaXMuYmFyQ3R4LnhSYXRpbztcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYykge1xuICAgICAgICAgICAgICB4UmF0aW8gPSB0aGlzLmJhckN0eC5pbml0aWFsWFJhdGlvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLm1pblhEaWZmICYmIHcuZ2xvYmFscy5taW5YRGlmZiAhPT0gMC41ICYmIHcuZ2xvYmFscy5taW5YRGlmZiAvIHhSYXRpbyA+IDApIHtcbiAgICAgICAgICAgICAgeERpdmlzaW9uID0gdy5nbG9iYWxzLm1pblhEaWZmIC8geFJhdGlvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXJXaWR0aCA9IHhEaXZpc2lvbiAvIHNlcmllc0xlbiAqIHBhcnNlSW50KHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuY29sdW1uV2lkdGgsIDEwKSAvIDEwMDtcblxuICAgICAgICAgICAgaWYgKGJhcldpZHRoIDwgMSkge1xuICAgICAgICAgICAgICBiYXJXaWR0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFN0cmluZyh0aGlzLmJhckN0eC5iYXJPcHRpb25zLmNvbHVtbldpZHRoKS5pbmRleE9mKCclJykgPT09IC0xKSB7XG4gICAgICAgICAgICBiYXJXaWR0aCA9IHBhcnNlSW50KHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuY29sdW1uV2lkdGgsIDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB6ZXJvSCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gdGhpcy5iYXJDdHguYmFzZUxpbmVZW3RoaXMuYmFyQ3R4LnlheGlzSW5kZXhdIC0gKHRoaXMuYmFyQ3R4LmlzUmV2ZXJzZWQgPyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCA6IDApICsgKHRoaXMuYmFyQ3R4LmlzUmV2ZXJzZWQgPyB0aGlzLmJhckN0eC5iYXNlTGluZVlbdGhpcy5iYXJDdHgueWF4aXNJbmRleF0gKiAyIDogMCk7XG4gICAgICAgICAgeCA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgKHhEaXZpc2lvbiAtIGJhcldpZHRoICogdGhpcy5iYXJDdHguc2VyaWVzTGVuKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB5RGl2aXNpb246IHlEaXZpc2lvbixcbiAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICAgIHplcm9XOiB6ZXJvV1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbml0aWFsaXplU3RhY2tlZFByZXZWYXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YWNrZWRQcmV2VmFycyhjdHgpIHtcbiAgICAgICAgdmFyIHcgPSBjdHgudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmhhc1Nlcmllc0dyb3Vwcykge1xuICAgICAgICAgIHcuZ2xvYmFscy5zZXJpZXNHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmICghY3R4W2dyb3VwXSkgY3R4W2dyb3VwXSA9IHt9O1xuICAgICAgICAgICAgY3R4W2dyb3VwXS5wcmV2WSA9IFtdO1xuICAgICAgICAgICAgY3R4W2dyb3VwXS5wcmV2WCA9IFtdO1xuICAgICAgICAgICAgY3R4W2dyb3VwXS5wcmV2WUYgPSBbXTtcbiAgICAgICAgICAgIGN0eFtncm91cF0ucHJldlhGID0gW107XG4gICAgICAgICAgICBjdHhbZ3JvdXBdLnByZXZZVmFsID0gW107XG4gICAgICAgICAgICBjdHhbZ3JvdXBdLnByZXZYVmFsID0gW107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnByZXZZID0gW107IC8vIHkgcG9zaXRpb24gb24gY2hhcnQgKGluIGNvbHVtbnMpXG5cbiAgICAgICAgICBjdHgucHJldlggPSBbXTsgLy8geCBwb3NpdGlvbiBvbiBjaGFydCAoaW4gaG9yeiBiYXJzKVxuXG4gICAgICAgICAgY3R4LnByZXZZRiA9IFtdOyAvLyBzdGFydGluZyB5IGFuZCBlbmRpbmcgeSAoaGVpZ2h0KSBpbiBjb2x1bW5zXG5cbiAgICAgICAgICBjdHgucHJldlhGID0gW107IC8vIHN0YXJ0aW5nIHggYW5kIGVuZGluZyB4ICh3aWR0aCkgaW4gYmFyc1xuXG4gICAgICAgICAgY3R4LnByZXZZVmFsID0gW107IC8vIHkgdmFsdWVzIChzZXJpZXNbaV1bal0pIGluIGNvbHVtbnNcblxuICAgICAgICAgIGN0eC5wcmV2WFZhbCA9IFtdOyAvLyB4IHZhbHVlcyAoc2VyaWVzW2ldW2pdKSBpbiBiYXJzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5pdGlhbGl6ZVN0YWNrZWRYWVZhcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplU3RhY2tlZFhZVmFycyhjdHgpIHtcbiAgICAgICAgdmFyIHcgPSBjdHgudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmhhc1Nlcmllc0dyb3Vwcykge1xuICAgICAgICAgIHcuZ2xvYmFscy5zZXJpZXNHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmICghY3R4W2dyb3VwXSkgY3R4W2dyb3VwXSA9IHt9O1xuICAgICAgICAgICAgY3R4W2dyb3VwXS54QXJyaiA9IFtdO1xuICAgICAgICAgICAgY3R4W2dyb3VwXS54QXJyakYgPSBbXTtcbiAgICAgICAgICAgIGN0eFtncm91cF0ueEFycmpWYWwgPSBbXTtcbiAgICAgICAgICAgIGN0eFtncm91cF0ueUFycmogPSBbXTtcbiAgICAgICAgICAgIGN0eFtncm91cF0ueUFycmpGID0gW107XG4gICAgICAgICAgICBjdHhbZ3JvdXBdLnlBcnJqVmFsID0gW107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnhBcnJqID0gW107IC8vIHhqIGluZGljYXRlcyB4IHBvc2l0aW9uIG9uIGdyYXBoIGluIGJhcnNcblxuICAgICAgICAgIGN0eC54QXJyakYgPSBbXTsgLy8geGpGIGluZGljYXRlcyBiYXIncyB4IHBvc2l0aW9uICsgeDIgcG9zaXRpb25zIGluIGJhcnNcblxuICAgICAgICAgIGN0eC54QXJyalZhbCA9IFtdOyAvLyB4IHZhbCBtZWFucyB0aGUgYWN0dWFsIHNlcmllcydzIHkgdmFsdWVzIGluIGhvcml6b250YWwvYmFyc1xuXG4gICAgICAgICAgY3R4LnlBcnJqID0gW107IC8vIHlqIGluZGljYXRlcyB5IHBvc2l0aW9uIG9uIGdyYXBoIGluIGNvbHVtbnNcblxuICAgICAgICAgIGN0eC55QXJyakYgPSBbXTsgLy8geWpGIGluZGljYXRlcyBiYXIncyB5IHBvc2l0aW9uICsgeTIgcG9zaXRpb25zIGluIGNvbHVtbnNcblxuICAgICAgICAgIGN0eC55QXJyalZhbCA9IFtdOyAvLyB5IHZhbCBtZWFucyB0aGUgYWN0dWFsIHNlcmllcydzIHkgdmFsdWVzIGluIGNvbHVtbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQYXRoRmlsbENvbG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aEZpbGxDb2xvcihzZXJpZXMsIGksIGosIHJlYWxJbmRleCkge1xuICAgICAgICB2YXIgX3ckY29uZmlnJHNlcmllcyRpJGRhLCBfdyRjb25maWckc2VyaWVzJGkkZGEyLCBfdyRjb25maWckc2VyaWVzJGkkZGEzLCBfdyRjb25maWckc2VyaWVzJGkkZGE0O1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuYmFyQ3R4LmN0eCk7XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSBudWxsO1xuICAgICAgICB2YXIgc2VyaWVzTnVtYmVyID0gdGhpcy5iYXJDdHguYmFyT3B0aW9ucy5kaXN0cmlidXRlZCA/IGogOiBpO1xuXG4gICAgICAgIGlmICh0aGlzLmJhckN0eC5iYXJPcHRpb25zLmNvbG9ycy5yYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb2xvclJhbmdlID0gdGhpcy5iYXJDdHguYmFyT3B0aW9ucy5jb2xvcnMucmFuZ2VzO1xuICAgICAgICAgIGNvbG9yUmFuZ2UubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHNlcmllc1tpXVtqXSA+PSByYW5nZS5mcm9tICYmIHNlcmllc1tpXVtqXSA8PSByYW5nZS50bykge1xuICAgICAgICAgICAgICBmaWxsQ29sb3IgPSByYW5nZS5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXSAmJiB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXS5maWxsQ29sb3IpIHtcbiAgICAgICAgICBmaWxsQ29sb3IgPSB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXS5maWxsQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXI6IHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuZGlzdHJpYnV0ZWQgPyBzZXJpZXNOdW1iZXIgOiByZWFsSW5kZXgsXG4gICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgY29sb3I6IGZpbGxDb2xvcixcbiAgICAgICAgICB2YWx1ZTogc2VyaWVzW2ldW2pdLFxuICAgICAgICAgIGZpbGxDb25maWc6IChfdyRjb25maWckc2VyaWVzJGkkZGEgPSB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXSkgPT09IG51bGwgfHwgX3ckY29uZmlnJHNlcmllcyRpJGRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdyRjb25maWckc2VyaWVzJGkkZGEuZmlsbCxcbiAgICAgICAgICBmaWxsVHlwZTogKF93JGNvbmZpZyRzZXJpZXMkaSRkYTIgPSB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXSkgIT09IG51bGwgJiYgX3ckY29uZmlnJHNlcmllcyRpJGRhMiAhPT0gdm9pZCAwICYmIChfdyRjb25maWckc2VyaWVzJGkkZGEzID0gX3ckY29uZmlnJHNlcmllcyRpJGRhMi5maWxsKSAhPT0gbnVsbCAmJiBfdyRjb25maWckc2VyaWVzJGkkZGEzICE9PSB2b2lkIDAgJiYgX3ckY29uZmlnJHNlcmllcyRpJGRhMy50eXBlID8gKF93JGNvbmZpZyRzZXJpZXMkaSRkYTQgPSB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXSkgPT09IG51bGwgfHwgX3ckY29uZmlnJHNlcmllcyRpJGRhNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ckY29uZmlnJHNlcmllcyRpJGRhNC5maWxsLnR5cGUgOiB3LmNvbmZpZy5maWxsLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXRoRmlsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U3Ryb2tlV2lkdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHJva2VXaWR0aChpLCBqLCByZWFsSW5kZXgpIHtcbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJhckN0eC5zZXJpZXNbaV1bal0pIHtcbiAgICAgICAgICB0aGlzLmJhckN0eC5pc051bGxWYWx1ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5iYXJDdHguaXNOdWxsVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdykge1xuICAgICAgICAgIGlmICghdGhpcy5iYXJDdHguaXNOdWxsVmFsdWUpIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheSh0aGlzLmJhckN0eC5zdHJva2VXaWR0aCkgPyB0aGlzLmJhckN0eC5zdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogdGhpcy5iYXJDdHguc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaG91bGRBcHBseVJhZGl1c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZEFwcGx5UmFkaXVzKHJlYWxJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGFwcGx5UmFkaXVzID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ib3JkZXJSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuYm9yZGVyUmFkaXVzV2hlblN0YWNrZWQgPT09ICdsYXN0Jykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5iYXJDdHgubGFzdEFjdGl2ZUJhclNlcmllSW5kZXggPT09IHJlYWxJbmRleCkge1xuICAgICAgICAgICAgICAgIGFwcGx5UmFkaXVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwbHlSYWRpdXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseVJhZGl1cyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFwcGx5UmFkaXVzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJiYXJCYWNrZ3JvdW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmFyQmFja2dyb3VuZChfcmVmKSB7XG4gICAgICAgIHZhciBqID0gX3JlZi5qLFxuICAgICAgICAgICAgaSA9IF9yZWYuaSxcbiAgICAgICAgICAgIHgxID0gX3JlZi54MSxcbiAgICAgICAgICAgIHgyID0gX3JlZi54MixcbiAgICAgICAgICAgIHkxID0gX3JlZi55MSxcbiAgICAgICAgICAgIHkyID0gX3JlZi55MixcbiAgICAgICAgICAgIGVsU2VyaWVzID0gX3JlZi5lbFNlcmllcztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmJhckN0eC5jdHgpO1xuICAgICAgICB2YXIgc3IgPSBuZXcgU2VyaWVzKHRoaXMuYmFyQ3R4LmN0eCk7XG4gICAgICAgIHZhciBhY3RpdmVTZXJpZXNJbmRleCA9IHNyLmdldEFjdGl2ZUNvbmZpZ1Nlcmllc0luZGV4KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBhY3RpdmVTZXJpZXNJbmRleCA9PT0gaSkge1xuICAgICAgICAgIGlmIChqID49IHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBqICU9IHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBiY29sb3IgPSB0aGlzLmJhckN0eC5iYXJPcHRpb25zLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzW2pdO1xuICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QodHlwZW9mIHgxICE9PSAndW5kZWZpbmVkJyA/IHgxIDogMCwgdHlwZW9mIHkxICE9PSAndW5kZWZpbmVkJyA/IHkxIDogMCwgdHlwZW9mIHgyICE9PSAndW5kZWZpbmVkJyA/IHgyIDogdy5nbG9iYWxzLmdyaWRXaWR0aCwgdHlwZW9mIHkyICE9PSAndW5kZWZpbmVkJyA/IHkyIDogdy5nbG9iYWxzLmdyaWRIZWlnaHQsIHRoaXMuYmFyQ3R4LmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJSYWRpdXMsIGJjb2xvciwgdGhpcy5iYXJDdHguYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhck9wYWNpdHkpO1xuICAgICAgICAgIGVsU2VyaWVzLmFkZChyZWN0KTtcbiAgICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0Q29sdW1uUGF0aHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2x1bW5QYXRocyhfcmVmMikge1xuICAgICAgICB2YXIgX3ckY29uZmlnJHNlcmllcyRyZWFsO1xuXG4gICAgICAgIHZhciBiYXJXaWR0aCA9IF9yZWYyLmJhcldpZHRoLFxuICAgICAgICAgICAgYmFyWFBvc2l0aW9uID0gX3JlZjIuYmFyWFBvc2l0aW9uLFxuICAgICAgICAgICAgeTEgPSBfcmVmMi55MSxcbiAgICAgICAgICAgIHkyID0gX3JlZjIueTIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYyLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgc2VyaWVzR3JvdXAgPSBfcmVmMi5zZXJpZXNHcm91cCxcbiAgICAgICAgICAgIHJlYWxJbmRleCA9IF9yZWYyLnJlYWxJbmRleCxcbiAgICAgICAgICAgIGkgPSBfcmVmMi5pLFxuICAgICAgICAgICAgaiA9IF9yZWYyLmosXG4gICAgICAgICAgICB3ID0gX3JlZjIudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuYmFyQ3R4LmN0eCk7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheShzdHJva2VXaWR0aCkgPyBzdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogc3Ryb2tlV2lkdGg7XG4gICAgICAgIGlmICghc3Ryb2tlV2lkdGgpIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJXID0gYmFyV2lkdGg7XG4gICAgICAgIHZhciBiWFAgPSBiYXJYUG9zaXRpb247XG5cbiAgICAgICAgaWYgKChfdyRjb25maWckc2VyaWVzJHJlYWwgPSB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhW2pdKSAhPT0gbnVsbCAmJiBfdyRjb25maWckc2VyaWVzJHJlYWwgIT09IHZvaWQgMCAmJiBfdyRjb25maWckc2VyaWVzJHJlYWwuY29sdW1uV2lkdGhPZmZzZXQpIHtcbiAgICAgICAgICBiWFAgPSBiYXJYUG9zaXRpb24gLSB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhW2pdLmNvbHVtbldpZHRoT2Zmc2V0IC8gMjtcbiAgICAgICAgICBiVyA9IGJhcldpZHRoICsgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0uZGF0YVtqXS5jb2x1bW5XaWR0aE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IGJYUDtcbiAgICAgICAgdmFyIHgyID0gYlhQICsgYlc7IC8vIGFwcGVuZCB0aW55IHBpeGVscyB0byBhdm9pZCBleHBvbmVudGlhbHMgKHdoaWNoIGNhdXNlIGlzc3VlcyBpbiBib3JkZXItcmFkaXVzKVxuXG4gICAgICAgIHkxICs9IDAuMDAxO1xuICAgICAgICB5MiArPSAwLjAwMTtcbiAgICAgICAgdmFyIHBhdGhUbyA9IGdyYXBoaWNzLm1vdmUoeDEsIHkxKTtcbiAgICAgICAgdmFyIHBhdGhGcm9tID0gZ3JhcGhpY3MubW92ZSh4MSwgeTEpO1xuICAgICAgICB2YXIgc2wgPSBncmFwaGljcy5saW5lKHgyIC0gc3Ryb2tlV2lkdGgsIHkxKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhdGhGcm9tID0gdGhpcy5iYXJDdHguZ2V0UHJldmlvdXNQYXRoKHJlYWxJbmRleCwgaiwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aFRvID0gcGF0aFRvICsgZ3JhcGhpY3MubGluZSh4MSwgeTIpICsgZ3JhcGhpY3MubGluZSh4MiAtIHN0cm9rZVdpZHRoLCB5MikgKyBncmFwaGljcy5saW5lKHgyIC0gc3Ryb2tlV2lkdGgsIHkxKSArICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuYm9yZGVyUmFkaXVzQXBwbGljYXRpb24gPT09ICdhcm91bmQnID8gJyBaJyA6ICcgeicpOyAvLyB0aGUgbGluZXMgaW4gcGF0aEZyb20gYXJlIHJlcGVhdGVkIHRvIGVxdWFsIGl0IHRvIHRoZSBwb2ludHMgb2YgcGF0aFRvXG4gICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgd2VpcmQgYW5pbWF0aW9uIChidWcgaW4gc3ZnLmpzKVxuXG4gICAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5saW5lKHgxLCB5MSkgKyBzbCArIHNsICsgc2wgKyBzbCArIHNsICsgZ3JhcGhpY3MubGluZSh4MSwgeTEpICsgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ib3JkZXJSYWRpdXNBcHBsaWNhdGlvbiA9PT0gJ2Fyb3VuZCcgPyAnIFonIDogJyB6Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQXBwbHlSYWRpdXMocmVhbEluZGV4KSkge1xuICAgICAgICAgIHBhdGhUbyA9IGdyYXBoaWNzLnJvdW5kUGF0aENvcm5lcnMocGF0aFRvLCB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgdmFyIF9jdHggPSB0aGlzLmJhckN0eDtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaGFzU2VyaWVzR3JvdXBzICYmIHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICBfY3R4ID0gdGhpcy5iYXJDdHhbc2VyaWVzR3JvdXBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jdHgueUFycmoucHVzaCh5Mik7XG5cbiAgICAgICAgICBfY3R4LnlBcnJqRi5wdXNoKE1hdGguYWJzKHkxIC0geTIpKTtcblxuICAgICAgICAgIF9jdHgueUFycmpWYWwucHVzaCh0aGlzLmJhckN0eC5zZXJpZXNbaV1bal0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb21cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0QmFycGF0aHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXJwYXRocyhfcmVmMykge1xuICAgICAgICB2YXIgX3ckY29uZmlnJHNlcmllcyRyZWFsMjtcblxuICAgICAgICB2YXIgYmFyWVBvc2l0aW9uID0gX3JlZjMuYmFyWVBvc2l0aW9uLFxuICAgICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZjMuYmFySGVpZ2h0LFxuICAgICAgICAgICAgeDEgPSBfcmVmMy54MSxcbiAgICAgICAgICAgIHgyID0gX3JlZjMueDIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgc2VyaWVzR3JvdXAgPSBfcmVmMy5zZXJpZXNHcm91cCxcbiAgICAgICAgICAgIHJlYWxJbmRleCA9IF9yZWYzLnJlYWxJbmRleCxcbiAgICAgICAgICAgIGkgPSBfcmVmMy5pLFxuICAgICAgICAgICAgaiA9IF9yZWYzLmosXG4gICAgICAgICAgICB3ID0gX3JlZjMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuYmFyQ3R4LmN0eCk7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheShzdHJva2VXaWR0aCkgPyBzdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogc3Ryb2tlV2lkdGg7XG4gICAgICAgIGlmICghc3Ryb2tlV2lkdGgpIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJZUCA9IGJhcllQb3NpdGlvbjtcbiAgICAgICAgdmFyIGJIID0gYmFySGVpZ2h0O1xuXG4gICAgICAgIGlmICgoX3ckY29uZmlnJHNlcmllcyRyZWFsMiA9IHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdLmRhdGFbal0pICE9PSBudWxsICYmIF93JGNvbmZpZyRzZXJpZXMkcmVhbDIgIT09IHZvaWQgMCAmJiBfdyRjb25maWckc2VyaWVzJHJlYWwyLmJhckhlaWdodE9mZnNldCkge1xuICAgICAgICAgIGJZUCA9IGJhcllQb3NpdGlvbiAtIHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdLmRhdGFbal0uYmFySGVpZ2h0T2Zmc2V0IC8gMjtcbiAgICAgICAgICBiSCA9IGJhckhlaWdodCArIHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdLmRhdGFbal0uYmFySGVpZ2h0T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkxID0gYllQO1xuICAgICAgICB2YXIgeTIgPSBiWVAgKyBiSDsgLy8gYXBwZW5kIHRpbnkgcGl4ZWxzIHRvIGF2b2lkIGV4cG9uZW50aWFscyAod2hpY2ggY2F1c2UgaXNzdWVzIGluIGJvcmRlci1yYWRpdXMpXG5cbiAgICAgICAgeDEgKz0gMC4wMDE7XG4gICAgICAgIHgyICs9IDAuMDAxO1xuICAgICAgICB2YXIgcGF0aFRvID0gZ3JhcGhpY3MubW92ZSh4MSwgeTEpO1xuICAgICAgICB2YXIgcGF0aEZyb20gPSBncmFwaGljcy5tb3ZlKHgxLCB5MSk7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXRoRnJvbSA9IHRoaXMuYmFyQ3R4LmdldFByZXZpb3VzUGF0aChyZWFsSW5kZXgsIGosIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzbCA9IGdyYXBoaWNzLmxpbmUoeDEsIHkyIC0gc3Ryb2tlV2lkdGgpO1xuICAgICAgICBwYXRoVG8gPSBwYXRoVG8gKyBncmFwaGljcy5saW5lKHgyLCB5MSkgKyBncmFwaGljcy5saW5lKHgyLCB5MiAtIHN0cm9rZVdpZHRoKSArIHNsICsgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ib3JkZXJSYWRpdXNBcHBsaWNhdGlvbiA9PT0gJ2Fyb3VuZCcgPyAnIFonIDogJyB6Jyk7XG4gICAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5saW5lKHgxLCB5MSkgKyBzbCArIHNsICsgc2wgKyBzbCArIHNsICsgZ3JhcGhpY3MubGluZSh4MSwgeTEpICsgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ib3JkZXJSYWRpdXNBcHBsaWNhdGlvbiA9PT0gJ2Fyb3VuZCcgPyAnIFonIDogJyB6Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQXBwbHlSYWRpdXMocmVhbEluZGV4KSkge1xuICAgICAgICAgIHBhdGhUbyA9IGdyYXBoaWNzLnJvdW5kUGF0aENvcm5lcnMocGF0aFRvLCB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgdmFyIF9jdHggPSB0aGlzLmJhckN0eDtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaGFzU2VyaWVzR3JvdXBzICYmIHNlcmllc0dyb3VwKSB7XG4gICAgICAgICAgICBfY3R4ID0gdGhpcy5iYXJDdHhbc2VyaWVzR3JvdXBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jdHgueEFycmoucHVzaCh4Mik7XG5cbiAgICAgICAgICBfY3R4LnhBcnJqRi5wdXNoKE1hdGguYWJzKHgxIC0geDIpKTtcblxuICAgICAgICAgIF9jdHgueEFycmpWYWwucHVzaCh0aGlzLmJhckN0eC5zZXJpZXNbaV1bal0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb21cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hlY2taZXJvU2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2taZXJvU2VyaWVzKF9yZWY0KSB7XG4gICAgICAgIHZhciBzZXJpZXMgPSBfcmVmNC5zZXJpZXM7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGZvciAodmFyIHpzID0gMDsgenMgPCBzZXJpZXMubGVuZ3RoOyB6cysrKSB7XG4gICAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIHpzaiA9IDA7IHpzaiA8IHNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyB6c2orKykge1xuICAgICAgICAgICAgdG90YWwgKz0gc2VyaWVzW3pzXVt6c2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b3RhbCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5iYXJDdHguemVyb1Nlcmllc2VzLnB1c2goenMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRYRm9yVmFsdWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYRm9yVmFsdWUodmFsdWUsIHplcm9XKSB7XG4gICAgICAgIHZhciB6ZXJvUG9zaXRpb25Gb3JOdWxsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgICB2YXIgeEZvclZhbCA9IHplcm9Qb3NpdGlvbkZvck51bGwgPyB6ZXJvVyA6IG51bGw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICB4Rm9yVmFsID0gemVyb1cgKyB2YWx1ZSAvIHRoaXMuYmFyQ3R4LmludmVydGVkWVJhdGlvIC0gKHRoaXMuYmFyQ3R4LmlzUmV2ZXJzZWQgPyB2YWx1ZSAvIHRoaXMuYmFyQ3R4LmludmVydGVkWVJhdGlvIDogMCkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhGb3JWYWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFlGb3JWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFlGb3JWYWx1ZSh2YWx1ZSwgemVyb0gpIHtcbiAgICAgICAgdmFyIHplcm9Qb3NpdGlvbkZvck51bGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICAgIHZhciB5Rm9yVmFsID0gemVyb1Bvc2l0aW9uRm9yTnVsbCA/IHplcm9IIDogbnVsbDtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHlGb3JWYWwgPSB6ZXJvSCAtIHZhbHVlIC8gdGhpcy5iYXJDdHgueVJhdGlvW3RoaXMuYmFyQ3R4LnlheGlzSW5kZXhdICsgKHRoaXMuYmFyQ3R4LmlzUmV2ZXJzZWQgPyB2YWx1ZSAvIHRoaXMuYmFyQ3R4LnlSYXRpb1t0aGlzLmJhckN0eC55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB5Rm9yVmFsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRHb2FsVmFsdWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R29hbFZhbHVlcyh0eXBlLCB6ZXJvVywgemVyb0gsIGksIGopIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdvYWxzID0gW107XG5cbiAgICAgICAgdmFyIHB1c2hHb2FsID0gZnVuY3Rpb24gcHVzaEdvYWwodmFsdWUsIGF0dHJzKSB7XG4gICAgICAgICAgdmFyIF9nb2FscyRwdXNoO1xuXG4gICAgICAgICAgZ29hbHMucHVzaCgoX2dvYWxzJHB1c2ggPSB7fSwgX2RlZmluZVByb3BlcnR5KF9nb2FscyRwdXNoLCB0eXBlLCB0eXBlID09PSAneCcgPyBfdGhpcy5nZXRYRm9yVmFsdWUodmFsdWUsIHplcm9XLCBmYWxzZSkgOiBfdGhpcy5nZXRZRm9yVmFsdWUodmFsdWUsIHplcm9ILCBmYWxzZSkpLCBfZGVmaW5lUHJvcGVydHkoX2dvYWxzJHB1c2gsIFwiYXR0cnNcIiwgYXR0cnMpLCBfZ29hbHMkcHVzaCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzR29hbHNbaV0gJiYgdy5nbG9iYWxzLnNlcmllc0dvYWxzW2ldW2pdICYmIEFycmF5LmlzQXJyYXkody5nbG9iYWxzLnNlcmllc0dvYWxzW2ldW2pdKSkge1xuICAgICAgICAgIHcuZ2xvYmFscy5zZXJpZXNHb2Fsc1tpXVtqXS5mb3JFYWNoKGZ1bmN0aW9uIChnb2FsKSB7XG4gICAgICAgICAgICBwdXNoR29hbChnb2FsLnZhbHVlLCBnb2FsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJhckN0eC5iYXJPcHRpb25zLmlzRHVtYmJlbGwgJiYgdy5nbG9iYWxzLnNlcmllc1JhbmdlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjb2xvcnMgPSB0aGlzLmJhckN0eC5iYXJPcHRpb25zLmR1bWJiZWxsQ29sb3JzID8gdGhpcy5iYXJDdHguYmFyT3B0aW9ucy5kdW1iYmVsbENvbG9ycyA6IHcuZ2xvYmFscy5jb2xvcnM7XG4gICAgICAgICAgdmFyIGNvbW1vbkF0dHJzID0ge1xuICAgICAgICAgICAgc3Ryb2tlSGVpZ2h0OiB0eXBlID09PSAneCcgPyAwIDogdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtpXSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0eXBlID09PSAneCcgPyB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2ldIDogMCxcbiAgICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogMCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVDYXA6ICdyb3VuZCcsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogQXJyYXkuaXNBcnJheShjb2xvcnNbaV0pID8gY29sb3JzW2ldWzBdIDogY29sb3JzW2ldXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwdXNoR29hbCh3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VTdGFydFtpXVtqXSwgY29tbW9uQXR0cnMpO1xuICAgICAgICAgIHB1c2hHb2FsKHcuZ2xvYmFscy5zZXJpZXNSYW5nZUVuZFtpXVtqXSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbW1vbkF0dHJzKSwge30sIHtcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBBcnJheS5pc0FycmF5KGNvbG9yc1tpXSkgPyBjb2xvcnNbaV1bMV0gOiBjb2xvcnNbaV1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ29hbHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdHb2FsTGluZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHb2FsTGluZShfcmVmNSkge1xuICAgICAgICB2YXIgYmFyWFBvc2l0aW9uID0gX3JlZjUuYmFyWFBvc2l0aW9uLFxuICAgICAgICAgICAgYmFyWVBvc2l0aW9uID0gX3JlZjUuYmFyWVBvc2l0aW9uLFxuICAgICAgICAgICAgZ29hbFggPSBfcmVmNS5nb2FsWCxcbiAgICAgICAgICAgIGdvYWxZID0gX3JlZjUuZ29hbFksXG4gICAgICAgICAgICBiYXJXaWR0aCA9IF9yZWY1LmJhcldpZHRoLFxuICAgICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZjUuYmFySGVpZ2h0O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5iYXJDdHguY3R4KTtcbiAgICAgICAgdmFyIGxpbmVHcm91cCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdhcGV4Y2hhcnRzLWJhci1nb2Fscy1ncm91cHMnXG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lR3JvdXAubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWVsZW1lbnQtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuYmFyQ3R4LncuZ2xvYmFscy5kZWxheWVkRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgZWw6IGxpbmVHcm91cC5ub2RlXG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lR3JvdXAuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFya2VyTWFza1wiLmNvbmNhdCh0aGlzLmJhckN0eC53Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTtcbiAgICAgICAgdmFyIGxpbmUgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLmJhckN0eC5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShnb2FsWCkpIHtcbiAgICAgICAgICAgIGdvYWxYLmZvckVhY2goZnVuY3Rpb24gKGdvYWwpIHtcbiAgICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSB0eXBlb2YgZ29hbC5hdHRycy5zdHJva2VIZWlnaHQgIT09ICd1bmRlZmluZWQnID8gZ29hbC5hdHRycy5zdHJva2VIZWlnaHQgOiBiYXJIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICB2YXIgeSA9IGJhcllQb3NpdGlvbiArIHNIZWlnaHQgKyBiYXJIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICBsaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUoZ29hbC54LCB5IC0gc0hlaWdodCAqIDIsIGdvYWwueCwgeSwgZ29hbC5hdHRycy5zdHJva2VDb2xvciA/IGdvYWwuYXR0cnMuc3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsIGdvYWwuYXR0cnMuc3Ryb2tlRGFzaEFycmF5LCBnb2FsLmF0dHJzLnN0cm9rZVdpZHRoID8gZ29hbC5hdHRycy5zdHJva2VXaWR0aCA6IDIsIGdvYWwuYXR0cnMuc3Ryb2tlTGluZUNhcCk7XG4gICAgICAgICAgICAgIGxpbmVHcm91cC5hZGQobGluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZ29hbFkpKSB7XG4gICAgICAgICAgICBnb2FsWS5mb3JFYWNoKGZ1bmN0aW9uIChnb2FsKSB7XG4gICAgICAgICAgICAgIHZhciBzV2lkdGggPSB0eXBlb2YgZ29hbC5hdHRycy5zdHJva2VXaWR0aCAhPT0gJ3VuZGVmaW5lZCcgPyBnb2FsLmF0dHJzLnN0cm9rZVdpZHRoIDogYmFyV2lkdGggLyAyO1xuICAgICAgICAgICAgICB2YXIgeCA9IGJhclhQb3NpdGlvbiArIHNXaWR0aCArIGJhcldpZHRoIC8gMjtcbiAgICAgICAgICAgICAgbGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHggLSBzV2lkdGggKiAyLCBnb2FsLnksIHgsIGdvYWwueSwgZ29hbC5hdHRycy5zdHJva2VDb2xvciA/IGdvYWwuYXR0cnMuc3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsIGdvYWwuYXR0cnMuc3Ryb2tlRGFzaEFycmF5LCBnb2FsLmF0dHJzLnN0cm9rZUhlaWdodCA/IGdvYWwuYXR0cnMuc3Ryb2tlSGVpZ2h0IDogMiwgZ29hbC5hdHRycy5zdHJva2VMaW5lQ2FwKTtcbiAgICAgICAgICAgICAgbGluZUdyb3VwLmFkZChsaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lR3JvdXA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdCYXJTaGFkb3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFyU2hhZG93KF9yZWY2KSB7XG4gICAgICAgIHZhciBwcmV2UGF0aHMgPSBfcmVmNi5wcmV2UGF0aHMsXG4gICAgICAgICAgICBjdXJyUGF0aHMgPSBfcmVmNi5jdXJyUGF0aHMsXG4gICAgICAgICAgICBjb2xvciA9IF9yZWY2LmNvbG9yO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHByZXZYMiA9IHByZXZQYXRocy54LFxuICAgICAgICAgICAgcHJldlgxID0gcHJldlBhdGhzLngxLFxuICAgICAgICAgICAgcHJldlkxID0gcHJldlBhdGhzLmJhcllQb3NpdGlvbjtcbiAgICAgICAgdmFyIGN1cnJYMiA9IGN1cnJQYXRocy54LFxuICAgICAgICAgICAgY3VyclgxID0gY3VyclBhdGhzLngxLFxuICAgICAgICAgICAgY3VyclkxID0gY3VyclBhdGhzLmJhcllQb3NpdGlvbjtcbiAgICAgICAgdmFyIHByZXZZMiA9IHByZXZZMSArIGN1cnJQYXRocy5iYXJIZWlnaHQ7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmJhckN0eC5jdHgpO1xuICAgICAgICB2YXIgdXRpbHMgPSBuZXcgVXRpbHMkMSgpO1xuICAgICAgICB2YXIgc2hhZG93UGF0aCA9IGdyYXBoaWNzLm1vdmUocHJldlgxLCBwcmV2WTIpICsgZ3JhcGhpY3MubGluZShwcmV2WDIsIHByZXZZMikgKyBncmFwaGljcy5saW5lKGN1cnJYMiwgY3VyclkxKSArIGdyYXBoaWNzLmxpbmUoY3VyclgxLCBjdXJyWTEpICsgZ3JhcGhpY3MubGluZShwcmV2WDEsIHByZXZZMikgKyAody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmJvcmRlclJhZGl1c0FwcGxpY2F0aW9uID09PSAnYXJvdW5kJyA/ICcgWicgOiAnIHonKTtcbiAgICAgICAgcmV0dXJuIGdyYXBoaWNzLmRyYXdQYXRoKHtcbiAgICAgICAgICBkOiBzaGFkb3dQYXRoLFxuICAgICAgICAgIGZpbGw6IHV0aWxzLnNoYWRlQ29sb3IoMC41LCBVdGlscyQxLnJnYjJoZXgoY29sb3IpKSxcbiAgICAgICAgICBzdHJva2U6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICBjbGFzc2VzOiAnYXBleGNoYXJ0cy1iYXItc2hhZG93cydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFplcm9WYWx1ZUVuY291bnRlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRaZXJvVmFsdWVFbmNvdW50ZXJzKF9yZWY3KSB7XG4gICAgICAgIHZhciBpID0gX3JlZjcuaSxcbiAgICAgICAgICAgIGogPSBfcmVmNy5qO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIG5vblplcm9Db2x1bW5zID0gMDtcbiAgICAgICAgdmFyIHplcm9FbmNvdW50ZXJzID0gMDtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1BlcmNlbnQuZm9yRWFjaChmdW5jdGlvbiAoX3MsIF9zaSkge1xuICAgICAgICAgIGlmIChfc1tqXSkge1xuICAgICAgICAgICAgbm9uWmVyb0NvbHVtbnMrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3NpIDwgaSAmJiBfc1tqXSA9PT0gMCkge1xuICAgICAgICAgICAgemVyb0VuY291bnRlcnMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vblplcm9Db2x1bW5zOiBub25aZXJvQ29sdW1ucyxcbiAgICAgICAgICB6ZXJvRW5jb3VudGVyczogemVyb0VuY291bnRlcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGVscGVycztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIEJhciBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBib3RoIENvbHVtbnMgYW5kIEJhcnMuXG4gICAqXG4gICAqIEBtb2R1bGUgQmFyXG4gICAqKi9cblxuICB2YXIgQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXIoY3R4LCB4eVJhdGlvcykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhcik7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMuYmFyT3B0aW9ucyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhcjtcbiAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gdGhpcy5iYXJPcHRpb25zLmhvcml6b250YWw7XG4gICAgICB0aGlzLnN0cm9rZVdpZHRoID0gdy5jb25maWcuc3Ryb2tlLndpZHRoO1xuICAgICAgdGhpcy5pc051bGxWYWx1ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1JhbmdlQmFyID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlLmxlbmd0aCAmJiB0aGlzLmlzSG9yaXpvbnRhbDtcbiAgICAgIHRoaXMuaXNWZXJ0aWNhbEdyb3VwZWRSYW5nZUJhciA9ICF3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsICYmIHcuZ2xvYmFscy5zZXJpZXNSYW5nZS5sZW5ndGggJiYgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLnJhbmdlQmFyR3JvdXBSb3dzO1xuICAgICAgdGhpcy5pc0Z1bm5lbCA9IHRoaXMuYmFyT3B0aW9ucy5pc0Z1bm5lbDtcbiAgICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcblxuICAgICAgaWYgKHRoaXMueHlSYXRpb3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy54UmF0aW8gPSB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgIHRoaXMuaW5pdGlhbFhSYXRpbyA9IHh5UmF0aW9zLmluaXRpYWxYUmF0aW87XG4gICAgICAgIHRoaXMueVJhdGlvID0geHlSYXRpb3MueVJhdGlvO1xuICAgICAgICB0aGlzLmludmVydGVkWFJhdGlvID0geHlSYXRpb3MuaW52ZXJ0ZWRYUmF0aW87XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gPSB4eVJhdGlvcy5pbnZlcnRlZFlSYXRpbztcbiAgICAgICAgdGhpcy5iYXNlTGluZVkgPSB4eVJhdGlvcy5iYXNlTGluZVk7XG4gICAgICAgIHRoaXMuYmFzZUxpbmVJbnZlcnRlZFkgPSB4eVJhdGlvcy5iYXNlTGluZUludmVydGVkWTtcbiAgICAgIH1cblxuICAgICAgdGhpcy55YXhpc0luZGV4ID0gMDtcbiAgICAgIHRoaXMuc2VyaWVzTGVuID0gMDtcbiAgICAgIHRoaXMucGF0aEFyciA9IFtdO1xuICAgICAgdmFyIHNlciA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgdGhpcy5sYXN0QWN0aXZlQmFyU2VyaWVJbmRleCA9IHNlci5nZXRBY3RpdmVDb25maWdTZXJpZXNJbmRleCgnZGVzYycsIFsnYmFyJywgJ2NvbHVtbiddKTtcbiAgICAgIHZhciBiYXJTZXJpZXNJbmRpY2VzID0gc2VyLmdldEJhclNlcmllc0luZGljZXMoKTtcbiAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuc3RhY2tlZFNlcmllc1RvdGFscyA9IGNvcmVVdGlscy5nZXRTdGFja2VkU2VyaWVzVG90YWxzKHRoaXMudy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICByZXR1cm4gYmFyU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSA/IGkgOiAtMTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcyAhPT0gLTE7XG4gICAgICB9KSk7XG4gICAgICB0aGlzLmJhckhlbHBlcnMgPSBuZXcgSGVscGVycyQxKHRoaXMpO1xuICAgIH1cbiAgICAvKiogcHJpbWFyeSBkcmF3IG1ldGhvZCB3aGljaCBpcyBjYWxsZWQgb24gYmFyIG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBCYXJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBzZXJpZXMgLSB1c2VyIHN1cHBsaWVkIHNlcmllcyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VyaWVzSW5kZXggLSB0aGUgaW5kZXggYnkgd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd24gb24gdGhlIHN2Z1xuICAgICAqIEByZXR1cm4ge25vZGV9IGVsZW1lbnQgd2hpY2ggaXMgc3VwcGxpZWQgdG8gcGFyZW50IGNoYXJ0IGRyYXcgbWV0aG9kIGZvciBhcHBlbmRpbmdcbiAgICAgKiovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhCYXIsIFt7XG4gICAgICBrZXk6IFwiZHJhd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgsIHcpO1xuICAgICAgICBzZXJpZXMgPSBjb3JlVXRpbHMuZ2V0TG9nU2VyaWVzKHNlcmllcyk7XG4gICAgICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLnlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHRoaXMueVJhdGlvKTtcbiAgICAgICAgdGhpcy5iYXJIZWxwZXJzLmluaXRWYXJpYWJsZXMoc2VyaWVzKTtcbiAgICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtYmFyLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMudG90YWxJdGVtcyA+IHRoaXMuYmFyT3B0aW9ucy5kYXRhTGFiZWxzLm1heEl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IERhdGFMYWJlbHMgYXJlIGVuYWJsZWQgYnV0IHRoZXJlIGFyZSB0b28gbWFueSB0byBkaXNwbGF5LiBUaGlzIG1heSBjYXVzZSBwZXJmb3JtYW5jZSBpc3N1ZSB3aGVuIHJlbmRlcmluZyAtIEFwZXhDaGFydHMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgYmMgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrLCBiYysrKSB7XG4gICAgICAgICAgdmFyIHggPSB2b2lkIDAsXG4gICAgICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIHhEaXZpc2lvbiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgLy8geERpdmlzaW9uIGlzIHRoZSBHUklEV0lEVEggZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoY29sdW1ucylcbiAgICAgICAgICB5RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAgIC8vIHlEaXZpc2lvbiBpcyB0aGUgR1JJREhFSUdIVCBkaXZpZGVkIGJ5IG51bWJlciBvZiBkYXRhcG9pbnRzIChiYXJzKVxuICAgICAgICAgIHplcm9IID0gdm9pZCAwLFxuICAgICAgICAgICAgICAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcbiAgICAgICAgICB6ZXJvVyA9IHZvaWQgMDsgLy8gemVyb1cgaXMgdGhlIGJhc2VsaW5lIHdoZXJlIDAgbWVldHMgeCBheGlzXG5cbiAgICAgICAgICB2YXIgeUFycmogPSBbXTsgLy8gaG9sZCB5IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICAgIHZhciB4QXJyaiA9IFtdOyAvLyBob2xkIHggdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgICAgdmFyIHJlYWxJbmRleCA9IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyA/IHNlcmllc0luZGV4W2ldIDogaTsgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cblxuICAgICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzXCIsXG4gICAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogVXRpbHMkMS5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW3JlYWxJbmRleF0pLFxuICAgICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxTZXJpZXMsIHJlYWxJbmRleCk7XG5cbiAgICAgICAgICBpZiAoc2VyaWVzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUkgPSB0aGlzLnZpc2libGVJICsgMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMueVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMueWF4aXNJbmRleCA9IHJlYWxJbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3RoaXMueWF4aXNJbmRleF0ucmV2ZXJzZWQ7XG4gICAgICAgICAgdmFyIGluaXRQb3NpdGlvbnMgPSB0aGlzLmJhckhlbHBlcnMuaW5pdGlhbFBvc2l0aW9ucygpO1xuICAgICAgICAgIHkgPSBpbml0UG9zaXRpb25zLnk7XG4gICAgICAgICAgYmFySGVpZ2h0ID0gaW5pdFBvc2l0aW9ucy5iYXJIZWlnaHQ7XG4gICAgICAgICAgeURpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy55RGl2aXNpb247XG4gICAgICAgICAgemVyb1cgPSBpbml0UG9zaXRpb25zLnplcm9XO1xuICAgICAgICAgIHggPSBpbml0UG9zaXRpb25zLng7XG4gICAgICAgICAgYmFyV2lkdGggPSBpbml0UG9zaXRpb25zLmJhcldpZHRoO1xuICAgICAgICAgIHhEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueERpdmlzaW9uO1xuICAgICAgICAgIHplcm9IID0gaW5pdFBvc2l0aW9ucy56ZXJvSDtcblxuICAgICAgICAgIGlmICghdGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpO1xuICAgICAgICAgIH0gLy8gZWxkYXRhbGFiZWxzXG5cblxuICAgICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMnLFxuICAgICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGVsOiBlbERhdGFMYWJlbHNXcmFwLm5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1lbGVtZW50LWhpZGRlbicpO1xuICAgICAgICAgIHZhciBlbEdvYWxzTWFya2VycyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1iYXItZ29hbHMtbWFya2VycydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZWxCYXJTaGFkb3dzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWJhci1zaGFkb3dzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHcuZ2xvYmFscy5kZWxheWVkRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBlbDogZWxCYXJTaGFkb3dzLm5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbEJhclNoYWRvd3Mubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWVsZW1lbnQtaGlkZGVuJyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHcuZ2xvYmFscy5kYXRhUG9pbnRzOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuYmFySGVscGVycy5nZXRTdHJva2VXaWR0aChpLCBqLCByZWFsSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBwYXRoc1BhcmFtcyA9IHtcbiAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICBwYXRocyA9IHRoaXMuZHJhd0JhclBhdGhzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXRoc1BhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgemVyb1c6IHplcm9XLFxuICAgICAgICAgICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYmFyV2lkdGggPSB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXRocyA9IHRoaXMuZHJhd0NvbHVtblBhdGhzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXRoc1BhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICAgICAgeERpdmlzaW9uOiB4RGl2aXNpb24sXG4gICAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICAgIHplcm9IOiB6ZXJvSFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGJhckhlaWdodCA9IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhdGhGaWxsID0gdGhpcy5iYXJIZWxwZXJzLmdldFBhdGhGaWxsQ29sb3Ioc2VyaWVzLCBpLCBqLCByZWFsSW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0Z1bm5lbCAmJiB0aGlzLmJhck9wdGlvbnMuaXNGdW5uZWwzZCAmJiB0aGlzLnBhdGhBcnIubGVuZ3RoICYmIGogPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBiYXJTaGFkb3cgPSB0aGlzLmJhckhlbHBlcnMuZHJhd0JhclNoYWRvdyh7XG4gICAgICAgICAgICAgICAgY29sb3I6IHR5cGVvZiBwYXRoRmlsbCA9PT0gJ3N0cmluZycgJiYgKHBhdGhGaWxsID09PSBudWxsIHx8IHBhdGhGaWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXRoRmlsbC5pbmRleE9mKCd1cmwnKSkgPT09IC0xID8gcGF0aEZpbGwgOiBVdGlscyQxLmhleFRvUmdiYSh3Lmdsb2JhbHMuY29sb3JzW2ldKSxcbiAgICAgICAgICAgICAgICBwcmV2UGF0aHM6IHRoaXMucGF0aEFyclt0aGlzLnBhdGhBcnIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgY3VyclBhdGhzOiBwYXRoc1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoYmFyU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgZWxCYXJTaGFkb3dzLmFkZChiYXJTaGFkb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGF0aEFyci5wdXNoKHBhdGhzKTtcbiAgICAgICAgICAgIHZhciBiYXJHb2FsTGluZSA9IHRoaXMuYmFySGVscGVycy5kcmF3R29hbExpbmUoe1xuICAgICAgICAgICAgICBiYXJYUG9zaXRpb246IHBhdGhzLmJhclhQb3NpdGlvbixcbiAgICAgICAgICAgICAgYmFyWVBvc2l0aW9uOiBwYXRocy5iYXJZUG9zaXRpb24sXG4gICAgICAgICAgICAgIGdvYWxYOiBwYXRocy5nb2FsWCxcbiAgICAgICAgICAgICAgZ29hbFk6IHBhdGhzLmdvYWxZLFxuICAgICAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGJhckdvYWxMaW5lKSB7XG4gICAgICAgICAgICAgIGVsR29hbHNNYXJrZXJzLmFkZChiYXJHb2FsTGluZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSBwYXRocy55O1xuICAgICAgICAgICAgeCA9IHBhdGhzLng7IC8vIHB1c2ggY3VycmVudCBYXG5cbiAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5QXJyai5wdXNoKHkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZXJpZXMoe1xuICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgcGF0aEZpbGw6IHBhdGhGaWxsLFxuICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aHMucGF0aEZyb20sXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aHMucGF0aFRvLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllcyxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgIGJhckhlaWdodDogcGF0aHMuYmFySGVpZ2h0ID8gcGF0aHMuYmFySGVpZ2h0IDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICBiYXJXaWR0aDogcGF0aHMuYmFyV2lkdGggPyBwYXRocy5iYXJXaWR0aCA6IGJhcldpZHRoLFxuICAgICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwOiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgICBlbEdvYWxzTWFya2VyczogZWxHb2Fsc01hcmtlcnMsXG4gICAgICAgICAgICAgIGVsQmFyU2hhZG93czogZWxCYXJTaGFkb3dzLFxuICAgICAgICAgICAgICB2aXNpYmxlU2VyaWVzOiB0aGlzLnZpc2libGVJLFxuICAgICAgICAgICAgICB0eXBlOiAnYmFyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgICAgdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbcmVhbEluZGV4XSA9IHhBcnJqO1xuICAgICAgICAgIHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzW3JlYWxJbmRleF0gPSB5QXJyajtcbiAgICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNlcmllcyhfcmVmKSB7XG4gICAgICAgIHZhciByZWFsSW5kZXggPSBfcmVmLnJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGaWxsID0gX3JlZi5wYXRoRmlsbCxcbiAgICAgICAgICAgIGxpbmVGaWxsID0gX3JlZi5saW5lRmlsbCxcbiAgICAgICAgICAgIGogPSBfcmVmLmosXG4gICAgICAgICAgICBpID0gX3JlZi5pLFxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IF9yZWYuZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIHBhdGhGcm9tID0gX3JlZi5wYXRoRnJvbSxcbiAgICAgICAgICAgIHBhdGhUbyA9IF9yZWYucGF0aFRvLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgZWxTZXJpZXMgPSBfcmVmLmVsU2VyaWVzLFxuICAgICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICAgIHkgPSBfcmVmLnksXG4gICAgICAgICAgICB5MSA9IF9yZWYueTEsXG4gICAgICAgICAgICB5MiA9IF9yZWYueTIsXG4gICAgICAgICAgICBzZXJpZXMgPSBfcmVmLnNlcmllcyxcbiAgICAgICAgICAgIGJhckhlaWdodCA9IF9yZWYuYmFySGVpZ2h0LFxuICAgICAgICAgICAgYmFyV2lkdGggPSBfcmVmLmJhcldpZHRoLFxuICAgICAgICAgICAgYmFyWFBvc2l0aW9uID0gX3JlZi5iYXJYUG9zaXRpb24sXG4gICAgICAgICAgICBiYXJZUG9zaXRpb24gPSBfcmVmLmJhcllQb3NpdGlvbixcbiAgICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXAgPSBfcmVmLmVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICBlbEdvYWxzTWFya2VycyA9IF9yZWYuZWxHb2Fsc01hcmtlcnMsXG4gICAgICAgICAgICBlbEJhclNoYWRvd3MgPSBfcmVmLmVsQmFyU2hhZG93cyxcbiAgICAgICAgICAgIHZpc2libGVTZXJpZXMgPSBfcmVmLnZpc2libGVTZXJpZXMsXG4gICAgICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcblxuICAgICAgICBpZiAoIWxpbmVGaWxsKSB7XG4gICAgICAgICAgLyogZml4IGFwZXhjaGFydHMjMzQxICovXG4gICAgICAgICAgbGluZUZpbGwgPSB0aGlzLmJhck9wdGlvbnMuZGlzdHJpYnV0ZWQgPyB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9yc1tqXSA6IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW3JlYWxJbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0gJiYgdy5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0uc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICBsaW5lRmlsbCA9IHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2pdLnN0cm9rZUNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNOdWxsVmFsdWUpIHtcbiAgICAgICAgICBwYXRoRmlsbCA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWxheSA9IGogLyB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGVHcmFkdWFsbHkuZGVsYXkgKiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzKSAvIDIuNDtcbiAgICAgICAgdmFyIHJlbmRlcmVkUGF0aCA9IGdyYXBoaWNzLnJlbmRlclBhdGhzKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgIHN0cm9rZTogbGluZUZpbGwsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIHN0cm9rZUxpbmVDYXA6IHcuY29uZmlnLnN0cm9rZS5saW5lQ2FwLFxuICAgICAgICAgIGZpbGw6IHBhdGhGaWxsLFxuICAgICAgICAgIGFuaW1hdGlvbkRlbGF5OiBkZWxheSxcbiAgICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgICAgZGF0YUNoYW5nZVNwZWVkOiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLWFyZWFcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcmVkUGF0aC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuICAgICAgICB2YXIgZm9yZWNhc3QgPSB3LmNvbmZpZy5mb3JlY2FzdERhdGFQb2ludHM7XG5cbiAgICAgICAgaWYgKGZvcmVjYXN0LmNvdW50ID4gMCkge1xuICAgICAgICAgIGlmIChqID49IHcuZ2xvYmFscy5kYXRhUG9pbnRzIC0gZm9yZWNhc3QuY291bnQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkUGF0aC5ub2RlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGZvcmVjYXN0LmRhc2hBcnJheSk7XG4gICAgICAgICAgICByZW5kZXJlZFBhdGgubm9kZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGZvcmVjYXN0LnN0cm9rZVdpZHRoKTtcbiAgICAgICAgICAgIHJlbmRlcmVkUGF0aC5ub2RlLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgZm9yZWNhc3QuZmlsbE9wYWNpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB5MiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZW5kZXJlZFBhdGguYXR0cignZGF0YS1yYW5nZS15MScsIHkxKTtcbiAgICAgICAgICByZW5kZXJlZFBhdGguYXR0cignZGF0YS1yYW5nZS15MicsIHkyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihyZW5kZXJlZFBhdGgsIHJlYWxJbmRleCwgaik7XG4gICAgICAgIGVsU2VyaWVzLmFkZChyZW5kZXJlZFBhdGgpO1xuICAgICAgICB2YXIgYmFyRGF0YUxhYmVscyA9IG5ldyBCYXJEYXRhTGFiZWxzKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YUxhYmVsc09iaiA9IGJhckRhdGFMYWJlbHMuaGFuZGxlQmFyRGF0YUxhYmVscyh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uLFxuICAgICAgICAgIHJlbmRlcmVkUGF0aDogcmVuZGVyZWRQYXRoLFxuICAgICAgICAgIHZpc2libGVTZXJpZXM6IHZpc2libGVTZXJpZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRhdGFMYWJlbHNPYmouZGF0YUxhYmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXAuYWRkKGRhdGFMYWJlbHNPYmouZGF0YUxhYmVscyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YUxhYmVsc09iai50b3RhbERhdGFMYWJlbHMpIHtcbiAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwLmFkZChkYXRhTGFiZWxzT2JqLnRvdGFsRGF0YUxhYmVscyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbFNlcmllcy5hZGQoZWxEYXRhTGFiZWxzV3JhcCk7XG5cbiAgICAgICAgaWYgKGVsR29hbHNNYXJrZXJzKSB7XG4gICAgICAgICAgZWxTZXJpZXMuYWRkKGVsR29hbHNNYXJrZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbEJhclNoYWRvd3MpIHtcbiAgICAgICAgICBlbFNlcmllcy5hZGQoZWxCYXJTaGFkb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbFNlcmllcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0JhclBhdGhzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhclBhdGhzKF9yZWYyKSB7XG4gICAgICAgIHZhciBpbmRleGVzID0gX3JlZjIuaW5kZXhlcyxcbiAgICAgICAgICAgIGJhckhlaWdodCA9IF9yZWYyLmJhckhlaWdodCxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZjIuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICB6ZXJvVyA9IF9yZWYyLnplcm9XLFxuICAgICAgICAgICAgeCA9IF9yZWYyLngsXG4gICAgICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgICAgIHlEaXZpc2lvbiA9IF9yZWYyLnlEaXZpc2lvbixcbiAgICAgICAgICAgIGVsU2VyaWVzID0gX3JlZjIuZWxTZXJpZXM7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICAgIHZhciBiYXJZUG9zaXRpb247XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgeSA9ICh3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMuaW52ZXJ0ZWRYUmF0aW8gLSBiYXJIZWlnaHQ7XG4gICAgICAgICAgYmFyWVBvc2l0aW9uID0geSArIGJhckhlaWdodCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5oaWRlWmVyb0JhcnNXaGVuR3JvdXBlZCkge1xuICAgICAgICAgICAgdmFyIG5vblplcm9Db2x1bW5zID0gMDtcbiAgICAgICAgICAgIHZhciB6ZXJvRW5jb3VudGVycyA9IDA7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuc2VyaWVzUGVyY2VudC5mb3JFYWNoKGZ1bmN0aW9uIChfcywgX3NpKSB7XG4gICAgICAgICAgICAgIGlmIChfc1tqXSkge1xuICAgICAgICAgICAgICAgIG5vblplcm9Db2x1bW5zKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX3NpIDwgaSAmJiBfc1tqXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHplcm9FbmNvdW50ZXJzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobm9uWmVyb0NvbHVtbnMgPiAwKSB7XG4gICAgICAgICAgICAgIGJhckhlaWdodCA9IHRoaXMuc2VyaWVzTGVuICogYmFySGVpZ2h0IC8gbm9uWmVyb0NvbHVtbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhcllQb3NpdGlvbiA9IHkgKyBiYXJIZWlnaHQgKiB0aGlzLnZpc2libGVJO1xuICAgICAgICAgICAgYmFyWVBvc2l0aW9uIC09IGJhckhlaWdodCAqIHplcm9FbmNvdW50ZXJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXJZUG9zaXRpb24gPSB5ICsgYmFySGVpZ2h0ICogdGhpcy52aXNpYmxlSTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0Z1bm5lbCkge1xuICAgICAgICAgIHplcm9XID0gemVyb1cgLSAodGhpcy5iYXJIZWxwZXJzLmdldFhGb3JWYWx1ZSh0aGlzLnNlcmllc1tpXVtqXSwgemVyb1cpIC0gemVyb1cpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSB0aGlzLmJhckhlbHBlcnMuZ2V0WEZvclZhbHVlKHRoaXMuc2VyaWVzW2ldW2pdLCB6ZXJvVyk7XG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMuYmFySGVscGVycy5nZXRCYXJwYXRocyh7XG4gICAgICAgICAgYmFyWVBvc2l0aW9uOiBiYXJZUG9zaXRpb24sXG4gICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgeDE6IHplcm9XLFxuICAgICAgICAgIHgyOiB4LFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzLFxuICAgICAgICAgIHJlYWxJbmRleDogaW5kZXhlcy5yZWFsSW5kZXgsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIHkgPSB5ICsgeURpdmlzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iYXJIZWxwZXJzLmJhckJhY2tncm91bmQoe1xuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICB5MTogYmFyWVBvc2l0aW9uIC0gYmFySGVpZ2h0ICogdGhpcy52aXNpYmxlSSxcbiAgICAgICAgICB5MjogYmFySGVpZ2h0ICogdGhpcy5zZXJpZXNMZW4sXG4gICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGhUbzogcGF0aHMucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tOiBwYXRocy5wYXRoRnJvbSxcbiAgICAgICAgICB4MTogemVyb1csXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGdvYWxYOiB0aGlzLmJhckhlbHBlcnMuZ2V0R29hbFZhbHVlcygneCcsIHplcm9XLCBudWxsLCBpLCBqKSxcbiAgICAgICAgICBiYXJZUG9zaXRpb246IGJhcllQb3NpdGlvbixcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Q29sdW1uUGF0aHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q29sdW1uUGF0aHMoX3JlZjMpIHtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmMy5pbmRleGVzLFxuICAgICAgICAgICAgeCA9IF9yZWYzLngsXG4gICAgICAgICAgICB5ID0gX3JlZjMueSxcbiAgICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYzLnhEaXZpc2lvbixcbiAgICAgICAgICAgIGJhcldpZHRoID0gX3JlZjMuYmFyV2lkdGgsXG4gICAgICAgICAgICB6ZXJvSCA9IF9yZWYzLnplcm9ILFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIGVsU2VyaWVzID0gX3JlZjMuZWxTZXJpZXM7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcmVhbEluZGV4ID0gaW5kZXhlcy5yZWFsSW5kZXg7XG4gICAgICAgIHZhciBpID0gaW5kZXhlcy5pO1xuICAgICAgICB2YXIgaiA9IGluZGV4ZXMuajtcbiAgICAgICAgdmFyIGJjID0gaW5kZXhlcy5iYztcbiAgICAgICAgdmFyIGJhclhQb3NpdGlvbjtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB2YXIgc3hJID0gcmVhbEluZGV4O1xuXG4gICAgICAgICAgaWYgKCF3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdLmxlbmd0aCkge1xuICAgICAgICAgICAgc3hJID0gdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXNYW3N4SV1bal0pIHtcbiAgICAgICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbc3hJXVtqXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMueFJhdGlvIC0gYmFyV2lkdGggKiB0aGlzLnNlcmllc0xlbiAvIDI7XG4gICAgICAgICAgfSAvLyByZS1jYWxjIGJhclhQb3NpdGlvbiBhcyB4IGNoYW5nZWRcblxuXG4gICAgICAgICAgYmFyWFBvc2l0aW9uID0geCArIGJhcldpZHRoICogdGhpcy52aXNpYmxlSTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhpZGVaZXJvQmFyc1doZW5Hcm91cGVkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkYmFySGVscGVycyRnZXRaID0gdGhpcy5iYXJIZWxwZXJzLmdldFplcm9WYWx1ZUVuY291bnRlcnMoe1xuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICBqOiBqXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBub25aZXJvQ29sdW1ucyA9IF90aGlzJGJhckhlbHBlcnMkZ2V0Wi5ub25aZXJvQ29sdW1ucyxcbiAgICAgICAgICAgICAgICB6ZXJvRW5jb3VudGVycyA9IF90aGlzJGJhckhlbHBlcnMkZ2V0Wi56ZXJvRW5jb3VudGVycztcblxuICAgICAgICAgICAgaWYgKG5vblplcm9Db2x1bW5zID4gMCkge1xuICAgICAgICAgICAgICBiYXJXaWR0aCA9IHRoaXMuc2VyaWVzTGVuICogYmFyV2lkdGggLyBub25aZXJvQ29sdW1ucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFyWFBvc2l0aW9uID0geCArIGJhcldpZHRoICogdGhpcy52aXNpYmxlSTtcbiAgICAgICAgICAgIGJhclhQb3NpdGlvbiAtPSBiYXJXaWR0aCAqIHplcm9FbmNvdW50ZXJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXJYUG9zaXRpb24gPSB4ICsgYmFyV2lkdGggKiB0aGlzLnZpc2libGVJO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHkgPSB0aGlzLmJhckhlbHBlcnMuZ2V0WUZvclZhbHVlKHRoaXMuc2VyaWVzW2ldW2pdLCB6ZXJvSCk7XG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMuYmFySGVscGVycy5nZXRDb2x1bW5QYXRocyh7XG4gICAgICAgICAgYmFyWFBvc2l0aW9uOiBiYXJYUG9zaXRpb24sXG4gICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgIHkxOiB6ZXJvSCxcbiAgICAgICAgICB5MjogeSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgc2VyaWVzOiB0aGlzLnNlcmllcyxcbiAgICAgICAgICByZWFsSW5kZXg6IGluZGV4ZXMucmVhbEluZGV4LFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgajogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB4ID0geCArIHhEaXZpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmFySGVscGVycy5iYXJCYWNrZ3JvdW5kKHtcbiAgICAgICAgICBiYzogYmMsXG4gICAgICAgICAgajogaixcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHgxOiBiYXJYUG9zaXRpb24gLSBzdHJva2VXaWR0aCAvIDIgLSBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUksXG4gICAgICAgICAgeDI6IGJhcldpZHRoICogdGhpcy5zZXJpZXNMZW4gKyBzdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGhUbzogcGF0aHMucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tOiBwYXRocy5wYXRoRnJvbSxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgZ29hbFk6IHRoaXMuYmFySGVscGVycy5nZXRHb2FsVmFsdWVzKCd5JywgbnVsbCwgemVyb0gsIGksIGopLFxuICAgICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqIGdldFByZXZpb3VzUGF0aCBpcyBhIGNvbW1vbiBmdW5jdGlvbiBmb3IgYmFycy9jb2x1bW5zIHdoaWNoIGlzIHVzZWQgdG8gZ2V0IHByZXZpb3VzIHBhdGhzIHdoZW4gZGF0YSBjaGFuZ2VzLlxuICAgICAgICogQG1lbWJlcm9mIEJhclxuICAgICAgICogQHBhcmFtIHtpbnR9IHJlYWxJbmRleCAtIGN1cnJlbnQgaXRlcmF0aW5nIGlcbiAgICAgICAqIEBwYXJhbSB7aW50fSBqIC0gY3VycmVudCBpdGVyYXRpbmcgc2VyaWVzJ3MgaiBpbmRleFxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBwYXRoRnJvbSBpcyB0aGUgc3RyaW5nIHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgaW4gYW5pbWF0aW9uc1xuICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFByZXZpb3VzUGF0aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByZXZpb3VzUGF0aChyZWFsSW5kZXgsIGopIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBwYXRoRnJvbTtcblxuICAgICAgICBmb3IgKHZhciBwcCA9IDA7IHBwIDwgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoOyBwcCsrKSB7XG4gICAgICAgICAgdmFyIGdwcCA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXTtcblxuICAgICAgICAgIGlmIChncHAucGF0aHMgJiYgZ3BwLnBhdGhzLmxlbmd0aCA+IDAgJiYgcGFyc2VJbnQoZ3BwLnJlYWxJbmRleCwgMTApID09PSBwYXJzZUludChyZWFsSW5kZXgsIDEwKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHBhdGhGcm9tID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzW2pdLmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGhGcm9tO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCYXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBCYXJTdGFja2VkIENsYXNzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIGJvdGggU3RhY2tlZCBDb2x1bW5zIGFuZCBCYXJzLlxuICAgKlxuICAgKiBAbW9kdWxlIEJhclN0YWNrZWRcbiAgICogVGhlIHdob2xlIGNhbGN1bGF0aW9uIGZvciBzdGFja2VkIGJhci9jb2x1bW4gaXMgZGlmZmVyZW50IGZyb20gbm9ybWFsIGJhci9jb2x1bW4sXG4gICAqIGhlbmNlIGl0IG1ha2VzIHNlbnNlIHRvIGRlcml2ZSBhIG5ldyBjbGFzcyBmb3IgaXQgZXh0ZW5kaW5nIG1vc3Qgb2YgdGhlIHByb3BzIG9mIFBhcmVudCBCYXJcbiAgICoqL1xuXG4gIHZhciBCYXJTdGFja2VkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFyKSB7XG4gICAgX2luaGVyaXRzKEJhclN0YWNrZWQsIF9CYXIpO1xuXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCYXJTdGFja2VkKTtcblxuICAgIGZ1bmN0aW9uIEJhclN0YWNrZWQoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFyU3RhY2tlZCk7XG5cbiAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQmFyU3RhY2tlZCwgW3tcbiAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMsIHNlcmllc0luZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmJhciA9IG5ldyBCYXIodGhpcy5jdHgsIHRoaXMueHlSYXRpb3MpO1xuICAgICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCwgdyk7XG4gICAgICAgIHNlcmllcyA9IGNvcmVVdGlscy5nZXRMb2dTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgdGhpcy55UmF0aW8gPSBjb3JlVXRpbHMuZ2V0TG9nWVJhdGlvcyh0aGlzLnlSYXRpbyk7XG4gICAgICAgIHRoaXMuYmFySGVscGVycy5pbml0VmFyaWFibGVzKHNlcmllcyk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrVHlwZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgc2VyaWVzID0gdy5nbG9iYWxzLnNlcmllc1BlcmNlbnQuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLmJhckhlbHBlcnMuaW5pdGlhbGl6ZVN0YWNrZWRQcmV2VmFycyh0aGlzKTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1iYXItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXMnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpLCBiYykge1xuICAgICAgICAgIHZhciB4RGl2aXNpb24gPSB2b2lkIDA7IC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG5cbiAgICAgICAgICB2YXIgeURpdmlzaW9uID0gdm9pZCAwOyAvLyB5RGl2aXNpb24gaXMgdGhlIEdSSURIRUlHSFQgZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoYmFycylcblxuICAgICAgICAgIHZhciB6ZXJvSCA9IHZvaWQgMDsgLy8gemVyb0ggaXMgdGhlIGJhc2VsaW5lIHdoZXJlIDAgbWVldHMgeSBheGlzXG5cbiAgICAgICAgICB2YXIgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgICAgdmFyIGdyb3VwSW5kZXggPSAtMTsgLy8gZ3JvdXBJbmRleCBpcyB0aGUgaW5kZXggb2YgZ3JvdXAgYnVja2V0cyAoZ3JvdXAxLCBncm91cDIsIC4uLilcblxuICAgICAgICAgIF90aGlzLmdyb3VwQ3R4ID0gX3RoaXM7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlcmllc0dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCwgZ0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAuaW5kZXhPZih3LmNvbmZpZy5zZXJpZXNbaV0ubmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICBncm91cEluZGV4ID0gZ0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGdyb3VwSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBfdGhpcy5ncm91cEN0eCA9IF90aGlzW3cuZ2xvYmFscy5zZXJpZXNHcm91cHNbZ3JvdXBJbmRleF1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB4QXJyVmFsdWVzID0gW107XG4gICAgICAgICAgdmFyIHlBcnJWYWx1ZXMgPSBbXTtcbiAgICAgICAgICB2YXIgcmVhbEluZGV4ID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gc2VyaWVzSW5kZXhbaV0gOiBpO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBfdGhpcy55YXhpc0luZGV4ID0gcmVhbEluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XS5yZXZlcnNlZDsgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cblxuICAgICAgICAgIHZhciBlbFNlcmllcyA9IF90aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzXCIsXG4gICAgICAgICAgICBzZXJpZXNOYW1lOiBVdGlscyQxLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbcmVhbEluZGV4XSksXG4gICAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxTZXJpZXMsIHJlYWxJbmRleCk7IC8vIGVsZGF0YWxhYmVsc1xuXG5cbiAgICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IF90aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJyxcbiAgICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGVsR29hbHNNYXJrZXJzID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWJhci1nb2Fscy1tYXJrZXJzJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICAgICAgdmFyIGJhcldpZHRoID0gMDtcblxuICAgICAgICAgIHZhciBpbml0UG9zaXRpb25zID0gX3RoaXMuaW5pdGlhbFBvc2l0aW9ucyh4LCB5LCB4RGl2aXNpb24sIHlEaXZpc2lvbiwgemVyb0gsIHplcm9XKTtcblxuICAgICAgICAgIHkgPSBpbml0UG9zaXRpb25zLnk7XG4gICAgICAgICAgYmFySGVpZ2h0ID0gaW5pdFBvc2l0aW9ucy5iYXJIZWlnaHQ7XG4gICAgICAgICAgeURpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy55RGl2aXNpb247XG4gICAgICAgICAgemVyb1cgPSBpbml0UG9zaXRpb25zLnplcm9XO1xuICAgICAgICAgIHggPSBpbml0UG9zaXRpb25zLng7XG4gICAgICAgICAgYmFyV2lkdGggPSBpbml0UG9zaXRpb25zLmJhcldpZHRoO1xuICAgICAgICAgIHhEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueERpdmlzaW9uO1xuICAgICAgICAgIHplcm9IID0gaW5pdFBvc2l0aW9ucy56ZXJvSDtcblxuICAgICAgICAgIF90aGlzLmJhckhlbHBlcnMuaW5pdGlhbGl6ZVN0YWNrZWRYWVZhcnMoX3RoaXMpOyAvLyB3aGVyZSBhbGwgc3RhY2sgYmFyIGRpc2FwcGVhciBhZnRlciBjb2xsYXBzaW5nIHRoZSBmaXJzdCBzZXJpZXNcblxuXG4gICAgICAgICAgaWYgKF90aGlzLmdyb3VwQ3R4LnByZXZZLmxlbmd0aCA9PT0gMSAmJiBfdGhpcy5ncm91cEN0eC5wcmV2WVswXS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4odmFsKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgX3RoaXMuZ3JvdXBDdHgucHJldllbMF0gPSBfdGhpcy5ncm91cEN0eC5wcmV2WVswXS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gemVyb0g7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmdyb3VwQ3R4LnByZXZZRlswXSA9IF90aGlzLmdyb3VwQ3R4LnByZXZZRlswXS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdy5nbG9iYWxzLmRhdGFQb2ludHM7IGorKykge1xuICAgICAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gX3RoaXMuYmFySGVscGVycy5nZXRTdHJva2VXaWR0aChpLCBqLCByZWFsSW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aE9wdHMgPSB7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgYmM6IGJjXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzLFxuICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICBzZXJpZXNHcm91cDogdy5nbG9iYWxzLnNlcmllc0dyb3Vwc1tncm91cEluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgcGF0aHMgPSBfdGhpcy5kcmF3U3RhY2tlZEJhclBhdGhzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb21tb25QYXRoT3B0cyksIHt9LCB7XG4gICAgICAgICAgICAgICAgemVyb1c6IHplcm9XLFxuICAgICAgICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYmFyV2lkdGggPSBfdGhpcy5zZXJpZXNbaV1bal0gLyBfdGhpcy5pbnZlcnRlZFlSYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhdGhzID0gX3RoaXMuZHJhd1N0YWNrZWRDb2x1bW5QYXRocyhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29tbW9uUGF0aE9wdHMpLCB7fSwge1xuICAgICAgICAgICAgICAgIHhEaXZpc2lvbjogeERpdmlzaW9uLFxuICAgICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgICB6ZXJvSDogemVyb0hcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBiYXJIZWlnaHQgPSBfdGhpcy5zZXJpZXNbaV1bal0gLyBfdGhpcy55UmF0aW9bX3RoaXMueWF4aXNJbmRleF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiYXJHb2FsTGluZSA9IF90aGlzLmJhckhlbHBlcnMuZHJhd0dvYWxMaW5lKHtcbiAgICAgICAgICAgICAgYmFyWFBvc2l0aW9uOiBwYXRocy5iYXJYUG9zaXRpb24sXG4gICAgICAgICAgICAgIGJhcllQb3NpdGlvbjogcGF0aHMuYmFyWVBvc2l0aW9uLFxuICAgICAgICAgICAgICBnb2FsWDogcGF0aHMuZ29hbFgsXG4gICAgICAgICAgICAgIGdvYWxZOiBwYXRocy5nb2FsWSxcbiAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChiYXJHb2FsTGluZSkge1xuICAgICAgICAgICAgICBlbEdvYWxzTWFya2Vycy5hZGQoYmFyR29hbExpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5ID0gcGF0aHMueTtcbiAgICAgICAgICAgIHggPSBwYXRocy54O1xuICAgICAgICAgICAgeEFyclZhbHVlcy5wdXNoKHgpO1xuICAgICAgICAgICAgeUFyclZhbHVlcy5wdXNoKHkpO1xuXG4gICAgICAgICAgICB2YXIgcGF0aEZpbGwgPSBfdGhpcy5iYXJIZWxwZXJzLmdldFBhdGhGaWxsQ29sb3Ioc2VyaWVzLCBpLCBqLCByZWFsSW5kZXgpO1xuXG4gICAgICAgICAgICBlbFNlcmllcyA9IF90aGlzLnJlbmRlclNlcmllcyh7XG4gICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICBwYXRoRmlsbDogcGF0aEZpbGwsXG4gICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRocy5wYXRoRnJvbSxcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRocy5wYXRoVG8sXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzLFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgZWxEYXRhTGFiZWxzV3JhcDogZWxEYXRhTGFiZWxzV3JhcCxcbiAgICAgICAgICAgICAgZWxHb2Fsc01hcmtlcnM6IGVsR29hbHNNYXJrZXJzLFxuICAgICAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICAgICAgdmlzaWJsZVNlcmllczogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgICAgdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbcmVhbEluZGV4XSA9IHhBcnJWYWx1ZXM7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJWYWx1ZXM7IC8vIHB1c2ggYWxsIGN1cnJlbnQgeSB2YWx1ZXMgYXJyYXkgdG8gbWFpbiBQcmV2WSBBcnJheVxuXG4gICAgICAgICAgX3RoaXMuZ3JvdXBDdHgucHJldlkucHVzaChfdGhpcy5ncm91cEN0eC55QXJyaik7XG5cbiAgICAgICAgICBfdGhpcy5ncm91cEN0eC5wcmV2WUYucHVzaChfdGhpcy5ncm91cEN0eC55QXJyakYpO1xuXG4gICAgICAgICAgX3RoaXMuZ3JvdXBDdHgucHJldllWYWwucHVzaChfdGhpcy5ncm91cEN0eC55QXJyalZhbCk7XG5cbiAgICAgICAgICBfdGhpcy5ncm91cEN0eC5wcmV2WC5wdXNoKF90aGlzLmdyb3VwQ3R4LnhBcnJqKTtcblxuICAgICAgICAgIF90aGlzLmdyb3VwQ3R4LnByZXZYRi5wdXNoKF90aGlzLmdyb3VwQ3R4LnhBcnJqRik7XG5cbiAgICAgICAgICBfdGhpcy5ncm91cEN0eC5wcmV2WFZhbC5wdXNoKF90aGlzLmdyb3VwQ3R4LnhBcnJqVmFsKTtcblxuICAgICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBiYyA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyssIGJjKyspIHtcbiAgICAgICAgICBfbG9vcChpLCBiYyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbml0aWFsUG9zaXRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbFBvc2l0aW9ucyh4LCB5LCB4RGl2aXNpb24sIHlEaXZpc2lvbiwgemVyb0gsIHplcm9XKSB7XG4gICAgICAgIHZhciBfdyRnbG9iYWxzJHNlcmllc0dyb3UsIF93JGdsb2JhbHMkc2VyaWVzR3JvdTI7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBiYXJIZWlnaHQsIGJhcldpZHRoO1xuXG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIC8vIGhlaWdodCBkaXZpZGVkIGludG8gZXF1YWwgcGFydHNcbiAgICAgICAgICB5RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbjtcbiAgICAgICAgICBiYXJIZWlnaHQgPSBiYXJIZWlnaHQgKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuYmFySGVpZ2h0LCAxMCkgLyAxMDA7XG5cbiAgICAgICAgICBpZiAoU3RyaW5nKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5iYXJIZWlnaHQpLmluZGV4T2YoJyUnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJhckhlaWdodCA9IHBhcnNlSW50KHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5iYXJIZWlnaHQsIDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB6ZXJvVyA9IHRoaXMuYmFzZUxpbmVJbnZlcnRlZFkgKyB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArICh0aGlzLmlzUmV2ZXJzZWQgPyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIDogMCkgLSAodGhpcy5pc1JldmVyc2VkID8gdGhpcy5iYXNlTGluZUludmVydGVkWSAqIDIgOiAwKTsgLy8gaW5pdGlhbCB5IHBvc2l0aW9uIGlzIGhhbGYgb2YgYmFySGVpZ2h0ICogaGFsZiBvZiBudW1iZXIgb2YgQmFyc1xuXG4gICAgICAgICAgeSA9ICh5RGl2aXNpb24gLSBiYXJIZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3aWR0aCBkaXZpZGVkIGludG8gZXF1YWwgcGFydHNcbiAgICAgICAgICB4RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgICAgYmFyV2lkdGggPSB4RGl2aXNpb247XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5nbG9iYWxzLmRhdGFQb2ludHMgPiAxKSB7XG4gICAgICAgICAgICAvLyB0aGUgY2hlY2sgKHcuZ2xvYmFscy5kYXRhUG9pbnRzID4gMSkgZml4ZXMgYXBleGNoYXJ0cy5qcyAjMTYxN1xuICAgICAgICAgICAgeERpdmlzaW9uID0gdy5nbG9iYWxzLm1pblhEaWZmIC8gdGhpcy54UmF0aW87XG4gICAgICAgICAgICBiYXJXaWR0aCA9IHhEaXZpc2lvbiAqIHBhcnNlSW50KHRoaXMuYmFyT3B0aW9ucy5jb2x1bW5XaWR0aCwgMTApIC8gMTAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXJXaWR0aCA9IGJhcldpZHRoICogcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmNvbHVtbldpZHRoLCAxMCkgLyAxMDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFN0cmluZyh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sdW1uV2lkdGgpLmluZGV4T2YoJyUnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJhcldpZHRoID0gcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmNvbHVtbldpZHRoLCAxMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgemVyb0ggPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIHRoaXMuYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gLSAodGhpcy5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRIZWlnaHQgOiAwKSArICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICogMiA6IDApOyAvLyBpbml0aWFsIHggcG9zaXRpb24gaXMgb25lIHRoaXJkIG9mIGJhcldpZHRoXG5cbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWwgKyAoeERpdmlzaW9uIC0gYmFyV2lkdGgpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uLFxuICAgICAgICAgIHhEaXZpc2lvbjogeERpdmlzaW9uLFxuICAgICAgICAgIGJhckhlaWdodDogKF93JGdsb2JhbHMkc2VyaWVzR3JvdSA9IHcuZ2xvYmFscy5zZXJpZXNHcm91cHMpICE9PSBudWxsICYmIF93JGdsb2JhbHMkc2VyaWVzR3JvdSAhPT0gdm9pZCAwICYmIF93JGdsb2JhbHMkc2VyaWVzR3JvdS5sZW5ndGggPyBiYXJIZWlnaHQgLyB3Lmdsb2JhbHMuc2VyaWVzR3JvdXBzLmxlbmd0aCA6IGJhckhlaWdodCxcbiAgICAgICAgICBiYXJXaWR0aDogKF93JGdsb2JhbHMkc2VyaWVzR3JvdTIgPSB3Lmdsb2JhbHMuc2VyaWVzR3JvdXBzKSAhPT0gbnVsbCAmJiBfdyRnbG9iYWxzJHNlcmllc0dyb3UyICE9PSB2b2lkIDAgJiYgX3ckZ2xvYmFscyRzZXJpZXNHcm91Mi5sZW5ndGggPyBiYXJXaWR0aCAvIHcuZ2xvYmFscy5zZXJpZXNHcm91cHMubGVuZ3RoIDogYmFyV2lkdGgsXG4gICAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICAgIHplcm9XOiB6ZXJvV1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3U3RhY2tlZEJhclBhdGhzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1N0YWNrZWRCYXJQYXRocyhfcmVmKSB7XG4gICAgICAgIHZhciBpbmRleGVzID0gX3JlZi5pbmRleGVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZi5iYXJIZWlnaHQsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICB6ZXJvVyA9IF9yZWYuemVyb1csXG4gICAgICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICAgICAgeSA9IF9yZWYueSxcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSBfcmVmLmdyb3VwSW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNHcm91cCA9IF9yZWYuc2VyaWVzR3JvdXAsXG4gICAgICAgICAgICB5RGl2aXNpb24gPSBfcmVmLnlEaXZpc2lvbixcbiAgICAgICAgICAgIGVsU2VyaWVzID0gX3JlZi5lbFNlcmllcztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBiYXJZUG9zaXRpb24gPSB5ICsgKGdyb3VwSW5kZXggIT09IC0xID8gZ3JvdXBJbmRleCAqIGJhckhlaWdodCA6IDApO1xuICAgICAgICB2YXIgYmFyWFBvc2l0aW9uO1xuICAgICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICAgIHZhciBwcmV2QmFyVyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmdyb3VwQ3R4LnByZXZYRi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHByZXZCYXJXID0gcHJldkJhclcgKyB0aGlzLmdyb3VwQ3R4LnByZXZYRltrXVtqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnc2kgPSBpOyAvLyBhbiBpbmRleCB0byBrZWVwIHRyYWNrIG9mIHRoZSBzZXJpZXMgaW5zaWRlIGEgZ3JvdXBcblxuICAgICAgICBpZiAoc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICBnc2kgPSBzZXJpZXNHcm91cC5pbmRleE9mKHcuY29uZmlnLnNlcmllc1tpXS5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnc2kgPiAwKSB7XG4gICAgICAgICAgdmFyIGJYUCA9IHplcm9XO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZ3JvdXBDdHgucHJldlhWYWxbZ3NpIC0gMV1bal0gPCAwKSB7XG4gICAgICAgICAgICBiWFAgPSB0aGlzLnNlcmllc1tpXVtqXSA+PSAwID8gdGhpcy5ncm91cEN0eC5wcmV2WFtnc2kgLSAxXVtqXSArIHByZXZCYXJXIC0gKHRoaXMuaXNSZXZlcnNlZCA/IHByZXZCYXJXIDogMCkgKiAyIDogdGhpcy5ncm91cEN0eC5wcmV2WFtnc2kgLSAxXVtqXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ3JvdXBDdHgucHJldlhWYWxbZ3NpIC0gMV1bal0gPj0gMCkge1xuICAgICAgICAgICAgYlhQID0gdGhpcy5zZXJpZXNbaV1bal0gPj0gMCA/IHRoaXMuZ3JvdXBDdHgucHJldlhbZ3NpIC0gMV1bal0gOiB0aGlzLmdyb3VwQ3R4LnByZXZYW2dzaSAtIDFdW2pdIC0gcHJldkJhclcgKyAodGhpcy5pc1JldmVyc2VkID8gcHJldkJhclcgOiAwKSAqIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmFyWFBvc2l0aW9uID0gYlhQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZSBmaXJzdCBzZXJpZXMgd2lsbCBub3QgaGF2ZSBwcmV2WCB2YWx1ZXNcbiAgICAgICAgICBiYXJYUG9zaXRpb24gPSB6ZXJvVztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHggPSBiYXJYUG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IGJhclhQb3NpdGlvbiArIHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy5pbnZlcnRlZFlSYXRpbyAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gOiAwKSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLmJhckhlbHBlcnMuZ2V0QmFycGF0aHMoe1xuICAgICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uLFxuICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgIHgxOiBiYXJYUG9zaXRpb24sXG4gICAgICAgICAgeDI6IHgsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIHNlcmllczogdGhpcy5zZXJpZXMsXG4gICAgICAgICAgcmVhbEluZGV4OiBpbmRleGVzLnJlYWxJbmRleCxcbiAgICAgICAgICBzZXJpZXNHcm91cDogc2VyaWVzR3JvdXAsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmFySGVscGVycy5iYXJCYWNrZ3JvdW5kKHtcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgeTE6IGJhcllQb3NpdGlvbixcbiAgICAgICAgICB5MjogYmFySGVpZ2h0LFxuICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICB9KTtcbiAgICAgICAgeSA9IHkgKyB5RGl2aXNpb247XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aFRvOiBwYXRocy5wYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb206IHBhdGhzLnBhdGhGcm9tLFxuICAgICAgICAgIGdvYWxYOiB0aGlzLmJhckhlbHBlcnMuZ2V0R29hbFZhbHVlcygneCcsIHplcm9XLCBudWxsLCBpLCBqKSxcbiAgICAgICAgICBiYXJZUG9zaXRpb246IGJhcllQb3NpdGlvbixcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1N0YWNrZWRDb2x1bW5QYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTdGFja2VkQ29sdW1uUGF0aHMoX3JlZjIpIHtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmMi5pbmRleGVzLFxuICAgICAgICAgICAgeCA9IF9yZWYyLngsXG4gICAgICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYyLnhEaXZpc2lvbixcbiAgICAgICAgICAgIGJhcldpZHRoID0gX3JlZjIuYmFyV2lkdGgsXG4gICAgICAgICAgICB6ZXJvSCA9IF9yZWYyLnplcm9ILFxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IF9yZWYyLmdyb3VwSW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNHcm91cCA9IF9yZWYyLnNlcmllc0dyb3VwLFxuICAgICAgICAgICAgZWxTZXJpZXMgPSBfcmVmMi5lbFNlcmllcztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBpID0gaW5kZXhlcy5pO1xuICAgICAgICB2YXIgaiA9IGluZGV4ZXMuajtcbiAgICAgICAgdmFyIGJjID0gaW5kZXhlcy5iYztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB2YXIgc2VyaWVzVmFsID0gdy5nbG9iYWxzLnNlcmllc1hbaV1bal07XG4gICAgICAgICAgaWYgKCFzZXJpZXNWYWwpIHNlcmllc1ZhbCA9IDA7XG4gICAgICAgICAgeCA9IChzZXJpZXNWYWwgLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLnhSYXRpbyAtIGJhcldpZHRoIC8gMjtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgeCA9IChzZXJpZXNWYWwgLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLnhSYXRpbyAtIGJhcldpZHRoIC8gMiAqIHcuZ2xvYmFscy5zZXJpZXNHcm91cHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYXJYUG9zaXRpb24gPSB4ICsgKGdyb3VwSW5kZXggIT09IC0xID8gZ3JvdXBJbmRleCAqIGJhcldpZHRoIDogMCk7XG4gICAgICAgIHZhciBiYXJZUG9zaXRpb247XG4gICAgICAgIHZhciBwcmV2QmFySCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmdyb3VwQ3R4LnByZXZZRi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIC8vIGZpeCBpc3N1ZSAjMTIxNVxuICAgICAgICAgIC8vIGluIGNhc2Ugd2hlcmUgdGhpcy5ncm91cEN0eC5wcmV2WUZba11bal0gaXMgTmFOLCB1c2UgMCBpbnN0ZWFkXG4gICAgICAgICAgcHJldkJhckggPSBwcmV2QmFySCArICghaXNOYU4odGhpcy5ncm91cEN0eC5wcmV2WUZba11bal0pID8gdGhpcy5ncm91cEN0eC5wcmV2WUZba11bal0gOiAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnc2kgPSBpOyAvLyBhbiBpbmRleCB0byBrZWVwIHRyYWNrIG9mIHRoZSBzZXJpZXMgaW5zaWRlIGEgZ3JvdXBcblxuICAgICAgICBpZiAoc2VyaWVzR3JvdXApIHtcbiAgICAgICAgICBnc2kgPSBzZXJpZXNHcm91cC5pbmRleE9mKHcuY29uZmlnLnNlcmllc1tpXS5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnc2kgPiAwICYmICF3Lmdsb2JhbHMuaXNYTnVtZXJpYyB8fCBnc2kgPiAwICYmIHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuZ2xvYmFscy5zZXJpZXNYW2kgLSAxXVtqXSA9PT0gdy5nbG9iYWxzLnNlcmllc1hbaV1bal0pIHtcbiAgICAgICAgICB2YXIgX3RoaXMkZ3JvdXBDdHgkcHJldllGO1xuXG4gICAgICAgICAgdmFyIGJZUDtcbiAgICAgICAgICB2YXIgcHJldllWYWx1ZTtcbiAgICAgICAgICB2YXIgcCA9IE1hdGgubWluKHRoaXMueVJhdGlvLmxlbmd0aCArIDEsIGkgKyAxKTtcblxuICAgICAgICAgIGlmICh0aGlzLmdyb3VwQ3R4LnByZXZZW2dzaSAtIDFdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ncm91cEN0eC5wcmV2WVtnc2kgLSAxXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlpID0gMTsgaWkgPCBwOyBpaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpcyRncm91cEN0eCRwcmV2WTtcblxuICAgICAgICAgICAgICBpZiAoIWlzTmFOKChfdGhpcyRncm91cEN0eCRwcmV2WSA9IHRoaXMuZ3JvdXBDdHgucHJldllbZ3NpIC0gaWldKSA9PT0gbnVsbCB8fCBfdGhpcyRncm91cEN0eCRwcmV2WSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ3JvdXBDdHgkcHJldllbal0pKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgcHJldmlvdXMgYXZhaWxhYmxlIHZhbHVlIHRvIGdpdmUgcHJldllWYWx1ZVxuICAgICAgICAgICAgICAgIHByZXZZVmFsdWUgPSB0aGlzLmdyb3VwQ3R4LnByZXZZW2dzaSAtIGlpXVtqXTsgLy8gaWYgZm91bmQgaXQsIGJyZWFrIHRoZSBsb29wXG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9paSA9IDE7IF9paSA8IHA7IF9paSsrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkZ3JvdXBDdHgkcHJldllWLCBfdGhpcyRncm91cEN0eCRwcmV2WVYyO1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBwcmV2aW91cyBhdmFpbGFibGUgdmFsdWUobm9uLU5hTikgdG8gZ2l2ZSBiWVBcbiAgICAgICAgICAgIGlmICgoKF90aGlzJGdyb3VwQ3R4JHByZXZZViA9IHRoaXMuZ3JvdXBDdHgucHJldllWYWxbZ3NpIC0gX2lpXSkgPT09IG51bGwgfHwgX3RoaXMkZ3JvdXBDdHgkcHJldllWID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRncm91cEN0eCRwcmV2WVZbal0pIDwgMCkge1xuICAgICAgICAgICAgICBiWVAgPSB0aGlzLnNlcmllc1tpXVtqXSA+PSAwID8gcHJldllWYWx1ZSAtIHByZXZCYXJIICsgKHRoaXMuaXNSZXZlcnNlZCA/IHByZXZCYXJIIDogMCkgKiAyIDogcHJldllWYWx1ZTsgLy8gZm91bmQgaXQ/IGJyZWFrIHRoZSBsb29wXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX3RoaXMkZ3JvdXBDdHgkcHJldllWMiA9IHRoaXMuZ3JvdXBDdHgucHJldllWYWxbZ3NpIC0gX2lpXSkgPT09IG51bGwgfHwgX3RoaXMkZ3JvdXBDdHgkcHJldllWMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ3JvdXBDdHgkcHJldllWMltqXSkgPj0gMCkge1xuICAgICAgICAgICAgICBiWVAgPSB0aGlzLnNlcmllc1tpXVtqXSA+PSAwID8gcHJldllWYWx1ZSA6IHByZXZZVmFsdWUgKyBwcmV2QmFySCAtICh0aGlzLmlzUmV2ZXJzZWQgPyBwcmV2QmFySCA6IDApICogMjsgLy8gZm91bmQgaXQ/IGJyZWFrIHRoZSBsb29wXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBiWVAgPT09ICd1bmRlZmluZWQnKSBiWVAgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodDsgLy8gaWYgdGhpcy5wcmV2WUZbMF0gaXMgYWxsIDAgcmVzdWx0ZWQgZnJvbSBsaW5lICM0ODZcbiAgICAgICAgICAvLyBBTkQgZXZlcnkgYXJyIHN0YXJ0aW5nIGZyb20gdGhlIHNlY29uZCBvbmx5IGNvbnRhaW5zIE5hTlxuXG4gICAgICAgICAgaWYgKChfdGhpcyRncm91cEN0eCRwcmV2WUYgPSB0aGlzLmdyb3VwQ3R4LnByZXZZRlswXSkgIT09IG51bGwgJiYgX3RoaXMkZ3JvdXBDdHgkcHJldllGICE9PSB2b2lkIDAgJiYgX3RoaXMkZ3JvdXBDdHgkcHJldllGLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPT09IDA7XG4gICAgICAgICAgfSkgJiYgdGhpcy5ncm91cEN0eC5wcmV2WUYuc2xpY2UoMSwgZ3NpKS5ldmVyeShmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHZhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgYmFyWVBvc2l0aW9uID0gemVyb0g7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgc3BlY2lhbFxuICAgICAgICAgICAgYmFyWVBvc2l0aW9uID0gYllQO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlkgdmFsdWVzLCBhbHNvIGlmIHRoZSBwcmV2IGluZGV4J3Mgc2VyaWVzIFggZG9lc24ndCBtYXRjaGVzIHRoZSBjdXJyZW50IGluZGV4J3Mgc2VyaWVzIFgsIHRoZW4gc3RhcnQgZnJvbSB6ZXJvXG4gICAgICAgICAgYmFyWVBvc2l0aW9uID0gemVyb0g7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXJpZXNbaV1bal0pIHtcbiAgICAgICAgICB5ID0gYmFyWVBvc2l0aW9uIC0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXhlcyAjMzYxMFxuICAgICAgICAgIHkgPSBiYXJZUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLmJhckhlbHBlcnMuZ2V0Q29sdW1uUGF0aHMoe1xuICAgICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICB5MTogYmFyWVBvc2l0aW9uLFxuICAgICAgICAgIHkyOiB5LFxuICAgICAgICAgIHlSYXRpbzogdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzLFxuICAgICAgICAgIHNlcmllc0dyb3VwOiBzZXJpZXNHcm91cCxcbiAgICAgICAgICByZWFsSW5kZXg6IGluZGV4ZXMucmVhbEluZGV4LFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgajogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhckhlbHBlcnMuYmFyQmFja2dyb3VuZCh7XG4gICAgICAgICAgYmM6IGJjLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICB4MTogYmFyWFBvc2l0aW9uLFxuICAgICAgICAgIHgyOiBiYXJXaWR0aCxcbiAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHggPSB4ICsgeERpdmlzaW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGhUbzogcGF0aHMucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tOiBwYXRocy5wYXRoRnJvbSxcbiAgICAgICAgICBnb2FsWTogdGhpcy5iYXJIZWxwZXJzLmdldEdvYWxWYWx1ZXMoJ3knLCBudWxsLCB6ZXJvSCwgaSwgaiksXG4gICAgICAgICAgYmFyWFBvc2l0aW9uOiBiYXJYUG9zaXRpb24sXG4gICAgICAgICAgeDogdy5nbG9iYWxzLmlzWE51bWVyaWMgPyB4IC0geERpdmlzaW9uIDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJhclN0YWNrZWQ7XG4gIH0oQmFyKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBCb3hDYW5kbGVTdGljayBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBib3RoIFN0YWNrZWQgQ29sdW1ucyBhbmQgQmFycy5cbiAgICpcbiAgICogQG1vZHVsZSBCb3hDYW5kbGVTdGlja1xuICAgKiovXG5cbiAgdmFyIEJveENhbmRsZVN0aWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFyKSB7XG4gICAgX2luaGVyaXRzKEJveENhbmRsZVN0aWNrLCBfQmFyKTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQm94Q2FuZGxlU3RpY2spO1xuXG4gICAgZnVuY3Rpb24gQm94Q2FuZGxlU3RpY2soKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94Q2FuZGxlU3RpY2spO1xuXG4gICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEJveENhbmRsZVN0aWNrLCBbe1xuICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcywgY3R5cGUsIHNlcmllc0luZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB0eXBlID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gY3R5cGUgOiB3LmNvbmZpZy5jaGFydC50eXBlO1xuICAgICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5jYW5kbGVzdGlja09wdGlvbnMgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmNhbmRsZXN0aWNrO1xuICAgICAgICB0aGlzLmJveE9wdGlvbnMgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmJveFBsb3Q7XG4gICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWw7XG4gICAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4LCB3KTtcbiAgICAgICAgc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy55UmF0aW8gPSBjb3JlVXRpbHMuZ2V0TG9nWVJhdGlvcyh0aGlzLnlSYXRpbyk7XG4gICAgICAgIHRoaXMuYmFySGVscGVycy5pbml0VmFyaWFibGVzKHNlcmllcyk7XG4gICAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXNcIilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgIF90aGlzLmlzQm94UGxvdCA9IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdib3hQbG90JyB8fCB3LmNvbmZpZy5zZXJpZXNbaV0udHlwZSA9PT0gJ2JveFBsb3QnO1xuICAgICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgICB5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICB4RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAgIC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG4gICAgICAgICAgeURpdmlzaW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgICAvLyB5RGl2aXNpb24gaXMgdGhlIEdSSURIRUlHSFQgZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoYmFycylcbiAgICAgICAgICB6ZXJvSCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgLy8gemVyb0ggaXMgdGhlIGJhc2VsaW5lIHdoZXJlIDAgbWVldHMgeSBheGlzXG4gICAgICAgICAgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgICAgdmFyIHlBcnJqID0gW107IC8vIGhvbGQgeSB2YWx1ZXMgb2YgY3VycmVudCBpdGVyYXRpbmcgc2VyaWVzXG5cbiAgICAgICAgICB2YXIgeEFycmogPSBbXTsgLy8gaG9sZCB4IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7IC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG5cbiAgICAgICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllc1wiLFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogVXRpbHMkMS5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW3JlYWxJbmRleF0pLFxuICAgICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMuY3R4LnNlcmllcy5hZGRDb2xsYXBzZWRDbGFzc1RvU2VyaWVzKGVsU2VyaWVzLCByZWFsSW5kZXgpO1xuXG4gICAgICAgICAgaWYgKHNlcmllc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBfdGhpcy52aXNpYmxlSSA9IF90aGlzLnZpc2libGVJICsgMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSAwO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBfdGhpcy55YXhpc0luZGV4ID0gcmVhbEluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbml0UG9zaXRpb25zID0gX3RoaXMuYmFySGVscGVycy5pbml0aWFsUG9zaXRpb25zKCk7XG5cbiAgICAgICAgICB5ID0gaW5pdFBvc2l0aW9ucy55O1xuICAgICAgICAgIGJhckhlaWdodCA9IGluaXRQb3NpdGlvbnMuYmFySGVpZ2h0O1xuICAgICAgICAgIHlEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueURpdmlzaW9uO1xuICAgICAgICAgIHplcm9XID0gaW5pdFBvc2l0aW9ucy56ZXJvVztcbiAgICAgICAgICB4ID0gaW5pdFBvc2l0aW9ucy54O1xuICAgICAgICAgIGJhcldpZHRoID0gaW5pdFBvc2l0aW9ucy5iYXJXaWR0aDtcbiAgICAgICAgICB4RGl2aXNpb24gPSBpbml0UG9zaXRpb25zLnhEaXZpc2lvbjtcbiAgICAgICAgICB6ZXJvSCA9IGluaXRQb3NpdGlvbnMuemVyb0g7XG4gICAgICAgICAgeEFycmoucHVzaCh4ICsgYmFyV2lkdGggLyAyKTsgLy8gZWxkYXRhbGFiZWxzXG5cbiAgICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJyxcbiAgICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihqKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSBfdGhpcy5iYXJIZWxwZXJzLmdldFN0cm9rZVdpZHRoKGksIGosIHJlYWxJbmRleCk7XG5cbiAgICAgICAgICAgIHZhciBwYXRocyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcGF0aHNQYXJhbXMgPSB7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXhcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgcGF0aHMgPSBfdGhpcy5kcmF3SG9yaXpvbnRhbEJveFBhdGhzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXRoc1BhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICAgICAgeURpdmlzaW9uOiB5RGl2aXNpb24sXG4gICAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgemVyb1c6IHplcm9XXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhdGhzID0gX3RoaXMuZHJhd1ZlcnRpY2FsQm94UGF0aHMoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBhdGhzUGFyYW1zKSwge30sIHtcbiAgICAgICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgemVyb0g6IHplcm9IXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeSA9IHBhdGhzLnk7XG4gICAgICAgICAgICB4ID0gcGF0aHMueDsgLy8gcHVzaCBjdXJyZW50IFhcblxuICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgIHhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHlBcnJqLnB1c2goeSk7XG4gICAgICAgICAgICBwYXRocy5wYXRoVG8uZm9yRWFjaChmdW5jdGlvbiAocGF0aFRvLCBwaSkge1xuICAgICAgICAgICAgICB2YXIgbGluZUZpbGwgPSAhX3RoaXMuaXNCb3hQbG90ICYmIF90aGlzLmNhbmRsZXN0aWNrT3B0aW9ucy53aWNrLnVzZUZpbGxDb2xvciA/IHBhdGhzLmNvbG9yW3BpXSA6IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW2ldO1xuICAgICAgICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgICAgICBzZXJpZXNOdW1iZXI6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgICAgICBjb2xvcjogcGF0aHMuY29sb3JbcGldLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzZXJpZXNbaV1bal1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMucmVuZGVyU2VyaWVzKHtcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBwYXRoRmlsbDogcGF0aEZpbGwsXG4gICAgICAgICAgICAgICAgbGluZUZpbGw6IGxpbmVGaWxsLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aHMucGF0aEZyb20sXG4gICAgICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllcyxcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXA6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICAgICAgdmlzaWJsZVNlcmllczogX3RoaXMudmlzaWJsZUksXG4gICAgICAgICAgICAgICAgdHlwZTogdy5jb25maWcuY2hhcnQudHlwZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHcuZ2xvYmFscy5kYXRhUG9pbnRzOyBqKyspIHtcbiAgICAgICAgICAgIF9sb29wMihqKTtcbiAgICAgICAgICB9IC8vIHB1c2ggYWxsIHggdmFsIGFycmF5cyBpbnRvIG1haW4geEFyclxuXG5cbiAgICAgICAgICB3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tyZWFsSW5kZXhdID0geEFycmo7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJqO1xuICAgICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3VmVydGljYWxCb3hQYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdWZXJ0aWNhbEJveFBhdGhzKF9yZWYpIHtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmLmluZGV4ZXMsXG4gICAgICAgICAgICB4ID0gX3JlZi54O1xuICAgICAgICAgICAgX3JlZi55O1xuICAgICAgICAgICAgdmFyIHhEaXZpc2lvbiA9IF9yZWYueERpdmlzaW9uLFxuICAgICAgICAgICAgYmFyV2lkdGggPSBfcmVmLmJhcldpZHRoLFxuICAgICAgICAgICAgemVyb0ggPSBfcmVmLnplcm9ILFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGkgPSBpbmRleGVzLmk7XG4gICAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgICB2YXIgaXNQb3NpdGl2ZSA9IHRydWU7XG4gICAgICAgIHZhciBjb2xvclBvcyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmNhbmRsZXN0aWNrLmNvbG9ycy51cHdhcmQ7XG4gICAgICAgIHZhciBjb2xvck5lZyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmNhbmRsZXN0aWNrLmNvbG9ycy5kb3dud2FyZDtcbiAgICAgICAgdmFyIGNvbG9yID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNCb3hQbG90KSB7XG4gICAgICAgICAgY29sb3IgPSBbdGhpcy5ib3hPcHRpb25zLmNvbG9ycy5sb3dlciwgdGhpcy5ib3hPcHRpb25zLmNvbG9ycy51cHBlcl07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeVJhdGlvID0gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XTtcbiAgICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgICB2YXIgb2hsYyA9IHRoaXMuZ2V0T0hMQ1ZhbHVlKHJlYWxJbmRleCwgaik7XG4gICAgICAgIHZhciBsMSA9IHplcm9IO1xuICAgICAgICB2YXIgbDIgPSB6ZXJvSDtcblxuICAgICAgICBpZiAob2hsYy5vID4gb2hsYy5jKSB7XG4gICAgICAgICAgaXNQb3NpdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkxID0gTWF0aC5taW4ob2hsYy5vLCBvaGxjLmMpO1xuICAgICAgICB2YXIgeTIgPSBNYXRoLm1heChvaGxjLm8sIG9obGMuYyk7XG4gICAgICAgIHZhciBtID0gb2hsYy5tO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbcmVhbEluZGV4XVtqXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMueFJhdGlvIC0gYmFyV2lkdGggLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhclhQb3NpdGlvbiA9IHggKyBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICB5MSA9IHplcm9IO1xuICAgICAgICAgIHkyID0gemVyb0g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeTEgPSB6ZXJvSCAtIHkxIC8geVJhdGlvO1xuICAgICAgICAgIHkyID0gemVyb0ggLSB5MiAvIHlSYXRpbztcbiAgICAgICAgICBsMSA9IHplcm9IIC0gb2hsYy5oIC8geVJhdGlvO1xuICAgICAgICAgIGwyID0gemVyb0ggLSBvaGxjLmwgLyB5UmF0aW87XG4gICAgICAgICAgbSA9IHplcm9IIC0gb2hsYy5tIC8geVJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGhUbyA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCB6ZXJvSCk7XG4gICAgICAgIHZhciBwYXRoRnJvbSA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MSk7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UHJldmlvdXNQYXRoKHJlYWxJbmRleCwgaiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0JveFBsb3QpIHtcbiAgICAgICAgICBwYXRoVG8gPSBbZ3JhcGhpY3MubW92ZShiYXJYUG9zaXRpb24sIHkxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgbDEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDQsIGwxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBiYXJXaWR0aCAvIDQsIGwxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCBsMSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCwgbSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgbSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgeTEgKyBzdHJva2VXaWR0aCAvIDIpLCBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgbSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoLCBtKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGgsIHkyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgbDIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIGJhcldpZHRoIC8gNCwgbDIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDQsIGwyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCBsMikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHkyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBtKSArICd6J107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FuZGxlc3RpY2tcbiAgICAgICAgICBwYXRoVG8gPSBbZ3JhcGhpY3MubW92ZShiYXJYUG9zaXRpb24sIHkyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgbDEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIHkyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGgsIHkyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGgsIHkxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgbDIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIHkxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCB5MSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgeTIgLSBzdHJva2VXaWR0aCAvIDIpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgeTEpO1xuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB4ID0geCArIHhEaXZpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeTIsXG4gICAgICAgICAgYmFyWFBvc2l0aW9uOiBiYXJYUG9zaXRpb24sXG4gICAgICAgICAgY29sb3I6IHRoaXMuaXNCb3hQbG90ID8gY29sb3IgOiBpc1Bvc2l0aXZlID8gW2NvbG9yUG9zXSA6IFtjb2xvck5lZ11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0hvcml6b250YWxCb3hQYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdIb3Jpem9udGFsQm94UGF0aHMoX3JlZjIpIHtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmMi5pbmRleGVzO1xuICAgICAgICAgICAgX3JlZjIueDtcbiAgICAgICAgICAgIHZhciB5ID0gX3JlZjIueSxcbiAgICAgICAgICAgIHlEaXZpc2lvbiA9IF9yZWYyLnlEaXZpc2lvbixcbiAgICAgICAgICAgIGJhckhlaWdodCA9IF9yZWYyLmJhckhlaWdodCxcbiAgICAgICAgICAgIHplcm9XID0gX3JlZjIuemVyb1csXG4gICAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYyLnN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGkgPSBpbmRleGVzLmk7XG4gICAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmJveE9wdGlvbnMuY29sb3JzLmxvd2VyO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQm94UGxvdCkge1xuICAgICAgICAgIGNvbG9yID0gW3RoaXMuYm94T3B0aW9ucy5jb2xvcnMubG93ZXIsIHRoaXMuYm94T3B0aW9ucy5jb2xvcnMudXBwZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHlSYXRpbyA9IHRoaXMuaW52ZXJ0ZWRZUmF0aW87XG4gICAgICAgIHZhciByZWFsSW5kZXggPSBpbmRleGVzLnJlYWxJbmRleDtcbiAgICAgICAgdmFyIG9obGMgPSB0aGlzLmdldE9ITENWYWx1ZShyZWFsSW5kZXgsIGopO1xuICAgICAgICB2YXIgbDEgPSB6ZXJvVztcbiAgICAgICAgdmFyIGwyID0gemVyb1c7XG4gICAgICAgIHZhciB4MSA9IE1hdGgubWluKG9obGMubywgb2hsYy5jKTtcbiAgICAgICAgdmFyIHgyID0gTWF0aC5tYXgob2hsYy5vLCBvaGxjLmMpO1xuICAgICAgICB2YXIgbSA9IG9obGMubTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB5ID0gKHcuZ2xvYmFscy5zZXJpZXNYW3JlYWxJbmRleF1bal0gLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLmludmVydGVkWFJhdGlvIC0gYmFySGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYXJZUG9zaXRpb24gPSB5ICsgYmFySGVpZ2h0ICogdGhpcy52aXNpYmxlSTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2VyaWVzW2ldW2pdID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLnNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHgxID0gemVyb1c7XG4gICAgICAgICAgeDIgPSB6ZXJvVztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MSA9IHplcm9XICsgeDEgLyB5UmF0aW87XG4gICAgICAgICAgeDIgPSB6ZXJvVyArIHgyIC8geVJhdGlvO1xuICAgICAgICAgIGwxID0gemVyb1cgKyBvaGxjLmggLyB5UmF0aW87XG4gICAgICAgICAgbDIgPSB6ZXJvVyArIG9obGMubCAvIHlSYXRpbztcbiAgICAgICAgICBtID0gemVyb1cgKyBvaGxjLm0gLyB5UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aFRvID0gZ3JhcGhpY3MubW92ZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHBhdGhGcm9tID0gZ3JhcGhpY3MubW92ZSh4MSwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC8gMik7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UHJldmlvdXNQYXRoKHJlYWxJbmRleCwgaiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoVG8gPSBbZ3JhcGhpY3MubW92ZSh4MSwgYmFyWVBvc2l0aW9uKSArIGdyYXBoaWNzLmxpbmUoeDEsIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAvIDIpICsgZ3JhcGhpY3MubGluZShsMSwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC8gMikgKyBncmFwaGljcy5saW5lKGwxLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLyAyIC0gYmFySGVpZ2h0IC8gNCkgKyBncmFwaGljcy5saW5lKGwxLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLyAyICsgYmFySGVpZ2h0IC8gNCkgKyBncmFwaGljcy5saW5lKGwxLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLyAyKSArIGdyYXBoaWNzLmxpbmUoeDEsIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAvIDIpICsgZ3JhcGhpY3MubGluZSh4MSwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0KSArIGdyYXBoaWNzLmxpbmUobSwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0KSArIGdyYXBoaWNzLmxpbmUobSwgYmFyWVBvc2l0aW9uKSArIGdyYXBoaWNzLmxpbmUoeDEgKyBzdHJva2VXaWR0aCAvIDIsIGJhcllQb3NpdGlvbiksIGdyYXBoaWNzLm1vdmUobSwgYmFyWVBvc2l0aW9uKSArIGdyYXBoaWNzLmxpbmUobSwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0KSArIGdyYXBoaWNzLmxpbmUoeDIsIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCkgKyBncmFwaGljcy5saW5lKHgyLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLyAyKSArIGdyYXBoaWNzLmxpbmUobDIsIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAvIDIpICsgZ3JhcGhpY3MubGluZShsMiwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gYmFySGVpZ2h0IC8gNCkgKyBncmFwaGljcy5saW5lKGwyLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLyA0KSArIGdyYXBoaWNzLmxpbmUobDIsIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAvIDIpICsgZ3JhcGhpY3MubGluZSh4MiwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC8gMikgKyBncmFwaGljcy5saW5lKHgyLCBiYXJZUG9zaXRpb24pICsgZ3JhcGhpY3MubGluZShtLCBiYXJZUG9zaXRpb24pICsgJ3onXTtcbiAgICAgICAgcGF0aEZyb20gPSBwYXRoRnJvbSArIGdyYXBoaWNzLm1vdmUoeDEsIGJhcllQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIHkgPSB5ICsgeURpdmlzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgeDogeDIsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBiYXJZUG9zaXRpb246IGJhcllQb3NpdGlvbixcbiAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0T0hMQ1ZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T0hMQ1ZhbHVlKGksIGopIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbzogdGhpcy5pc0JveFBsb3QgPyB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlSFtpXVtqXSA6IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVPW2ldW2pdLFxuICAgICAgICAgIGg6IHRoaXMuaXNCb3hQbG90ID8gdy5nbG9iYWxzLnNlcmllc0NhbmRsZU9baV1bal0gOiB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlSFtpXVtqXSxcbiAgICAgICAgICBtOiB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlTVtpXVtqXSxcbiAgICAgICAgICBsOiB0aGlzLmlzQm94UGxvdCA/IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVDW2ldW2pdIDogdy5nbG9iYWxzLnNlcmllc0NhbmRsZUxbaV1bal0sXG4gICAgICAgICAgYzogdGhpcy5pc0JveFBsb3QgPyB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlTFtpXVtqXSA6IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVDW2ldW2pdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJveENhbmRsZVN0aWNrO1xuICB9KEJhcik7XG5cbiAgdmFyIFRyZWVtYXBIZWxwZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlbWFwSGVscGVycyhjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmVlbWFwSGVscGVycyk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRyZWVtYXBIZWxwZXJzLCBbe1xuICAgICAga2V5OiBcImNoZWNrQ29sb3JSYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29sb3JSYW5nZSgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBuZWdSYW5nZSA9IGZhbHNlO1xuICAgICAgICB2YXIgY2hhcnRPcHRzID0gdy5jb25maWcucGxvdE9wdGlvbnNbdy5jb25maWcuY2hhcnQudHlwZV07XG5cbiAgICAgICAgaWYgKGNoYXJ0T3B0cy5jb2xvclNjYWxlLnJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2hhcnRPcHRzLmNvbG9yU2NhbGUucmFuZ2VzLm1hcChmdW5jdGlvbiAocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8PSAwKSB7XG4gICAgICAgICAgICAgIG5lZ1JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZWdSYW5nZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U2hhZGVDb2xvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlQ29sb3IoY2hhcnRUeXBlLCBpLCBqLCBuZWdSYW5nZSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGNvbG9yU2hhZGVQZXJjZW50ID0gMTtcbiAgICAgICAgdmFyIHNoYWRlSW50ZW5zaXR5ID0gdy5jb25maWcucGxvdE9wdGlvbnNbY2hhcnRUeXBlXS5zaGFkZUludGVuc2l0eTtcbiAgICAgICAgdmFyIGNvbG9yUHJvcHMgPSB0aGlzLmRldGVybWluZUNvbG9yKGNoYXJ0VHlwZSwgaSwgaik7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5oYXNOZWdzIHx8IG5lZ1JhbmdlKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zW2NoYXJ0VHlwZV0ucmV2ZXJzZU5lZ2F0aXZlU2hhZGUpIHtcbiAgICAgICAgICAgIGlmIChjb2xvclByb3BzLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gY29sb3JQcm9wcy5wZXJjZW50IC8gMTAwICogKHNoYWRlSW50ZW5zaXR5ICogMS4yNSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2xvclNoYWRlUGVyY2VudCA9ICgxIC0gY29sb3JQcm9wcy5wZXJjZW50IC8gMTAwKSAqIChzaGFkZUludGVuc2l0eSAqIDEuMjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29sb3JQcm9wcy5wZXJjZW50IDw9IDApIHtcbiAgICAgICAgICAgICAgY29sb3JTaGFkZVBlcmNlbnQgPSAxIC0gKDEgKyBjb2xvclByb3BzLnBlcmNlbnQgLyAxMDApICogc2hhZGVJbnRlbnNpdHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2xvclNoYWRlUGVyY2VudCA9ICgxIC0gY29sb3JQcm9wcy5wZXJjZW50IC8gMTAwKSAqIHNoYWRlSW50ZW5zaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xvclNoYWRlUGVyY2VudCA9IDEgLSBjb2xvclByb3BzLnBlcmNlbnQgLyAxMDA7XG5cbiAgICAgICAgICBpZiAoY2hhcnRUeXBlID09PSAndHJlZW1hcCcpIHtcbiAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gKDEgLSBjb2xvclByb3BzLnBlcmNlbnQgLyAxMDApICogKHNoYWRlSW50ZW5zaXR5ICogMS4yNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbG9yID0gY29sb3JQcm9wcy5jb2xvcjtcbiAgICAgICAgdmFyIHV0aWxzID0gbmV3IFV0aWxzJDEoKTtcblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnNbY2hhcnRUeXBlXS5lbmFibGVTaGFkZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy53LmNvbmZpZy50aGVtZS5tb2RlID09PSAnZGFyaycpIHtcbiAgICAgICAgICAgIGNvbG9yID0gVXRpbHMkMS5oZXhUb1JnYmEodXRpbHMuc2hhZGVDb2xvcihjb2xvclNoYWRlUGVyY2VudCAqIC0xLCBjb2xvclByb3BzLmNvbG9yKSwgdy5jb25maWcuZmlsbC5vcGFjaXR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3IgPSBVdGlscyQxLmhleFRvUmdiYSh1dGlscy5zaGFkZUNvbG9yKGNvbG9yU2hhZGVQZXJjZW50LCBjb2xvclByb3BzLmNvbG9yKSwgdy5jb25maWcuZmlsbC5vcGFjaXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICBjb2xvclByb3BzOiBjb2xvclByb3BzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRldGVybWluZUNvbG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lQ29sb3IoY2hhcnRUeXBlLCBpLCBqKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXVtqXTtcbiAgICAgICAgdmFyIGNoYXJ0T3B0cyA9IHcuY29uZmlnLnBsb3RPcHRpb25zW2NoYXJ0VHlwZV07XG4gICAgICAgIHZhciBzZXJpZXNOdW1iZXIgPSBjaGFydE9wdHMuY29sb3JTY2FsZS5pbnZlcnNlID8gaiA6IGk7XG5cbiAgICAgICAgaWYgKGNoYXJ0T3B0cy5kaXN0cmlidXRlZCAmJiB3LmNvbmZpZy5jaGFydC50eXBlID09PSAndHJlZW1hcCcpIHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXIgPSBqO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tzZXJpZXNOdW1iZXJdO1xuICAgICAgICB2YXIgZm9yZUNvbG9yID0gbnVsbDtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh3Lmdsb2JhbHMuc2VyaWVzW2ldKSk7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkody5nbG9iYWxzLnNlcmllc1tpXSkpO1xuXG4gICAgICAgIGlmICghY2hhcnRPcHRzLmRpc3RyaWJ1dGVkICYmIGNoYXJ0VHlwZSA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgICAgbWluID0gdy5nbG9iYWxzLm1pblk7XG4gICAgICAgICAgbWF4ID0gdy5nbG9iYWxzLm1heFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoYXJ0T3B0cy5jb2xvclNjYWxlLm1pbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBtaW4gPSBjaGFydE9wdHMuY29sb3JTY2FsZS5taW4gPCB3Lmdsb2JhbHMubWluWSA/IGNoYXJ0T3B0cy5jb2xvclNjYWxlLm1pbiA6IHcuZ2xvYmFscy5taW5ZO1xuICAgICAgICAgIG1heCA9IGNoYXJ0T3B0cy5jb2xvclNjYWxlLm1heCA+IHcuZ2xvYmFscy5tYXhZID8gY2hhcnRPcHRzLmNvbG9yU2NhbGUubWF4IDogdy5nbG9iYWxzLm1heFk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWwgPSBNYXRoLmFicyhtYXgpICsgTWF0aC5hYnMobWluKTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSAxMDAgKiB2YWwgLyAodG90YWwgPT09IDAgPyB0b3RhbCAtIDAuMDAwMDAxIDogdG90YWwpO1xuXG4gICAgICAgIGlmIChjaGFydE9wdHMuY29sb3JTY2FsZS5yYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb2xvclJhbmdlID0gY2hhcnRPcHRzLmNvbG9yU2NhbGUucmFuZ2VzO1xuICAgICAgICAgIGNvbG9yUmFuZ2UubWFwKGZ1bmN0aW9uIChyYW5nZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPj0gcmFuZ2UuZnJvbSAmJiB2YWwgPD0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgY29sb3IgPSByYW5nZS5jb2xvcjtcbiAgICAgICAgICAgICAgZm9yZUNvbG9yID0gcmFuZ2UuZm9yZUNvbG9yID8gcmFuZ2UuZm9yZUNvbG9yIDogbnVsbDtcbiAgICAgICAgICAgICAgbWluID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgICAgbWF4ID0gcmFuZ2UudG87XG4gICAgICAgICAgICAgIHZhciByVG90YWwgPSBNYXRoLmFicyhtYXgpICsgTWF0aC5hYnMobWluKTtcbiAgICAgICAgICAgICAgcGVyY2VudCA9IDEwMCAqIHZhbCAvIChyVG90YWwgPT09IDAgPyByVG90YWwgLSAwLjAwMDAwMSA6IHJUb3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICBmb3JlQ29sb3I6IGZvcmVDb2xvcixcbiAgICAgICAgICBwZXJjZW50OiBwZXJjZW50XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbGN1bGF0ZURhdGFMYWJlbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVEYXRhTGFiZWxzKF9yZWYpIHtcbiAgICAgICAgdmFyIHRleHQgPSBfcmVmLnRleHQsXG4gICAgICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICAgICAgeSA9IF9yZWYueSxcbiAgICAgICAgICAgIGkgPSBfcmVmLmksXG4gICAgICAgICAgICBqID0gX3JlZi5qLFxuICAgICAgICAgICAgY29sb3JQcm9wcyA9IF9yZWYuY29sb3JQcm9wcyxcbiAgICAgICAgICAgIGZvbnRTaXplID0gX3JlZi5mb250U2l6ZTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzQ29uZmlnID0gdy5jb25maWcuZGF0YUxhYmVscztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGRhdGFMYWJlbHMgPSBuZXcgRGF0YUxhYmVscyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gbnVsbDtcblxuICAgICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgICAgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhLWxhYmVscydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgb2ZmWCA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WDtcbiAgICAgICAgICB2YXIgb2ZmWSA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WTtcbiAgICAgICAgICB2YXIgZGF0YUxhYmVsc1ggPSB4ICsgb2ZmWDtcbiAgICAgICAgICB2YXIgZGF0YUxhYmVsc1kgPSB5ICsgcGFyc2VGbG9hdChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSAvIDMgKyBvZmZZO1xuICAgICAgICAgIGRhdGFMYWJlbHMucGxvdERhdGFMYWJlbHNUZXh0KHtcbiAgICAgICAgICAgIHg6IGRhdGFMYWJlbHNYLFxuICAgICAgICAgICAgeTogZGF0YUxhYmVsc1ksXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBjb2xvcjogY29sb3JQcm9wcy5mb3JlQ29sb3IsXG4gICAgICAgICAgICBwYXJlbnQ6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxEYXRhTGFiZWxzV3JhcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkTGlzdGVuZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGVsUmVjdCkge1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICBlbFJlY3Qubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZ3JhcGhpY3MucGF0aE1vdXNlRW50ZXIuYmluZCh0aGlzLCBlbFJlY3QpKTtcbiAgICAgICAgZWxSZWN0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGdyYXBoaWNzLnBhdGhNb3VzZUxlYXZlLmJpbmQodGhpcywgZWxSZWN0KSk7XG4gICAgICAgIGVsUmVjdC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGdyYXBoaWNzLnBhdGhNb3VzZURvd24uYmluZCh0aGlzLCBlbFJlY3QpKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVHJlZW1hcEhlbHBlcnM7XG4gIH0oKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBIZWF0TWFwIENsYXNzLlxuICAgKiBAbW9kdWxlIEhlYXRNYXBcbiAgICoqL1xuXG4gIHZhciBIZWF0TWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWF0TWFwKGN0eCwgeHlSYXRpb3MpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWF0TWFwKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMueFJhdGlvID0geHlSYXRpb3MueFJhdGlvO1xuICAgICAgdGhpcy55UmF0aW8gPSB4eVJhdGlvcy55UmF0aW87XG4gICAgICB0aGlzLmR5bmFtaWNBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb247XG4gICAgICB0aGlzLmhlbHBlcnMgPSBuZXcgVHJlZW1hcEhlbHBlcnMoY3R4KTtcbiAgICAgIHRoaXMucmVjdFJhZGl1cyA9IHRoaXMudy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5yYWRpdXM7XG4gICAgICB0aGlzLnN0cm9rZVdpZHRoID0gdGhpcy53LmNvbmZpZy5zdHJva2Uuc2hvdyA/IHRoaXMudy5jb25maWcuc3Ryb2tlLndpZHRoIDogMDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGVhdE1hcCwgW3tcbiAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWhlYXRtYXAnXG4gICAgICAgIH0pO1xuICAgICAgICByZXQuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTsgLy8gd2lkdGggZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG5cbiAgICAgICAgdmFyIHhEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgdmFyIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgIHZhciByZXYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZWdSYW5nZSA9IHRoaXMuaGVscGVycy5jaGVja0NvbG9yUmFuZ2UoKTtcbiAgICAgICAgdmFyIGhlYXRTZXJpZXMgPSBzZXJpZXMuc2xpY2UoKTtcblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbMF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICByZXYgPSB0cnVlO1xuICAgICAgICAgIGhlYXRTZXJpZXMucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHJldiA/IDAgOiBoZWF0U2VyaWVzLmxlbmd0aCAtIDE7IHJldiA/IGkgPCBoZWF0U2VyaWVzLmxlbmd0aCA6IGkgPj0gMDsgcmV2ID8gaSsrIDogaS0tKSB7XG4gICAgICAgICAgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cbiAgICAgICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBhcGV4Y2hhcnRzLWhlYXRtYXAtc2VyaWVzXCIsXG4gICAgICAgICAgICBzZXJpZXNOYW1lOiBVdGlscyQxLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbaV0pLFxuICAgICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmN0eC5zZXJpZXMuYWRkQ29sbGFwc2VkQ2xhc3NUb1NlcmllcyhlbFNlcmllcywgaSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsU2VyaWVzLCBzaGFkb3csIGkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB4MSA9IDA7XG4gICAgICAgICAgdmFyIHNoYWRlSW50ZW5zaXR5ID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5zaGFkZUludGVuc2l0eTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGVhdFNlcmllc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGhlYXRDb2xvciA9IHRoaXMuaGVscGVycy5nZXRTaGFkZUNvbG9yKHcuY29uZmlnLmNoYXJ0LnR5cGUsIGksIGosIHRoaXMubmVnUmFuZ2UpO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaGVhdENvbG9yLmNvbG9yO1xuICAgICAgICAgICAgdmFyIGhlYXRDb2xvclByb3BzID0gaGVhdENvbG9yLmNvbG9yUHJvcHM7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5maWxsLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICAgICAgICAgIGNvbG9yID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHcuZ2xvYmFscy5oYXNOZWdzID8gaGVhdENvbG9yUHJvcHMucGVyY2VudCA8IDAgPyAxIC0gKDEgKyBoZWF0Q29sb3JQcm9wcy5wZXJjZW50IC8gMTAwKSA6IHNoYWRlSW50ZW5zaXR5ICsgaGVhdENvbG9yUHJvcHMucGVyY2VudCAvIDEwMCA6IGhlYXRDb2xvclByb3BzLnBlcmNlbnQgLyAxMDAsXG4gICAgICAgICAgICAgICAgcGF0dGVybklEOiBVdGlscyQxLnJhbmRvbUlkKCksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHcuY29uZmlnLmZpbGwuaW1hZ2Uud2lkdGggPyB3LmNvbmZpZy5maWxsLmltYWdlLndpZHRoIDogeERpdmlzaW9uLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdy5jb25maWcuZmlsbC5pbWFnZS5oZWlnaHQgPyB3LmNvbmZpZy5maWxsLmltYWdlLmhlaWdodCA6IHlEaXZpc2lvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMucmVjdFJhZGl1cztcbiAgICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoeDEsIHkxLCB4RGl2aXNpb24sIHlEaXZpc2lvbiwgcmFkaXVzKTtcbiAgICAgICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICAgIGN4OiB4MSxcbiAgICAgICAgICAgICAgY3k6IHkxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlY3Qubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWhlYXRtYXAtcmVjdCcpO1xuICAgICAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICAgICAgcmVjdC5hdHRyKHtcbiAgICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICB2YWw6IGhlYXRTZXJpZXNbaV1bal0sXG4gICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBzdHJva2U6IHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAudXNlRmlsbENvbG9yQXNTdHJva2UgPyBjb2xvciA6IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzWzBdLFxuICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5oZWxwZXJzLmFkZExpc3RlbmVycyhyZWN0KTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHZhciBzcGVlZCA9IDE7XG5cbiAgICAgICAgICAgICAgaWYgKCF3Lmdsb2JhbHMucmVzaXplZCkge1xuICAgICAgICAgICAgICAgIHNwZWVkID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUhlYXRNYXAocmVjdCwgeDEsIHkxLCB4RGl2aXNpb24sIHlEaXZpc2lvbiwgc3BlZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHZhciBfc3BlZWQgPSAxO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNBbmltLmVuYWJsZWQgJiYgdy5nbG9iYWxzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgICAgICAgICBfc3BlZWQgPSB0aGlzLmR5bmFtaWNBbmltLnNwZWVkO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckZyb20gPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tpXSAmJiB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tpXVtqXSAmJiB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tpXVtqXS5jb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbG9yRnJvbSkgY29sb3JGcm9tID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMCknO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUhlYXRDb2xvcihyZWN0LCBVdGlscyQxLmlzQ29sb3JIZXgoY29sb3JGcm9tKSA/IGNvbG9yRnJvbSA6IFV0aWxzJDEucmdiMmhleChjb2xvckZyb20pLCBVdGlscyQxLmlzQ29sb3JIZXgoY29sb3IpID8gY29sb3IgOiBVdGlscyQxLnJnYjJoZXgoY29sb3IpLCBfc3BlZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRUZXh0ID0gZm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbaV1bal0sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHcuZ2xvYmFscy5zZXJpZXNbaV1bal0sXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMuaGVscGVycy5jYWxjdWxhdGVEYXRhTGFiZWxzKHtcbiAgICAgICAgICAgICAgdGV4dDogZm9ybWF0dGVkVGV4dCxcbiAgICAgICAgICAgICAgeDogeDEgKyB4RGl2aXNpb24gLyAyLFxuICAgICAgICAgICAgICB5OiB5MSArIHlEaXZpc2lvbiAvIDIsXG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgIGNvbG9yUHJvcHM6IGhlYXRDb2xvclByb3BzLFxuICAgICAgICAgICAgICBzZXJpZXM6IGhlYXRTZXJpZXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUxhYmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbFNlcmllcy5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHgxID0geDEgKyB4RGl2aXNpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeTEgPSB5MSArIHlEaXZpc2lvbjtcbiAgICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgICAgfSAvLyBhZGp1c3QgeWF4aXMgbGFiZWxzIGZvciBoZWF0bWFwXG5cblxuICAgICAgICB2YXIgeUF4aXNTY2FsZSA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLnJlc3VsdC5zbGljZSgpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCkge1xuICAgICAgICAgIHlBeGlzU2NhbGUudW5zaGlmdCgnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeUF4aXNTY2FsZS5wdXNoKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLnJlc3VsdCA9IHlBeGlzU2NhbGU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFuaW1hdGVIZWF0TWFwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUhlYXRNYXAoZWwsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHNwZWVkKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgICBhbmltYXRpb25zLmFuaW1hdGVSZWN0KGVsLCB7XG4gICAgICAgICAgeDogeCArIHdpZHRoIC8gMixcbiAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSwgc3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhbmltYXRpb25zLmFuaW1hdGlvbkNvbXBsZXRlZChlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbmltYXRlSGVhdENvbG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUhlYXRDb2xvcihlbCwgY29sb3JGcm9tLCBjb2xvclRvLCBzcGVlZCkge1xuICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICBmaWxsOiBjb2xvckZyb21cbiAgICAgICAgfSkuYW5pbWF0ZShzcGVlZCkuYXR0cih7XG4gICAgICAgICAgZmlsbDogY29sb3JUb1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGVhdE1hcDtcbiAgfSgpO1xuXG4gIHZhciBDaXJjdWxhckNoYXJ0c0hlbHBlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENpcmN1bGFyQ2hhcnRzSGVscGVycyhjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjdWxhckNoYXJ0c0hlbHBlcnMpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaXJjdWxhckNoYXJ0c0hlbHBlcnMsIFt7XG4gICAgICBrZXk6IFwiZHJhd1lBeGlzVGV4dHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WUF4aXNUZXh0cyh4LCB5LCBpLCB0ZXh0KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgeWF4aXNDb25maWcgPSB3LmNvbmZpZy55YXhpc1swXTtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgeWF4aXNMYWJlbCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiB4ICsgeWF4aXNDb25maWcubGFiZWxzLm9mZnNldFgsXG4gICAgICAgICAgeTogeSArIHlheGlzQ29uZmlnLmxhYmVscy5vZmZzZXRZLFxuICAgICAgICAgIHRleHQ6IGZvcm1hdHRlcih0ZXh0LCBpKSxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICBmb250U2l6ZTogeWF4aXNDb25maWcubGFiZWxzLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHlheGlzQ29uZmlnLmxhYmVscy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvcmVDb2xvcjogQXJyYXkuaXNBcnJheSh5YXhpc0NvbmZpZy5sYWJlbHMuc3R5bGUuY29sb3JzKSA/IHlheGlzQ29uZmlnLmxhYmVscy5zdHlsZS5jb2xvcnNbaV0gOiB5YXhpc0NvbmZpZy5sYWJlbHMuc3R5bGUuY29sb3JzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geWF4aXNMYWJlbDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2lyY3VsYXJDaGFydHNIZWxwZXJzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgUGllIENsYXNzIGZvciBkcmF3aW5nIFBpZSAvIERvbnV0IENoYXJ0cy5cbiAgICogQG1vZHVsZSBQaWVcbiAgICoqL1xuXG4gIHZhciBQaWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBpZShjdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaWUpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLmNoYXJ0VHlwZSA9IHRoaXMudy5jb25maWcuY2hhcnQudHlwZTtcbiAgICAgIHRoaXMuaW5pdGlhbEFuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICAgIHRoaXMuZHluYW1pY0FuaW0gPSB0aGlzLmluaXRpYWxBbmltICYmIHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQ7XG4gICAgICB0aGlzLmFuaW1CZWdpbkFyciA9IFswXTtcbiAgICAgIHRoaXMuYW5pbUR1ciA9IDA7XG4gICAgICB0aGlzLmRvbnV0RGF0YUxhYmVscyA9IHRoaXMudy5jb25maWcucGxvdE9wdGlvbnMucGllLmRvbnV0LmxhYmVscztcbiAgICAgIHRoaXMubGluZUNvbG9yQXJyID0gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgIT09IHVuZGVmaW5lZCA/IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIDogdy5nbG9iYWxzLmNvbG9ycztcbiAgICAgIHRoaXMuZGVmYXVsdFNpemUgPSBNYXRoLm1pbih3Lmdsb2JhbHMuZ3JpZFdpZHRoLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICB0aGlzLmNlbnRlclkgPSB0aGlzLmRlZmF1bHRTaXplIC8gMjtcbiAgICAgIHRoaXMuY2VudGVyWCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGlhbEJhcicpIHtcbiAgICAgICAgdGhpcy5mdWxsQW5nbGUgPSAzNjA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZ1bGxBbmdsZSA9IE1hdGguYWJzKHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5lbmRBbmdsZSAtIHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5zdGFydEFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0aWFsQW5nbGUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuc3RhcnRBbmdsZSAlIHRoaXMuZnVsbEFuZ2xlO1xuICAgICAgdy5nbG9iYWxzLnJhZGlhbFNpemUgPSB0aGlzLmRlZmF1bHRTaXplIC8gMi4wNSAtIHcuY29uZmlnLnN0cm9rZS53aWR0aCAtICghdy5jb25maWcuY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQgPyB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmJsdXIgOiAwKTtcbiAgICAgIHRoaXMuZG9udXRTaXplID0gdy5nbG9iYWxzLnJhZGlhbFNpemUgKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuc2l6ZSwgMTApIC8gMTAwO1xuICAgICAgdGhpcy5tYXhZID0gMDtcbiAgICAgIHRoaXMuc2xpY2VMYWJlbHMgPSBbXTtcbiAgICAgIHRoaXMuc2xpY2VTaXplcyA9IFtdO1xuICAgICAgdGhpcy5wcmV2U2VjdG9yQW5nbGVBcnIgPSBbXTsgLy8gZm9yIGR5bmFtaWMgYW5pbWF0aW9uc1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQaWUsIFt7XG4gICAgICBrZXk6IFwiZHJhd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5yZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXBpZSdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMubm9EYXRhKSByZXR1cm4gdGhpcy5yZXQ7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZXJpZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIFRPVEFMXG4gICAgICAgICAgdG90YWwgKz0gVXRpbHMkMS5uZWdUb1plcm8oc2VyaWVzW2tdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWN0b3JBbmdsZUFyciA9IFtdOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKCk7IC8vIHByZXZlbnQgZGl2aXNpb24gYnkgemVybyBlcnJvciBpZiB0aGVyZSBpcyBubyBkYXRhXG5cbiAgICAgICAgaWYgKHRvdGFsID09PSAwKSB7XG4gICAgICAgICAgdG90YWwgPSAwLjAwMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBfdGhpcy5tYXhZID0gTWF0aC5tYXgoX3RoaXMubWF4WSwgbSk7XG4gICAgICAgIH0pOyAvLyBvdmVycmlkZSBtYXhZIGlmIHVzZXIgcHJvdmlkZWQgaW4gY29uZmlnXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLm1heCkge1xuICAgICAgICAgIHRoaXMubWF4WSA9IHcuY29uZmlnLnlheGlzWzBdLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnBvc2l0aW9uID09PSAnYmFjaycgJiYgdGhpcy5jaGFydFR5cGUgPT09ICdwb2xhckFyZWEnKSB7XG4gICAgICAgICAgdGhpcy5kcmF3UG9sYXJFbGVtZW50cyh0aGlzLnJldCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIENBTENVTEFURSBUSEUgQU5HTEVTXG4gICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5mdWxsQW5nbGUgKiBVdGlscyQxLm5lZ1RvWmVybyhzZXJpZXNbaV0pIC8gdG90YWw7XG4gICAgICAgICAgc2VjdG9yQW5nbGVBcnIucHVzaChhbmdsZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09ICdwb2xhckFyZWEnKSB7XG4gICAgICAgICAgICBzZWN0b3JBbmdsZUFycltpXSA9IHRoaXMuZnVsbEFuZ2xlIC8gc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2xpY2VTaXplcy5wdXNoKHcuZ2xvYmFscy5yYWRpYWxTaXplICogc2VyaWVzW2ldIC8gdGhpcy5tYXhZKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zbGljZVNpemVzLnB1c2gody5nbG9iYWxzLnJhZGlhbFNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICB2YXIgcHJldlRvdGFsID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAgIC8vIENBTENVTEFURSBUSEUgUFJFViBUT1RBTFxuICAgICAgICAgICAgcHJldlRvdGFsICs9IFV0aWxzJDEubmVnVG9aZXJvKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW19rXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByZXZpb3VzQW5nbGU7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIFBSRVZJT1VTIEFOR0xFU1xuICAgICAgICAgICAgcHJldmlvdXNBbmdsZSA9IHRoaXMuZnVsbEFuZ2xlICogVXRpbHMkMS5uZWdUb1plcm8ody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbX2ldKSAvIHByZXZUb3RhbDtcbiAgICAgICAgICAgIHRoaXMucHJldlNlY3RvckFuZ2xlQXJyLnB1c2gocHJldmlvdXNBbmdsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIG9uIHNtYWxsIGNoYXJ0IHNpemUgYWZ0ZXIgZmV3IGNvdW50IG9mIHJlc2l6ZXMgYnJvd3NlciB3aW5kb3cgZG9udXRTaXplIGNhbiBiZSBuZWdhdGl2ZVxuXG5cbiAgICAgICAgaWYgKHRoaXMuZG9udXRTaXplIDwgMCkge1xuICAgICAgICAgIHRoaXMuZG9udXRTaXplID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZVNpemUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuY3VzdG9tU2NhbGU7XG4gICAgICAgIHZhciBoYWxmVyA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgICB2YXIgaGFsZkggPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDI7XG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gaGFsZlcgLSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMiAqIHNjYWxlU2l6ZTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBoYWxmSCAtIHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gMiAqIHNjYWxlU2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICAvLyBkcmF3IHRoZSBpbm5lciBjaXJjbGUgYW5kIGFkZCBzb21lIHRleHQgdG8gaXRcbiAgICAgICAgICB2YXIgY2lyY2xlID0gZ3JhcGhpY3MuZHJhd0NpcmNsZSh0aGlzLmRvbnV0U2l6ZSk7XG4gICAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgICAgY3g6IHRoaXMuY2VudGVyWCxcbiAgICAgICAgICAgIGN5OiB0aGlzLmNlbnRlclksXG4gICAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuYmFja2dyb3VuZCA/IHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5kb251dC5iYWNrZ3JvdW5kIDogJ3RyYW5zcGFyZW50J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsU2VyaWVzLmFkZChjaXJjbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsRyA9IHNlbGYuZHJhd0FyY3Moc2VjdG9yQW5nbGVBcnIsIHNlcmllcyk7IC8vIGFkZCBzbGljZSBkYXRhTGFiZWxzIGF0IHRoZSBlbmRcblxuICAgICAgICB0aGlzLnNsaWNlTGFiZWxzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBlbEcuYWRkKHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxTZXJpZXMuYXR0cih7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCwgXCIsIFwiKS5jb25jYXQodHJhbnNsYXRlWSwgXCIpIHNjYWxlKFwiKS5jb25jYXQoc2NhbGVTaXplLCBcIilcIilcbiAgICAgICAgfSk7XG4gICAgICAgIGVsU2VyaWVzLmFkZChlbEcpO1xuICAgICAgICB0aGlzLnJldC5hZGQoZWxTZXJpZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbnV0RGF0YUxhYmVscy5zaG93KSB7XG4gICAgICAgICAgdmFyIGRhdGFMYWJlbHMgPSB0aGlzLnJlbmRlcklubmVyRGF0YUxhYmVscyh0aGlzLmRvbnV0RGF0YUxhYmVscywge1xuICAgICAgICAgICAgaG9sbG93U2l6ZTogdGhpcy5kb251dFNpemUsXG4gICAgICAgICAgICBjZW50ZXJYOiB0aGlzLmNlbnRlclgsXG4gICAgICAgICAgICBjZW50ZXJZOiB0aGlzLmNlbnRlclksXG4gICAgICAgICAgICBvcGFjaXR5OiB0aGlzLmRvbnV0RGF0YUxhYmVscy5zaG93LFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogdHJhbnNsYXRlWCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IHRyYW5zbGF0ZVlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJldC5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC5wb3NpdGlvbiA9PT0gJ2Zyb250JyAmJiB0aGlzLmNoYXJ0VHlwZSA9PT0gJ3BvbGFyQXJlYScpIHtcbiAgICAgICAgICB0aGlzLmRyYXdQb2xhckVsZW1lbnRzKHRoaXMucmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJldDtcbiAgICAgIH0gLy8gY29yZSBmdW5jdGlvbiBmb3IgZHJhd2luZyBwaWUgYXJjc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdBcmNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0FyY3Moc2VjdG9yQW5nbGVBcnIsIHNlcmllcykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBmaWxsID0gbmV3IEZpbGwodGhpcy5jdHgpO1xuICAgICAgICB2YXIgZyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc2xpY2VzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmluaXRpYWxBbmdsZTtcbiAgICAgICAgdmFyIHByZXZTdGFydEFuZ2xlID0gdGhpcy5pbml0aWFsQW5nbGU7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IHRoaXMuaW5pdGlhbEFuZ2xlO1xuICAgICAgICB2YXIgcHJldkVuZEFuZ2xlID0gdGhpcy5pbml0aWFsQW5nbGU7XG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB3LmNvbmZpZy5zdHJva2Uuc2hvdyA/IHcuY29uZmlnLnN0cm9rZS53aWR0aCA6IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWN0b3JBbmdsZUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbFBpZUFyYyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtcGllLXNlcmllc1wiLFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogVXRpbHMkMS5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW2ldKSxcbiAgICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZy5hZGQoZWxQaWVBcmMpO1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgICBwcmV2U3RhcnRBbmdsZSA9IHByZXZFbmRBbmdsZTtcbiAgICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzZWN0b3JBbmdsZUFycltpXTtcbiAgICAgICAgICBwcmV2RW5kQW5nbGUgPSBwcmV2U3RhcnRBbmdsZSArIHRoaXMucHJldlNlY3RvckFuZ2xlQXJyW2ldO1xuICAgICAgICAgIHZhciBhbmdsZSA9IGVuZEFuZ2xlIDwgc3RhcnRBbmdsZSA/IHRoaXMuZnVsbEFuZ2xlICsgZW5kQW5nbGUgLSBzdGFydEFuZ2xlIDogZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICAgIHZhciBwYXRoRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiBpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5zbGljZVNpemVzW2ldLFxuICAgICAgICAgICAgdmFsdWU6IHNlcmllc1tpXVxuICAgICAgICAgIH0pOyAvLyBhZGRpdGlvbmFsbHksIHBhc3Mgc2l6ZSBmb3IgZ3JhZGllbnQgZHJhd2luZyBpbiB0aGUgZmlsbFBhdGggZnVuY3Rpb25cblxuICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRDaGFuZ2VkUGF0aChwcmV2U3RhcnRBbmdsZSwgcHJldkVuZEFuZ2xlKTtcbiAgICAgICAgICB2YXIgZWxQYXRoID0gZ3JhcGhpY3MuZHJhd1BhdGgoe1xuICAgICAgICAgICAgZDogcGF0aCxcbiAgICAgICAgICAgIHN0cm9rZTogQXJyYXkuaXNBcnJheSh0aGlzLmxpbmVDb2xvckFycikgPyB0aGlzLmxpbmVDb2xvckFycltpXSA6IHRoaXMubGluZUNvbG9yQXJyLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgICAgICBmaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB3LmNvbmZpZy5maWxsLm9wYWNpdHksXG4gICAgICAgICAgICBjbGFzc2VzOiBcImFwZXhjaGFydHMtcGllLWFyZWEgYXBleGNoYXJ0cy1cIi5jb25jYXQodGhpcy5jaGFydFR5cGUudG9Mb3dlckNhc2UoKSwgXCItc2xpY2UtXCIpLmNvbmNhdChpKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgajogaVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZpbHRlcnMuc2V0U2VsZWN0aW9uRmlsdGVyKGVsUGF0aCwgMCwgaSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFBhdGgsIHNoYWRvdywgaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoZWxQYXRoLCB0aGlzLmRvbnV0RGF0YUxhYmVscyk7XG4gICAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXRoLm5vZGUsIHtcbiAgICAgICAgICAgICdkYXRhOmFuZ2xlJzogYW5nbGUsXG4gICAgICAgICAgICAnZGF0YTpzdGFydEFuZ2xlJzogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICdkYXRhOnN0cm9rZVdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgICdkYXRhOnZhbHVlJzogc2VyaWVzW2ldXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09ICdwaWUnIHx8IHRoaXMuY2hhcnRUeXBlID09PSAncG9sYXJBcmVhJykge1xuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiA9IFV0aWxzJDEucG9sYXJUb0NhcnRlc2lhbih0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgdy5nbG9iYWxzLnJhZGlhbFNpemUgLyAxLjI1ICsgdy5jb25maWcucGxvdE9wdGlvbnMucGllLmRhdGFMYWJlbHMub2Zmc2V0LCAoc3RhcnRBbmdsZSArIGFuZ2xlIC8gMikgJSB0aGlzLmZ1bGxBbmdsZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoYXJ0VHlwZSA9PT0gJ2RvbnV0Jykge1xuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiA9IFV0aWxzJDEucG9sYXJUb0NhcnRlc2lhbih0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgKHcuZ2xvYmFscy5yYWRpYWxTaXplICsgdGhpcy5kb251dFNpemUpIC8gMiArIHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5kYXRhTGFiZWxzLm9mZnNldCwgKHN0YXJ0QW5nbGUgKyBhbmdsZSAvIDIpICUgdGhpcy5mdWxsQW5nbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsUGllQXJjLmFkZChlbFBhdGgpOyAvLyBBbmltYXRpb24gY29kZSBzdGFydHNcblxuICAgICAgICAgIHZhciBkdXIgPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5yZXNpemVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGR1ciA9IGFuZ2xlIC8gdGhpcy5mdWxsQW5nbGUgKiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkO1xuICAgICAgICAgICAgaWYgKGR1ciA9PT0gMCkgZHVyID0gMTtcbiAgICAgICAgICAgIHRoaXMuYW5pbUR1ciA9IGR1ciArIHRoaXMuYW5pbUR1cjtcbiAgICAgICAgICAgIHRoaXMuYW5pbUJlZ2luQXJyLnB1c2godGhpcy5hbmltRHVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbmltQmVnaW5BcnIucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5keW5hbWljQW5pbSAmJiB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVBhdGhzKGVsUGF0aCwge1xuICAgICAgICAgICAgICBzaXplOiB0aGlzLnNsaWNlU2l6ZXNbaV0sXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgcHJldlN0YXJ0QW5nbGU6IHByZXZTdGFydEFuZ2xlLFxuICAgICAgICAgICAgICBwcmV2RW5kQW5nbGU6IHByZXZFbmRBbmdsZSxcbiAgICAgICAgICAgICAgYW5pbWF0ZVN0YXJ0aW5nUG9zOiB0cnVlLFxuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICBhbmltQmVnaW5BcnI6IHRoaXMuYW5pbUJlZ2luQXJyLFxuICAgICAgICAgICAgICBzaG91bGRTZXRQcmV2UGF0aHM6IHRydWUsXG4gICAgICAgICAgICAgIGR1cjogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgICAgIHNpemU6IHRoaXMuc2xpY2VTaXplc1tpXSxcbiAgICAgICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICB0b3RhbEl0ZW1zOiBzZWN0b3JBbmdsZUFyci5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICBhbmltQmVnaW5BcnI6IHRoaXMuYW5pbUJlZ2luQXJyLFxuICAgICAgICAgICAgICBkdXI6IGR1clxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBhbmltYXRpb24gY29kZSBlbmRzXG5cblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZXhwYW5kT25DbGljayAmJiB0aGlzLmNoYXJ0VHlwZSAhPT0gJ3BvbGFyQXJlYScpIHtcbiAgICAgICAgICAgIGVsUGF0aC5jbGljayh0aGlzLnBpZUNsaWNrZWQuYmluZCh0aGlzLCBpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdICE9PSAndW5kZWZpbmVkJyAmJiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdLmluZGV4T2YoaSkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5waWVDbGlja2VkKGkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5kYXRhTGFiZWxzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciB4UG9zID0gbGFiZWxQb3NpdGlvbi54O1xuICAgICAgICAgICAgdmFyIHlQb3MgPSBsYWJlbFBvc2l0aW9uLnk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IDEwMCAqIGFuZ2xlIC8gdGhpcy5mdWxsQW5nbGUgKyAnJSc7XG5cbiAgICAgICAgICAgIGlmIChhbmdsZSAhPT0gMCAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZGF0YUxhYmVscy5taW5BbmdsZVRvU2hvd0xhYmVsIDwgc2VjdG9yQW5nbGVBcnJbaV0pIHtcbiAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IHcuY29uZmlnLmRhdGFMYWJlbHMuZm9ybWF0dGVyO1xuXG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1BlcmNlbnRbaV1bMF0sIHtcbiAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGZvcmVDb2xvciA9IHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGVsUGllTGFiZWxXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtZGF0YWxhYmVsc1wiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgZWxQaWVMYWJlbCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgICAgICB4OiB4UG9zLFxuICAgICAgICAgICAgICAgIHk6IHlQb3MsXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgIGZvcmVDb2xvcjogZm9yZUNvbG9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBlbFBpZUxhYmVsV3JhcC5hZGQoZWxQaWVMYWJlbCk7XG5cbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRTaGFkb3cgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmRyb3BTaGFkb3c7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsUGllTGFiZWwsIHRleHRTaGFkb3cpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWxQaWVMYWJlbC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtcGllLWxhYmVsJyk7XG5cbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuYW5pbWF0ZSAmJiB3Lmdsb2JhbHMucmVzaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlbFBpZUxhYmVsLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1waWUtbGFiZWwtZGVsYXknKTtcbiAgICAgICAgICAgICAgICBlbFBpZUxhYmVsLm5vZGUuc3R5bGUuYW5pbWF0aW9uRGVsYXkgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkIC8gOTQwICsgJ3MnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zbGljZUxhYmVscy5wdXNoKGVsUGllTGFiZWxXcmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkTGlzdGVuZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGVsUGF0aCwgZGF0YUxhYmVscykge1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpOyAvLyBhcHBlbmQgZmlsdGVycyBvbiBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlXG5cbiAgICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcywgZWxQYXRoKSk7XG4gICAgICAgIGVsUGF0aC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBncmFwaGljcy5wYXRoTW91c2VMZWF2ZS5iaW5kKHRoaXMsIGVsUGF0aCkpO1xuICAgICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5yZXZlcnREYXRhTGFiZWxzSW5uZXIuYmluZCh0aGlzLCBlbFBhdGgubm9kZSwgZGF0YUxhYmVscykpO1xuICAgICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBncmFwaGljcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcywgZWxQYXRoKSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRvbnV0RGF0YUxhYmVscy50b3RhbC5zaG93QWx3YXlzKSB7XG4gICAgICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMucHJpbnREYXRhTGFiZWxzSW5uZXIuYmluZCh0aGlzLCBlbFBhdGgubm9kZSwgZGF0YUxhYmVscykpO1xuICAgICAgICAgIGVsUGF0aC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMucHJpbnREYXRhTGFiZWxzSW5uZXIuYmluZCh0aGlzLCBlbFBhdGgubm9kZSwgZGF0YUxhYmVscykpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yIG90aGVyIGNpcmNsZSBjaGFydHMgdG9vXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYW5pbWF0ZVBhdGhzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVBhdGhzKGVsLCBvcHRzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYW5nbGUgPSBvcHRzLmVuZEFuZ2xlIDwgb3B0cy5zdGFydEFuZ2xlID8gdGhpcy5mdWxsQW5nbGUgKyBvcHRzLmVuZEFuZ2xlIC0gb3B0cy5zdGFydEFuZ2xlIDogb3B0cy5lbmRBbmdsZSAtIG9wdHMuc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIHByZXZBbmdsZSA9IGFuZ2xlO1xuICAgICAgICB2YXIgZnJvbVN0YXJ0QW5nbGUgPSBvcHRzLnN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciB0b1N0YXJ0QW5nbGUgPSBvcHRzLnN0YXJ0QW5nbGU7XG5cbiAgICAgICAgaWYgKG9wdHMucHJldlN0YXJ0QW5nbGUgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnByZXZFbmRBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZnJvbVN0YXJ0QW5nbGUgPSBvcHRzLnByZXZFbmRBbmdsZTtcbiAgICAgICAgICBwcmV2QW5nbGUgPSBvcHRzLnByZXZFbmRBbmdsZSA8IG9wdHMucHJldlN0YXJ0QW5nbGUgPyB0aGlzLmZ1bGxBbmdsZSArIG9wdHMucHJldkVuZEFuZ2xlIC0gb3B0cy5wcmV2U3RhcnRBbmdsZSA6IG9wdHMucHJldkVuZEFuZ2xlIC0gb3B0cy5wcmV2U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmkgPT09IHcuY29uZmlnLnNlcmllcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gc29tZSBhZGp1c3RtZW50cyBmb3IgdGhlIGxhc3Qgb3ZlcmxhcHBpbmcgcGF0aHNcbiAgICAgICAgICBpZiAoYW5nbGUgKyB0b1N0YXJ0QW5nbGUgPiB0aGlzLmZ1bGxBbmdsZSkge1xuICAgICAgICAgICAgb3B0cy5lbmRBbmdsZSA9IG9wdHMuZW5kQW5nbGUgLSAoYW5nbGUgKyB0b1N0YXJ0QW5nbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYW5nbGUgKyB0b1N0YXJ0QW5nbGUgPCB0aGlzLmZ1bGxBbmdsZSkge1xuICAgICAgICAgICAgb3B0cy5lbmRBbmdsZSA9IG9wdHMuZW5kQW5nbGUgKyAodGhpcy5mdWxsQW5nbGUgLSAoYW5nbGUgKyB0b1N0YXJ0QW5nbGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5nbGUgPT09IHRoaXMuZnVsbEFuZ2xlKSBhbmdsZSA9IHRoaXMuZnVsbEFuZ2xlIC0gMC4wMTtcbiAgICAgICAgbWUuYW5pbWF0ZUFyYyhlbCwgZnJvbVN0YXJ0QW5nbGUsIHRvU3RhcnRBbmdsZSwgYW5nbGUsIHByZXZBbmdsZSwgb3B0cyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFuaW1hdGVBcmNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlQXJjKGVsLCBmcm9tU3RhcnRBbmdsZSwgdG9TdGFydEFuZ2xlLCBhbmdsZSwgcHJldkFuZ2xlLCBvcHRzKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHNpemUgPSBvcHRzLnNpemU7XG4gICAgICAgIHZhciBwYXRoO1xuXG4gICAgICAgIGlmIChpc05hTihmcm9tU3RhcnRBbmdsZSkgfHwgaXNOYU4ocHJldkFuZ2xlKSkge1xuICAgICAgICAgIGZyb21TdGFydEFuZ2xlID0gdG9TdGFydEFuZ2xlO1xuICAgICAgICAgIHByZXZBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIG9wdHMuZHVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0b1N0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBmcm9tQW5nbGUgPSBmcm9tU3RhcnRBbmdsZSA8IHRvU3RhcnRBbmdsZSA/IHRoaXMuZnVsbEFuZ2xlICsgZnJvbVN0YXJ0QW5nbGUgLSB0b1N0YXJ0QW5nbGUgOiBmcm9tU3RhcnRBbmdsZSAtIHRvU3RhcnRBbmdsZTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkICYmIG9wdHMuc2hvdWxkU2V0UHJldlBhdGhzKSB7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgZmxpY2tlciB3aGVuIHVwZGF0aW5nLCBzZXQgcHJldiBwYXRoIGZpcnN0IGFuZCB0aGVuIGFuaW1hdGUgZnJvbSB0aGVyZVxuICAgICAgICAgIGlmIChvcHRzLnByZXZFbmRBbmdsZSkge1xuICAgICAgICAgICAgcGF0aCA9IG1lLmdldFBpZVBhdGgoe1xuICAgICAgICAgICAgICBtZTogbWUsXG4gICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IG9wdHMucHJldlN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgIGFuZ2xlOiBvcHRzLnByZXZFbmRBbmdsZSA8IG9wdHMucHJldlN0YXJ0QW5nbGUgPyB0aGlzLmZ1bGxBbmdsZSArIG9wdHMucHJldkVuZEFuZ2xlIC0gb3B0cy5wcmV2U3RhcnRBbmdsZSA6IG9wdHMucHJldkVuZEFuZ2xlIC0gb3B0cy5wcmV2U3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAgICAgZDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuZHVyICE9PSAwKSB7XG4gICAgICAgICAgZWwuYW5pbWF0ZShvcHRzLmR1ciwgdy5nbG9iYWxzLmVhc2luZywgb3B0cy5hbmltQmVnaW5BcnJbb3B0cy5pXSkuYWZ0ZXJBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG1lLmNoYXJ0VHlwZSA9PT0gJ3BpZScgfHwgbWUuY2hhcnRUeXBlID09PSAnZG9udXQnIHx8IG1lLmNoYXJ0VHlwZSA9PT0gJ3BvbGFyQXJlYScpIHtcbiAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5zcGVlZCkuYXR0cih7XG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG1lLnN0cm9rZVdpZHRoXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cy5pID09PSB3LmNvbmZpZy5zZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBhbmltYXRpb25zLmFuaW1hdGlvbkNvbXBsZXRlZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuZHVyaW5nKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIGN1cnJBbmdsZSA9IGZyb21BbmdsZSArIChhbmdsZSAtIGZyb21BbmdsZSkgKiBwb3M7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmFuaW1hdGVTdGFydGluZ1Bvcykge1xuICAgICAgICAgICAgICBjdXJyQW5nbGUgPSBwcmV2QW5nbGUgKyAoYW5nbGUgLSBwcmV2QW5nbGUpICogcG9zO1xuICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gZnJvbVN0YXJ0QW5nbGUgLSBwcmV2QW5nbGUgKyAodG9TdGFydEFuZ2xlIC0gKGZyb21TdGFydEFuZ2xlIC0gcHJldkFuZ2xlKSkgKiBwb3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdGggPSBtZS5nZXRQaWVQYXRoKHtcbiAgICAgICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICBhbmdsZTogY3VyckFuZ2xlLFxuICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsLm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhOnBhdGhPcmlnJywgcGF0aCk7XG4gICAgICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAgICAgZDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IG1lLmdldFBpZVBhdGgoe1xuICAgICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghb3B0cy5pc1RyYWNrKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsLm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhOnBhdGhPcmlnJywgcGF0aCk7XG4gICAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG1lLnN0cm9rZVdpZHRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGllQ2xpY2tlZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBpZUNsaWNrZWQoaSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHZhciBzaXplID0gbWUuc2xpY2VTaXplc1tpXSArICh3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZXhwYW5kT25DbGljayA/IDQgOiAwKTtcbiAgICAgICAgdmFyIGVsUGF0aCA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KG1lLmNoYXJ0VHlwZS50b0xvd2VyQ2FzZSgpLCBcIi1zbGljZS1cIikuY29uY2F0KGkpKS5tZW1iZXJzWzBdO1xuXG4gICAgICAgIGlmIChlbFBhdGguYXR0cignZGF0YTpwaWVDbGlja2VkJykgPT09ICd0cnVlJykge1xuICAgICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICAgICdkYXRhOnBpZUNsaWNrZWQnOiAnZmFsc2UnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5yZXZlcnREYXRhTGFiZWxzSW5uZXIoZWxQYXRoLm5vZGUsIHRoaXMuZG9udXREYXRhTGFiZWxzKTtcbiAgICAgICAgICB2YXIgb3JpZ1BhdGggPSBlbFBhdGguYXR0cignZGF0YTpwYXRoT3JpZycpO1xuICAgICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICAgIGQ6IG9yaWdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlc2V0IGFsbCBlbGVtc1xuICAgICAgICAgIHZhciBhbGxFbHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhcGV4Y2hhcnRzLXBpZS1hcmVhJyk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhbGxFbHMsIGZ1bmN0aW9uIChwaWVTbGljZSkge1xuICAgICAgICAgICAgcGllU2xpY2Uuc2V0QXR0cmlidXRlKCdkYXRhOnBpZUNsaWNrZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIHZhciBvcmlnUGF0aCA9IHBpZVNsaWNlLmdldEF0dHJpYnV0ZSgnZGF0YTpwYXRoT3JpZycpO1xuXG4gICAgICAgICAgICBpZiAob3JpZ1BhdGgpIHtcbiAgICAgICAgICAgICAgcGllU2xpY2Uuc2V0QXR0cmlidXRlKCdkJywgb3JpZ1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsUGF0aC5hdHRyKCdkYXRhOnBpZUNsaWNrZWQnLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBwYXJzZUludChlbFBhdGguYXR0cignZGF0YTpzdGFydEFuZ2xlJyksIDEwKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gcGFyc2VJbnQoZWxQYXRoLmF0dHIoJ2RhdGE6YW5nbGUnKSwgMTApO1xuICAgICAgICBwYXRoID0gbWUuZ2V0UGllUGF0aCh7XG4gICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhbmdsZSA9PT0gMzYwKSByZXR1cm47XG4gICAgICAgIGVsUGF0aC5wbG90KHBhdGgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRDaGFuZ2VkUGF0aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5nZWRQYXRoKHByZXZTdGFydEFuZ2xlLCBwcmV2RW5kQW5nbGUpIHtcbiAgICAgICAgdmFyIHBhdGggPSAnJztcblxuICAgICAgICBpZiAodGhpcy5keW5hbWljQW5pbSAmJiB0aGlzLncuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICAgIHBhdGggPSB0aGlzLmdldFBpZVBhdGgoe1xuICAgICAgICAgICAgbWU6IHRoaXMsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBwcmV2U3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGFuZ2xlOiBwcmV2RW5kQW5nbGUgLSBwcmV2U3RhcnRBbmdsZSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFBpZVBhdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaWVQYXRoKF9yZWYpIHtcbiAgICAgICAgdmFyIG1lID0gX3JlZi5tZSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBhbmdsZSA9IF9yZWYuYW5nbGUsXG4gICAgICAgICAgICBzaXplID0gX3JlZi5zaXplO1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgdmFyIHN0YXJ0RGVnID0gc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIHN0YXJ0UmFkaWFucyA9IE1hdGguUEkgKiAoc3RhcnREZWcgLSA5MCkgLyAxODA7XG4gICAgICAgIHZhciBlbmREZWcgPSBhbmdsZSArIHN0YXJ0QW5nbGU7IC8vIHByZXZlbnQgb3ZlcmxhcFxuXG4gICAgICAgIGlmIChNYXRoLmNlaWwoZW5kRGVnKSA+PSB0aGlzLmZ1bGxBbmdsZSArIHRoaXMudy5jb25maWcucGxvdE9wdGlvbnMucGllLnN0YXJ0QW5nbGUgJSB0aGlzLmZ1bGxBbmdsZSkge1xuICAgICAgICAgIGVuZERlZyA9IHRoaXMuZnVsbEFuZ2xlICsgdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuc3RhcnRBbmdsZSAlIHRoaXMuZnVsbEFuZ2xlIC0gMC4wMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChNYXRoLmNlaWwoZW5kRGVnKSA+IHRoaXMuZnVsbEFuZ2xlKSBlbmREZWcgLT0gdGhpcy5mdWxsQW5nbGU7XG4gICAgICAgIHZhciBlbmRSYWRpYW5zID0gTWF0aC5QSSAqIChlbmREZWcgLSA5MCkgLyAxODA7XG4gICAgICAgIHZhciB4MSA9IG1lLmNlbnRlclggKyBzaXplICogTWF0aC5jb3Moc3RhcnRSYWRpYW5zKTtcbiAgICAgICAgdmFyIHkxID0gbWUuY2VudGVyWSArIHNpemUgKiBNYXRoLnNpbihzdGFydFJhZGlhbnMpO1xuICAgICAgICB2YXIgeDIgPSBtZS5jZW50ZXJYICsgc2l6ZSAqIE1hdGguY29zKGVuZFJhZGlhbnMpO1xuICAgICAgICB2YXIgeTIgPSBtZS5jZW50ZXJZICsgc2l6ZSAqIE1hdGguc2luKGVuZFJhZGlhbnMpO1xuICAgICAgICB2YXIgc3RhcnRJbm5lciA9IFV0aWxzJDEucG9sYXJUb0NhcnRlc2lhbihtZS5jZW50ZXJYLCBtZS5jZW50ZXJZLCBtZS5kb251dFNpemUsIGVuZERlZyk7XG4gICAgICAgIHZhciBlbmRJbm5lciA9IFV0aWxzJDEucG9sYXJUb0NhcnRlc2lhbihtZS5jZW50ZXJYLCBtZS5jZW50ZXJZLCBtZS5kb251dFNpemUsIHN0YXJ0RGVnKTtcbiAgICAgICAgdmFyIGxhcmdlQXJjID0gYW5nbGUgPiAxODAgPyAxIDogMDtcbiAgICAgICAgdmFyIHBhdGhCZWdpbm5pbmcgPSBbJ00nLCB4MSwgeTEsICdBJywgc2l6ZSwgc2l6ZSwgMCwgbGFyZ2VBcmMsIDEsIHgyLCB5Ml07XG5cbiAgICAgICAgaWYgKG1lLmNoYXJ0VHlwZSA9PT0gJ2RvbnV0Jykge1xuICAgICAgICAgIHBhdGggPSBbXS5jb25jYXQocGF0aEJlZ2lubmluZywgWydMJywgc3RhcnRJbm5lci54LCBzdGFydElubmVyLnksICdBJywgbWUuZG9udXRTaXplLCBtZS5kb251dFNpemUsIDAsIGxhcmdlQXJjLCAwLCBlbmRJbm5lci54LCBlbmRJbm5lci55LCAnTCcsIHgxLCB5MSwgJ3onXSkuam9pbignICcpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lLmNoYXJ0VHlwZSA9PT0gJ3BpZScgfHwgbWUuY2hhcnRUeXBlID09PSAncG9sYXJBcmVhJykge1xuICAgICAgICAgIHBhdGggPSBbXS5jb25jYXQocGF0aEJlZ2lubmluZywgWydMJywgbWUuY2VudGVyWCwgbWUuY2VudGVyWSwgJ0wnLCB4MSwgeTFdKS5qb2luKCcgJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IFtdLmNvbmNhdChwYXRoQmVnaW5uaW5nKS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1BvbGFyRWxlbWVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UG9sYXJFbGVtZW50cyhwYXJlbnQpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBzY2FsZSA9IG5ldyBSYW5nZSQxKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGhlbHBlcnMgPSBuZXcgQ2lyY3VsYXJDaGFydHNIZWxwZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGdDaXJjbGVzID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgICAgdmFyIGdZQXhpcyA9IGdyYXBoaWNzLmdyb3VwKCk7XG4gICAgICAgIHZhciB5U2NhbGUgPSBzY2FsZS5uaWNlU2NhbGUoMCwgTWF0aC5jZWlsKHRoaXMubWF4WSksIHcuY29uZmlnLnlheGlzWzBdLnRpY2tBbW91bnQsIDAsIHRydWUpO1xuICAgICAgICB2YXIgeVRleHRzID0geVNjYWxlLnJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBsZW4gPSB5U2NhbGUucmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5tYXhZID0geVNjYWxlLm5pY2VNYXg7XG4gICAgICAgIHZhciBjaXJjbGVTaXplID0gdy5nbG9iYWxzLnJhZGlhbFNpemU7XG4gICAgICAgIHZhciBkaWZmID0gY2lyY2xlU2l6ZSAvIChsZW4gLSAxKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBjaXJjbGUgPSBncmFwaGljcy5kcmF3Q2lyY2xlKGNpcmNsZVNpemUpO1xuICAgICAgICAgIGNpcmNsZS5hdHRyKHtcbiAgICAgICAgICAgIGN4OiB0aGlzLmNlbnRlclgsXG4gICAgICAgICAgICBjeTogdGhpcy5jZW50ZXJZLFxuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLnBsb3RPcHRpb25zLnBvbGFyQXJlYS5yaW5ncy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIHN0cm9rZTogdy5jb25maWcucGxvdE9wdGlvbnMucG9sYXJBcmVhLnJpbmdzLnN0cm9rZUNvbG9yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbMF0uc2hvdykge1xuICAgICAgICAgICAgdmFyIHlMYWJlbCA9IGhlbHBlcnMuZHJhd1lBeGlzVGV4dHModGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclkgLSBjaXJjbGVTaXplICsgcGFyc2VJbnQody5jb25maWcueWF4aXNbMF0ubGFiZWxzLnN0eWxlLmZvbnRTaXplLCAxMCkgLyAyLCBpLCB5VGV4dHNbaV0pO1xuICAgICAgICAgICAgZ1lBeGlzLmFkZCh5TGFiZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdDaXJjbGVzLmFkZChjaXJjbGUpO1xuICAgICAgICAgIGNpcmNsZVNpemUgPSBjaXJjbGVTaXplIC0gZGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd1Nwb2tlcyhwYXJlbnQpO1xuICAgICAgICBwYXJlbnQuYWRkKGdDaXJjbGVzKTtcbiAgICAgICAgcGFyZW50LmFkZChnWUF4aXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJJbm5lckRhdGFMYWJlbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJbm5lckRhdGFMYWJlbHMoZGF0YUxhYmVsc0NvbmZpZywgb3B0cykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGcgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMtZ3JvdXAnLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KG9wdHMudHJhbnNsYXRlWCA/IG9wdHMudHJhbnNsYXRlWCA6IDAsIFwiLCBcIikuY29uY2F0KG9wdHMudHJhbnNsYXRlWSA/IG9wdHMudHJhbnNsYXRlWSA6IDAsIFwiKSBzY2FsZShcIikuY29uY2F0KHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5jdXN0b21TY2FsZSwgXCIpXCIpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2hvd1RvdGFsID0gZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5zaG93O1xuICAgICAgICBnLm5vZGUuc3R5bGUub3BhY2l0eSA9IG9wdHMub3BhY2l0eTtcbiAgICAgICAgdmFyIHggPSBvcHRzLmNlbnRlclg7XG4gICAgICAgIHZhciB5ID0gb3B0cy5jZW50ZXJZO1xuICAgICAgICB2YXIgbGFiZWxDb2xvciwgdmFsdWVDb2xvcjtcblxuICAgICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5uYW1lLmNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYWJlbENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbENvbG9yID0gZGF0YUxhYmVsc0NvbmZpZy5uYW1lLmNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsRm9udFNpemUgPSBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuZm9udFNpemU7XG4gICAgICAgIHZhciBsYWJlbEZvbnRGYW1pbHkgPSBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuZm9udEZhbWlseTtcbiAgICAgICAgdmFyIGxhYmVsRm9udFdlaWdodCA9IGRhdGFMYWJlbHNDb25maWcubmFtZS5mb250V2VpZ2h0O1xuXG4gICAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLmNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZUNvbG9yID0gdy5jb25maWcuY2hhcnQuZm9yZUNvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlQ29sb3IgPSBkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLmNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxiRm9ybWF0dGVyID0gZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5mb3JtYXR0ZXI7XG4gICAgICAgIHZhciB2YWwgPSAnJztcbiAgICAgICAgdmFyIG5hbWUgPSAnJztcblxuICAgICAgICBpZiAoc2hvd1RvdGFsKSB7XG4gICAgICAgICAgbGFiZWxDb2xvciA9IGRhdGFMYWJlbHNDb25maWcudG90YWwuY29sb3I7XG4gICAgICAgICAgbGFiZWxGb250U2l6ZSA9IGRhdGFMYWJlbHNDb25maWcudG90YWwuZm9udFNpemU7XG4gICAgICAgICAgbGFiZWxGb250RmFtaWx5ID0gZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5mb250RmFtaWx5O1xuICAgICAgICAgIGxhYmVsRm9udFdlaWdodCA9IGRhdGFMYWJlbHNDb25maWcudG90YWwuZm9udFdlaWdodDtcbiAgICAgICAgICBuYW1lID0gZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5sYWJlbDtcbiAgICAgICAgICB2YWwgPSBkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLmZvcm1hdHRlcih3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnNlcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbMF0sIHcpO1xuICAgICAgICAgICAgbmFtZSA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lc1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuZm9ybWF0dGVyKG5hbWUsIGRhdGFMYWJlbHNDb25maWcudG90YWwuc2hvdywgdyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5uYW1lLnNob3cpIHtcbiAgICAgICAgICB2YXIgZWxMYWJlbCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5ICsgcGFyc2VGbG9hdChkYXRhTGFiZWxzQ29uZmlnLm5hbWUub2Zmc2V0WSksXG4gICAgICAgICAgICB0ZXh0OiBuYW1lLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICBmb3JlQ29sb3I6IGxhYmVsQ29sb3IsXG4gICAgICAgICAgICBmb250U2l6ZTogbGFiZWxGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsRm9udFdlaWdodCxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsRm9udEZhbWlseVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsTGFiZWwubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWRhdGFsYWJlbC1sYWJlbCcpO1xuICAgICAgICAgIGcuYWRkKGVsTGFiZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcudmFsdWUuc2hvdykge1xuICAgICAgICAgIHZhciB2YWxPZmZzZXQgPSBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuc2hvdyA/IHBhcnNlRmxvYXQoZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5vZmZzZXRZKSArIDE2IDogZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5vZmZzZXRZO1xuICAgICAgICAgIHZhciBlbFZhbHVlID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHkgKyB2YWxPZmZzZXQsXG4gICAgICAgICAgICB0ZXh0OiB2YWwsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogdmFsdWVDb2xvcixcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGRhdGFMYWJlbHNDb25maWcudmFsdWUuZm9udFdlaWdodCxcbiAgICAgICAgICAgIGZvbnRTaXplOiBkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLmZvbnRTaXplLFxuICAgICAgICAgICAgZm9udEZhbWlseTogZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5mb250RmFtaWx5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxWYWx1ZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZGF0YWxhYmVsLXZhbHVlJyk7XG4gICAgICAgICAgZy5hZGQoZWxWYWx1ZSk7XG4gICAgICAgIH0gLy8gZm9yIGEgbXVsdGktc2VyaWVzIGNpcmNsZSBjaGFydCwgd2UgbmVlZCB0byBzaG93IHRvdGFsIHZhbHVlIGluc3RlYWQgb2YgZmlyc3Qgc2VyaWVzIGxhYmVsc1xuXG5cbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgLSBUaGUgdmFsdWUgb2YgdGhhdCBzZXJpZXNcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbCAtIE9wdGlvbmFsIGVsIChpbmRpY2F0ZXMgd2hpY2ggc2VyaWVzIHdhcyBob3ZlcmVkL2NsaWNrZWQpLiBJZiB0aGlzIHBhcmFtIGlzIG5vdCBwcmVzZW50LCBtZWFucyB3ZSBuZWVkIHRvIHNob3cgdG90YWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInByaW50SW5uZXJMYWJlbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludElubmVyTGFiZWxzKGxhYmVsc0NvbmZpZywgbmFtZSwgdmFsLCBlbCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGxhYmVsQ29sb3I7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgaWYgKGxhYmVsc0NvbmZpZy5uYW1lLmNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhYmVsQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW3BhcnNlSW50KGVsLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdyZWwnKSwgMTApIC0gMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsQ29sb3IgPSBsYWJlbHNDb25maWcubmFtZS5jb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSAmJiBsYWJlbHNDb25maWcudG90YWwuc2hvdykge1xuICAgICAgICAgICAgbGFiZWxDb2xvciA9IGxhYmVsc0NvbmZpZy50b3RhbC5jb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxMYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWRhdGFsYWJlbC1sYWJlbCcpO1xuICAgICAgICB2YXIgZWxWYWx1ZSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWRhdGFsYWJlbC12YWx1ZScpO1xuICAgICAgICB2YXIgbGJGb3JtYXR0ZXIgPSBsYWJlbHNDb25maWcudmFsdWUuZm9ybWF0dGVyO1xuICAgICAgICB2YWwgPSBsYkZvcm1hdHRlcih2YWwsIHcpOyAvLyB3ZSBuZWVkIHRvIHNob3cgVG90YWwgVmFsIC0gc28gZ2V0IHRoZSBmb3JtYXR0ZXIgb2YgaXRcblxuICAgICAgICBpZiAoIWVsICYmIHR5cGVvZiBsYWJlbHNDb25maWcudG90YWwuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsID0gbGFiZWxzQ29uZmlnLnRvdGFsLmZvcm1hdHRlcih3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc1RvdGFsID0gbmFtZSA9PT0gbGFiZWxzQ29uZmlnLnRvdGFsLmxhYmVsO1xuICAgICAgICBuYW1lID0gbGFiZWxzQ29uZmlnLm5hbWUuZm9ybWF0dGVyKG5hbWUsIGlzVG90YWwsIHcpO1xuXG4gICAgICAgIGlmIChlbExhYmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgZWxMYWJlbC50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsVmFsdWUudGV4dENvbnRlbnQgPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxMYWJlbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsTGFiZWwuc3R5bGUuZmlsbCA9IGxhYmVsQ29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJpbnREYXRhTGFiZWxzSW5uZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludERhdGFMYWJlbHNJbm5lcihlbCwgZGF0YUxhYmVsc0NvbmZpZykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YTp2YWx1ZScpO1xuICAgICAgICB2YXIgbmFtZSA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lc1twYXJzZUludChlbC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgncmVsJyksIDEwKSAtIDFdO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLnByaW50SW5uZXJMYWJlbHMoZGF0YUxhYmVsc0NvbmZpZywgbmFtZSwgdmFsLCBlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YUxhYmVsc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVscy1ncm91cCcpO1xuXG4gICAgICAgIGlmIChkYXRhTGFiZWxzR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhTGFiZWxzR3JvdXAuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1Nwb2tlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTcG9rZXMocGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgc3Bva2VDb25maWcgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5wb2xhckFyZWEuc3Bva2VzO1xuICAgICAgICBpZiAoc3Bva2VDb25maWcuc3Ryb2tlV2lkdGggPT09IDApIHJldHVybjtcbiAgICAgICAgdmFyIHNwb2tlcyA9IFtdO1xuICAgICAgICB2YXIgYW5nbGVEaXZpc2lvbiA9IDM2MCAvIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNwb2tlcy5wdXNoKFV0aWxzJDEucG9sYXJUb0NhcnRlc2lhbih0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgdy5nbG9iYWxzLnJhZGlhbFNpemUsIHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5zdGFydEFuZ2xlICsgYW5nbGVEaXZpc2lvbiAqIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwb2tlcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBncmFwaGljcy5kcmF3TGluZShwLngsIHAueSwgX3RoaXMyLmNlbnRlclgsIF90aGlzMi5jZW50ZXJZLCBBcnJheS5pc0FycmF5KHNwb2tlQ29uZmlnLmNvbm5lY3RvckNvbG9ycykgPyBzcG9rZUNvbmZpZy5jb25uZWN0b3JDb2xvcnNbaV0gOiBzcG9rZUNvbmZpZy5jb25uZWN0b3JDb2xvcnMpO1xuICAgICAgICAgIHBhcmVudC5hZGQobGluZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXZlcnREYXRhTGFiZWxzSW5uZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnREYXRhTGFiZWxzSW5uZXIoZWxlbSwgZGF0YUxhYmVsc0NvbmZpZywgZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzR3JvdXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1kYXRhbGFiZWxzLWdyb3VwJyk7XG4gICAgICAgIHZhciBzbGljZU91dCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2xpY2VzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImFwZXhjaGFydHMtcGllLWFyZWFcIik7XG5cbiAgICAgICAgdmFyIHNlbGVjdFNsaWNlID0gZnVuY3Rpb24gc2VsZWN0U2xpY2UoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgbWFrZVNsaWNlT3V0ID0gX3JlZjIubWFrZVNsaWNlT3V0LFxuICAgICAgICAgICAgICBwcmludExhYmVsID0gX3JlZjIucHJpbnRMYWJlbDtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNsaWNlcywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLmdldEF0dHJpYnV0ZSgnZGF0YTpwaWVDbGlja2VkJykgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICBpZiAobWFrZVNsaWNlT3V0KSB7XG4gICAgICAgICAgICAgICAgc2xpY2VPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHByaW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMucHJpbnREYXRhTGFiZWxzSW5uZXIocywgZGF0YUxhYmVsc0NvbmZpZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxlY3RTbGljZSh7XG4gICAgICAgICAgbWFrZVNsaWNlT3V0OiB0cnVlLFxuICAgICAgICAgIHByaW50TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLnNob3cgJiYgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKHNsaWNlT3V0ICYmICFkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLnNob3dBbHdheXMpIHtcbiAgICAgICAgICAgIHNlbGVjdFNsaWNlKHtcbiAgICAgICAgICAgICAgbWFrZVNsaWNlT3V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgcHJpbnRMYWJlbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRJbm5lckxhYmVscyhkYXRhTGFiZWxzQ29uZmlnLCBkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLmxhYmVsLCBkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLmZvcm1hdHRlcih3KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdFNsaWNlKHtcbiAgICAgICAgICAgIG1ha2VTbGljZU91dDogZmFsc2UsXG4gICAgICAgICAgICBwcmludExhYmVsOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXNsaWNlT3V0KSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cy5sZW5ndGggJiYgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQodGhpcy5jaGFydFR5cGUudG9Mb3dlckNhc2UoKSwgXCItc2xpY2UtXCIpLmNvbmNhdChpbmRleCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnREYXRhTGFiZWxzSW5uZXIoZWwsIGRhdGFMYWJlbHNDb25maWcpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFMYWJlbHNHcm91cCAmJiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLmxlbmd0aCAmJiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRhdGFMYWJlbHNHcm91cC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGFMYWJlbHNHcm91cCAmJiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBkYXRhTGFiZWxzR3JvdXAuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGllO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgUmFkYXIgQ2xhc3MgZm9yIFNwaWRlci9SYWRhciBDaGFydHMuXG4gICAqIEBtb2R1bGUgUmFkYXJcbiAgICoqL1xuXG4gIHZhciBSYWRhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFkYXIoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkYXIpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdGhpcy5jaGFydFR5cGUgPSB0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGU7XG4gICAgICB0aGlzLmluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgICB0aGlzLmR5bmFtaWNBbmltID0gdGhpcy5pbml0aWFsQW5pbSAmJiB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkO1xuICAgICAgdGhpcy5hbmltRHVyID0gMDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmxpbmVDb2xvckFyciA9IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzICE9PSB1bmRlZmluZWQgPyB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycyA6IHcuZ2xvYmFscy5jb2xvcnM7XG4gICAgICB0aGlzLmRlZmF1bHRTaXplID0gdy5nbG9iYWxzLnN2Z0hlaWdodCA8IHcuZ2xvYmFscy5zdmdXaWR0aCA/IHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgdy5nbG9iYWxzLmdvbGRlblBhZGRpbmcgKiAxLjUgOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuICAgICAgdGhpcy5pc0xvZyA9IHcuY29uZmlnLnlheGlzWzBdLmxvZ2FyaXRobWljO1xuICAgICAgdGhpcy5jb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMubWF4VmFsdWUgPSB0aGlzLmlzTG9nID8gdGhpcy5jb3JlVXRpbHMuZ2V0TG9nVmFsKHcuZ2xvYmFscy5tYXhZLCAwKSA6IHcuZ2xvYmFscy5tYXhZO1xuICAgICAgdGhpcy5taW5WYWx1ZSA9IHRoaXMuaXNMb2cgPyB0aGlzLmNvcmVVdGlscy5nZXRMb2dWYWwodGhpcy53Lmdsb2JhbHMubWluWSwgMCkgOiB3Lmdsb2JhbHMubWluWTtcbiAgICAgIHRoaXMucG9seWdvbnMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5wb2x5Z29ucztcbiAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB3LmNvbmZpZy5zdHJva2Uuc2hvdyA/IHcuY29uZmlnLnN0cm9rZS53aWR0aCA6IDA7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLmRlZmF1bHRTaXplIC8gMi4xIC0gdGhpcy5zdHJva2VXaWR0aCAtIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuYmx1cjtcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy5zaG93KSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuc2l6ZSAtIHcuZ2xvYmFscy54QXhpc0xhYmVsc1dpZHRoIC8gMS43NTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGFyLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5zaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFSYWRpdXNPZlBlcmNlbnQgPSBbXTtcbiAgICAgIHRoaXMuZGF0YVJhZGl1cyA9IFtdO1xuICAgICAgdGhpcy5hbmdsZUFyciA9IFtdO1xuICAgICAgdGhpcy55YXhpc0xhYmVsc1RleHRzUG9zID0gW107XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFJhZGFyLCBbe1xuICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGFsbFNlcmllcyA9IFtdO1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKHRoaXMuY3R4KTtcblxuICAgICAgICBpZiAoc2VyaWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZGF0YVBvaW50c0xlbiA9IHNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNBbmdsZSA9IE1hdGguUEkgKiAyIC8gdGhpcy5kYXRhUG9pbnRzTGVuO1xuICAgICAgICB2YXIgaGFsZlcgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMjtcbiAgICAgICAgdmFyIGhhbGZIID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyO1xuICAgICAgICB2YXIgdHJhbnNsYXRlWCA9IGhhbGZXICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkYXIub2Zmc2V0WDtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBoYWxmSCArIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGFyLm9mZnNldFk7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcmFkYXItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXMnLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zbGF0ZVggfHwgMCwgXCIsIFwiKS5jb25jYXQodHJhbnNsYXRlWSB8fCAwLCBcIilcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkYXRhUG9pbnRzUG9zID0gW107XG4gICAgICAgIHZhciBlbFBvaW50c01haW4gPSBudWxsO1xuICAgICAgICB2YXIgZWxEYXRhUG9pbnRzTWFpbiA9IG51bGw7XG4gICAgICAgIHRoaXMueWF4aXNMYWJlbHMgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMnXG4gICAgICAgIH0pO1xuICAgICAgICBzZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgIHZhciBsb25nZXN0U2VyaWVzID0gcy5sZW5ndGggPT09IHcuZ2xvYmFscy5kYXRhUG9pbnRzOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICAgICAgdmFyIGVsU2VyaWVzID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoKS5hdHRyKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzXCIsXG4gICAgICAgICAgICAnZGF0YTpsb25nZXN0U2VyaWVzJzogbG9uZ2VzdFNlcmllcyxcbiAgICAgICAgICAgIHNlcmllc05hbWU6IFV0aWxzJDEuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpXSksXG4gICAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogaVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMuZGF0YVJhZGl1c09mUGVyY2VudFtpXSA9IFtdO1xuICAgICAgICAgIF90aGlzLmRhdGFSYWRpdXNbaV0gPSBbXTtcbiAgICAgICAgICBfdGhpcy5hbmdsZUFycltpXSA9IFtdO1xuICAgICAgICAgIHMuZm9yRWFjaChmdW5jdGlvbiAoZHYsIGopIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IE1hdGguYWJzKF90aGlzLm1heFZhbHVlIC0gX3RoaXMubWluVmFsdWUpO1xuICAgICAgICAgICAgZHYgPSBkdiArIE1hdGguYWJzKF90aGlzLm1pblZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKF90aGlzLmlzTG9nKSB7XG4gICAgICAgICAgICAgIGR2ID0gX3RoaXMuY29yZVV0aWxzLmdldExvZ1ZhbChkdiwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLmRhdGFSYWRpdXNPZlBlcmNlbnRbaV1bal0gPSBkdiAvIHJhbmdlO1xuICAgICAgICAgICAgX3RoaXMuZGF0YVJhZGl1c1tpXVtqXSA9IF90aGlzLmRhdGFSYWRpdXNPZlBlcmNlbnRbaV1bal0gKiBfdGhpcy5zaXplO1xuICAgICAgICAgICAgX3RoaXMuYW5nbGVBcnJbaV1bal0gPSBqICogX3RoaXMuZGlzQW5nbGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YVBvaW50c1BvcyA9IF90aGlzLmdldERhdGFQb2ludHNQb3MoX3RoaXMuZGF0YVJhZGl1c1tpXSwgX3RoaXMuYW5nbGVBcnJbaV0pO1xuXG4gICAgICAgICAgdmFyIHBhdGhzID0gX3RoaXMuY3JlYXRlUGF0aHMoZGF0YVBvaW50c1Bvcywge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9KTsgLy8gcG9pbnRzXG5cblxuICAgICAgICAgIGVsUG9pbnRzTWFpbiA9IF90aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1zZXJpZXMtbWFya2Vycy13cmFwIGFwZXhjaGFydHMtZWxlbWVudC1oaWRkZW4nXG4gICAgICAgICAgfSk7IC8vIGRhdGFwb2ludHNcblxuICAgICAgICAgIGVsRGF0YVBvaW50c01haW4gPSBfdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLWRhdGFsYWJlbHNcIixcbiAgICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB3Lmdsb2JhbHMuZGVsYXllZEVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgZWw6IGVsUG9pbnRzTWFpbi5ub2RlLFxuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcmVhbEluZGV4OiBpLFxuICAgICAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGksXG4gICAgICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgICAgICBkYXRhQ2hhbmdlU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5zcGVlZCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJhcGV4Y2hhcnRzLXJhZGFyXCIsXG4gICAgICAgICAgICBzaG91bGRDbGlwVG9HcmlkOiBmYWxzZSxcbiAgICAgICAgICAgIGJpbmRFdmVudHNPblBhdGhzOiBmYWxzZSxcbiAgICAgICAgICAgIHN0cm9rZTogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbaV0sXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiB3LmNvbmZpZy5zdHJva2UubGluZUNhcFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHBhdGhGcm9tID0gbnVsbDtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXRoRnJvbSA9IF90aGlzLmdldFByZXZpb3VzUGF0aChpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhzLmxpbmVQYXRoc1RvLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRMaW5lUGF0aCA9IF90aGlzLmdyYXBoaWNzLnJlbmRlclBhdGhzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSA9PT0gbnVsbCA/IHBhdGhzLmxpbmVQYXRoc0Zyb21bcF0gOiBwYXRoRnJvbSxcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRocy5saW5lUGF0aHNUb1twXSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IEFycmF5LmlzQXJyYXkoX3RoaXMuc3Ryb2tlV2lkdGgpID8gX3RoaXMuc3Ryb2tlV2lkdGhbaV0gOiBfdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICBkcmF3U2hhZG93OiBmYWxzZVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBlbFNlcmllcy5hZGQocmVuZGVyZWRMaW5lUGF0aCk7XG4gICAgICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiBpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHJlbmRlcmVkQXJlYVBhdGggPSBfdGhpcy5ncmFwaGljcy5yZW5kZXJQYXRocyhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20gPT09IG51bGwgPyBwYXRocy5hcmVhUGF0aHNGcm9tW3BdIDogcGF0aEZyb20sXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aHMuYXJlYVBhdGhzVG9bcF0sXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAgICAgICBmaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgICAgZHJhd1NoYWRvdzogZmFsc2VcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKF90aGlzLmN0eCk7XG4gICAgICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3cocmVuZGVyZWRBcmVhUGF0aCwgT2JqZWN0LmFzc2lnbih7fSwgc2hhZG93LCB7XG4gICAgICAgICAgICAgICAgbm9Vc2VyU3BhY2VPblVzZTogdHJ1ZVxuICAgICAgICAgICAgICB9KSwgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsU2VyaWVzLmFkZChyZW5kZXJlZEFyZWFQYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHNqLCBqKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VycyA9IG5ldyBNYXJrZXJzKF90aGlzLmN0eCk7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IG1hcmtlcnMuZ2V0TWFya2VyQ29uZmlnKHtcbiAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLW1hcmtlcicsXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogalxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IF90aGlzLmdyYXBoaWNzLmRyYXdNYXJrZXIoZGF0YVBvaW50c1Bvc1tqXS54LCBkYXRhUG9pbnRzUG9zW2pdLnksIG9wdHMpO1xuXG4gICAgICAgICAgICBwb2ludC5hdHRyKCdyZWwnLCBqKTtcbiAgICAgICAgICAgIHBvaW50LmF0dHIoJ2onLCBqKTtcbiAgICAgICAgICAgIHBvaW50LmF0dHIoJ2luZGV4JywgaSk7XG4gICAgICAgICAgICBwb2ludC5ub2RlLnNldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScsIG9wdHMucFNpemUpO1xuXG4gICAgICAgICAgICB2YXIgZWxQb2ludHNXcmFwID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGVsUG9pbnRzV3JhcCkge1xuICAgICAgICAgICAgICBlbFBvaW50c1dyYXAuYWRkKHBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxQb2ludHNNYWluLmFkZChlbFBvaW50c1dyYXApO1xuICAgICAgICAgICAgZWxTZXJpZXMuYWRkKGVsUG9pbnRzTWFpbik7XG4gICAgICAgICAgICB2YXIgZGF0YUxhYmVsc0NvbmZpZyA9IHcuY29uZmlnLmRhdGFMYWJlbHM7XG5cbiAgICAgICAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBkYXRhTGFiZWxzQ29uZmlnLmZvcm1hdHRlcih3Lmdsb2JhbHMuc2VyaWVzW2ldW2pdLCB7XG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZGF0YUxhYmVscy5wbG90RGF0YUxhYmVsc1RleHQoe1xuICAgICAgICAgICAgICAgIHg6IGRhdGFQb2ludHNQb3Nbal0ueCxcbiAgICAgICAgICAgICAgICB5OiBkYXRhUG9pbnRzUG9zW2pdLnksXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGksXG4gICAgICAgICAgICAgICAgcGFyZW50OiBlbERhdGFQb2ludHNNYWluLFxuICAgICAgICAgICAgICAgIG9mZnNldENvcnJlY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRhdGFMYWJlbHNDb25maWc6IF9vYmplY3RTcHJlYWQyKHt9LCBkYXRhTGFiZWxzQ29uZmlnKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxTZXJpZXMuYWRkKGVsRGF0YVBvaW50c01haW4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFsbFNlcmllcy5wdXNoKGVsU2VyaWVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZHJhd1BvbHlnb25zKHtcbiAgICAgICAgICBwYXJlbnQ6IHJldFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLnNob3cpIHtcbiAgICAgICAgICB2YXIgeGF4aXNUZXh0cyA9IHRoaXMuZHJhd1hBeGlzVGV4dHMoKTtcbiAgICAgICAgICByZXQuYWRkKHhheGlzVGV4dHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxsU2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVsUykge1xuICAgICAgICAgIHJldC5hZGQoZWxTKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldC5hZGQodGhpcy55YXhpc0xhYmVscyk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdQb2x5Z29uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQb2x5Z29ucyhvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcGFyZW50ID0gb3B0cy5wYXJlbnQ7XG4gICAgICAgIHZhciBoZWxwZXJzID0gbmV3IENpcmN1bGFyQ2hhcnRzSGVscGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB5YXhpc1RleHRzID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ucmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgdmFyIGxheWVycyA9IHlheGlzVGV4dHMubGVuZ3RoO1xuICAgICAgICB2YXIgcmFkaXVzU2l6ZXMgPSBbXTtcbiAgICAgICAgdmFyIGxheWVyRGlzID0gdGhpcy5zaXplIC8gKGxheWVycyAtIDEpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzOyBpKyspIHtcbiAgICAgICAgICByYWRpdXNTaXplc1tpXSA9IGxheWVyRGlzICogaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhZGl1c1NpemVzLnJldmVyc2UoKTtcbiAgICAgICAgdmFyIHBvbHlnb25TdHJpbmdzID0gW107XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICByYWRpdXNTaXplcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpdXNTaXplLCByKSB7XG4gICAgICAgICAgdmFyIHBvbHlnb24gPSBVdGlscyQxLmdldFBvbHlnb25Qb3MocmFkaXVzU2l6ZSwgX3RoaXMyLmRhdGFQb2ludHNMZW4pO1xuICAgICAgICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5lID0gX3RoaXMyLmdyYXBoaWNzLmRyYXdMaW5lKHAueCwgcC55LCAwLCAwLCBBcnJheS5pc0FycmF5KF90aGlzMi5wb2x5Z29ucy5jb25uZWN0b3JDb2xvcnMpID8gX3RoaXMyLnBvbHlnb25zLmNvbm5lY3RvckNvbG9yc1tpXSA6IF90aGlzMi5wb2x5Z29ucy5jb25uZWN0b3JDb2xvcnMpO1xuXG4gICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIF90aGlzMi55YXhpc0xhYmVsc1RleHRzUG9zLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IHAueCxcbiAgICAgICAgICAgICAgICB5OiBwLnlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0cmluZyArPSBwLnggKyAnLCcgKyBwLnkgKyAnICc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9seWdvblN0cmluZ3MucHVzaChzdHJpbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcG9seWdvblN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgIHZhciBzdHJva2VDb2xvcnMgPSBfdGhpczIucG9seWdvbnMuc3Ryb2tlQ29sb3JzO1xuICAgICAgICAgIHZhciBzdHJva2VXaWR0aCA9IF90aGlzMi5wb2x5Z29ucy5zdHJva2VXaWR0aDtcblxuICAgICAgICAgIHZhciBwb2x5Z29uID0gX3RoaXMyLmdyYXBoaWNzLmRyYXdQb2x5Z29uKHAsIEFycmF5LmlzQXJyYXkoc3Ryb2tlQ29sb3JzKSA/IHN0cm9rZUNvbG9yc1tpXSA6IHN0cm9rZUNvbG9ycywgQXJyYXkuaXNBcnJheShzdHJva2VXaWR0aCkgPyBzdHJva2VXaWR0aFtpXSA6IHN0cm9rZVdpZHRoLCB3Lmdsb2JhbHMucmFkYXJQb2x5Z29ucy5maWxsLmNvbG9yc1tpXSk7XG5cbiAgICAgICAgICBwYXJlbnQuYWRkKHBvbHlnb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICAgIHBhcmVudC5hZGQobCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS5zaG93KSB7XG4gICAgICAgICAgdGhpcy55YXhpc0xhYmVsc1RleHRzUG9zLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgIHZhciB5VGV4dCA9IGhlbHBlcnMuZHJhd1lBeGlzVGV4dHMocC54LCBwLnksIGksIHlheGlzVGV4dHNbaV0pO1xuXG4gICAgICAgICAgICBfdGhpczIueWF4aXNMYWJlbHMuYWRkKHlUZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3WEF4aXNUZXh0c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYQXhpc1RleHRzKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHhheGlzTGFiZWxzQ29uZmlnID0gdy5jb25maWcueGF4aXMubGFiZWxzO1xuICAgICAgICB2YXIgZWxYQXhpc1dyYXAgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcG9seWdvblBvcyA9IFV0aWxzJDEuZ2V0UG9seWdvblBvcyh0aGlzLnNpemUsIHRoaXMuZGF0YVBvaW50c0xlbik7XG4gICAgICAgIHcuZ2xvYmFscy5sYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwsIGkpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKF90aGlzMy5jdHgpO1xuXG4gICAgICAgICAgaWYgKHBvbHlnb25Qb3NbaV0pIHtcbiAgICAgICAgICAgIHZhciB0ZXh0UG9zID0gX3RoaXMzLmdldFRleHRQb3MocG9seWdvblBvc1tpXSwgX3RoaXMzLnNpemUpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IGZvcm1hdHRlcihsYWJlbCwge1xuICAgICAgICAgICAgICBzZXJpZXNJbmRleDogLTEsXG4gICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGFMYWJlbHMucGxvdERhdGFMYWJlbHNUZXh0KHtcbiAgICAgICAgICAgICAgeDogdGV4dFBvcy5uZXdYLFxuICAgICAgICAgICAgICB5OiB0ZXh0UG9zLm5ld1ksXG4gICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRQb3MudGV4dEFuY2hvcixcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgajogaSxcbiAgICAgICAgICAgICAgcGFyZW50OiBlbFhBeGlzV3JhcCxcbiAgICAgICAgICAgICAgY29sb3I6IEFycmF5LmlzQXJyYXkoeGF4aXNMYWJlbHNDb25maWcuc3R5bGUuY29sb3JzKSAmJiB4YXhpc0xhYmVsc0NvbmZpZy5zdHlsZS5jb2xvcnNbaV0gPyB4YXhpc0xhYmVsc0NvbmZpZy5zdHlsZS5jb2xvcnNbaV0gOiAnI2E4YThhOCcsXG4gICAgICAgICAgICAgIGRhdGFMYWJlbHNDb25maWc6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0UG9zLnRleHRBbmNob3IsXG4gICAgICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHhheGlzTGFiZWxzQ29uZmlnKSxcbiAgICAgICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbFhBeGlzV3JhcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3JlYXRlUGF0aHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQYXRocyhwb3MsIG9yaWdpbikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB2YXIgbGluZVBhdGhzVG8gPSBbXTtcbiAgICAgICAgdmFyIGxpbmVQYXRoc0Zyb20gPSBbXTtcbiAgICAgICAgdmFyIGFyZWFQYXRoc1RvID0gW107XG4gICAgICAgIHZhciBhcmVhUGF0aHNGcm9tID0gW107XG5cbiAgICAgICAgaWYgKHBvcy5sZW5ndGgpIHtcbiAgICAgICAgICBsaW5lUGF0aHNGcm9tID0gW3RoaXMuZ3JhcGhpY3MubW92ZShvcmlnaW4ueCwgb3JpZ2luLnkpXTtcbiAgICAgICAgICBhcmVhUGF0aHNGcm9tID0gW3RoaXMuZ3JhcGhpY3MubW92ZShvcmlnaW4ueCwgb3JpZ2luLnkpXTtcbiAgICAgICAgICB2YXIgbGluZVBhdGhUbyA9IHRoaXMuZ3JhcGhpY3MubW92ZShwb3NbMF0ueCwgcG9zWzBdLnkpO1xuICAgICAgICAgIHZhciBhcmVhUGF0aFRvID0gdGhpcy5ncmFwaGljcy5tb3ZlKHBvc1swXS54LCBwb3NbMF0ueSk7XG4gICAgICAgICAgcG9zLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgIGxpbmVQYXRoVG8gKz0gX3RoaXM0LmdyYXBoaWNzLmxpbmUocC54LCBwLnkpO1xuICAgICAgICAgICAgYXJlYVBhdGhUbyArPSBfdGhpczQuZ3JhcGhpY3MubGluZShwLngsIHAueSk7XG5cbiAgICAgICAgICAgIGlmIChpID09PSBwb3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBsaW5lUGF0aFRvICs9ICdaJztcbiAgICAgICAgICAgICAgYXJlYVBhdGhUbyArPSAnWic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGluZVBhdGhzVG8ucHVzaChsaW5lUGF0aFRvKTtcbiAgICAgICAgICBhcmVhUGF0aHNUby5wdXNoKGFyZWFQYXRoVG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lUGF0aHNGcm9tOiBsaW5lUGF0aHNGcm9tLFxuICAgICAgICAgIGxpbmVQYXRoc1RvOiBsaW5lUGF0aHNUbyxcbiAgICAgICAgICBhcmVhUGF0aHNGcm9tOiBhcmVhUGF0aHNGcm9tLFxuICAgICAgICAgIGFyZWFQYXRoc1RvOiBhcmVhUGF0aHNUb1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRUZXh0UG9zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFBvcyhwb3MsIHBvbHlnb25TaXplKSB7XG4gICAgICAgIHZhciBsaW1pdCA9IDEwO1xuICAgICAgICB2YXIgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICB2YXIgbmV3WCA9IHBvcy54O1xuICAgICAgICB2YXIgbmV3WSA9IHBvcy55O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhwb3MueCkgPj0gbGltaXQpIHtcbiAgICAgICAgICBpZiAocG9zLnggPiAwKSB7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIG5ld1ggKz0gMTA7XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3MueCA8IDApIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgICAgICAgIG5ld1ggLT0gMTA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChNYXRoLmFicyhwb3MueSkgPj0gcG9seWdvblNpemUgLSBsaW1pdCkge1xuICAgICAgICAgIGlmIChwb3MueSA8IDApIHtcbiAgICAgICAgICAgIG5ld1kgLT0gMTA7XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3MueSA+IDApIHtcbiAgICAgICAgICAgIG5ld1kgKz0gMTA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgIG5ld1g6IG5ld1gsXG4gICAgICAgICAgbmV3WTogbmV3WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQcmV2aW91c1BhdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcmV2aW91c1BhdGgocmVhbEluZGV4KSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgcGF0aEZyb20gPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIHBwID0gMDsgcHAgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IHBwKyspIHtcbiAgICAgICAgICB2YXIgZ3BwID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdO1xuXG4gICAgICAgICAgaWYgKGdwcC5wYXRocy5sZW5ndGggPiAwICYmIHBhcnNlSW50KGdwcC5yZWFsSW5kZXgsIDEwKSA9PT0gcGFyc2VJbnQocmVhbEluZGV4LCAxMCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBwYXRoRnJvbSA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXS5wYXRoc1swXS5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoRnJvbTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RGF0YVBvaW50c1Bvc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFQb2ludHNQb3MoZGF0YVJhZGl1c0FyciwgYW5nbGVBcnIpIHtcbiAgICAgICAgdmFyIGRhdGFQb2ludHNMZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuZGF0YVBvaW50c0xlbjtcbiAgICAgICAgZGF0YVJhZGl1c0FyciA9IGRhdGFSYWRpdXNBcnIgfHwgW107XG4gICAgICAgIGFuZ2xlQXJyID0gYW5nbGVBcnIgfHwgW107XG4gICAgICAgIHZhciBkYXRhUG9pbnRzUG9zQXJyYXkgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFQb2ludHNMZW47IGorKykge1xuICAgICAgICAgIHZhciBjdXJQb2ludFBvcyA9IHt9O1xuICAgICAgICAgIGN1clBvaW50UG9zLnggPSBkYXRhUmFkaXVzQXJyW2pdICogTWF0aC5zaW4oYW5nbGVBcnJbal0pO1xuICAgICAgICAgIGN1clBvaW50UG9zLnkgPSAtZGF0YVJhZGl1c0FycltqXSAqIE1hdGguY29zKGFuZ2xlQXJyW2pdKTtcbiAgICAgICAgICBkYXRhUG9pbnRzUG9zQXJyYXkucHVzaChjdXJQb2ludFBvcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVBvaW50c1Bvc0FycmF5O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSYWRhcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIFJhZGlhbCBDbGFzcyBmb3IgZHJhd2luZyBDaXJjbGUgLyBTZW1pIENpcmNsZSBDaGFydHMuXG4gICAqIEBtb2R1bGUgUmFkaWFsXG4gICAqKi9cblxuICB2YXIgUmFkaWFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGllKSB7XG4gICAgX2luaGVyaXRzKFJhZGlhbCwgX1BpZSk7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJhZGlhbCk7XG5cbiAgICBmdW5jdGlvbiBSYWRpYWwoY3R4KSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpYWwpO1xuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICBfdGhpcy5jdHggPSBjdHg7XG4gICAgICBfdGhpcy53ID0gY3R4Lnc7XG4gICAgICBfdGhpcy5hbmltQmVnaW5BcnIgPSBbMF07XG4gICAgICBfdGhpcy5hbmltRHVyID0gMDtcbiAgICAgIHZhciB3ID0gX3RoaXMudztcbiAgICAgIF90aGlzLnN0YXJ0QW5nbGUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuc3RhcnRBbmdsZTtcbiAgICAgIF90aGlzLmVuZEFuZ2xlID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmVuZEFuZ2xlO1xuICAgICAgX3RoaXMudG90YWxBbmdsZSA9IE1hdGguYWJzKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5lbmRBbmdsZSAtIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zdGFydEFuZ2xlKTtcbiAgICAgIF90aGlzLnRyYWNrU3RhcnRBbmdsZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci50cmFjay5zdGFydEFuZ2xlO1xuICAgICAgX3RoaXMudHJhY2tFbmRBbmdsZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci50cmFjay5lbmRBbmdsZTtcbiAgICAgIF90aGlzLmRvbnV0RGF0YUxhYmVscyA9IF90aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5kYXRhTGFiZWxzO1xuICAgICAgX3RoaXMucmFkaWFsRGF0YUxhYmVscyA9IF90aGlzLmRvbnV0RGF0YUxhYmVsczsgLy8gbWFrZSBhIGNvcHkgZm9yIGVhc3kgcmVmZXJlbmNlXG5cbiAgICAgIGlmICghX3RoaXMudHJhY2tTdGFydEFuZ2xlKSBfdGhpcy50cmFja1N0YXJ0QW5nbGUgPSBfdGhpcy5zdGFydEFuZ2xlO1xuICAgICAgaWYgKCFfdGhpcy50cmFja0VuZEFuZ2xlKSBfdGhpcy50cmFja0VuZEFuZ2xlID0gX3RoaXMuZW5kQW5nbGU7XG4gICAgICBpZiAoX3RoaXMuZW5kQW5nbGUgPT09IDM2MCkgX3RoaXMuZW5kQW5nbGUgPSAzNTkuOTk7XG4gICAgICBfdGhpcy5tYXJnaW4gPSBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2subWFyZ2luLCAxMCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFJhZGlhbCwgW3tcbiAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhcidcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMubm9EYXRhKSByZXR1cm4gcmV0O1xuICAgICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCgpO1xuICAgICAgICB2YXIgY2VudGVyWSA9IHRoaXMuZGVmYXVsdFNpemUgLyAyO1xuICAgICAgICB2YXIgY2VudGVyWCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZGVmYXVsdFNpemUgLyAyLjA1O1xuXG4gICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQpIHtcbiAgICAgICAgICBzaXplID0gc2l6ZSAtIHcuY29uZmlnLnN0cm9rZS53aWR0aCAtIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuYmx1cjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xvckFyciA9IHcuZ2xvYmFscy5maWxsLmNvbG9ycztcblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnRyYWNrLnNob3cpIHtcbiAgICAgICAgICB2YXIgZWxUcmFja3MgPSB0aGlzLmRyYXdUcmFja3Moe1xuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIGNlbnRlclg6IGNlbnRlclgsXG4gICAgICAgICAgICBjZW50ZXJZOiBjZW50ZXJZLFxuICAgICAgICAgICAgY29sb3JBcnI6IGNvbG9yQXJyLFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFNlcmllcy5hZGQoZWxUcmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsRyA9IHRoaXMuZHJhd0FyY3Moe1xuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgY2VudGVyWDogY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZOiBjZW50ZXJZLFxuICAgICAgICAgIGNvbG9yQXJyOiBjb2xvckFycixcbiAgICAgICAgICBzZXJpZXM6IHNlcmllc1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRvdGFsQW5nbGUgPSAzNjA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zdGFydEFuZ2xlIDwgMCkge1xuICAgICAgICAgIHRvdGFsQW5nbGUgPSB0aGlzLnRvdGFsQW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5nbGVSYXRpbyA9ICgzNjAgLSB0b3RhbEFuZ2xlKSAvIDM2MDtcbiAgICAgICAgdy5nbG9iYWxzLnJhZGlhbFNpemUgPSBzaXplIC0gc2l6ZSAqIGFuZ2xlUmF0aW87XG5cbiAgICAgICAgaWYgKHRoaXMucmFkaWFsRGF0YUxhYmVscy52YWx1ZS5zaG93KSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KHRoaXMucmFkaWFsRGF0YUxhYmVscy52YWx1ZS5vZmZzZXRZLCB0aGlzLnJhZGlhbERhdGFMYWJlbHMubmFtZS5vZmZzZXRZKTtcbiAgICAgICAgICB3Lmdsb2JhbHMucmFkaWFsU2l6ZSArPSBvZmZzZXQgKiBhbmdsZVJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxTZXJpZXMuYWRkKGVsRy5nKTtcblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgIGVsRy5nLmFkZChlbEcuZWxIb2xsb3cpO1xuXG4gICAgICAgICAgaWYgKGVsRy5kYXRhTGFiZWxzKSB7XG4gICAgICAgICAgICBlbEcuZy5hZGQoZWxHLmRhdGFMYWJlbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3VHJhY2tzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RyYWNrcyhvcHRzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgZyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtdHJhY2tzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBmaWxsID0gbmV3IEZpbGwodGhpcy5jdHgpO1xuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKG9wdHMpO1xuICAgICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAvIDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbFJhZGlhbEJhclRyYWNrID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci10cmFjayBhcGV4Y2hhcnRzLXRyYWNrJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGcuYWRkKGVsUmFkaWFsQmFyVHJhY2spO1xuICAgICAgICAgIGVsUmFkaWFsQmFyVHJhY2suYXR0cih7XG4gICAgICAgICAgICByZWw6IGkgKyAxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3B0cy5zaXplID0gb3B0cy5zaXplIC0gc3Ryb2tlV2lkdGggLSB0aGlzLm1hcmdpbjtcbiAgICAgICAgICB2YXIgdHJhY2tDb25maWcgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2s7XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IDAsXG4gICAgICAgICAgICBzaXplOiBvcHRzLnNpemUsXG4gICAgICAgICAgICBmaWxsQ29sb3JzOiBBcnJheS5pc0FycmF5KHRyYWNrQ29uZmlnLmJhY2tncm91bmQpID8gdHJhY2tDb25maWcuYmFja2dyb3VuZFtpXSA6IHRyYWNrQ29uZmlnLmJhY2tncm91bmQsXG4gICAgICAgICAgICBzb2xpZDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gdGhpcy50cmFja1N0YXJ0QW5nbGU7XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhpcy50cmFja0VuZEFuZ2xlO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSkgKyBNYXRoLmFicyhzdGFydEFuZ2xlKSA+PSAzNjApIGVuZEFuZ2xlID0gMzYwIC0gTWF0aC5hYnModGhpcy5zdGFydEFuZ2xlKSAtIDAuMTtcbiAgICAgICAgICB2YXIgZWxQYXRoID0gZ3JhcGhpY3MuZHJhd1BhdGgoe1xuICAgICAgICAgICAgZDogJycsXG4gICAgICAgICAgICBzdHJva2U6IHBhdGhGaWxsLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoICogcGFyc2VJbnQodHJhY2tDb25maWcuc3Ryb2tlV2lkdGgsIDEwKSAvIDEwMCxcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRyYWNrQ29uZmlnLm9wYWNpdHksXG4gICAgICAgICAgICBjbGFzc2VzOiAnYXBleGNoYXJ0cy1yYWRpYWxiYXItYXJlYSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0cmFja0NvbmZpZy5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBzaGFkb3cgPSB0cmFja0NvbmZpZy5kcm9wU2hhZG93O1xuICAgICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsUGF0aCwgc2hhZG93KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbFJhZGlhbEJhclRyYWNrLmFkZChlbFBhdGgpO1xuICAgICAgICAgIGVsUGF0aC5hdHRyKCdpZCcsICdhcGV4Y2hhcnRzLXJhZGlhbGJhclRyYWNrLScgKyBpKTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGVQYXRocyhlbFBhdGgsIHtcbiAgICAgICAgICAgIGNlbnRlclg6IG9wdHMuY2VudGVyWCxcbiAgICAgICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBzaXplOiBvcHRzLnNpemUsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgdG90YWxJdGVtczogMixcbiAgICAgICAgICAgIGFuaW1CZWdpbkFycjogMCxcbiAgICAgICAgICAgIGR1cjogMCxcbiAgICAgICAgICAgIGlzVHJhY2s6IHRydWUsXG4gICAgICAgICAgICBlYXNpbmc6IHcuZ2xvYmFscy5lYXNpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3QXJjc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBcmNzKG9wdHMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIHNpemUsIGRvbnV0U2l6ZSwgY2VudGVyWCwgY2VudGVyWSwgY29sb3JBcnIsIGxpbmVDb2xvckFyciwgc2VjdG9yQW5nbGVBcnIsIHNlcmllc1xuXG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBmaWxsID0gbmV3IEZpbGwodGhpcy5jdHgpO1xuICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGcgPSBncmFwaGljcy5ncm91cCgpO1xuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKG9wdHMpO1xuICAgICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIHZhciBob2xsb3dGaWxsSUQgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmJhY2tncm91bmQ7XG4gICAgICAgIHZhciBob2xsb3dTaXplID0gb3B0cy5zaXplIC0gc3Ryb2tlV2lkdGggKiBvcHRzLnNlcmllcy5sZW5ndGggLSB0aGlzLm1hcmdpbiAqIG9wdHMuc2VyaWVzLmxlbmd0aCAtIHN0cm9rZVdpZHRoICogcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnRyYWNrLnN0cm9rZVdpZHRoLCAxMCkgLyAxMDAgLyAyO1xuICAgICAgICB2YXIgaG9sbG93UmFkaXVzID0gaG9sbG93U2l6ZSAtIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cubWFyZ2luO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBob2xsb3dGaWxsSUQgPSB0aGlzLmRyYXdIb2xsb3dJbWFnZShvcHRzLCBnLCBob2xsb3dTaXplLCBob2xsb3dGaWxsSUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsSG9sbG93ID0gdGhpcy5kcmF3SG9sbG93KHtcbiAgICAgICAgICBzaXplOiBob2xsb3dSYWRpdXMsXG4gICAgICAgICAgY2VudGVyWDogb3B0cy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgICBmaWxsOiBob2xsb3dGaWxsSUQgPyBob2xsb3dGaWxsSUQgOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmRyb3BTaGFkb3c7XG4gICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsSG9sbG93LCBzaGFkb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3duID0gMTtcblxuICAgICAgICBpZiAoIXRoaXMucmFkaWFsRGF0YUxhYmVscy50b3RhbC5zaG93ICYmIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHNob3duID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhTGFiZWxzID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5yYWRpYWxEYXRhTGFiZWxzLnNob3cpIHtcbiAgICAgICAgICBkYXRhTGFiZWxzID0gdGhpcy5yZW5kZXJJbm5lckRhdGFMYWJlbHModGhpcy5yYWRpYWxEYXRhTGFiZWxzLCB7XG4gICAgICAgICAgICBob2xsb3dTaXplOiBob2xsb3dTaXplLFxuICAgICAgICAgICAgY2VudGVyWDogb3B0cy5jZW50ZXJYLFxuICAgICAgICAgICAgY2VudGVyWTogb3B0cy5jZW50ZXJZLFxuICAgICAgICAgICAgb3BhY2l0eTogc2hvd25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LnBvc2l0aW9uID09PSAnYmFjaycpIHtcbiAgICAgICAgICBnLmFkZChlbEhvbGxvdyk7XG5cbiAgICAgICAgICBpZiAoZGF0YUxhYmVscykge1xuICAgICAgICAgICAgZy5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldmVyc2VMb29wID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5pbnZlcnNlT3JkZXIpIHtcbiAgICAgICAgICByZXZlcnNlTG9vcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gcmV2ZXJzZUxvb3AgPyBvcHRzLnNlcmllcy5sZW5ndGggLSAxIDogMDsgcmV2ZXJzZUxvb3AgPyBpID49IDAgOiBpIDwgb3B0cy5zZXJpZXMubGVuZ3RoOyByZXZlcnNlTG9vcCA/IGktLSA6IGkrKykge1xuICAgICAgICAgIHZhciBlbFJhZGlhbEJhckFyYyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtcmFkaWFsLXNlcmllc1wiLFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogVXRpbHMkMS5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW2ldKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGcuYWRkKGVsUmFkaWFsQmFyQXJjKTtcbiAgICAgICAgICBlbFJhZGlhbEJhckFyYy5hdHRyKHtcbiAgICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxSYWRpYWxCYXJBcmMsIGkpO1xuICAgICAgICAgIG9wdHMuc2l6ZSA9IG9wdHMuc2l6ZSAtIHN0cm9rZVdpZHRoIC0gdGhpcy5tYXJnaW47XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IGksXG4gICAgICAgICAgICBzaXplOiBvcHRzLnNpemUsXG4gICAgICAgICAgICB2YWx1ZTogb3B0cy5zZXJpZXNbaV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgICB2YXIgcHJldlN0YXJ0QW5nbGUgPSB2b2lkIDA7IC8vIGlmIGRhdGEgZXhjZWVkcyAxMDAsIG1ha2UgaXQgMTAwXG5cbiAgICAgICAgICB2YXIgZGF0YVZhbHVlID0gVXRpbHMkMS5uZWdUb1plcm8ob3B0cy5zZXJpZXNbaV0gPiAxMDAgPyAxMDAgOiBvcHRzLnNlcmllc1tpXSkgLyAxMDA7XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gTWF0aC5yb3VuZCh0aGlzLnRvdGFsQW5nbGUgKiBkYXRhVmFsdWUpICsgdGhpcy5zdGFydEFuZ2xlO1xuICAgICAgICAgIHZhciBwcmV2RW5kQW5nbGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICBwcmV2U3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHByZXZFbmRBbmdsZSA9IE1hdGgucm91bmQodGhpcy50b3RhbEFuZ2xlICogVXRpbHMkMS5uZWdUb1plcm8ody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV0pIC8gMTAwKSArIHByZXZTdGFydEFuZ2xlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXJyRnVsbEFuZ2xlID0gTWF0aC5hYnMoZW5kQW5nbGUpICsgTWF0aC5hYnMoc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICBpZiAoY3VyckZ1bGxBbmdsZSA+PSAzNjApIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgLSAwLjAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcmV2RnVsbEFuZ2xlID0gTWF0aC5hYnMocHJldkVuZEFuZ2xlKSArIE1hdGguYWJzKHByZXZTdGFydEFuZ2xlKTtcblxuICAgICAgICAgIGlmIChwcmV2RnVsbEFuZ2xlID49IDM2MCkge1xuICAgICAgICAgICAgcHJldkVuZEFuZ2xlID0gcHJldkVuZEFuZ2xlIC0gMC4wMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYW5nbGUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgICAgICAgdmFyIGRhc2hBcnJheSA9IEFycmF5LmlzQXJyYXkody5jb25maWcuc3Ryb2tlLmRhc2hBcnJheSkgPyB3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5W2ldIDogdy5jb25maWcuc3Ryb2tlLmRhc2hBcnJheTtcbiAgICAgICAgICB2YXIgZWxQYXRoID0gZ3JhcGhpY3MuZHJhd1BhdGgoe1xuICAgICAgICAgICAgZDogJycsXG4gICAgICAgICAgICBzdHJva2U6IHBhdGhGaWxsLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHcuY29uZmlnLmZpbGwub3BhY2l0eSxcbiAgICAgICAgICAgIGNsYXNzZXM6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1hcmVhIGFwZXhjaGFydHMtcmFkaWFsYmFyLXNsaWNlLScgKyBpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiBkYXNoQXJyYXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbFBhdGgubm9kZSwge1xuICAgICAgICAgICAgJ2RhdGE6YW5nbGUnOiBhbmdsZSxcbiAgICAgICAgICAgICdkYXRhOnZhbHVlJzogb3B0cy5zZXJpZXNbaV1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBfc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFBhdGgsIF9zaGFkb3csIGkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbHRlcnMuc2V0U2VsZWN0aW9uRmlsdGVyKGVsUGF0aCwgMCwgaSk7XG4gICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoZWxQYXRoLCB0aGlzLnJhZGlhbERhdGFMYWJlbHMpO1xuICAgICAgICAgIGVsUmFkaWFsQmFyQXJjLmFkZChlbFBhdGgpO1xuICAgICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgajogaVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBkdXIgPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5yZXNpemVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGR1ciA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICAgICAgZHVyID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYW5pbUR1ciA9IGR1ciAvIChvcHRzLnNlcmllcy5sZW5ndGggKiAxLjIpICsgdGhpcy5hbmltRHVyO1xuICAgICAgICAgIHRoaXMuYW5pbUJlZ2luQXJyLnB1c2godGhpcy5hbmltRHVyKTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGVQYXRocyhlbFBhdGgsIHtcbiAgICAgICAgICAgIGNlbnRlclg6IG9wdHMuY2VudGVyWCxcbiAgICAgICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBwcmV2RW5kQW5nbGU6IHByZXZFbmRBbmdsZSxcbiAgICAgICAgICAgIHByZXZTdGFydEFuZ2xlOiBwcmV2U3RhcnRBbmdsZSxcbiAgICAgICAgICAgIHNpemU6IG9wdHMuc2l6ZSxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICB0b3RhbEl0ZW1zOiAyLFxuICAgICAgICAgICAgYW5pbUJlZ2luQXJyOiB0aGlzLmFuaW1CZWdpbkFycixcbiAgICAgICAgICAgIGR1cjogZHVyLFxuICAgICAgICAgICAgc2hvdWxkU2V0UHJldlBhdGhzOiB0cnVlLFxuICAgICAgICAgICAgZWFzaW5nOiB3Lmdsb2JhbHMuZWFzaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgZWxIb2xsb3c6IGVsSG9sbG93LFxuICAgICAgICAgIGRhdGFMYWJlbHM6IGRhdGFMYWJlbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0hvbGxvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdIb2xsb3cob3B0cykge1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgY2lyY2xlID0gZ3JhcGhpY3MuZHJhd0NpcmNsZShvcHRzLnNpemUgKiAyKTtcbiAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1yYWRpYWxiYXItaG9sbG93JyxcbiAgICAgICAgICBjeDogb3B0cy5jZW50ZXJYLFxuICAgICAgICAgIGN5OiBvcHRzLmNlbnRlclksXG4gICAgICAgICAgcjogb3B0cy5zaXplLFxuICAgICAgICAgIGZpbGw6IG9wdHMuZmlsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0hvbGxvd0ltYWdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0hvbGxvd0ltYWdlKG9wdHMsIGcsIGhvbGxvd1NpemUsIGhvbGxvd0ZpbGxJRCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICAgIHZhciByYW5kSUQgPSBVdGlscyQxLnJhbmRvbUlkKCk7XG4gICAgICAgIHZhciBob2xsb3dGaWxsSW1nID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZTtcblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZUNsaXBwZWQpIHtcbiAgICAgICAgICBmaWxsLmNsaXBwZWRJbWdBcmVhKHtcbiAgICAgICAgICAgIHdpZHRoOiBob2xsb3dTaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBob2xsb3dTaXplLFxuICAgICAgICAgICAgaW1hZ2U6IGhvbGxvd0ZpbGxJbWcsXG4gICAgICAgICAgICBwYXR0ZXJuSUQ6IFwicGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KHJhbmRJRClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBob2xsb3dGaWxsSUQgPSBcInVybCgjcGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KHJhbmRJRCwgXCIpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbWdXaWR0aCA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2VXaWR0aDtcbiAgICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZUhlaWdodDtcblxuICAgICAgICAgIGlmIChpbWdXaWR0aCA9PT0gdW5kZWZpbmVkICYmIGltZ0hlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmltYWdlKGhvbGxvd0ZpbGxJbWcpLmxvYWRlZChmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMubW92ZShvcHRzLmNlbnRlclggLSBsb2FkZXIud2lkdGggLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFgsIG9wdHMuY2VudGVyWSAtIGxvYWRlci5oZWlnaHQgLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnLmFkZChpbWFnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfaW1hZ2UgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmltYWdlKGhvbGxvd0ZpbGxJbWcpLmxvYWRlZChmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMubW92ZShvcHRzLmNlbnRlclggLSBpbWdXaWR0aCAvIDIgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlT2Zmc2V0WCwgb3B0cy5jZW50ZXJZIC0gaW1nSGVpZ2h0IC8gMiArIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2VPZmZzZXRZKTtcbiAgICAgICAgICAgICAgdGhpcy5zaXplKGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGcuYWRkKF9pbWFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhvbGxvd0ZpbGxJRDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U3Ryb2tlV2lkdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHJva2VXaWR0aChvcHRzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICByZXR1cm4gb3B0cy5zaXplICogKDEwMCAtIHBhcnNlSW50KHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuc2l6ZSwgMTApKSAvIDEwMCAvIChvcHRzLnNlcmllcy5sZW5ndGggKyAxKSAtIHRoaXMubWFyZ2luO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSYWRpYWw7XG4gIH0oUGllKTtcblxuICAvKipcbiAgICogQXBleENoYXJ0cyBSYW5nZUJhciBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBSYW5nZS9UaW1lbGluZSBCYXJzLlxuICAgKlxuICAgKiBAbW9kdWxlIFJhbmdlQmFyXG4gICAqKi9cblxuICB2YXIgUmFuZ2VCYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXIpIHtcbiAgICBfaW5oZXJpdHMoUmFuZ2VCYXIsIF9CYXIpO1xuXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSYW5nZUJhcik7XG5cbiAgICBmdW5jdGlvbiBSYW5nZUJhcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZUJhcik7XG5cbiAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUmFuZ2VCYXIsIFt7XG4gICAgICBrZXk6IFwiZHJhd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5yYW5nZUJhck9wdGlvbnMgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLnJhbmdlQmFyO1xuICAgICAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy5zZXJpZXNSYW5nZVN0YXJ0ID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlU3RhcnQ7XG4gICAgICAgIHRoaXMuc2VyaWVzUmFuZ2VFbmQgPSB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VFbmQ7XG4gICAgICAgIHRoaXMuYmFySGVscGVycy5pbml0VmFyaWFibGVzKHNlcmllcyk7XG4gICAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhbmdlYmFyLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzJ1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgICB5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICB4RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAgIC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG4gICAgICAgICAgeURpdmlzaW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgICAvLyB5RGl2aXNpb24gaXMgdGhlIEdSSURIRUlHSFQgZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoYmFycylcbiAgICAgICAgICB6ZXJvSCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgLy8gemVyb0ggaXMgdGhlIGJhc2VsaW5lIHdoZXJlIDAgbWVldHMgeSBheGlzXG4gICAgICAgICAgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgICAgdmFyIHJlYWxJbmRleCA9IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyA/IHNlcmllc0luZGV4W2ldIDogaTsgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cblxuICAgICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzXCIsXG4gICAgICAgICAgICBzZXJpZXNOYW1lOiBVdGlscyQxLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbcmVhbEluZGV4XSksXG4gICAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxTZXJpZXMsIHJlYWxJbmRleCk7XG5cbiAgICAgICAgICBpZiAoc2VyaWVzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUkgPSB0aGlzLnZpc2libGVJICsgMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMueVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMueWF4aXNJbmRleCA9IHJlYWxJbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5pdFBvc2l0aW9ucyA9IHRoaXMuYmFySGVscGVycy5pbml0aWFsUG9zaXRpb25zKCk7XG4gICAgICAgICAgeSA9IGluaXRQb3NpdGlvbnMueTtcbiAgICAgICAgICB6ZXJvVyA9IGluaXRQb3NpdGlvbnMuemVyb1c7XG4gICAgICAgICAgeCA9IGluaXRQb3NpdGlvbnMueDtcbiAgICAgICAgICBiYXJXaWR0aCA9IGluaXRQb3NpdGlvbnMuYmFyV2lkdGg7XG4gICAgICAgICAgYmFySGVpZ2h0ID0gaW5pdFBvc2l0aW9ucy5iYXJIZWlnaHQ7XG4gICAgICAgICAgeERpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy54RGl2aXNpb247XG4gICAgICAgICAgeURpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy55RGl2aXNpb247XG4gICAgICAgICAgemVyb0ggPSBpbml0UG9zaXRpb25zLnplcm9IOyAvLyBlbGRhdGFsYWJlbHNcblxuICAgICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMnLFxuICAgICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGVsR29hbHNNYXJrZXJzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhbmdlYmFyLWdvYWxzLW1hcmtlcnMnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHcuZ2xvYmFscy5kYXRhUG9pbnRzOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRyZW5kZXJTZXJpZXM7XG5cbiAgICAgICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuYmFySGVscGVycy5nZXRTdHJva2VXaWR0aChpLCBqLCByZWFsSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHkxID0gdGhpcy5zZXJpZXNSYW5nZVN0YXJ0W2ldW2pdO1xuICAgICAgICAgICAgdmFyIHkyID0gdGhpcy5zZXJpZXNSYW5nZUVuZFtpXVtqXTtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgYmFyWFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBiYXJZUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2VyaWVzTGVuID0gdGhpcy5zZXJpZXNMZW47XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIucmFuZ2VCYXJHcm91cFJvd3MpIHtcbiAgICAgICAgICAgICAgc2VyaWVzTGVuID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gbm8gZGF0YSBleGlzdHMgZm9yIGZ1cnRoZXIgaW5kZXhlcywgaGVuY2Ugd2UgbmVlZCB0byBnZXQgb3V0IHRoZSBpbm5yIGxvb3AuXG4gICAgICAgICAgICAgIC8vIEFzIHdlIGFyZSBpdGVyYXRpbmcgb3ZlciB0b3RhbCBkYXRhcG9pbnRzLCB0aGVyZSBpcyBhIHBvc3NpYmxpdHkgdGhlIHNlcmllcyBtaWdodCBub3QgaGF2ZSBkYXRhIGZvciBqIGluZGV4XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgYmFyWVBvc2l0aW9uID0geSArIGJhckhlaWdodCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICAgICAgICAgIHZhciBzcnR5ID0gKHlEaXZpc2lvbiAtIGJhckhlaWdodCAqIHNlcmllc0xlbikgLyAyO1xuXG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXS54KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuZGV0ZWN0T3ZlcmxhcHBpbmdCYXJzKHtcbiAgICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgICAgYmFyWVBvc2l0aW9uOiBiYXJZUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBzcnR5OiBzcnR5LFxuICAgICAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICB5RGl2aXNpb246IHlEaXZpc2lvbixcbiAgICAgICAgICAgICAgICAgIGluaXRQb3NpdGlvbnM6IGluaXRQb3NpdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYXJIZWlnaHQgPSBwb3NpdGlvbnMuYmFySGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJhcllQb3NpdGlvbiA9IHBvc2l0aW9ucy5iYXJZUG9zaXRpb247XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwYXRocyA9IHRoaXMuZHJhd1JhbmdlQmFyUGF0aHMoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHplcm9XOiB6ZXJvVyxcbiAgICAgICAgICAgICAgICB5RGl2aXNpb246IHlEaXZpc2lvbixcbiAgICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgICBiYXJXaWR0aCA9IHBhdGhzLmJhcldpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgICAgICAgeCA9ICh3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMueFJhdGlvIC0gYmFyV2lkdGggLyAyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYmFyWFBvc2l0aW9uID0geCArIGJhcldpZHRoICogdGhpcy52aXNpYmxlSTtcbiAgICAgICAgICAgICAgdmFyIHNydHggPSAoeERpdmlzaW9uIC0gYmFyV2lkdGggKiBzZXJpZXNMZW4pIC8gMjtcblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0ueCkge1xuICAgICAgICAgICAgICAgIHZhciBfcG9zaXRpb25zID0gdGhpcy5kZXRlY3RPdmVybGFwcGluZ0JhcnMoe1xuICAgICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgICBiYXJYUG9zaXRpb246IGJhclhQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIHNydHg6IHNydHgsXG4gICAgICAgICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgICAgICAgIGluaXRQb3NpdGlvbnM6IGluaXRQb3NpdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJhcldpZHRoID0gX3Bvc2l0aW9ucy5iYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBiYXJYUG9zaXRpb24gPSBfcG9zaXRpb25zLmJhclhQb3NpdGlvbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBhdGhzID0gdGhpcy5kcmF3UmFuZ2VDb2x1bW5QYXRocyhfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHplcm9IOiB6ZXJvSCxcbiAgICAgICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvblxuICAgICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgICAgYmFySGVpZ2h0ID0gcGF0aHMuYmFySGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmFyR29hbExpbmUgPSB0aGlzLmJhckhlbHBlcnMuZHJhd0dvYWxMaW5lKHtcbiAgICAgICAgICAgICAgYmFyWFBvc2l0aW9uOiBwYXRocy5iYXJYUG9zaXRpb24sXG4gICAgICAgICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uLFxuICAgICAgICAgICAgICBnb2FsWDogcGF0aHMuZ29hbFgsXG4gICAgICAgICAgICAgIGdvYWxZOiBwYXRocy5nb2FsWSxcbiAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChiYXJHb2FsTGluZSkge1xuICAgICAgICAgICAgICBlbEdvYWxzTWFya2Vycy5hZGQoYmFyR29hbExpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5ID0gcGF0aHMueTtcbiAgICAgICAgICAgIHggPSBwYXRocy54O1xuICAgICAgICAgICAgdmFyIHBhdGhGaWxsID0gdGhpcy5iYXJIZWxwZXJzLmdldFBhdGhGaWxsQ29sb3Ioc2VyaWVzLCBpLCBqLCByZWFsSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGxpbmVGaWxsID0gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbcmVhbEluZGV4XTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VyaWVzKChfdGhpcyRyZW5kZXJTZXJpZXMgPSB7XG4gICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICBwYXRoRmlsbDogcGF0aEZpbGwsXG4gICAgICAgICAgICAgIGxpbmVGaWxsOiBsaW5lRmlsbCxcbiAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRocy5wYXRoRnJvbSxcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRocy5wYXRoVG8sXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzLFxuICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgYmFyWFBvc2l0aW9uOiBiYXJYUG9zaXRpb24sXG4gICAgICAgICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uXG4gICAgICAgICAgICB9LCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkcmVuZGVyU2VyaWVzLCBcImJhcldpZHRoXCIsIGJhcldpZHRoKSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHJlbmRlclNlcmllcywgXCJlbERhdGFMYWJlbHNXcmFwXCIsIGVsRGF0YUxhYmVsc1dyYXApLCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkcmVuZGVyU2VyaWVzLCBcImVsR29hbHNNYXJrZXJzXCIsIGVsR29hbHNNYXJrZXJzKSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHJlbmRlclNlcmllcywgXCJ2aXNpYmxlU2VyaWVzXCIsIHRoaXMudmlzaWJsZUkpLCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkcmVuZGVyU2VyaWVzLCBcInR5cGVcIiwgJ3JhbmdlYmFyJyksIF90aGlzJHJlbmRlclNlcmllcykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGV0ZWN0T3ZlcmxhcHBpbmdCYXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZWN0T3ZlcmxhcHBpbmdCYXJzKF9yZWYpIHtcbiAgICAgICAgdmFyIGkgPSBfcmVmLmksXG4gICAgICAgICAgICBqID0gX3JlZi5qLFxuICAgICAgICAgICAgYmFyWVBvc2l0aW9uID0gX3JlZi5iYXJZUG9zaXRpb24sXG4gICAgICAgICAgICBiYXJYUG9zaXRpb24gPSBfcmVmLmJhclhQb3NpdGlvbixcbiAgICAgICAgICAgIHNydHkgPSBfcmVmLnNydHksXG4gICAgICAgICAgICBzcnR4ID0gX3JlZi5zcnR4LFxuICAgICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZi5iYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aCA9IF9yZWYuYmFyV2lkdGgsXG4gICAgICAgICAgICB5RGl2aXNpb24gPSBfcmVmLnlEaXZpc2lvbixcbiAgICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYueERpdmlzaW9uLFxuICAgICAgICAgICAgaW5pdFBvc2l0aW9ucyA9IF9yZWYuaW5pdFBvc2l0aW9ucztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBvdmVybGFwcyA9IFtdO1xuICAgICAgICB2YXIgcmFuZ2VOYW1lID0gdy5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0ucmFuZ2VOYW1lO1xuICAgICAgICB2YXIgeCA9IHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2pdLng7XG4gICAgICAgIHZhciBsYWJlbFggPSBBcnJheS5pc0FycmF5KHgpID8geC5qb2luKCcgJykgOiB4O1xuICAgICAgICB2YXIgcm93SW5kZXggPSB3Lmdsb2JhbHMubGFiZWxzLm1hcChmdW5jdGlvbiAoXykge1xuICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KF8pID8gXy5qb2luKCcgJykgOiBfO1xuICAgICAgICB9KS5pbmRleE9mKGxhYmVsWCk7XG4gICAgICAgIHZhciBvdmVybGFwcGVkSW5kZXggPSB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VbaV0uZmluZEluZGV4KGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgIHJldHVybiB0eC54ID09PSBsYWJlbFggJiYgdHgub3ZlcmxhcHMubGVuZ3RoID4gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5yYW5nZUJhckdyb3VwUm93cykge1xuICAgICAgICAgICAgYmFyWVBvc2l0aW9uID0gc3J0eSArIHlEaXZpc2lvbiAqIHJvd0luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXJZUG9zaXRpb24gPSBzcnR5ICsgYmFySGVpZ2h0ICogdGhpcy52aXNpYmxlSSArIHlEaXZpc2lvbiAqIHJvd0luZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdmVybGFwcGVkSW5kZXggPiAtMSAmJiAhdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLnJhbmdlQmFyT3ZlcmxhcCkge1xuICAgICAgICAgICAgb3ZlcmxhcHMgPSB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VbaV1bb3ZlcmxhcHBlZEluZGV4XS5vdmVybGFwcztcblxuICAgICAgICAgICAgaWYgKG92ZXJsYXBzLmluZGV4T2YocmFuZ2VOYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgIGJhckhlaWdodCA9IGluaXRQb3NpdGlvbnMuYmFySGVpZ2h0IC8gb3ZlcmxhcHMubGVuZ3RoO1xuICAgICAgICAgICAgICBiYXJZUG9zaXRpb24gPSBiYXJIZWlnaHQgKiB0aGlzLnZpc2libGVJICsgeURpdmlzaW9uICogKDEwMCAtIHBhcnNlSW50KHRoaXMuYmFyT3B0aW9ucy5iYXJIZWlnaHQsIDEwKSkgLyAxMDAgLyAyICsgYmFySGVpZ2h0ICogKHRoaXMudmlzaWJsZUkgKyBvdmVybGFwcy5pbmRleE9mKHJhbmdlTmFtZSkpICsgeURpdmlzaW9uICogcm93SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyb3dJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMuYmFyLnJhbmdlQmFyR3JvdXBSb3dzKSB7XG4gICAgICAgICAgICAgIGJhclhQb3NpdGlvbiA9IHNydHggKyB4RGl2aXNpb24gKiByb3dJbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJhclhQb3NpdGlvbiA9IHNydHggKyBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUkgKyB4RGl2aXNpb24gKiByb3dJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3ZlcmxhcHBlZEluZGV4ID4gLTEgJiYgIXcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5yYW5nZUJhck92ZXJsYXApIHtcbiAgICAgICAgICAgIG92ZXJsYXBzID0gdy5nbG9iYWxzLnNlcmllc1JhbmdlW2ldW292ZXJsYXBwZWRJbmRleF0ub3ZlcmxhcHM7XG5cbiAgICAgICAgICAgIGlmIChvdmVybGFwcy5pbmRleE9mKHJhbmdlTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICBiYXJXaWR0aCA9IGluaXRQb3NpdGlvbnMuYmFyV2lkdGggLyBvdmVybGFwcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGJhclhQb3NpdGlvbiA9IGJhcldpZHRoICogdGhpcy52aXNpYmxlSSArIHhEaXZpc2lvbiAqICgxMDAgLSBwYXJzZUludCh0aGlzLmJhck9wdGlvbnMuYmFyV2lkdGgsIDEwKSkgLyAxMDAgLyAyICsgYmFyV2lkdGggKiAodGhpcy52aXNpYmxlSSArIG92ZXJsYXBzLmluZGV4T2YocmFuZ2VOYW1lKSkgKyB4RGl2aXNpb24gKiByb3dJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uLFxuICAgICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3UmFuZ2VDb2x1bW5QYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdSYW5nZUNvbHVtblBhdGhzKF9yZWYyKSB7XG4gICAgICAgIHZhciBpbmRleGVzID0gX3JlZjIuaW5kZXhlcyxcbiAgICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgICAgeERpdmlzaW9uID0gX3JlZjIueERpdmlzaW9uLFxuICAgICAgICAgICAgYmFyV2lkdGggPSBfcmVmMi5iYXJXaWR0aCxcbiAgICAgICAgICAgIGJhclhQb3NpdGlvbiA9IF9yZWYyLmJhclhQb3NpdGlvbixcbiAgICAgICAgICAgIHplcm9IID0gX3JlZjIuemVyb0g7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICAgIHZhciB5UmF0aW8gPSB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdO1xuICAgICAgICB2YXIgcmVhbEluZGV4ID0gaW5kZXhlcy5yZWFsSW5kZXg7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VWYWx1ZShyZWFsSW5kZXgsIGopO1xuICAgICAgICB2YXIgeTEgPSBNYXRoLm1pbihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgICAgdmFyIHkyID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICB5MSA9IHplcm9IO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkxID0gemVyb0ggLSB5MSAvIHlSYXRpbztcbiAgICAgICAgICB5MiA9IHplcm9IIC0geTIgLyB5UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFySGVpZ2h0ID0gTWF0aC5hYnMoeTIgLSB5MSk7XG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMuYmFySGVscGVycy5nZXRDb2x1bW5QYXRocyh7XG4gICAgICAgICAgYmFyWFBvc2l0aW9uOiBiYXJYUG9zaXRpb24sXG4gICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgc2VyaWVzOiB0aGlzLnNlcmllc1JhbmdlRW5kLFxuICAgICAgICAgIHJlYWxJbmRleDogaW5kZXhlcy5yZWFsSW5kZXgsXG4gICAgICAgICAgaTogcmVhbEluZGV4LFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgdzogd1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgeCA9IHggKyB4RGl2aXNpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGhUbzogcGF0aHMucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tOiBwYXRocy5wYXRoRnJvbSxcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHkyLFxuICAgICAgICAgIGdvYWxZOiB0aGlzLmJhckhlbHBlcnMuZ2V0R29hbFZhbHVlcygneScsIG51bGwsIHplcm9ILCBpLCBqKSxcbiAgICAgICAgICBiYXJYUG9zaXRpb246IGJhclhQb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3UmFuZ2VCYXJQYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdSYW5nZUJhclBhdGhzKF9yZWYzKSB7XG4gICAgICAgIHZhciBpbmRleGVzID0gX3JlZjMuaW5kZXhlcyxcbiAgICAgICAgICAgIHkgPSBfcmVmMy55LFxuICAgICAgICAgICAgeTEgPSBfcmVmMy55MSxcbiAgICAgICAgICAgIHkyID0gX3JlZjMueTIsXG4gICAgICAgICAgICB5RGl2aXNpb24gPSBfcmVmMy55RGl2aXNpb24sXG4gICAgICAgICAgICBiYXJIZWlnaHQgPSBfcmVmMy5iYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJZUG9zaXRpb24gPSBfcmVmMy5iYXJZUG9zaXRpb24sXG4gICAgICAgICAgICB6ZXJvVyA9IF9yZWYzLnplcm9XO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHgxID0gemVyb1cgKyB5MSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW87XG4gICAgICAgIHZhciB4MiA9IHplcm9XICsgeTIgLyB0aGlzLmludmVydGVkWVJhdGlvO1xuICAgICAgICB2YXIgYmFyV2lkdGggPSBNYXRoLmFicyh4MiAtIHgxKTtcbiAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5iYXJIZWxwZXJzLmdldEJhcnBhdGhzKHtcbiAgICAgICAgICBiYXJZUG9zaXRpb246IGJhcllQb3NpdGlvbixcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHNlcmllczogdGhpcy5zZXJpZXNSYW5nZUVuZCxcbiAgICAgICAgICBpOiBpbmRleGVzLnJlYWxJbmRleCxcbiAgICAgICAgICByZWFsSW5kZXg6IGluZGV4ZXMucmVhbEluZGV4LFxuICAgICAgICAgIGo6IGluZGV4ZXMuaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB5ID0geSArIHlEaXZpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aFRvOiBwYXRocy5wYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb206IHBhdGhzLnBhdGhGcm9tLFxuICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICB4OiB4MixcbiAgICAgICAgICBnb2FsWDogdGhpcy5iYXJIZWxwZXJzLmdldEdvYWxWYWx1ZXMoJ3gnLCB6ZXJvVywgbnVsbCwgaW5kZXhlcy5yZWFsSW5kZXgsIGluZGV4ZXMuaiksXG4gICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRSYW5nZVZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VWYWx1ZShpLCBqKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VTdGFydFtpXVtqXSxcbiAgICAgICAgICBlbmQ6IHcuZ2xvYmFscy5zZXJpZXNSYW5nZUVuZFtpXVtqXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSYW5nZUJhcjtcbiAgfShCYXIpO1xuXG4gIHZhciBIZWxwZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWxwZXJzKGxpbmVDdHgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWxwZXJzKTtcblxuICAgICAgdGhpcy53ID0gbGluZUN0eC53O1xuICAgICAgdGhpcy5saW5lQ3R4ID0gbGluZUN0eDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGVscGVycywgW3tcbiAgICAgIGtleTogXCJzYW1lVmFsdWVTZXJpZXNGaXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzYW1lVmFsdWVTZXJpZXNGaXgoaSwgc2VyaWVzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5maWxsLnR5cGUgPT09ICdncmFkaWVudCcgfHwgdy5jb25maWcuZmlsbC50eXBlW2ldID09PSAnZ3JhZGllbnQnKSB7XG4gICAgICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5saW5lQ3R4LmN0eCwgdyk7IC8vIGFwcGxpZWQgb25seSB0byBMSU5FIGNoYXJ0XG4gICAgICAgICAgLy8gYSBzbWFsbCBhZGp1c3RtZW50IHRvIGFsbG93IGdyYWRpZW50IGxpbmUgdG8gZHJhdyBjb3JyZWN0bHkgZm9yIGFsbCBzYW1lIHZhbHVlc1xuXG4gICAgICAgICAgLyogI2ZpeCBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy8zNTggKi9cblxuICAgICAgICAgIGlmIChjb3JlVXRpbHMuc2VyaWVzSGF2ZVNhbWVWYWx1ZXMoaSkpIHtcbiAgICAgICAgICAgIHZhciBnU2VyaWVzID0gc2VyaWVzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICBnU2VyaWVzW2dTZXJpZXMubGVuZ3RoIC0gMV0gPSBnU2VyaWVzW2dTZXJpZXMubGVuZ3RoIC0gMV0gKyAwLjAwMDAwMTtcbiAgICAgICAgICAgIHNlcmllc1tpXSA9IGdTZXJpZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FsY3VsYXRlUG9pbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUG9pbnRzKF9yZWYpIHtcbiAgICAgICAgdmFyIHNlcmllcyA9IF9yZWYuc2VyaWVzLFxuICAgICAgICAgICAgcmVhbEluZGV4ID0gX3JlZi5yZWFsSW5kZXgsXG4gICAgICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICAgICAgeSA9IF9yZWYueSxcbiAgICAgICAgICAgIGkgPSBfcmVmLmksXG4gICAgICAgICAgICBqID0gX3JlZi5qLFxuICAgICAgICAgICAgcHJldlkgPSBfcmVmLnByZXZZO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHB0WCA9IFtdO1xuICAgICAgICB2YXIgcHRZID0gW107XG5cbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICB2YXIgeFBUMXN0ID0gdGhpcy5saW5lQ3R4LmNhdGVnb3J5QXhpc0NvcnJlY3Rpb24gKyB3LmNvbmZpZy5tYXJrZXJzLm9mZnNldFg7IC8vIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZSBzZXJpZXNcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgaXQncyBub3QgYSB0aW1lIHNlcmllcywgYmVjYXVzZSBhIHRpbWUgc2VyaWVzIG1heVxuICAgICAgICAgIC8vIHN0YXJ0IGZyb20gdGhlIG1pZGRsZSBvZiB0aGUgeCBheGlzXG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgIHhQVDFzdCA9ICh3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdWzBdIC0gdy5nbG9iYWxzLm1pblgpIC8gdGhpcy5saW5lQ3R4LnhSYXRpbyArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WDtcbiAgICAgICAgICB9IC8vIHB1c2ggMiBwb2ludHMgZm9yIHRoZSBmaXJzdCBkYXRhIHZhbHVlc1xuXG5cbiAgICAgICAgICBwdFgucHVzaCh4UFQxc3QpO1xuICAgICAgICAgIHB0WS5wdXNoKFV0aWxzJDEuaXNOdW1iZXIoc2VyaWVzW2ldWzBdKSA/IHByZXZZICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRZIDogbnVsbCk7XG4gICAgICAgICAgcHRYLnB1c2goeCArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WCk7XG4gICAgICAgICAgcHRZLnB1c2goVXRpbHMkMS5pc051bWJlcihzZXJpZXNbaV1baiArIDFdKSA/IHkgKyB3LmNvbmZpZy5tYXJrZXJzLm9mZnNldFkgOiBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdFgucHVzaCh4ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRYKTtcbiAgICAgICAgICBwdFkucHVzaChVdGlscyQxLmlzTnVtYmVyKHNlcmllc1tpXVtqICsgMV0pID8geSArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WSA6IG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50c1BvcyA9IHtcbiAgICAgICAgICB4OiBwdFgsXG4gICAgICAgICAgeTogcHRZXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwb2ludHNQb3M7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrUHJldmlvdXNQYXRoc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUHJldmlvdXNQYXRocyhfcmVmMikge1xuICAgICAgICB2YXIgcGF0aEZyb21MaW5lID0gX3JlZjIucGF0aEZyb21MaW5lLFxuICAgICAgICAgICAgcGF0aEZyb21BcmVhID0gX3JlZjIucGF0aEZyb21BcmVhLFxuICAgICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjIucmVhbEluZGV4O1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBmb3IgKHZhciBwcCA9IDA7IHBwIDwgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoOyBwcCsrKSB7XG4gICAgICAgICAgdmFyIGdwcCA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXTtcblxuICAgICAgICAgIGlmICgoZ3BwLnR5cGUgPT09ICdsaW5lJyB8fCBncHAudHlwZSA9PT0gJ2FyZWEnKSAmJiBncHAucGF0aHMubGVuZ3RoID4gMCAmJiBwYXJzZUludChncHAucmVhbEluZGV4LCAxMCkgPT09IHBhcnNlSW50KHJlYWxJbmRleCwgMTApKSB7XG4gICAgICAgICAgICBpZiAoZ3BwLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICB0aGlzLmxpbmVDdHguYXBwZW5kUGF0aEZyb20gPSBmYWxzZTtcbiAgICAgICAgICAgICAgcGF0aEZyb21MaW5lID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdLmQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdwcC50eXBlID09PSAnYXJlYScpIHtcbiAgICAgICAgICAgICAgdGhpcy5saW5lQ3R4LmFwcGVuZFBhdGhGcm9tID0gZmFsc2U7XG4gICAgICAgICAgICAgIHBhdGhGcm9tQXJlYSA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXS5wYXRoc1swXS5kO1xuXG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdyAmJiB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbMV0pIHtcbiAgICAgICAgICAgICAgICBwYXRoRnJvbUxpbmUgPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbMV0uZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aEZyb21MaW5lOiBwYXRoRnJvbUxpbmUsXG4gICAgICAgICAgcGF0aEZyb21BcmVhOiBwYXRoRnJvbUFyZWFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGV0ZXJtaW5lRmlyc3RQcmV2WVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZUZpcnN0UHJldlkoX3JlZjMpIHtcbiAgICAgICAgdmFyIF9zZXJpZXMkaTtcblxuICAgICAgICB2YXIgaSA9IF9yZWYzLmksXG4gICAgICAgICAgICBzZXJpZXMgPSBfcmVmMy5zZXJpZXMsXG4gICAgICAgICAgICBwcmV2WSA9IF9yZWYzLnByZXZZLFxuICAgICAgICAgICAgbGluZVlQb3NpdGlvbiA9IF9yZWYzLmxpbmVZUG9zaXRpb247XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICAgIGlmICh0eXBlb2YgKChfc2VyaWVzJGkgPSBzZXJpZXNbaV0pID09PSBudWxsIHx8IF9zZXJpZXMkaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NlcmllcyRpWzBdKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIDFzdCB5IHZhbHVlIG9mIHByZXZpb3VzIHNlcmllc1xuICAgICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gdGhpcy5saW5lQ3R4LnByZXZTZXJpZXNZW2kgLSAxXVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBzZXJpZXMgd2lsbCBub3QgaGF2ZSBwcmV2WSB2YWx1ZXNcbiAgICAgICAgICAgICAgbGluZVlQb3NpdGlvbiA9IHRoaXMubGluZUN0eC56ZXJvWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVlQb3NpdGlvbiA9IHRoaXMubGluZUN0eC56ZXJvWTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2WSA9IGxpbmVZUG9zaXRpb24gLSBzZXJpZXNbaV1bMF0gLyB0aGlzLmxpbmVDdHgueVJhdGlvW3RoaXMubGluZUN0eC55YXhpc0luZGV4XSArICh0aGlzLmxpbmVDdHguaXNSZXZlcnNlZCA/IHNlcmllc1tpXVswXSAvIHRoaXMubGluZUN0eC55UmF0aW9bdGhpcy5saW5lQ3R4LnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgY3VycmVudCBzZXJpZXMgaXMgbnVsbFxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkICYmIGkgPiAwICYmIHR5cGVvZiBzZXJpZXNbaV1bMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdW5kZWZpbmVkIHZhbHVlICh1bmRlZmluZWQgdmFsdWUgd2lsbCBvY2N1ciB3aGVuIHdlIGNsZWFyIHRoZSBzZXJpZXMgd2hpbGUgdXNlciBjbGlja3Mgb24gbGVnZW5kIHRvIGhpZGUgc2VyaWVzZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gaSAtIDE7IHMgPj0gMDsgcy0tKSB7XG4gICAgICAgICAgICAgIC8vIGZvciBsb29wIHRvIGdldCB0byAxc3QgcHJldmlvdXMgdmFsdWUgdW50aWwgd2UgZ2V0IGl0XG4gICAgICAgICAgICAgIGlmIChzZXJpZXNbc11bMF0gIT09IG51bGwgJiYgdHlwZW9mIHNlcmllc1tzXVswXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gdGhpcy5saW5lQ3R4LnByZXZTZXJpZXNZW3NdWzBdO1xuICAgICAgICAgICAgICAgIHByZXZZID0gbGluZVlQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJldlk6IHByZXZZLFxuICAgICAgICAgIGxpbmVZUG9zaXRpb246IGxpbmVZUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGVscGVycztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAeXIvbW9ub3RvbmUtY3ViaWMtc3BsaW5lIChodHRwczovL2dpdGh1Yi5jb20vWVIvbW9ub3RvbmUtY3ViaWMtc3BsaW5lKVxuICAgKlxuICAgKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSAyMDE1IHlyLm5vXG4gICAqXG4gICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAgICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICAgKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gICAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mXG4gICAqIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAqXG4gICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1NcbiAgICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SXG4gICAqIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuICAgKiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICAgKiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgKi9cblxuICAvKipcbiAgICogR2VuZXJhdGUgdGFuZ2VudHMgZm9yICdwb2ludHMnXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICB2YXIgdGFuZ2VudHMgPSBmdW5jdGlvbiB0YW5nZW50cyhwb2ludHMpIHtcbiAgICB2YXIgbSA9IGZpbml0ZURpZmZlcmVuY2VzKHBvaW50cyk7XG4gICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgzrUgPSAxZS02O1xuICAgIHZhciB0Z3RzID0gW107XG4gICAgdmFyIGEsIGIsIGQsIHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgZCA9IHNsb3BlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhkKSA8IM61KSB7XG4gICAgICAgIG1baV0gPSBtW2kgKyAxXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gbVtpXSAvIGQ7XG4gICAgICAgIGIgPSBtW2kgKyAxXSAvIGQ7XG4gICAgICAgIHMgPSBhICogYSArIGIgKiBiO1xuXG4gICAgICAgIGlmIChzID4gOSkge1xuICAgICAgICAgIHMgPSBkICogMyAvIE1hdGguc3FydChzKTtcbiAgICAgICAgICBtW2ldID0gcyAqIGE7XG4gICAgICAgICAgbVtpICsgMV0gPSBzICogYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPD0gbjsgX2krKykge1xuICAgICAgcyA9IChwb2ludHNbTWF0aC5taW4obiwgX2kgKyAxKV1bMF0gLSBwb2ludHNbTWF0aC5tYXgoMCwgX2kgLSAxKV1bMF0pIC8gKDYgKiAoMSArIG1bX2ldICogbVtfaV0pKTtcbiAgICAgIHRndHMucHVzaChbcyB8fCAwLCBtW19pXSAqIHMgfHwgMF0pO1xuICAgIH1cblxuICAgIHJldHVybiB0Z3RzO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydCAncG9pbnRzJyB0byBzdmcgcGF0aFxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG5cbiAgdmFyIHN2Z1BhdGggPSBmdW5jdGlvbiBzdmdQYXRoKHBvaW50cykge1xuICAgIHZhciBwID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgdmFyIG4gPSBwb2ludC5sZW5ndGg7XG5cbiAgICAgIGlmIChuID4gNCkge1xuICAgICAgICBwICs9IFwiQ1wiLmNvbmNhdChwb2ludFswXSwgXCIsIFwiKS5jb25jYXQocG9pbnRbMV0pO1xuICAgICAgICBwICs9IFwiLCBcIi5jb25jYXQocG9pbnRbMl0sIFwiLCBcIikuY29uY2F0KHBvaW50WzNdKTtcbiAgICAgICAgcCArPSBcIiwgXCIuY29uY2F0KHBvaW50WzRdLCBcIiwgXCIpLmNvbmNhdChwb2ludFs1XSk7XG4gICAgICB9IGVsc2UgaWYgKG4gPiAyKSB7XG4gICAgICAgIHAgKz0gXCJTXCIuY29uY2F0KHBvaW50WzBdLCBcIiwgXCIpLmNvbmNhdChwb2ludFsxXSk7XG4gICAgICAgIHAgKz0gXCIsIFwiLmNvbmNhdChwb2ludFsyXSwgXCIsIFwiKS5jb25jYXQocG9pbnRbM10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9O1xuICB2YXIgc3BsaW5lID0ge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgJ3BvaW50cycgdG8gYmV6aWVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHBvaW50czogZnVuY3Rpb24gcG9pbnRzKF9wb2ludHMpIHtcbiAgICAgIHZhciB0Z3RzID0gdGFuZ2VudHMoX3BvaW50cyk7XG4gICAgICB2YXIgcCA9IF9wb2ludHNbMV07XG4gICAgICB2YXIgcDAgPSBfcG9pbnRzWzBdO1xuICAgICAgdmFyIHB0cyA9IFtdO1xuICAgICAgdmFyIHQgPSB0Z3RzWzFdO1xuICAgICAgdmFyIHQwID0gdGd0c1swXTsgLy8gQWRkIHN0YXJ0aW5nICdNJyBhbmQgJ0MnIHBvaW50c1xuXG4gICAgICBwdHMucHVzaChwMCwgW3AwWzBdICsgdDBbMF0sIHAwWzFdICsgdDBbMV0sIHBbMF0gLSB0WzBdLCBwWzFdIC0gdFsxXSwgcFswXSwgcFsxXV0pOyAvLyBBZGQgJ1MnIHBvaW50c1xuXG4gICAgICBmb3IgKHZhciBpID0gMiwgbiA9IHRndHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBfcCA9IF9wb2ludHNbaV07XG4gICAgICAgIHZhciBfdCA9IHRndHNbaV07XG4gICAgICAgIHB0cy5wdXNoKFtfcFswXSAtIF90WzBdLCBfcFsxXSAtIF90WzFdLCBfcFswXSwgX3BbMV1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2xpY2Ugb3V0IGEgc2VnbWVudCBvZiAncG9pbnRzJ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHBvaW50cywgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHB0cyA9IHBvaW50cy5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsICdDJyBwb2ludHNcbiAgICAgICAgaWYgKHB0c1sxXS5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgdmFyIG4gPSBwdHNbMF0ubGVuZ3RoO1xuICAgICAgICAgIHB0c1sxXSA9IFtwdHNbMF1bbiAtIDJdICogMiAtIHB0c1swXVtuIC0gNF0sIHB0c1swXVtuIC0gMV0gKiAyIC0gcHRzWzBdW24gLSAzXV0uY29uY2F0KHB0c1sxXSk7XG4gICAgICAgIH0gLy8gUmVtb3ZlIGNvbnRyb2wgcG9pbnRzIGZvciAnTSdcblxuXG4gICAgICAgIHB0c1swXSA9IHB0c1swXS5zbGljZSgtMik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdHM7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ29tcHV0ZSBzbG9wZSBmcm9tIHBvaW50ICdwMCcgdG8gJ3AxJ1xuICAgKiBAcGFyYW0ge0FycmF5fSBwMFxuICAgKiBAcGFyYW0ge0FycmF5fSBwMVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiBzbG9wZShwMCwgcDEpIHtcbiAgICByZXR1cm4gKHAxWzFdIC0gcDBbMV0pIC8gKHAxWzBdIC0gcDBbMF0pO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlIHRocmVlLXBvaW50IGRpZmZlcmVuY2VzIGZvciAncG9pbnRzJ1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGZpbml0ZURpZmZlcmVuY2VzKHBvaW50cykge1xuICAgIHZhciBtID0gW107XG4gICAgdmFyIHAwID0gcG9pbnRzWzBdO1xuICAgIHZhciBwMSA9IHBvaW50c1sxXTtcbiAgICB2YXIgZCA9IG1bMF0gPSBzbG9wZShwMCwgcDEpO1xuICAgIHZhciBpID0gMTtcblxuICAgIGZvciAodmFyIG4gPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA8IG47IGkrKykge1xuICAgICAgcDAgPSBwMTtcbiAgICAgIHAxID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIG1baV0gPSAoZCArIChkID0gc2xvcGUocDAsIHAxKSkpICogMC41O1xuICAgIH1cblxuICAgIG1baV0gPSBkO1xuICAgIHJldHVybiBtO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwZXhDaGFydHMgTGluZSBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBMaW5lIC8gQXJlYSAvIFJhbmdlQXJlYSBDaGFydHMuXG4gICAqIFRoaXMgY2xhc3MgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB2YWx1ZXMgZm9yIEJ1YmJsZS9TY2F0dGVyIGNoYXJ0cywgc28gbmVlZCB0byByZW5hbWUgaXQgdG8gQXhpcyBDaGFydHMgdG8gYXZvaWQgY29uZnVzaW9uc1xuICAgKiBAbW9kdWxlIExpbmVcbiAgICoqL1xuXG4gIHZhciBMaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5lKGN0eCwgeHlSYXRpb3MsIGlzUG9pbnRzQ2hhcnQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lKTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcbiAgICAgIHRoaXMucG9pbnRzQ2hhcnQgPSAhKHRoaXMudy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2J1YmJsZScgJiYgdGhpcy53LmNvbmZpZy5jaGFydC50eXBlICE9PSAnc2NhdHRlcicpIHx8IGlzUG9pbnRzQ2hhcnQ7XG4gICAgICB0aGlzLnNjYXR0ZXIgPSBuZXcgU2NhdHRlcih0aGlzLmN0eCk7XG4gICAgICB0aGlzLm5vTmVnYXRpdmVzID0gdGhpcy53Lmdsb2JhbHMubWluWCA9PT0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHRoaXMubGluZUhlbHBlcnMgPSBuZXcgSGVscGVycyh0aGlzKTtcbiAgICAgIHRoaXMubWFya2VycyA9IG5ldyBNYXJrZXJzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucHJldlNlcmllc1kgPSBbXTtcbiAgICAgIHRoaXMuY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbiA9IDA7XG4gICAgICB0aGlzLnlheGlzSW5kZXggPSAwO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMaW5lLCBbe1xuICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcywgY3R5cGUsIHNlcmllc0luZGV4LCBzZXJpZXNSYW5nZUVuZCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHR5cGUgPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBjdHlwZSA6IHcuY29uZmlnLmNoYXJ0LnR5cGU7XG4gICAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXNcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4LCB3KTtcbiAgICAgICAgdGhpcy55UmF0aW8gPSB0aGlzLnh5UmF0aW9zLnlSYXRpbztcbiAgICAgICAgdGhpcy56UmF0aW8gPSB0aGlzLnh5UmF0aW9zLnpSYXRpbztcbiAgICAgICAgdGhpcy54UmF0aW8gPSB0aGlzLnh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgdGhpcy5iYXNlTGluZVkgPSB0aGlzLnh5UmF0aW9zLmJhc2VMaW5lWTtcbiAgICAgICAgc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgICB0aGlzLnlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHRoaXMueVJhdGlvKTsgLy8gcHVzaCBhbGwgc2VyaWVzIGluIGFuIGFycmF5LCBzbyB3ZSBjYW4gZHJhdyBpbiByZXZlcnNlIG9yZGVyIChmb3Igc3RhY2tlZCBjaGFydHMpXG5cbiAgICAgICAgdmFyIGFsbFNlcmllcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VyaWVzID0gdGhpcy5saW5lSGVscGVycy5zYW1lVmFsdWVTZXJpZXNGaXgoaSwgc2VyaWVzKTtcbiAgICAgICAgICB2YXIgcmVhbEluZGV4ID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gc2VyaWVzSW5kZXhbaV0gOiBpO1xuXG4gICAgICAgICAgdGhpcy5faW5pdFNlcmllVmFyaWFibGVzKHNlcmllcywgaSwgcmVhbEluZGV4KTtcblxuICAgICAgICAgIHZhciB5QXJyaiA9IFtdOyAvLyBob2xkIHkgdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgICAgdmFyIHkyQXJyaiA9IFtdOyAvLyBob2xkcyB5MiB2YWx1ZXMgaW4gcmFuZ2UtYXJlYSBjaGFydHNcblxuICAgICAgICAgIHZhciB4QXJyaiA9IFtdOyAvLyBob2xkIHggdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgICAgdmFyIHggPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArIHRoaXMuY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbjtcbiAgICAgICAgICB2YXIgeSA9IDE7XG4gICAgICAgICAgdmFyIGxpbmVQYXRocyA9IFtdO1xuICAgICAgICAgIHZhciBhcmVhUGF0aHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmN0eC5zZXJpZXMuYWRkQ29sbGFwc2VkQ2xhc3NUb1Nlcmllcyh0aGlzLmVsU2VyaWVzLCByZWFsSW5kZXgpO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuZ2xvYmFscy5zZXJpZXNYLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbcmVhbEluZGV4XVswXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMueFJhdGlvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHhBcnJqLnB1c2goeCk7XG4gICAgICAgICAgdmFyIHByZXZYID0geDtcbiAgICAgICAgICB2YXIgcHJldlkgPSB0aGlzLnplcm9ZO1xuICAgICAgICAgIHZhciBwcmV2WTIgPSB0aGlzLnplcm9ZO1xuICAgICAgICAgIHZhciBsaW5lWVBvc2l0aW9uID0gMDsgLy8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBjdXJyZW50IHNlcmllcyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcblxuICAgICAgICAgIHZhciBmaXJzdFByZXZZID0gdGhpcy5saW5lSGVscGVycy5kZXRlcm1pbmVGaXJzdFByZXZZKHtcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgIHByZXZZOiBwcmV2WSxcbiAgICAgICAgICAgIGxpbmVZUG9zaXRpb246IGxpbmVZUG9zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmV2WSA9IGZpcnN0UHJldlkucHJldlk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuc3Ryb2tlLmN1cnZlID09PSAnc21vb3RoJyAmJiBzZXJpZXNbaV1bMF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gZGlzY2FyZCB0aGUgeSBwb3NpdGlvbiBpZiAxc3QgZGF0YVBvaW50IGlzIG51bGwgYXMgaXQgY2F1c2VzIGlzc3VlcyB3aXRoIG1vbm90b25lQ3ViaWMgcGF0aCBjcmVhdGlvblxuICAgICAgICAgICAgeUFycmoucHVzaChudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeUFycmoucHVzaChwcmV2WSk7XG4gICAgICAgICAgfSAvLyB5MiBhcmUgbmVlZGVkIGZvciByYW5nZS1hcmVhIGNoYXJ0c1xuXG5cbiAgICAgICAgICB2YXIgZmlyc3RQcmV2WTIgPSB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JhbmdlQXJlYScpIHtcbiAgICAgICAgICAgIGZpcnN0UHJldlkyID0gdGhpcy5saW5lSGVscGVycy5kZXRlcm1pbmVGaXJzdFByZXZZKHtcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNSYW5nZUVuZCxcbiAgICAgICAgICAgICAgcHJldlk6IHByZXZZMixcbiAgICAgICAgICAgICAgbGluZVlQb3NpdGlvbjogbGluZVlQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcmV2WTIgPSBmaXJzdFByZXZZMi5wcmV2WTtcbiAgICAgICAgICAgIHkyQXJyai5wdXNoKHByZXZZMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGhzRnJvbSA9IHRoaXMuX2NhbGN1bGF0ZVBhdGhzRnJvbSh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICBwcmV2WDogcHJldlgsXG4gICAgICAgICAgICBwcmV2WTogcHJldlksXG4gICAgICAgICAgICBwcmV2WTI6IHByZXZZMlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGl0ZXJhdGluZ09wdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHBhdGhzRnJvbTogcGF0aHNGcm9tLFxuICAgICAgICAgICAgbGluZVBhdGhzOiBsaW5lUGF0aHMsXG4gICAgICAgICAgICBhcmVhUGF0aHM6IGFyZWFQYXRocyxcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgICAgIGxpbmVZUG9zaXRpb246IGxpbmVZUG9zaXRpb24sXG4gICAgICAgICAgICB4QXJyajogeEFycmosXG4gICAgICAgICAgICB5QXJyajogeUFycmosXG4gICAgICAgICAgICB5MkFycmo6IHkyQXJyaixcbiAgICAgICAgICAgIHNlcmllc1JhbmdlRW5kOiBzZXJpZXNSYW5nZUVuZFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9pdGVyYXRlT3ZlckRhdGFQb2ludHMoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGl0ZXJhdGluZ09wdHMpLCB7fSwge1xuICAgICAgICAgICAgaXRlcmF0aW9uczogdHlwZSA9PT0gJ3JhbmdlQXJlYScgPyBzZXJpZXNbaV0ubGVuZ3RoIC0gMSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogdHJ1ZVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGlmICh0eXBlID09PSAncmFuZ2VBcmVhJykge1xuICAgICAgICAgICAgdmFyIHBhdGhzRnJvbTIgPSB0aGlzLl9jYWxjdWxhdGVQYXRoc0Zyb20oe1xuICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllc1JhbmdlRW5kLFxuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgcHJldlg6IHByZXZYLFxuICAgICAgICAgICAgICBwcmV2WTogcHJldlkyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHJhbmdlUGF0aHMgPSB0aGlzLl9pdGVyYXRlT3ZlckRhdGFQb2ludHMoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGl0ZXJhdGluZ09wdHMpLCB7fSwge1xuICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllc1JhbmdlRW5kLFxuICAgICAgICAgICAgICBwYXRoc0Zyb206IHBhdGhzRnJvbTIsXG4gICAgICAgICAgICAgIGl0ZXJhdGlvbnM6IHNlcmllc1JhbmdlRW5kW2ldLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogZmFsc2VcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgcGF0aHMubGluZVBhdGhzWzBdID0gcmFuZ2VQYXRocy5saW5lUGF0aCArIHBhdGhzLmxpbmVQYXRoO1xuICAgICAgICAgICAgcGF0aHMucGF0aEZyb21MaW5lID0gcmFuZ2VQYXRocy5wYXRoRnJvbUxpbmUgKyBwYXRocy5wYXRoRnJvbUxpbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5faGFuZGxlUGF0aHMoe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIHBhdGhzOiBwYXRoc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5lbFNlcmllcy5hZGQodGhpcy5lbFBvaW50c01haW4pO1xuICAgICAgICAgIHRoaXMuZWxTZXJpZXMuYWRkKHRoaXMuZWxEYXRhTGFiZWxzV3JhcCk7XG4gICAgICAgICAgYWxsU2VyaWVzLnB1c2godGhpcy5lbFNlcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgIGZvciAodmFyIHMgPSBhbGxTZXJpZXMubGVuZ3RoOyBzID4gMDsgcy0tKSB7XG4gICAgICAgICAgICByZXQuYWRkKGFsbFNlcmllc1tzIC0gMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfcyA9IDA7IF9zIDwgYWxsU2VyaWVzLmxlbmd0aDsgX3MrKykge1xuICAgICAgICAgICAgcmV0LmFkZChhbGxTZXJpZXNbX3NdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaW5pdFNlcmllVmFyaWFibGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRTZXJpZVZhcmlhYmxlcyhzZXJpZXMsIGksIHJlYWxJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTsgLy8gd2lkdGggZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG5cbiAgICAgICAgdGhpcy54RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gKHcuZ2xvYmFscy5kYXRhUG9pbnRzIC0gKHcuY29uZmlnLnhheGlzLnRpY2tQbGFjZW1lbnQgPT09ICdvbicgPyAxIDogMCkpO1xuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpID8gdy5jb25maWcuc3Ryb2tlLndpZHRoW3JlYWxJbmRleF0gOiB3LmNvbmZpZy5zdHJva2Uud2lkdGg7XG5cbiAgICAgICAgaWYgKHRoaXMueVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLnlheGlzSW5kZXggPSByZWFsSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3RoaXMueWF4aXNJbmRleF0ucmV2ZXJzZWQ7IC8vIHplcm9ZIGlzIHRoZSAwIHZhbHVlIGluIHkgc2VyaWVzIHdoaWNoIGNhbiBiZSB1c2VkIGluIG5lZ2F0aXZlIGNoYXJ0c1xuXG4gICAgICAgIHRoaXMuemVyb1kgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIHRoaXMuYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gLSAodGhpcy5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRIZWlnaHQgOiAwKSArICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICogMiA6IDApO1xuICAgICAgICB0aGlzLmFyZWFCb3R0b21ZID0gdGhpcy56ZXJvWTtcblxuICAgICAgICBpZiAodGhpcy56ZXJvWSA+IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IHx8IHcuY29uZmlnLnBsb3RPcHRpb25zLmFyZWEuZmlsbFRvID09PSAnZW5kJykge1xuICAgICAgICAgIHRoaXMuYXJlYUJvdHRvbVkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbiA9IHRoaXMueERpdmlzaW9uIC8gMjsgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cblxuICAgICAgICB0aGlzLmVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzXCIsXG4gICAgICAgICAgc2VyaWVzTmFtZTogVXRpbHMkMS5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW3JlYWxJbmRleF0pXG4gICAgICAgIH0pOyAvLyBwb2ludHNcblxuICAgICAgICB0aGlzLmVsUG9pbnRzTWFpbiA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCcsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgIH0pOyAvLyBlbGRhdGFsYWJlbHNcblxuICAgICAgICB0aGlzLmVsRGF0YUxhYmVsc1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMnLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvbmdlc3RTZXJpZXMgPSBzZXJpZXNbaV0ubGVuZ3RoID09PSB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgdGhpcy5lbFNlcmllcy5hdHRyKHtcbiAgICAgICAgICAnZGF0YTpsb25nZXN0U2VyaWVzJzogbG9uZ2VzdFNlcmllcyxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBlbmRQYXRoRnJvbSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jYWxjdWxhdGVQYXRoc0Zyb21cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlUGF0aHNGcm9tKF9yZWYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgICBzZXJpZXMgPSBfcmVmLnNlcmllcyxcbiAgICAgICAgICAgIGkgPSBfcmVmLmksXG4gICAgICAgICAgICByZWFsSW5kZXggPSBfcmVmLnJlYWxJbmRleCxcbiAgICAgICAgICAgIHByZXZYID0gX3JlZi5wcmV2WCxcbiAgICAgICAgICAgIHByZXZZID0gX3JlZi5wcmV2WSxcbiAgICAgICAgICAgIHByZXZZMiA9IF9yZWYucHJldlkyO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGxpbmVQYXRoLCBhcmVhUGF0aCwgcGF0aEZyb21MaW5lLCBwYXRoRnJvbUFyZWE7XG5cbiAgICAgICAgaWYgKHNlcmllc1tpXVswXSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IHZhbHVlIGl0c2VsZiBpcyBudWxsLCB3ZSBuZWVkIHRvIG1vdmUgdGhlIHBvaW50ZXIgdG8gYSBsb2NhdGlvbiB3aGVyZSBhIG51bGwgdmFsdWUgaXMgbm90IGZvdW5kXG4gICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZXJpZXNbaV0ubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNbaV1bc10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldlggPSB0aGlzLnhEaXZpc2lvbiAqIHM7XG4gICAgICAgICAgICAgIHByZXZZID0gdGhpcy56ZXJvWSAtIHNlcmllc1tpXVtzXSAvIHRoaXMueVJhdGlvW3RoaXMueWF4aXNJbmRleF07XG4gICAgICAgICAgICAgIGxpbmVQYXRoID0gZ3JhcGhpY3MubW92ZShwcmV2WCwgcHJldlkpO1xuICAgICAgICAgICAgICBhcmVhUGF0aCA9IGdyYXBoaWNzLm1vdmUocHJldlgsIHRoaXMuYXJlYUJvdHRvbVkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZVBhdGggPSBncmFwaGljcy5tb3ZlKHByZXZYLCBwcmV2WSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JhbmdlQXJlYScpIHtcbiAgICAgICAgICAgIGxpbmVQYXRoID0gZ3JhcGhpY3MubW92ZShwcmV2WCwgcHJldlkyKSArIGdyYXBoaWNzLmxpbmUocHJldlgsIHByZXZZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcmVhUGF0aCA9IGdyYXBoaWNzLm1vdmUocHJldlgsIHRoaXMuYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubGluZShwcmV2WCwgcHJldlkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aEZyb21MaW5lID0gZ3JhcGhpY3MubW92ZSgtMSwgdGhpcy56ZXJvWSkgKyBncmFwaGljcy5saW5lKC0xLCB0aGlzLnplcm9ZKTtcbiAgICAgICAgcGF0aEZyb21BcmVhID0gZ3JhcGhpY3MubW92ZSgtMSwgdGhpcy56ZXJvWSkgKyBncmFwaGljcy5saW5lKC0xLCB0aGlzLnplcm9ZKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBwYXRoRnJvbSA9IHRoaXMubGluZUhlbHBlcnMuY2hlY2tQcmV2aW91c1BhdGhzKHtcbiAgICAgICAgICAgIHBhdGhGcm9tTGluZTogcGF0aEZyb21MaW5lLFxuICAgICAgICAgICAgcGF0aEZyb21BcmVhOiBwYXRoRnJvbUFyZWEsXG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHBhdGhGcm9tLnBhdGhGcm9tTGluZTtcbiAgICAgICAgICBwYXRoRnJvbUFyZWEgPSBwYXRoRnJvbS5wYXRoRnJvbUFyZWE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZXZYOiBwcmV2WCxcbiAgICAgICAgICBwcmV2WTogcHJldlksXG4gICAgICAgICAgbGluZVBhdGg6IGxpbmVQYXRoLFxuICAgICAgICAgIGFyZWFQYXRoOiBhcmVhUGF0aCxcbiAgICAgICAgICBwYXRoRnJvbUxpbmU6IHBhdGhGcm9tTGluZSxcbiAgICAgICAgICBwYXRoRnJvbUFyZWE6IHBhdGhGcm9tQXJlYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlUGF0aHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUGF0aHMoX3JlZjIpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmMi50eXBlLFxuICAgICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjIucmVhbEluZGV4LFxuICAgICAgICAgICAgaSA9IF9yZWYyLmksXG4gICAgICAgICAgICBwYXRocyA9IF9yZWYyLnBhdGhzO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7IC8vIHB1c2ggYWxsIGN1cnJlbnQgeSB2YWx1ZXMgYXJyYXkgdG8gbWFpbiBQcmV2WSBBcnJheVxuXG4gICAgICAgIHRoaXMucHJldlNlcmllc1kucHVzaChwYXRocy55QXJyaik7IC8vIHB1c2ggYWxsIHggdmFsIGFycmF5cyBpbnRvIG1haW4geEFyclxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSBwYXRocy54QXJyajtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHBhdGhzLnlBcnJqO1xuICAgICAgICB2YXIgZm9yZWNhc3QgPSB3LmNvbmZpZy5mb3JlY2FzdERhdGFQb2ludHM7XG5cbiAgICAgICAgaWYgKGZvcmVjYXN0LmNvdW50ID4gMCAmJiB0eXBlICE9PSAncmFuZ2VBcmVhJykge1xuICAgICAgICAgIHZhciBmb3JlY2FzdEN1dG9mZiA9IHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF1bdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbcmVhbEluZGV4XS5sZW5ndGggLSBmb3JlY2FzdC5jb3VudCAtIDFdO1xuICAgICAgICAgIHZhciBlbEZvcmVjYXN0TWFzayA9IGdyYXBoaWNzLmRyYXdSZWN0KGZvcmVjYXN0Q3V0b2ZmLCAwLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgMCk7XG4gICAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEZvcmVjYXN0TWFzay5hcHBlbmRDaGlsZChlbEZvcmVjYXN0TWFzay5ub2RlKTtcbiAgICAgICAgICB2YXIgZWxOb25Gb3JlY2FzdE1hc2sgPSBncmFwaGljcy5kcmF3UmVjdCgwLCAwLCBmb3JlY2FzdEN1dG9mZiwgdy5nbG9iYWxzLmdyaWRIZWlnaHQsIDApO1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxOb25Gb3JlY2FzdE1hc2suYXBwZW5kQ2hpbGQoZWxOb25Gb3JlY2FzdE1hc2subm9kZSk7XG4gICAgICAgIH0gLy8gdGhlc2UgZWxlbWVudHMgd2lsbCBiZSBzaG93biBhZnRlciBhcmVhIHBhdGggYW5pbWF0aW9uIGNvbXBsZXRlc1xuXG5cbiAgICAgICAgaWYgKCF0aGlzLnBvaW50c0NoYXJ0KSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGVsOiB0aGlzLmVsUG9pbnRzTWFpbi5ub2RlLFxuICAgICAgICAgICAgaW5kZXg6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRSZW5kZXJlZFBhdGhPcHRpb25zID0ge1xuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGksXG4gICAgICAgICAgaW5pdGlhbFNwZWVkOiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkLFxuICAgICAgICAgIGRhdGFDaGFuZ2VTcGVlZDogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnYXJlYScpIHtcbiAgICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgIHNlcmllc051bWJlcjogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhzLmFyZWFQYXRocy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkUGF0aCA9IGdyYXBoaWNzLnJlbmRlclBhdGhzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRocy5wYXRoRnJvbUFyZWEsXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aHMuYXJlYVBhdGhzW3BdLFxuICAgICAgICAgICAgICBzdHJva2U6ICdub25lJyxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgICAgICAgIHN0cm9rZUxpbmVDYXA6IG51bGwsXG4gICAgICAgICAgICAgIGZpbGw6IHBhdGhGaWxsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLmVsU2VyaWVzLmFkZChyZW5kZXJlZFBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdyAmJiAhdGhpcy5wb2ludHNDaGFydCkge1xuICAgICAgICAgIHZhciBsaW5lRmlsbCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICBsaW5lRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgICAgICBzZXJpZXNOdW1iZXI6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgaTogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2UuZmlsbC50eXBlID09PSAnc29saWQnKSB7XG4gICAgICAgICAgICAgIGxpbmVGaWxsID0gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbcmVhbEluZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2RmlsbCA9IHcuY29uZmlnLmZpbGw7XG4gICAgICAgICAgICAgIHcuY29uZmlnLmZpbGwgPSB3LmNvbmZpZy5zdHJva2UuZmlsbDtcbiAgICAgICAgICAgICAgbGluZUZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgICAgICBzZXJpZXNOdW1iZXI6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3LmNvbmZpZy5maWxsID0gcHJldkZpbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyByYW5nZS1hcmVhIHBhdGhzIGFyZSBkcmF3biB1c2luZyBsaW5lUGF0aHNcblxuXG4gICAgICAgICAgZm9yICh2YXIgX3AgPSAwOyBfcCA8IHBhdGhzLmxpbmVQYXRocy5sZW5ndGg7IF9wKyspIHtcbiAgICAgICAgICAgIHZhciBfcGF0aEZpbGwgPSBsaW5lRmlsbDtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdyYW5nZUFyZWEnKSB7XG4gICAgICAgICAgICAgIF9wYXRoRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgICAgICAgIHNlcmllc051bWJlcjogcmVhbEluZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZVBhdGhDb21tb25PcHRzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRSZW5kZXJlZFBhdGhPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgcGF0aEZyb206IHBhdGhzLnBhdGhGcm9tTGluZSxcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRocy5saW5lUGF0aHNbX3BdLFxuICAgICAgICAgICAgICBzdHJva2U6IGxpbmVGaWxsLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgc3Ryb2tlTGluZUNhcDogdy5jb25maWcuc3Ryb2tlLmxpbmVDYXAsXG4gICAgICAgICAgICAgIGZpbGw6IHR5cGUgPT09ICdyYW5nZUFyZWEnID8gX3BhdGhGaWxsIDogJ25vbmUnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIF9yZW5kZXJlZFBhdGggPSBncmFwaGljcy5yZW5kZXJQYXRocyhsaW5lUGF0aENvbW1vbk9wdHMpO1xuXG4gICAgICAgICAgICB0aGlzLmVsU2VyaWVzLmFkZChfcmVuZGVyZWRQYXRoKTtcblxuICAgICAgICAgICAgX3JlbmRlcmVkUGF0aC5hdHRyKCdmaWxsLXJ1bGUnLCBcImV2ZW5vZGRcIik7XG5cbiAgICAgICAgICAgIGlmIChmb3JlY2FzdC5jb3VudCA+IDAgJiYgdHlwZSAhPT0gJ3JhbmdlQXJlYScpIHtcbiAgICAgICAgICAgICAgdmFyIHJlbmRlcmVkRm9yZWNhc3RQYXRoID0gZ3JhcGhpY3MucmVuZGVyUGF0aHMobGluZVBhdGhDb21tb25PcHRzKTtcbiAgICAgICAgICAgICAgcmVuZGVyZWRGb3JlY2FzdFBhdGgubm9kZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBmb3JlY2FzdC5kYXNoQXJyYXkpO1xuXG4gICAgICAgICAgICAgIGlmIChmb3JlY2FzdC5zdHJva2VXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkRm9yZWNhc3RQYXRoLm5vZGUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBmb3JlY2FzdC5zdHJva2VXaWR0aCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmVsU2VyaWVzLmFkZChyZW5kZXJlZEZvcmVjYXN0UGF0aCk7XG4gICAgICAgICAgICAgIHJlbmRlcmVkRm9yZWNhc3RQYXRoLmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNmb3JlY2FzdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG5cbiAgICAgICAgICAgICAgX3JlbmRlcmVkUGF0aC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjbm9uRm9yZWNhc3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaXRlcmF0ZU92ZXJEYXRhUG9pbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2l0ZXJhdGVPdmVyRGF0YVBvaW50cyhfcmVmMykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB0eXBlID0gX3JlZjMudHlwZSxcbiAgICAgICAgICAgIHNlcmllcyA9IF9yZWYzLnNlcmllcyxcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgPSBfcmVmMy5pdGVyYXRpb25zLFxuICAgICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjMucmVhbEluZGV4LFxuICAgICAgICAgICAgaSA9IF9yZWYzLmksXG4gICAgICAgICAgICB4ID0gX3JlZjMueCxcbiAgICAgICAgICAgIHkgPSBfcmVmMy55LFxuICAgICAgICAgICAgcGF0aHNGcm9tID0gX3JlZjMucGF0aHNGcm9tLFxuICAgICAgICAgICAgbGluZVBhdGhzID0gX3JlZjMubGluZVBhdGhzLFxuICAgICAgICAgICAgYXJlYVBhdGhzID0gX3JlZjMuYXJlYVBhdGhzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXggPSBfcmVmMy5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSBfcmVmMy5saW5lWVBvc2l0aW9uLFxuICAgICAgICAgICAgeEFycmogPSBfcmVmMy54QXJyaixcbiAgICAgICAgICAgIHlBcnJqID0gX3JlZjMueUFycmosXG4gICAgICAgICAgICB5MkFycmogPSBfcmVmMy55MkFycmosXG4gICAgICAgICAgICBpc1JhbmdlU3RhcnQgPSBfcmVmMy5pc1JhbmdlU3RhcnQsXG4gICAgICAgICAgICBzZXJpZXNSYW5nZUVuZCA9IF9yZWYzLnNlcmllc1JhbmdlRW5kO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHlSYXRpbyA9IHRoaXMueVJhdGlvO1xuICAgICAgICB2YXIgcHJldlkgPSBwYXRoc0Zyb20ucHJldlksXG4gICAgICAgICAgICBsaW5lUGF0aCA9IHBhdGhzRnJvbS5saW5lUGF0aCxcbiAgICAgICAgICAgIGFyZWFQYXRoID0gcGF0aHNGcm9tLmFyZWFQYXRoLFxuICAgICAgICAgICAgcGF0aEZyb21MaW5lID0gcGF0aHNGcm9tLnBhdGhGcm9tTGluZSxcbiAgICAgICAgICAgIHBhdGhGcm9tQXJlYSA9IHBhdGhzRnJvbS5wYXRoRnJvbUFyZWE7XG4gICAgICAgIHZhciBtaW5ZID0gVXRpbHMkMS5pc051bWJlcih3Lmdsb2JhbHMubWluWUFycltyZWFsSW5kZXhdKSA/IHcuZ2xvYmFscy5taW5ZQXJyW3JlYWxJbmRleF0gOiB3Lmdsb2JhbHMubWluWTtcblxuICAgICAgICBpZiAoIWl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBpdGVyYXRpb25zID0gdy5nbG9iYWxzLmRhdGFQb2ludHMgPiAxID8gdy5nbG9iYWxzLmRhdGFQb2ludHMgLSAxIDogdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0WSA9IGZ1bmN0aW9uIGdldFkoX3ksIGxpbmVZUG9zKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVZUG9zIC0gX3kgLyB5UmF0aW9bX3RoaXMueWF4aXNJbmRleF0gKyAoX3RoaXMuaXNSZXZlcnNlZCA/IF95IC8geVJhdGlvW190aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB5MiA9IHk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICAgICAgICB2YXIgaXNOdWxsID0gdHlwZW9mIHNlcmllc1tpXVtqICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqICsgMV0gPT09IG51bGw7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgIHZhciBzWCA9IHcuZ2xvYmFscy5zZXJpZXNYW3JlYWxJbmRleF1baiArIDFdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZXJpZXNYW3JlYWxJbmRleF1baiArIDFdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvKiBmaXggIzM3NCAqL1xuICAgICAgICAgICAgICBzWCA9IHcuZ2xvYmFscy5zZXJpZXNYW3JlYWxJbmRleF1baXRlcmF0aW9ucyAtIDFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ID0gKHNYIC0gdy5nbG9iYWxzLm1pblgpIC8gdGhpcy54UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSB4ICsgdGhpcy54RGl2aXNpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA8IHcuY29uZmlnLnNlcmllcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIC8vIGEgY29sbGFwc2VkIHNlcmllcyBpbiBhIHN0YWNrZWQgYmFyIGNoYXJ0IG1heSBwcm92aWRlIHdyb25nIHJlc3VsdCBmb3IgdGhlIG5leHQgc2VyaWVzLCBoZW5jZSBmaW5kIHRoZSBwcmV2SW5kZXggb2YgcHJldiBzZXJpZXMgd2hpY2ggaXMgbm90IGNvbGxhcHNlZCAtIGZpeGVzIGFwZXhjaGFydHMuanMjMTM3MlxuICAgICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gZnVuY3Rpb24gcHJldkluZGV4KHBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpaSA9IHBpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY3BpID0gMDsgY3BpIDwgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7IGNwaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihwaSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwaWktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpaSA+PSAwID8gcGlpIDogMDtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gdGhpcy5wcmV2U2VyaWVzWVtwcmV2SW5kZXgoaSAtIDEpXVtqICsgMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlkgdmFsdWVzXG4gICAgICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSB0aGlzLnplcm9ZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gdGhpcy56ZXJvWTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNOdWxsKSB7XG4gICAgICAgICAgICB5ID0gZ2V0WShtaW5ZLCBsaW5lWVBvc2l0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IGdldFkoc2VyaWVzW2ldW2ogKyAxXSwgbGluZVlQb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAncmFuZ2VBcmVhJykge1xuICAgICAgICAgICAgICB5MiA9IGdldFkoc2VyaWVzUmFuZ2VFbmRbaV1baiArIDFdLCBsaW5lWVBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHB1c2ggY3VycmVudCBYXG5cblxuICAgICAgICAgIHhBcnJqLnB1c2goeCk7IC8vIHB1c2ggY3VycmVudCBZIHRoYXQgd2lsbCBiZSB1c2VkIGFzIG5leHQgc2VyaWVzJ3MgYm90dG9tIHBvc2l0aW9uXG5cbiAgICAgICAgICBpZiAoaXNOdWxsICYmIHcuY29uZmlnLnN0cm9rZS5jdXJ2ZSA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgICAgIHlBcnJqLnB1c2gobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlBcnJqLnB1c2goeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeTJBcnJqLnB1c2goeTIpO1xuICAgICAgICAgIHZhciBwb2ludHNQb3MgPSB0aGlzLmxpbmVIZWxwZXJzLmNhbGN1bGF0ZVBvaW50cyh7XG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgIHByZXZZOiBwcmV2WVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYXRocyA9IHRoaXMuX2NyZWF0ZVBhdGhzKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHkyOiB5MixcbiAgICAgICAgICAgIHhBcnJqOiB4QXJyaixcbiAgICAgICAgICAgIHlBcnJqOiB5QXJyaixcbiAgICAgICAgICAgIHkyQXJyajogeTJBcnJqLFxuICAgICAgICAgICAgbGluZVBhdGg6IGxpbmVQYXRoLFxuICAgICAgICAgICAgYXJlYVBhdGg6IGFyZWFQYXRoLFxuICAgICAgICAgICAgbGluZVBhdGhzOiBsaW5lUGF0aHMsXG4gICAgICAgICAgICBhcmVhUGF0aHM6IGFyZWFQYXRocyxcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgICAgIGlzUmFuZ2VTdGFydDogaXNSYW5nZVN0YXJ0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhcmVhUGF0aHMgPSBjYWxjdWxhdGVkUGF0aHMuYXJlYVBhdGhzO1xuICAgICAgICAgIGxpbmVQYXRocyA9IGNhbGN1bGF0ZWRQYXRocy5saW5lUGF0aHM7XG4gICAgICAgICAgYXJlYVBhdGggPSBjYWxjdWxhdGVkUGF0aHMuYXJlYVBhdGg7XG4gICAgICAgICAgbGluZVBhdGggPSBjYWxjdWxhdGVkUGF0aHMubGluZVBhdGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRQYXRoRnJvbSAmJiAhKHcuY29uZmlnLnN0cm9rZS5jdXJ2ZSA9PT0gJ3Ntb290aCcgJiYgdHlwZSA9PT0gJ3JhbmdlQXJlYScpKSB7XG4gICAgICAgICAgICBwYXRoRnJvbUxpbmUgPSBwYXRoRnJvbUxpbmUgKyBncmFwaGljcy5saW5lKHgsIHRoaXMuemVyb1kpO1xuICAgICAgICAgICAgcGF0aEZyb21BcmVhID0gcGF0aEZyb21BcmVhICsgZ3JhcGhpY3MubGluZSh4LCB0aGlzLnplcm9ZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmhhbmRsZU51bGxEYXRhUG9pbnRzKHNlcmllcywgcG9pbnRzUG9zLCBpLCBqLCByZWFsSW5kZXgpO1xuXG4gICAgICAgICAgdGhpcy5faGFuZGxlTWFya2Vyc0FuZExhYmVscyh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgcG9pbnRzUG9zOiBwb2ludHNQb3MsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgaXNSYW5nZVN0YXJ0OiBpc1JhbmdlU3RhcnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeUFycmo6IHlBcnJqLFxuICAgICAgICAgIHhBcnJqOiB4QXJyaixcbiAgICAgICAgICBwYXRoRnJvbUFyZWE6IHBhdGhGcm9tQXJlYSxcbiAgICAgICAgICBhcmVhUGF0aHM6IGFyZWFQYXRocyxcbiAgICAgICAgICBwYXRoRnJvbUxpbmU6IHBhdGhGcm9tTGluZSxcbiAgICAgICAgICBsaW5lUGF0aHM6IGxpbmVQYXRocyxcbiAgICAgICAgICBsaW5lUGF0aDogbGluZVBhdGgsXG4gICAgICAgICAgYXJlYVBhdGg6IGFyZWFQYXRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVNYXJrZXJzQW5kTGFiZWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1hcmtlcnNBbmRMYWJlbHMoX3JlZjQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgICAgICAgICAgcG9pbnRzUG9zID0gX3JlZjQucG9pbnRzUG9zLFxuICAgICAgICAgICAgaXNSYW5nZVN0YXJ0ID0gX3JlZjQuaXNSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgaSA9IF9yZWY0LmksXG4gICAgICAgICAgICBqID0gX3JlZjQuaixcbiAgICAgICAgICAgIHJlYWxJbmRleCA9IF9yZWY0LnJlYWxJbmRleDtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzID0gbmV3IERhdGFMYWJlbHModGhpcy5jdHgpO1xuXG4gICAgICAgIGlmICghdGhpcy5wb2ludHNDaGFydCkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzW2ldLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZWxQb2ludHNNYWluLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1lbGVtZW50LWhpZGRlbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbFBvaW50c1dyYXAgPSB0aGlzLm1hcmtlcnMucGxvdENoYXJ0TWFya2Vycyhwb2ludHNQb3MsIHJlYWxJbmRleCwgaiArIDEpO1xuXG4gICAgICAgICAgaWYgKGVsUG9pbnRzV3JhcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbFBvaW50c01haW4uYWRkKGVsUG9pbnRzV3JhcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNjYXR0ZXIgLyBidWJibGUgY2hhcnQgcG9pbnRzIGNyZWF0aW9uXG4gICAgICAgICAgdGhpcy5zY2F0dGVyLmRyYXcodGhpcy5lbFNlcmllcywgaiwge1xuICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICBwb2ludHNQb3M6IHBvaW50c1BvcyxcbiAgICAgICAgICAgIHpSYXRpbzogdGhpcy56UmF0aW8sXG4gICAgICAgICAgICBlbFBhcmVudDogdGhpcy5lbFBvaW50c01haW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmF3bkxhYmVscyA9IGRhdGFMYWJlbHMuZHJhd0RhdGFMYWJlbCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBpc1JhbmdlU3RhcnQ6IGlzUmFuZ2VTdGFydCxcbiAgICAgICAgICBwb3M6IHBvaW50c1BvcyxcbiAgICAgICAgICBpOiByZWFsSW5kZXgsXG4gICAgICAgICAgajogaiArIDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRyYXduTGFiZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5lbERhdGFMYWJlbHNXcmFwLmFkZChkcmF3bkxhYmVscyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NyZWF0ZVBhdGhzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVBhdGhzKF9yZWY1KSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjUudHlwZSxcbiAgICAgICAgICAgIHNlcmllcyA9IF9yZWY1LnNlcmllcyxcbiAgICAgICAgICAgIGkgPSBfcmVmNS5pLFxuICAgICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjUucmVhbEluZGV4LFxuICAgICAgICAgICAgaiA9IF9yZWY1LmosXG4gICAgICAgICAgICB4ID0gX3JlZjUueCxcbiAgICAgICAgICAgIHkgPSBfcmVmNS55LFxuICAgICAgICAgICAgeEFycmogPSBfcmVmNS54QXJyaixcbiAgICAgICAgICAgIHlBcnJqID0gX3JlZjUueUFycmosXG4gICAgICAgICAgICB5MiA9IF9yZWY1LnkyLFxuICAgICAgICAgICAgeTJBcnJqID0gX3JlZjUueTJBcnJqLFxuICAgICAgICAgICAgbGluZVBhdGggPSBfcmVmNS5saW5lUGF0aCxcbiAgICAgICAgICAgIGFyZWFQYXRoID0gX3JlZjUuYXJlYVBhdGgsXG4gICAgICAgICAgICBsaW5lUGF0aHMgPSBfcmVmNS5saW5lUGF0aHMsXG4gICAgICAgICAgICBhcmVhUGF0aHMgPSBfcmVmNS5hcmVhUGF0aHMsXG4gICAgICAgICAgICBzZXJpZXNJbmRleCA9IF9yZWY1LnNlcmllc0luZGV4LFxuICAgICAgICAgICAgaXNSYW5nZVN0YXJ0ID0gX3JlZjUuaXNSYW5nZVN0YXJ0O1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGN1cnZlID0gdy5jb25maWcuc3Ryb2tlLmN1cnZlO1xuICAgICAgICB2YXIgYXJlYUJvdHRvbVkgPSB0aGlzLmFyZWFCb3R0b21ZO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS5jdXJ2ZSkpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXJpZXNJbmRleCkpIHtcbiAgICAgICAgICAgIGN1cnZlID0gdy5jb25maWcuc3Ryb2tlLmN1cnZlW3Nlcmllc0luZGV4W2ldXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VydmUgPSB3LmNvbmZpZy5zdHJva2UuY3VydmVbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYW5nZUFyZWEnICYmICh3Lmdsb2JhbHMuaGFzTnVsbFZhbHVlcyB8fCB3LmNvbmZpZy5mb3JlY2FzdERhdGFQb2ludHMuY291bnQgPiAwKSAmJiBjdXJ2ZSA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgICBjdXJ2ZSA9ICdzdHJhaWdodCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VydmUgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgICAgdmFyIHNob3VsZFJlbmRlck1vbm90b25lID0gdHlwZSA9PT0gJ3JhbmdlQXJlYScgPyB4QXJyai5sZW5ndGggPT09IHcuZ2xvYmFscy5kYXRhUG9pbnRzIDogaiA9PT0gc2VyaWVzW2ldLmxlbmd0aCAtIDI7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkUmVuZGVyTW9ub3RvbmUpIHtcbiAgICAgICAgICAgIHZhciBzbW9vdGhJbnB1dHMgPSB4QXJyai5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFt4QXJyaltpXSwgeUFycmpbaV1dO1xuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfWzFdICE9PSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc3BsaW5lLnBvaW50cyhzbW9vdGhJbnB1dHMpO1xuICAgICAgICAgICAgbGluZVBhdGggKz0gc3ZnUGF0aChwb2ludHMpO1xuXG4gICAgICAgICAgICBpZiAoc2VyaWVzW2ldWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBkYXRhUG9pbnQgaXMgbnVsbCwgd2UgdXNlIHRoZSBsaW5lUGF0aCBkaXJlY3RseVxuICAgICAgICAgICAgICBhcmVhUGF0aCA9IGxpbmVQYXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZWxzZSwgd2UgYXBwZW5kIHRoZSBhcmVhUGF0aFxuICAgICAgICAgICAgICBhcmVhUGF0aCArPSBzdmdQYXRoKHBvaW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAncmFuZ2VBcmVhJyAmJiBpc1JhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgbGluZSB0byBjb25uZWN0IHkgd2l0aCB5MjsgdGhlbiBkcmF3IHRoZSBvdGhlciBlbmQgb2YgcmFuZ2VcbiAgICAgICAgICAgICAgbGluZVBhdGggKz0gZ3JhcGhpY3MubGluZSh4QXJyalt4QXJyai5sZW5ndGggLSAxXSwgeTJBcnJqW3kyQXJyai5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgIHZhciB4QXJyakludmVyc2VkID0geEFycmouc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgIHZhciB5MkFycmpJbnZlcnNlZCA9IHkyQXJyai5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgdmFyIHNtb290aElucHV0c1kyID0geEFycmpJbnZlcnNlZC5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3hBcnJqSW52ZXJzZWRbaV0sIHkyQXJyakludmVyc2VkW2ldXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBwb2ludHNZMiA9IHNwbGluZS5wb2ludHMoc21vb3RoSW5wdXRzWTIpO1xuICAgICAgICAgICAgICBsaW5lUGF0aCArPSBzdmdQYXRoKHBvaW50c1kyKTsgLy8gaW4gcmFuZ2UgYXJlYSwgd2UgZG9uJ3QgaGF2ZSBzZXBhcmF0ZSBsaW5lIGFuZCBhcmVhIHBhdGhcblxuICAgICAgICAgICAgICBhcmVhUGF0aCA9IGxpbmVQYXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJlYVBhdGggKz0gZ3JhcGhpY3MubGluZShzbW9vdGhJbnB1dHNbc21vb3RoSW5wdXRzLmxlbmd0aCAtIDFdWzBdLCBhcmVhQm90dG9tWSkgKyBncmFwaGljcy5saW5lKHNtb290aElucHV0c1swXVswXSwgYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubW92ZShzbW9vdGhJbnB1dHNbMF1bMF0sIHNtb290aElucHV0c1swXVsxXSkgKyAneic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVQYXRocy5wdXNoKGxpbmVQYXRoKTtcbiAgICAgICAgICAgIGFyZWFQYXRocy5wdXNoKGFyZWFQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlcmllc1tpXVtqICsgMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxpbmVQYXRoID0gbGluZVBhdGggKyBncmFwaGljcy5tb3ZlKHgsIHkpO1xuICAgICAgICAgICAgdmFyIG51bWVyaWNPckNhdFggPSB3Lmdsb2JhbHMuaXNYTnVtZXJpYyA/ICh3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdW2pdIC0gdy5nbG9iYWxzLm1pblgpIC8gdGhpcy54UmF0aW8gOiB4IC0gdGhpcy54RGl2aXNpb247XG4gICAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubGluZShudW1lcmljT3JDYXRYLCBhcmVhQm90dG9tWSkgKyBncmFwaGljcy5tb3ZlKHgsIHkpICsgJ3onO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxpbmVQYXRoID0gbGluZVBhdGggKyBncmFwaGljcy5tb3ZlKHgsIHkpO1xuICAgICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLm1vdmUoeCwgYXJlYUJvdHRvbVkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJ2ZSA9PT0gJ3N0ZXBsaW5lJykge1xuICAgICAgICAgICAgbGluZVBhdGggPSBsaW5lUGF0aCArIGdyYXBoaWNzLmxpbmUoeCwgbnVsbCwgJ0gnKSArIGdyYXBoaWNzLmxpbmUobnVsbCwgeSwgJ1YnKTtcbiAgICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5saW5lKHgsIG51bGwsICdIJykgKyBncmFwaGljcy5saW5lKG51bGwsIHksICdWJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJ2ZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgICAgICAgbGluZVBhdGggPSBsaW5lUGF0aCArIGdyYXBoaWNzLmxpbmUoeCwgeSk7XG4gICAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubGluZSh4LCB5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA9PT0gc2VyaWVzW2ldLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgIC8vIGxhc3QgbG9vcCwgY2xvc2UgcGF0aFxuICAgICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLmxpbmUoeCwgYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubW92ZSh4LCB5KSArICd6JztcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdyYW5nZUFyZWEnICYmIGlzUmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MubGluZSh4LCB5MikgKyBncmFwaGljcy5tb3ZlKHgsIHkyKSArICd6JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxpbmVQYXRocy5wdXNoKGxpbmVQYXRoKTtcbiAgICAgICAgICAgICAgYXJlYVBhdGhzLnB1c2goYXJlYVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZVBhdGhzOiBsaW5lUGF0aHMsXG4gICAgICAgICAgYXJlYVBhdGhzOiBhcmVhUGF0aHMsXG4gICAgICAgICAgbGluZVBhdGg6IGxpbmVQYXRoLFxuICAgICAgICAgIGFyZWFQYXRoOiBhcmVhUGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVOdWxsRGF0YVBvaW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU51bGxEYXRhUG9pbnRzKHNlcmllcywgcG9pbnRzUG9zLCBpLCBqLCByZWFsSW5kZXgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgaWYgKHNlcmllc1tpXVtqXSA9PT0gbnVsbCAmJiB3LmNvbmZpZy5tYXJrZXJzLnNob3dOdWxsRGF0YVBvaW50cyB8fCBzZXJpZXNbaV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gZml4ZXMgYXBleGNoYXJ0cy5qcyMxMjgyLCAjMTI1MlxuICAgICAgICAgIHZhciBlbFBvaW50c1dyYXAgPSB0aGlzLm1hcmtlcnMucGxvdENoYXJ0TWFya2Vycyhwb2ludHNQb3MsIHJlYWxJbmRleCwgaiArIDEsIHRoaXMuc3Ryb2tlV2lkdGggLSB3LmNvbmZpZy5tYXJrZXJzLnN0cm9rZVdpZHRoIC8gMiwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoZWxQb2ludHNXcmFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVsUG9pbnRzTWFpbi5hZGQoZWxQb2ludHNXcmFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGluZTtcbiAgfSgpO1xuXG4gIC8qXG4gICAqIHRyZWVtYXAtc3F1YXJpZnkuanMgLSBvcGVuIHNvdXJjZSBpbXBsZW1lbnRhdGlvbiBvZiBzcXVhcmlmaWVkIHRyZWVtYXBzXG4gICAqXG4gICAqIFRyZWVtYXAgU3F1YXJlZCAwLjUgLSBUcmVlbWFwIENoYXJ0aW5nIGxpYnJhcnlcbiAgICpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ltcmFuZ2hvcnkvdHJlZW1hcC1zcXVhcmVkL1xuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTIgSW1yYW4gR2hvcnkgKGltcmFuZ2hvcnlAZ21haWwuY29tKVxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocCkgbGljZW5zZS5cbiAgICpcbiAgICpcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNxdWFyaWZ5IHRyZWVtYXAgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbjpcbiAgICpcbiAgICogQnJ1bHMsIE1hcms7IEh1aXppbmcsIEtlZXM7IHZhbiBXaWprLCBKYXJrZSBKLiAoMjAwMCksIFwiU3F1YXJpZmllZCB0cmVlbWFwc1wiXG4gICAqIGluIGRlIExlZXV3LCBXLjsgdmFuIExpZXJlLCBSLiwgRGF0YSBWaXN1YWxpemF0aW9uIDIwMDA6XG4gICAqIFByb2MuIEpvaW50IEV1cm9ncmFwaGljcyBhbmQgSUVFRSBUQ1ZHIFN5bXAuIG9uIFZpc3VhbGl6YXRpb24sIFNwcmluZ2VyLVZlcmxhZywgcHAuIDMz4oCTNDIuXG4gICAqXG4gICAqIFBhcGVyIGlzIGF2YWlsYWJsZSBvbmxpbmUgYXQ6IGh0dHA6Ly93d3cud2luLnR1ZS5ubC9+dmFud2lqay9zdG0ucGRmXG4gICAqXG4gICAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBjb21wbGV0ZWxleSBkZWNvdXBsZWQgZnJvbSB0aGUgZHJhd2luZyBjb2RlIHNvIGl0IHNob3VsZCBiZSB0cml2aWFsXG4gICAqIHRvIHBvcnQgaXQgdG8gYW55IG90aGVyIHZlY3RvciBkcmF3aW5nIGxpYnJhcnkuIEdpdmVuIGFuIGFycmF5IG9mIGRhdGFwb2ludHMgdGhpcyBsaWJyYXJ5IHJldHVybnNcbiAgICogYW4gYXJyYXkgb2YgY2FydGVzaWFuIGNvb3JkaW5hdGVzIHRoYXQgcmVwcmVzZW50IHRoZSByZWN0YW5nbGVzIHRoYXQgbWFrZSB1cCB0aGUgdHJlZW1hcC5cbiAgICpcbiAgICogVGhlIGxpYnJhcnkgYWxzbyBzdXBwb3J0cyBtdWx0aWRpbWVuc2lvbmFsIGRhdGEgKG5lc3RlZCB0cmVlbWFwcykgYW5kIHBlcmZvcm1zIG5vcm1hbGl6YXRpb24gb24gdGhlIGRhdGEuXG4gICAqXG4gICAqIFNlZSB0aGUgUkVBRE1FIGZpbGUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHdpbmRvdy5UcmVlbWFwU3F1YXJlZCA9IHt9O1xuXG4gIChmdW5jdGlvbiAoKSB7XG5cbiAgICB3aW5kb3cuVHJlZW1hcFNxdWFyZWQuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb250YWluZXIoeG9mZnNldCwgeW9mZnNldCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnhvZmZzZXQgPSB4b2Zmc2V0OyAvLyBvZmZzZXQgZnJvbSB0aGUgdGhlIHRvcCBsZWZ0IGhhbmQgY29ybmVyXG5cbiAgICAgICAgdGhpcy55b2Zmc2V0ID0geW9mZnNldDsgLy8gZGl0dG9cblxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuXG4gICAgICAgIHRoaXMuc2hvcnRlc3RFZGdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmhlaWdodCwgdGhpcy53aWR0aCk7XG4gICAgICAgIH07IC8vIGdldENvb3JkaW5hdGVzIC0gZm9yIGEgcm93IG9mIGJveGVzIHdoaWNoIHdlJ3ZlIHBsYWNlZFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHJldHVybiBhbiBhcnJheSBvZiB0aGVpciBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXNcblxuXG4gICAgICAgIHRoaXMuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gW107XG4gICAgICAgICAgdmFyIHN1YnhvZmZzZXQgPSB0aGlzLnhvZmZzZXQsXG4gICAgICAgICAgICAgIHN1YnlvZmZzZXQgPSB0aGlzLnlvZmZzZXQ7IC8vb3VyIG9mZnNldCB3aXRoaW4gdGhlIGNvbnRhaW5lclxuXG4gICAgICAgICAgdmFyIGFyZWF3aWR0aCA9IHN1bUFycmF5KHJvdykgLyB0aGlzLmhlaWdodDtcbiAgICAgICAgICB2YXIgYXJlYWhlaWdodCA9IHN1bUFycmF5KHJvdykgLyB0aGlzLndpZHRoO1xuICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgaWYgKHRoaXMud2lkdGggPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29vcmRpbmF0ZXMucHVzaChbc3VieG9mZnNldCwgc3VieW9mZnNldCwgc3VieG9mZnNldCArIGFyZWF3aWR0aCwgc3VieW9mZnNldCArIHJvd1tpXSAvIGFyZWF3aWR0aF0pO1xuICAgICAgICAgICAgICBzdWJ5b2Zmc2V0ID0gc3VieW9mZnNldCArIHJvd1tpXSAvIGFyZWF3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKFtzdWJ4b2Zmc2V0LCBzdWJ5b2Zmc2V0LCBzdWJ4b2Zmc2V0ICsgcm93W2ldIC8gYXJlYWhlaWdodCwgc3VieW9mZnNldCArIGFyZWFoZWlnaHRdKTtcbiAgICAgICAgICAgICAgc3VieG9mZnNldCA9IHN1YnhvZmZzZXQgKyByb3dbaV0gLyBhcmVhaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgICAgICAgfTsgLy8gY3V0QXJlYSAtIG9uY2Ugd2UndmUgcGxhY2VkIHNvbWUgYm94ZXMgaW50byBhbiByb3cgd2UgdGhlbiBuZWVkIHRvIGlkZW50aWZ5IHRoZSByZW1haW5pbmcgYXJlYSxcbiAgICAgICAgLy8gICAgICAgICAgIHRoaXMgZnVuY3Rpb24gdGFrZXMgdGhlIGFyZWEgb2YgdGhlIGJveGVzIHdlJ3ZlIHBsYWNlZCBhbmQgY2FsY3VsYXRlcyB0aGUgbG9jYXRpb24gYW5kXG4gICAgICAgIC8vICAgICAgICAgICBkaW1lbnNpb25zIG9mIHRoZSByZW1haW5pbmcgc3BhY2UgYW5kIHJldHVybnMgYSBjb250YWluZXIgYm94IGRlZmluZWQgYnkgdGhlIHJlbWFpbmluZyBhcmVhXG5cblxuICAgICAgICB0aGlzLmN1dEFyZWEgPSBmdW5jdGlvbiAoYXJlYSkge1xuICAgICAgICAgIHZhciBuZXdjb250YWluZXI7XG5cbiAgICAgICAgICBpZiAodGhpcy53aWR0aCA+PSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGFyZWF3aWR0aCA9IGFyZWEgLyB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBuZXd3aWR0aCA9IHRoaXMud2lkdGggLSBhcmVhd2lkdGg7XG4gICAgICAgICAgICBuZXdjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKHRoaXMueG9mZnNldCArIGFyZWF3aWR0aCwgdGhpcy55b2Zmc2V0LCBuZXd3aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJlYWhlaWdodCA9IGFyZWEgLyB0aGlzLndpZHRoO1xuICAgICAgICAgICAgdmFyIG5ld2hlaWdodCA9IHRoaXMuaGVpZ2h0IC0gYXJlYWhlaWdodDtcbiAgICAgICAgICAgIG5ld2NvbnRhaW5lciA9IG5ldyBDb250YWluZXIodGhpcy54b2Zmc2V0LCB0aGlzLnlvZmZzZXQgKyBhcmVhaGVpZ2h0LCB0aGlzLndpZHRoLCBuZXdoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXdjb250YWluZXI7XG4gICAgICAgIH07XG4gICAgICB9IC8vIG5vcm1hbGl6ZSAtIHRoZSBCcnVscyBhbGdvcml0aG0gYXNzdW1lcyB3ZSdyZSBwYXNzaW5nIGluIGFyZWFzIHRoYXQgbmljZWx5IGZpdCBpbnRvIG91clxuICAgICAgLy8gICAgICAgICAgICAgY29udGFpbmVyIGJveCwgdGhpcyBtZXRob2QgdGFrZXMgb3VyIHJhdyBkYXRhIGFuZCBub3JtYWxpemVzIHRoZSBkYXRhIHZhbHVlcyBpbnRvXG4gICAgICAvLyAgICAgICAgICAgICBhcmVhIHZhbHVlcyBzbyB0aGF0IHRoaXMgYXNzdW1wdGlvbiBpcyB2YWxpZC5cblxuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemUoZGF0YSwgYXJlYSkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZGRhdGEgPSBbXTtcbiAgICAgICAgdmFyIHN1bSA9IHN1bUFycmF5KGRhdGEpO1xuICAgICAgICB2YXIgbXVsdGlwbGllciA9IGFyZWEgLyBzdW07XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9ybWFsaXplZGRhdGFbaV0gPSBkYXRhW2ldICogbXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkZGF0YTtcbiAgICAgIH0gLy8gdHJlZW1hcE11bHRpZGltZW5zaW9uYWwgLSB0YWtlcyBtdWx0aWRpbWVuc2lvbmFsIGRhdGEgKGFrYSBbWzIzLDExXSxbMTEsMzJdXSAtIG5lc3RlZCBhcnJheSlcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiB1c2luZyB0cmVlbWFwU2luZ2xlZGltZW5zaW9uYWxcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gY3JlYXRlIGEgcGF0Y2h3b3JrIG9mIHRyZWVtYXBzIGFuZCBtZXJnZSB0aGVtXG5cblxuICAgICAgZnVuY3Rpb24gdHJlZW1hcE11bHRpZGltZW5zaW9uYWwoZGF0YSwgd2lkdGgsIGhlaWdodCwgeG9mZnNldCwgeW9mZnNldCkge1xuICAgICAgICB4b2Zmc2V0ID0gdHlwZW9mIHhvZmZzZXQgPT09ICd1bmRlZmluZWQnID8gMCA6IHhvZmZzZXQ7XG4gICAgICAgIHlvZmZzZXQgPSB0eXBlb2YgeW9mZnNldCA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogeW9mZnNldDtcbiAgICAgICAgdmFyIG1lcmdlZGRhdGEgPSBbXTtcbiAgICAgICAgdmFyIG1lcmdlZHRyZWVtYXA7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGlmIChpc0FycmF5KGRhdGFbMF0pKSB7XG4gICAgICAgICAgLy8gaWYgd2UndmUgZ290IG1vcmUgZGltZW5zaW9ucyBvZiBkZXB0aFxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtZXJnZWRkYXRhW2ldID0gc3VtTXVsdGlkaW1lbnNpb25hbEFycmF5KGRhdGFbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1lcmdlZHRyZWVtYXAgPSB0cmVlbWFwU2luZ2xlZGltZW5zaW9uYWwobWVyZ2VkZGF0YSwgd2lkdGgsIGhlaWdodCwgeG9mZnNldCwgeW9mZnNldCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRyZWVtYXBNdWx0aWRpbWVuc2lvbmFsKGRhdGFbaV0sIG1lcmdlZHRyZWVtYXBbaV1bMl0gLSBtZXJnZWR0cmVlbWFwW2ldWzBdLCBtZXJnZWR0cmVlbWFwW2ldWzNdIC0gbWVyZ2VkdHJlZW1hcFtpXVsxXSwgbWVyZ2VkdHJlZW1hcFtpXVswXSwgbWVyZ2VkdHJlZW1hcFtpXVsxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRzID0gdHJlZW1hcFNpbmdsZWRpbWVuc2lvbmFsKGRhdGEsIHdpZHRoLCBoZWlnaHQsIHhvZmZzZXQsIHlvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9IC8vIHRyZWVtYXBTaW5nbGVkaW1lbnNpb25hbCAtIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCBzcXVhcmlmeVxuXG5cbiAgICAgIGZ1bmN0aW9uIHRyZWVtYXBTaW5nbGVkaW1lbnNpb25hbChkYXRhLCB3aWR0aCwgaGVpZ2h0LCB4b2Zmc2V0LCB5b2Zmc2V0KSB7XG4gICAgICAgIHhvZmZzZXQgPSB0eXBlb2YgeG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogeG9mZnNldDtcbiAgICAgICAgeW9mZnNldCA9IHR5cGVvZiB5b2Zmc2V0ID09PSAndW5kZWZpbmVkJyA/IDAgOiB5b2Zmc2V0O1xuICAgICAgICB2YXIgcmF3dHJlZW1hcCA9IHNxdWFyaWZ5KG5vcm1hbGl6ZShkYXRhLCB3aWR0aCAqIGhlaWdodCksIFtdLCBuZXcgQ29udGFpbmVyKHhvZmZzZXQsIHlvZmZzZXQsIHdpZHRoLCBoZWlnaHQpLCBbXSk7XG4gICAgICAgIHJldHVybiBmbGF0dGVuVHJlZW1hcChyYXd0cmVlbWFwKTtcbiAgICAgIH0gLy8gZmxhdHRlblRyZWVtYXAgLSBzcXVhcmlmeSBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIGFycmF5cyBvZiBjb29yZGluYXRlc1xuICAgICAgLy8gICAgICAgICAgICAgICAgICBiZWNhdXNlIHdlIGhhdmUgYSBuZXcgYXJyYXkgZXZlcnl0aW1lIHdlIHN3aXRjaCB0byBidWlsZGluZyBhIG5ldyByb3dcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgdGhpcyBjb252ZXJ0cyBpdCBpbnRvIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVzLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGZsYXR0ZW5UcmVlbWFwKHJhd3RyZWVtYXApIHtcbiAgICAgICAgdmFyIGZsYXR0cmVlbWFwID0gW107XG4gICAgICAgIHZhciBpLCBqO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYXd0cmVlbWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHJhd3RyZWVtYXBbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZsYXR0cmVlbWFwLnB1c2gocmF3dHJlZW1hcFtpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZsYXR0cmVlbWFwO1xuICAgICAgfSAvLyBzcXVhcmlmeSAgLSBhcyBwZXIgdGhlIEJydWxzIHBhcGVyXG4gICAgICAvLyAgICAgICAgICAgICBwbHVzIGNvb3JkaW5hdGVzIHN0YWNrIGFuZCBjb250YWluZXJzIHNvIHdlIGdldFxuICAgICAgLy8gICAgICAgICAgICAgdXNhYmxlIGRhdGEgb3V0IG9mIGl0XG5cblxuICAgICAgZnVuY3Rpb24gc3F1YXJpZnkoZGF0YSwgY3VycmVudHJvdywgY29udGFpbmVyLCBzdGFjaykge1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICB2YXIgbmV4dGRhdGFwb2ludDtcbiAgICAgICAgdmFyIG5ld2NvbnRhaW5lcjtcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGNvbnRhaW5lci5nZXRDb29yZGluYXRlcyhjdXJyZW50cm93KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gY29udGFpbmVyLnNob3J0ZXN0RWRnZSgpO1xuICAgICAgICBuZXh0ZGF0YXBvaW50ID0gZGF0YVswXTtcblxuICAgICAgICBpZiAoaW1wcm92ZXNSYXRpbyhjdXJyZW50cm93LCBuZXh0ZGF0YXBvaW50LCBsZW5ndGgpKSB7XG4gICAgICAgICAgY3VycmVudHJvdy5wdXNoKG5leHRkYXRhcG9pbnQpO1xuICAgICAgICAgIHNxdWFyaWZ5KGRhdGEuc2xpY2UoMSksIGN1cnJlbnRyb3csIGNvbnRhaW5lciwgc3RhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld2NvbnRhaW5lciA9IGNvbnRhaW5lci5jdXRBcmVhKHN1bUFycmF5KGN1cnJlbnRyb3cpLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2sucHVzaChjb250YWluZXIuZ2V0Q29vcmRpbmF0ZXMoY3VycmVudHJvdykpO1xuICAgICAgICAgIHNxdWFyaWZ5KGRhdGEsIFtdLCBuZXdjb250YWluZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgIH0gLy8gaW1wcm92ZVJhdGlvIC0gaW1wbGVtZW50cyB0aGUgd29yc2UgY2FsY3VsYXRpb24gYW5kIGNvbXBhcmlzaW9uIGFzIGdpdmVuIGluIEJydWxzXG4gICAgICAvLyAgICAgICAgICAgICAgICAobm90ZSB0aGUgZXJyb3IgaW4gdGhlIG9yaWdpbmFsIHBhcGVyOyBmaXhlZCBoZXJlKVxuXG5cbiAgICAgIGZ1bmN0aW9uIGltcHJvdmVzUmF0aW8oY3VycmVudHJvdywgbmV4dG5vZGUsIGxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3cm93O1xuXG4gICAgICAgIGlmIChjdXJyZW50cm93Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3cm93ID0gY3VycmVudHJvdy5zbGljZSgpO1xuICAgICAgICBuZXdyb3cucHVzaChuZXh0bm9kZSk7XG4gICAgICAgIHZhciBjdXJyZW50cmF0aW8gPSBjYWxjdWxhdGVSYXRpbyhjdXJyZW50cm93LCBsZW5ndGgpO1xuICAgICAgICB2YXIgbmV3cmF0aW8gPSBjYWxjdWxhdGVSYXRpbyhuZXdyb3csIGxlbmd0aCk7IC8vIHRoZSBwc2V1ZG9jb2RlIGluIHRoZSBCcnVscyBwYXBlciBoYXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgY29tcGFyaXNvblxuICAgICAgICAvLyB3cm9uZywgdGhpcyBpcyB0aGUgY29ycmVjdCBvbmUuXG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRyYXRpbyA+PSBuZXdyYXRpbztcbiAgICAgIH0gLy8gY2FsY3VsYXRlUmF0aW8gLSBjYWxjdWxhdGVzIHRoZSBtYXhpbXVtIHdpZHRoIHRvIGhlaWdodCByYXRpbyBvZiB0aGVcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgYm94ZXMgaW4gdGhpcyByb3dcblxuXG4gICAgICBmdW5jdGlvbiBjYWxjdWxhdGVSYXRpbyhyb3csIGxlbmd0aCkge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgcm93KTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJvdyk7XG4gICAgICAgIHZhciBzdW0gPSBzdW1BcnJheShyb3cpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5wb3cobGVuZ3RoLCAyKSAqIG1heCAvIE1hdGgucG93KHN1bSwgMiksIE1hdGgucG93KHN1bSwgMikgLyAoTWF0aC5wb3cobGVuZ3RoLCAyKSAqIG1pbikpO1xuICAgICAgfSAvLyBpc0FycmF5IC0gY2hlY2tzIGlmIGFyciBpcyBhbiBhcnJheVxuXG5cbiAgICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIgJiYgYXJyLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICAgIH0gLy8gc3VtQXJyYXkgLSBzdW1zIGEgc2luZ2xlIGRpbWVuc2lvbmFsIGFycmF5XG5cblxuICAgICAgZnVuY3Rpb24gc3VtQXJyYXkoYXJyKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3VtICs9IGFycltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgICB9IC8vIHN1bU11bHRpZGltZW5zaW9uYWxBcnJheSAtIHN1bXMgdGhlIHZhbHVlcyBpbiBhIG5lc3RlZCBhcnJheSAoYWthIFtbMCwxXSxbWzIsM11dXSlcblxuXG4gICAgICBmdW5jdGlvbiBzdW1NdWx0aWRpbWVuc2lvbmFsQXJyYXkoYXJyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdG90YWwgPSAwO1xuXG4gICAgICAgIGlmIChpc0FycmF5KGFyclswXSkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBzdW1NdWx0aWRpbWVuc2lvbmFsQXJyYXkoYXJyW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWwgPSBzdW1BcnJheShhcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJlZW1hcE11bHRpZGltZW5zaW9uYWw7XG4gICAgfSgpO1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIFRyZWVtYXBDaGFydCBDbGFzcy5cbiAgICogQG1vZHVsZSBUcmVlbWFwQ2hhcnRcbiAgICoqL1xuXG4gIHZhciBUcmVlbWFwQ2hhcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyZWVtYXBDaGFydChjdHgsIHh5UmF0aW9zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZW1hcENoYXJ0KTtcblxuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICB0aGlzLncgPSBjdHgudztcbiAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB0aGlzLncuY29uZmlnLnN0cm9rZS53aWR0aDtcbiAgICAgIHRoaXMuaGVscGVycyA9IG5ldyBUcmVlbWFwSGVscGVycyhjdHgpO1xuICAgICAgdGhpcy5keW5hbWljQW5pbSA9IHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uO1xuICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJlZW1hcENoYXJ0LCBbe1xuICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtdHJlZW1hcCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMubm9EYXRhKSByZXR1cm4gcmV0O1xuICAgICAgICB2YXIgc2VyID0gW107XG4gICAgICAgIHNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgdmFyIGQgPSBzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlci5wdXNoKGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uZWdSYW5nZSA9IHRoaXMuaGVscGVycy5jaGVja0NvbG9yUmFuZ2UoKTtcbiAgICAgICAgdy5jb25maWcuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICBzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KF90aGlzLmxhYmVsc1tpXSkpIF90aGlzLmxhYmVsc1tpXSA9IFtdO1xuXG4gICAgICAgICAgICBfdGhpcy5sYWJlbHNbaV0ucHVzaChsLngpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5vZGVzID0gd2luZG93LlRyZWVtYXBTcXVhcmVkLmdlbmVyYXRlKHNlciwgdy5nbG9iYWxzLmdyaWRXaWR0aCwgdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgYXBleGNoYXJ0cy10cmVlbWFwLXNlcmllc1wiLFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogVXRpbHMkMS5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW2ldKSxcbiAgICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiBpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnMoX3RoaXMuY3R4KTtcbiAgICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhyZXQsIHNoYWRvdywgaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVsRGF0YUxhYmVsV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhLWxhYmVscydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBub2RlLmZvckVhY2goZnVuY3Rpb24gKHIsIGopIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHJbMF07XG4gICAgICAgICAgICB2YXIgeTEgPSByWzFdO1xuICAgICAgICAgICAgdmFyIHgyID0gclsyXTtcbiAgICAgICAgICAgIHZhciB5MiA9IHJbM107XG4gICAgICAgICAgICB2YXIgZWxSZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxLCAwLCAnI2ZmZicsIDEsIF90aGlzLnN0cm9rZVdpZHRoLCB3LmNvbmZpZy5wbG90T3B0aW9ucy50cmVlbWFwLnVzZUZpbGxDb2xvckFzU3Ryb2tlID8gY29sb3IgOiB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9yc1tpXSk7XG4gICAgICAgICAgICBlbFJlY3QuYXR0cih7XG4gICAgICAgICAgICAgIGN4OiB4MSxcbiAgICAgICAgICAgICAgY3k6IHkxLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgd2lkdGg6IHgyIC0geDEsXG4gICAgICAgICAgICAgIGhlaWdodDogeTIgLSB5MVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvclByb3BzID0gX3RoaXMuaGVscGVycy5nZXRTaGFkZUNvbG9yKHcuY29uZmlnLmNoYXJ0LnR5cGUsIGksIGosIF90aGlzLm5lZ1JhbmdlKTtcblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JQcm9wcy5jb2xvcjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdy5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0uZmlsbENvbG9yKSB7XG4gICAgICAgICAgICAgIGNvbG9yID0gdy5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0uZmlsbENvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICBzZXJpZXNOdW1iZXI6IGksXG4gICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsUmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdHJlZW1hcC1yZWN0Jyk7XG4gICAgICAgICAgICBlbFJlY3QuYXR0cih7XG4gICAgICAgICAgICAgIGZpbGw6IHBhdGhGaWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX3RoaXMuaGVscGVycy5hZGRMaXN0ZW5lcnMoZWxSZWN0KTtcblxuICAgICAgICAgICAgdmFyIGZyb21SZWN0ID0ge1xuICAgICAgICAgICAgICB4OiB4MSArICh4MiAtIHgxKSAvIDIsXG4gICAgICAgICAgICAgIHk6IHkxICsgKHkyIC0geTEpIC8gMixcbiAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0b1JlY3QgPSB7XG4gICAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgICB5OiB5MSxcbiAgICAgICAgICAgICAgd2lkdGg6IHgyIC0geDEsXG4gICAgICAgICAgICAgIGhlaWdodDogeTIgLSB5MVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHZhciBzcGVlZCA9IDE7XG5cbiAgICAgICAgICAgICAgaWYgKCF3Lmdsb2JhbHMucmVzaXplZCkge1xuICAgICAgICAgICAgICAgIHNwZWVkID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLmFuaW1hdGVUcmVlbWFwKGVsUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgc3BlZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHZhciBfc3BlZWQgPSAxO1xuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5keW5hbWljQW5pbS5lbmFibGVkICYmIHcuZ2xvYmFscy5zaG91bGRBbmltYXRlKSB7XG4gICAgICAgICAgICAgICAgX3NwZWVkID0gX3RoaXMuZHluYW1pY0FuaW0uc3BlZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0ucmVjdCkge1xuICAgICAgICAgICAgICAgICAgZnJvbVJlY3QgPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tpXVtqXS5yZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGVUcmVlbWFwKGVsUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgX3NwZWVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm9udFNpemUgPSBfdGhpcy5nZXRGb250U2l6ZShyKTtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRleHQgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmZvcm1hdHRlcihfdGhpcy5sYWJlbHNbaV1bal0sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHcuZ2xvYmFscy5zZXJpZXNbaV1bal0sXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy50cmVlbWFwLmRhdGFMYWJlbHMuZm9ybWF0ID09PSAndHJ1bmNhdGUnKSB7XG4gICAgICAgICAgICAgIGZvbnRTaXplID0gcGFyc2VJbnQody5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250U2l6ZSwgMTApO1xuICAgICAgICAgICAgICBmb3JtYXR0ZWRUZXh0ID0gX3RoaXMudHJ1bmNhdGVMYWJlbHMoZm9ybWF0dGVkVGV4dCwgZm9udFNpemUsIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGFMYWJlbHMgPSBfdGhpcy5oZWxwZXJzLmNhbGN1bGF0ZURhdGFMYWJlbHMoe1xuICAgICAgICAgICAgICB0ZXh0OiBmb3JtYXR0ZWRUZXh0LFxuICAgICAgICAgICAgICB4OiAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgICAgICB5OiAoeTEgKyB5MikgLyAyICsgX3RoaXMuc3Ryb2tlV2lkdGggLyAyICsgZm9udFNpemUgLyAzLFxuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICBjb2xvclByb3BzOiBjb2xvclByb3BzLFxuICAgICAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCAmJiBkYXRhTGFiZWxzKSB7XG4gICAgICAgICAgICAgIF90aGlzLnJvdGF0ZVRvRml0TGFiZWwoZGF0YUxhYmVscywgZm9udFNpemUsIGZvcm1hdHRlZFRleHQsIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxTZXJpZXMuYWRkKGVsUmVjdCk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhTGFiZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVsU2VyaWVzLmFkZChkYXRhTGFiZWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFNlcmllcy5hZGQoZWxEYXRhTGFiZWxXcmFwKTtcbiAgICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9IC8vIFRoaXMgY2FsY3VsYXRlcyBhIGZvbnQtc2l6ZSBiYXNlZCB1cG9uXG4gICAgICAvLyBhdmVyYWdlIGxhYmVsIGxlbmd0aCBhbmQgdGhlIHNpemUgb2YgdGhlIGJveCB0aGUgbGFiZWwgaXNcbiAgICAgIC8vIGdvaW5nIGludG8uIFRoZSBtYXhpbXVtIGZvbnQgc2l6ZSBpcyBzZXQgaW4gY2hhcnQgY29uZmlnLlxuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEZvbnRTaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udFNpemUoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIHRvdGFsIGxlbmd0aCBvZiBsYWJlbHMgKGkuZSBbW1wiSXRhbHlcIl0sW1wiU3BhaW5cIiwgXCJHcmVlY2VcIl1dIC0+IDE2KVxuXG4gICAgICAgIGZ1bmN0aW9uIHRvdGFsTGFiZWxMZW5ndGgoYXJyKSB7XG4gICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgIHRvdGFsID0gMDtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyclswXSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdG90YWwgKz0gdG90YWxMYWJlbExlbmd0aChhcnJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRvdGFsICs9IGFycltpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9IC8vIGNvdW50IG9mIGxhYmVscyAoaS5lIFtbXCJJdGFseVwiXSxbXCJTcGFpblwiLCBcIkdyZWVjZVwiXV0gLT4gMylcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNvdW50TGFiZWxzKGFycikge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICB0b3RhbCA9IDA7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRvdGFsICs9IGNvdW50TGFiZWxzKGFycltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdG90YWwgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXZlcmFnZWxhYmVsc2l6ZSA9IHRvdGFsTGFiZWxMZW5ndGgodGhpcy5sYWJlbHMpIC8gY291bnRMYWJlbHModGhpcy5sYWJlbHMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZvbnRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAvLyB0aGUgZm9udCBzaXplIHNob3VsZCBiZSBwcm9wb3J0aW9uYWwgdG8gdGhlIHNpemUgb2YgdGhlIGJveCAoYW5kIHRoZSB2YWx1ZSlcbiAgICAgICAgICAvLyBvdGhlcndpc2UgeW91IGNhbiBlbmQgdXAgY3JlYXRpbmcgYSB2aXN1YWwgZGlzdG9ydGlvbiB3aGVyZSB0d28gYm94ZXMgb2YgaWRlbnRpY2FsXG4gICAgICAgICAgLy8gc2l6ZSBoYXZlIGRpZmZlcmVudCBzaXplZCBsYWJlbHMsIGFuZCB0aHVzIG1ha2UgaXQgbG9vayBhcyBpZiB0aGUgdHdvIGJveGVzXG4gICAgICAgICAgLy8gcmVwcmVzZW50IGRpZmZlcmVudCBzaXplc1xuICAgICAgICAgIHZhciBhcmVhID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgICAgdmFyIGFyZWFyb290ID0gTWF0aC5wb3coYXJlYSwgMC41KTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYXJlYXJvb3QgLyBhdmVyYWdlbGFiZWxzaXplLCBwYXJzZUludCh3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmZvbnRTaXplLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvbnRTaXplKGNvb3JkaW5hdGVzWzJdIC0gY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzNdIC0gY29vcmRpbmF0ZXNbMV0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyb3RhdGVUb0ZpdExhYmVsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlVG9GaXRMYWJlbChlbFRleHQsIGZvbnRTaXplLCB0ZXh0LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgdGV4dFJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModGV4dCwgZm9udFNpemUpOyAvL2lmIHRoZSBsYWJlbCBmaXRzIGJldHRlciBzaWRld2F5cyB0aGVuIHJvdGF0ZSBpdFxuXG4gICAgICAgIGlmICh0ZXh0UmVjdC53aWR0aCArIHRoaXMudy5jb25maWcuc3Ryb2tlLndpZHRoICsgNSA+IHgyIC0geDEgJiYgdGV4dFJlY3Qud2lkdGggPD0geTIgLSB5MSkge1xuICAgICAgICAgIHZhciBsYWJlbFJvdGF0aW5nQ2VudGVyID0gZ3JhcGhpY3Mucm90YXRlQXJvdW5kQ2VudGVyKGVsVGV4dC5ub2RlKTtcbiAgICAgICAgICBlbFRleHQubm9kZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKC05MCBcIi5jb25jYXQobGFiZWxSb3RhdGluZ0NlbnRlci54LCBcIiBcIikuY29uY2F0KGxhYmVsUm90YXRpbmdDZW50ZXIueSwgXCIpIHRyYW5zbGF0ZShcIikuY29uY2F0KHRleHRSZWN0LmhlaWdodCAvIDMsIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSBsYWJlbCBmb3JtYXR0aW5nIG1ldGhvZCB0aGF0IHVzZXMgYVxuICAgICAgLy8gY29uc2lzdGVudCBmb250IHNpemUsIGFuZCB0cmltcyB0aGUgZWRnZSBvZiBsb25nIGxhYmVsc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRydW5jYXRlTGFiZWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdHJ1bmNhdGVMYWJlbHModGV4dCwgZm9udFNpemUsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB0ZXh0UmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh0ZXh0LCBmb250U2l6ZSk7IC8vIERldGVybWluZSBtYXggd2lkdGggYmFzZWQgb24gaWRlYWwgb3JpZW50YXRpb24gb2YgdGV4dFxuXG4gICAgICAgIHZhciBsYWJlbE1heFdpZHRoID0gdGV4dFJlY3Qud2lkdGggKyB0aGlzLncuY29uZmlnLnN0cm9rZS53aWR0aCArIDUgPiB4MiAtIHgxICYmIHkyIC0geTEgPiB4MiAtIHgxID8geTIgLSB5MSA6IHgyIC0geDE7XG4gICAgICAgIHZhciB0cnVuY2F0ZWRUZXh0ID0gZ3JhcGhpY3MuZ2V0VGV4dEJhc2VkT25NYXhXaWR0aCh7XG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBtYXhXaWR0aDogbGFiZWxNYXhXaWR0aCxcbiAgICAgICAgICBmb250U2l6ZTogZm9udFNpemVcbiAgICAgICAgfSk7IC8vIFJldHVybiBlbXB0eSBsYWJlbCB3aGVuIHRleHQgaGFzIGJlZW4gdHJpbW1lZCBmb3IgdmVyeSBzbWFsbCByZWN0c1xuXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCAhPT0gdHJ1bmNhdGVkVGV4dC5sZW5ndGggJiYgbGFiZWxNYXhXaWR0aCAvIGZvbnRTaXplIDwgNSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbmltYXRlVHJlZW1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVUcmVlbWFwKGVsLCBmcm9tUmVjdCwgdG9SZWN0LCBzcGVlZCkge1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgYW5pbWF0aW9ucy5hbmltYXRlUmVjdChlbCwge1xuICAgICAgICAgIHg6IGZyb21SZWN0LngsXG4gICAgICAgICAgeTogZnJvbVJlY3QueSxcbiAgICAgICAgICB3aWR0aDogZnJvbVJlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBmcm9tUmVjdC5oZWlnaHRcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHRvUmVjdC54LFxuICAgICAgICAgIHk6IHRvUmVjdC55LFxuICAgICAgICAgIHdpZHRoOiB0b1JlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0b1JlY3QuaGVpZ2h0XG4gICAgICAgIH0sIHNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYW5pbWF0aW9ucy5hbmltYXRpb25Db21wbGV0ZWQoZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVHJlZW1hcENoYXJ0O1xuICB9KCk7XG5cbiAgdmFyIE1JTlVURVNfSU5fREFZID0gMjQgKiA2MDtcbiAgdmFyIFNFQ09ORFNfSU5fREFZID0gTUlOVVRFU19JTl9EQVkgKiA2MDtcbiAgdmFyIE1JTl9aT09NX0RBWVMgPSAxMCAvIFNFQ09ORFNfSU5fREFZO1xuICAvKipcbiAgICogQXBleENoYXJ0cyBUaW1lU2NhbGUgQ2xhc3MgZm9yIGdlbmVyYXRpbmcgdGltZSB0aWNrcyBmb3IgeC1heGlzLlxuICAgKlxuICAgKiBAbW9kdWxlIFRpbWVTY2FsZVxuICAgKiovXG5cbiAgdmFyIFRpbWVTY2FsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZVNjYWxlKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVTY2FsZSk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgICB0aGlzLnRpbWVTY2FsZUFycmF5ID0gW107XG4gICAgICB0aGlzLnV0YyA9IHRoaXMudy5jb25maWcueGF4aXMubGFiZWxzLmRhdGV0aW1lVVRDO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUaW1lU2NhbGUsIFt7XG4gICAgICBrZXk6IFwiY2FsY3VsYXRlVGltZVNjYWxlVGlja3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVUaW1lU2NhbGVUaWNrcyhtaW5YLCBtYXhYKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIG51bGwgY2hlY2sgd2hlbiBubyBzZXJpZXMgdG8gc2hvd1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuYWxsU2VyaWVzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmxhYmVscyA9IFtdO1xuICAgICAgICAgIHcuZ2xvYmFscy50aW1lc2NhbGVMYWJlbHMgPSBbXTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgICB2YXIgZGF5c0RpZmYgPSAobWF4WCAtIG1pblgpIC8gKDEwMDAgKiBTRUNPTkRTX0lOX0RBWSk7XG4gICAgICAgIHRoaXMuZGV0ZXJtaW5lSW50ZXJ2YWwoZGF5c0RpZmYpO1xuICAgICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21JbiA9IGZhbHNlO1xuICAgICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21PdXQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZGF5c0RpZmYgPCBNSU5fWk9PTV9EQVlTKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmRpc2FibGVab29tSW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRheXNEaWZmID4gNTAwMDApIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21PdXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpbWVJbnRlcnZhbHMgPSBkdC5nZXRUaW1lVW5pdHNmcm9tVGltZXN0YW1wKG1pblgsIG1heFgsIHRoaXMudXRjKTtcbiAgICAgICAgdmFyIGRheXNXaWR0aE9uWEF4aXMgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gZGF5c0RpZmY7XG4gICAgICAgIHZhciBob3Vyc1dpZHRoT25YQXhpcyA9IGRheXNXaWR0aE9uWEF4aXMgLyAyNDtcbiAgICAgICAgdmFyIG1pbnV0ZXNXaWR0aE9uWEF4aXMgPSBob3Vyc1dpZHRoT25YQXhpcyAvIDYwO1xuICAgICAgICB2YXIgc2Vjb25kc1dpZHRoT25YQXhpcyA9IG1pbnV0ZXNXaWR0aE9uWEF4aXMgLyA2MDtcbiAgICAgICAgdmFyIG51bWJlck9mSG91cnMgPSBNYXRoLmZsb29yKGRheXNEaWZmICogMjQpO1xuICAgICAgICB2YXIgbnVtYmVyT2ZNaW51dGVzID0gTWF0aC5mbG9vcihkYXlzRGlmZiAqIE1JTlVURVNfSU5fREFZKTtcbiAgICAgICAgdmFyIG51bWJlck9mU2Vjb25kcyA9IE1hdGguZmxvb3IoZGF5c0RpZmYgKiBTRUNPTkRTX0lOX0RBWSk7XG4gICAgICAgIHZhciBudW1iZXJPZkRheXMgPSBNYXRoLmZsb29yKGRheXNEaWZmKTtcbiAgICAgICAgdmFyIG51bWJlck9mTW9udGhzID0gTWF0aC5mbG9vcihkYXlzRGlmZiAvIDMwKTtcbiAgICAgICAgdmFyIG51bWJlck9mWWVhcnMgPSBNYXRoLmZsb29yKGRheXNEaWZmIC8gMzY1KTtcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ge1xuICAgICAgICAgIG1pbk1pbGxpc2Vjb25kOiB0aW1lSW50ZXJ2YWxzLm1pbk1pbGxpc2Vjb25kLFxuICAgICAgICAgIG1pblNlY29uZDogdGltZUludGVydmFscy5taW5TZWNvbmQsXG4gICAgICAgICAgbWluTWludXRlOiB0aW1lSW50ZXJ2YWxzLm1pbk1pbnV0ZSxcbiAgICAgICAgICBtaW5Ib3VyOiB0aW1lSW50ZXJ2YWxzLm1pbkhvdXIsXG4gICAgICAgICAgbWluRGF0ZTogdGltZUludGVydmFscy5taW5EYXRlLFxuICAgICAgICAgIG1pbk1vbnRoOiB0aW1lSW50ZXJ2YWxzLm1pbk1vbnRoLFxuICAgICAgICAgIG1pblllYXI6IHRpbWVJbnRlcnZhbHMubWluWWVhclxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3VycmVudE1pbGxpc2Vjb25kID0gZmlyc3RWYWwubWluTWlsbGlzZWNvbmQ7XG4gICAgICAgIHZhciBjdXJyZW50U2Vjb25kID0gZmlyc3RWYWwubWluU2Vjb25kO1xuICAgICAgICB2YXIgY3VycmVudE1pbnV0ZSA9IGZpcnN0VmFsLm1pbk1pbnV0ZTtcbiAgICAgICAgdmFyIGN1cnJlbnRIb3VyID0gZmlyc3RWYWwubWluSG91cjtcbiAgICAgICAgdmFyIGN1cnJlbnRNb250aERhdGUgPSBmaXJzdFZhbC5taW5EYXRlO1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBmaXJzdFZhbC5taW5EYXRlO1xuICAgICAgICB2YXIgY3VycmVudE1vbnRoID0gZmlyc3RWYWwubWluTW9udGg7XG4gICAgICAgIHZhciBjdXJyZW50WWVhciA9IGZpcnN0VmFsLm1pblllYXI7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgZmlyc3RWYWw6IGZpcnN0VmFsLFxuICAgICAgICAgIGN1cnJlbnRNaWxsaXNlY29uZDogY3VycmVudE1pbGxpc2Vjb25kLFxuICAgICAgICAgIGN1cnJlbnRTZWNvbmQ6IGN1cnJlbnRTZWNvbmQsXG4gICAgICAgICAgY3VycmVudE1pbnV0ZTogY3VycmVudE1pbnV0ZSxcbiAgICAgICAgICBjdXJyZW50SG91cjogY3VycmVudEhvdXIsXG4gICAgICAgICAgY3VycmVudE1vbnRoRGF0ZTogY3VycmVudE1vbnRoRGF0ZSxcbiAgICAgICAgICBjdXJyZW50RGF0ZTogY3VycmVudERhdGUsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBjdXJyZW50TW9udGgsXG4gICAgICAgICAgY3VycmVudFllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICAgIGRheXNXaWR0aE9uWEF4aXM6IGRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgaG91cnNXaWR0aE9uWEF4aXM6IGhvdXJzV2lkdGhPblhBeGlzLFxuICAgICAgICAgIG1pbnV0ZXNXaWR0aE9uWEF4aXM6IG1pbnV0ZXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgc2Vjb25kc1dpZHRoT25YQXhpczogc2Vjb25kc1dpZHRoT25YQXhpcyxcbiAgICAgICAgICBudW1iZXJPZlNlY29uZHM6IG51bWJlck9mU2Vjb25kcyxcbiAgICAgICAgICBudW1iZXJPZk1pbnV0ZXM6IG51bWJlck9mTWludXRlcyxcbiAgICAgICAgICBudW1iZXJPZkhvdXJzOiBudW1iZXJPZkhvdXJzLFxuICAgICAgICAgIG51bWJlck9mRGF5czogbnVtYmVyT2ZEYXlzLFxuICAgICAgICAgIG51bWJlck9mTW9udGhzOiBudW1iZXJPZk1vbnRocyxcbiAgICAgICAgICBudW1iZXJPZlllYXJzOiBudW1iZXJPZlllYXJzXG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnRpY2tJbnRlcnZhbCkge1xuICAgICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVllYXJTY2FsZShwYXJhbXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ21vbnRocyc6XG4gICAgICAgICAgY2FzZSAnaGFsZl95ZWFyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU1vbnRoU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdtb250aHNfZGF5cyc6XG4gICAgICAgICAgY2FzZSAnbW9udGhzX2ZvcnRuaWdodCc6XG4gICAgICAgICAgY2FzZSAnZGF5cyc6XG4gICAgICAgICAgY2FzZSAnd2Vla19kYXlzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZURheVNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlSG91clNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbWludXRlc19maXZlcyc6XG4gICAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlTWludXRlU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2Vjb25kc190ZW5zJzpcbiAgICAgICAgICBjYXNlICdzZWNvbmRzX2ZpdmVzJzpcbiAgICAgICAgICBjYXNlICdzZWNvbmRzJzpcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTZWNvbmRTY2FsZShwYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZmlyc3QsIHdlIHdpbGwgYWRqdXN0IHRoZSBtb250aCB2YWx1ZXMgaW5kZXhcbiAgICAgICAgLy8gYXMgaW4gdGhlIHVwcGVyIGZ1bmN0aW9uLCBpdCBpcyBzdGFydGluZyBmcm9tIDBcbiAgICAgICAgLy8gd2Ugd2lsbCBzdGFydCB0aGVtIGZyb20gMVxuXG5cbiAgICAgICAgdmFyIGFkanVzdGVkTW9udGhJblRpbWVTY2FsZUFycmF5ID0gdGhpcy50aW1lU2NhbGVBcnJheS5tYXAoZnVuY3Rpb24gKHRzKSB7XG4gICAgICAgICAgdmFyIGRlZmF1bHRSZXR1cm4gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogdHMucG9zaXRpb24sXG4gICAgICAgICAgICB1bml0OiB0cy51bml0LFxuICAgICAgICAgICAgeWVhcjogdHMueWVhcixcbiAgICAgICAgICAgIGRheTogdHMuZGF5ID8gdHMuZGF5IDogMSxcbiAgICAgICAgICAgIGhvdXI6IHRzLmhvdXIgPyB0cy5ob3VyIDogMCxcbiAgICAgICAgICAgIG1vbnRoOiB0cy5tb250aCArIDFcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdFJldHVybiksIHt9LCB7XG4gICAgICAgICAgICAgIGRheTogMSxcbiAgICAgICAgICAgICAgdmFsdWU6IHRzLnZhbHVlICsgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0cy51bml0ID09PSAnZGF5JyB8fCB0cy51bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdFJldHVybiksIHt9LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0cy52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0cy51bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0UmV0dXJuKSwge30sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRzLnZhbHVlLFxuICAgICAgICAgICAgICBtaW51dGU6IHRzLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRzLnVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRSZXR1cm4pLCB7fSwge1xuICAgICAgICAgICAgICB2YWx1ZTogdHMudmFsdWUsXG4gICAgICAgICAgICAgIG1pbnV0ZTogdHMubWludXRlLFxuICAgICAgICAgICAgICBzZWNvbmQ6IHRzLnNlY29uZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRzO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpbHRlcmVkVGltZVNjYWxlID0gYWRqdXN0ZWRNb250aEluVGltZVNjYWxlQXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh0cykge1xuICAgICAgICAgIHZhciBtb2R1bG8gPSAxO1xuICAgICAgICAgIHZhciB0aWNrcyA9IE1hdGguY2VpbCh3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTIwKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0cy52YWx1ZTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50aWNrQW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpY2tzID0gdy5jb25maWcueGF4aXMudGlja0Ftb3VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWRqdXN0ZWRNb250aEluVGltZVNjYWxlQXJyYXkubGVuZ3RoID4gdGlja3MpIHtcbiAgICAgICAgICAgIG1vZHVsbyA9IE1hdGguZmxvb3IoYWRqdXN0ZWRNb250aEluVGltZVNjYWxlQXJyYXkubGVuZ3RoIC8gdGlja3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzaG91bGROb3RTa2lwVW5pdCA9IGZhbHNlOyAvLyB0aGVyZSBpcyBhIGJpZyBjaGFuZ2UgaW4gdW5pdCBpLmUgZGF5cyB0byBtb250aHNcblxuICAgICAgICAgIHZhciBzaG91bGROb3RQcmludCA9IGZhbHNlOyAvLyBzaG91bGQgc2tpcCB0aGVzZSB2YWx1ZXNcblxuICAgICAgICAgIHN3aXRjaCAoX3RoaXMudGlja0ludGVydmFsKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFycyc6XG4gICAgICAgICAgICAgIC8vIG1ha2UgeWVhcnMgbGFiZWwgZGVuc2VyXG4gICAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnaGFsZl95ZWFyJzpcbiAgICAgICAgICAgICAgbW9kdWxvID0gNztcblxuICAgICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vbnRocyc6XG4gICAgICAgICAgICAgIG1vZHVsbyA9IDE7XG5cbiAgICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtb250aHNfZm9ydG5pZ2h0JzpcbiAgICAgICAgICAgICAgbW9kdWxvID0gMTU7XG5cbiAgICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJyB8fCB0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAzMCkge1xuICAgICAgICAgICAgICAgIHNob3VsZE5vdFByaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtb250aHNfZGF5cyc6XG4gICAgICAgICAgICAgIG1vZHVsbyA9IDEwO1xuXG4gICAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAzMCkge1xuICAgICAgICAgICAgICAgIHNob3VsZE5vdFByaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd3ZWVrX2RheXMnOlxuICAgICAgICAgICAgICBtb2R1bG8gPSA4O1xuXG4gICAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICAgICAgICBtb2R1bG8gPSAxO1xuXG4gICAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZXNfZml2ZXMnOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgJSA1ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90UHJpbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZHNfdGVucyc6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAlIDEwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90UHJpbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZHNfZml2ZXMnOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgJSA1ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTm90UHJpbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLnRpY2tJbnRlcnZhbCA9PT0gJ2hvdXJzJyB8fCBfdGhpcy50aWNrSW50ZXJ2YWwgPT09ICdtaW51dGVzX2ZpdmVzJyB8fCBfdGhpcy50aWNrSW50ZXJ2YWwgPT09ICdzZWNvbmRzX3RlbnMnIHx8IF90aGlzLnRpY2tJbnRlcnZhbCA9PT0gJ3NlY29uZHNfZml2ZXMnKSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZE5vdFByaW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICUgbW9kdWxvID09PSAwIHx8IHNob3VsZE5vdFNraXBVbml0KSAmJiAhc2hvdWxkTm90UHJpbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkVGltZVNjYWxlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZWNhbGNEaW1lbnNpb25zQmFzZWRPbkZvcm1hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FsY0RpbWVuc2lvbnNCYXNlZE9uRm9ybWF0KGZpbHRlcmVkVGltZVNjYWxlLCBpbnZlcnRlZCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHJlZm9ybWF0dGVkVGltZXNjYWxlQXJyYXkgPSB0aGlzLmZvcm1hdERhdGVzKGZpbHRlcmVkVGltZVNjYWxlKTtcbiAgICAgICAgdmFyIHJlbW92ZWRPdmVybGFwcGluZ1RTID0gdGhpcy5yZW1vdmVPdmVybGFwcGluZ1RTKHJlZm9ybWF0dGVkVGltZXNjYWxlQXJyYXkpO1xuICAgICAgICB3Lmdsb2JhbHMudGltZXNjYWxlTGFiZWxzID0gcmVtb3ZlZE92ZXJsYXBwaW5nVFMuc2xpY2UoKTsgLy8gYXQgdGhpcyBzdGFnZSwgd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgY29vcmRzIG9mIHRoZSBncmlkIGFzIHRpbWVsaW5lIGxhYmVscyBtYXkgaGF2ZSBhbHRlcmVkIHRoZSB4YXhpcyBsYWJlbHMgY29vcmRzXG4gICAgICAgIC8vIFRoZSByZWFzb24gd2UgY2FuJ3QgZG8gdGhpcyBwcmlvciB0byB0aGlzIHN0YWdlIGlzIGJlY2F1c2UgdGltZWxpbmUgbGFiZWxzIGRlcGVuZHMgb24gZ3JpZFdpZHRoLCBhbmQgYXMgdGhlIHRpY2tzIGFyZSBjYWxjdWxhdGVkIGJhc2VkIG9uIGF2YWlsYWJsZSBncmlkV2lkdGgsIHRoZXJlIGNhbiBiZSB1bmtub3duIG51bWJlciBvZiB0aWNrcyBnZW5lcmF0ZWQgZm9yIGRpZmZlcmVudCBtaW5YIGFuZCBtYXhYXG4gICAgICAgIC8vIERlcGVuZGVuY3kgb24gRGltZW5zaW9ucygpLCBuZWVkIHRvIHJlZmFjdG9yIGNvcnJlY3RseVxuICAgICAgICAvLyBUT0RPIC0gZmluZCBhbiBhbHRlcm5hdGUgd2F5IHRvIGF2b2lkIGNhbGxpbmcgdGhpcyBIZWF2eSBtZXRob2QgdHdpY2VcblxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgZGltZW5zaW9ucy5wbG90Q29vcmRzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRldGVybWluZUludGVydmFsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lSW50ZXJ2YWwoZGF5c0RpZmYpIHtcbiAgICAgICAgdmFyIHllYXJzRGlmZiA9IGRheXNEaWZmIC8gMzY1O1xuICAgICAgICB2YXIgaG91cnNEaWZmID0gZGF5c0RpZmYgKiAyNDtcbiAgICAgICAgdmFyIG1pbnV0ZXNEaWZmID0gaG91cnNEaWZmICogNjA7XG4gICAgICAgIHZhciBzZWNvbmRzRGlmZiA9IG1pbnV0ZXNEaWZmICogNjA7XG5cbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgY2FzZSB5ZWFyc0RpZmYgPiA1OlxuICAgICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAneWVhcnMnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIGRheXNEaWZmID4gODAwOlxuICAgICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnaGFsZl95ZWFyJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDE4MDpcbiAgICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ21vbnRocyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZGF5c0RpZmYgPiA5MDpcbiAgICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ21vbnRoc19mb3J0bmlnaHQnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIGRheXNEaWZmID4gNjA6XG4gICAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdtb250aHNfZGF5cyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZGF5c0RpZmYgPiAzMDpcbiAgICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ3dlZWtfZGF5cyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZGF5c0RpZmYgPiAyOlxuICAgICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnZGF5cyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgaG91cnNEaWZmID4gMi40OlxuICAgICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnaG91cnMnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG1pbnV0ZXNEaWZmID4gMTU6XG4gICAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdtaW51dGVzX2ZpdmVzJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBtaW51dGVzRGlmZiA+IDU6XG4gICAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdtaW51dGVzJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBtaW51dGVzRGlmZiA+IDE6XG4gICAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdzZWNvbmRzX3RlbnMnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHNlY29uZHNEaWZmID4gMjA6XG4gICAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdzZWNvbmRzX2ZpdmVzJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ3NlY29uZHMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2VuZXJhdGVZZWFyU2NhbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVllYXJTY2FsZShfcmVmKSB7XG4gICAgICAgIHZhciBmaXJzdFZhbCA9IF9yZWYuZmlyc3RWYWwsXG4gICAgICAgICAgICBjdXJyZW50TW9udGggPSBfcmVmLmN1cnJlbnRNb250aCxcbiAgICAgICAgICAgIGN1cnJlbnRZZWFyID0gX3JlZi5jdXJyZW50WWVhcixcbiAgICAgICAgICAgIGRheXNXaWR0aE9uWEF4aXMgPSBfcmVmLmRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgICBudW1iZXJPZlllYXJzID0gX3JlZi5udW1iZXJPZlllYXJzO1xuICAgICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5ZZWFyO1xuICAgICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgICB2YXIgdW5pdCA9ICd5ZWFyJztcblxuICAgICAgICBpZiAoZmlyc3RWYWwubWluRGF0ZSA+IDEgfHwgZmlyc3RWYWwubWluTW9udGggPiAwKSB7XG4gICAgICAgICAgdmFyIHJlbWFpbmluZ0RheXMgPSBkdC5kZXRlcm1pbmVSZW1haW5pbmdEYXlzT2ZZZWFyKGZpcnN0VmFsLm1pblllYXIsIGZpcnN0VmFsLm1pbk1vbnRoLCBmaXJzdFZhbC5taW5EYXRlKTsgLy8gcmVtYWluaW5nRGF5c29mRmlyc3RNb250aCBpcyB1c2VkIHRvIHJlYWNodCB0aGUgMm5kIHRpY2sgcG9zaXRpb25cblxuICAgICAgICAgIHZhciByZW1haW5pbmdEYXlzT2ZGaXJzdFllYXIgPSBkdC5kZXRlcm1pbmVEYXlzT2ZZZWFyKGZpcnN0VmFsLm1pblllYXIpIC0gcmVtYWluaW5nRGF5cyArIDE7IC8vIGNhbGN1bGF0ZSB0aGUgZmlyc3QgdGljayBwb3NpdGlvblxuXG4gICAgICAgICAgZmlyc3RUaWNrUG9zaXRpb24gPSByZW1haW5pbmdEYXlzT2ZGaXJzdFllYXIgKiBkYXlzV2lkdGhPblhBeGlzO1xuICAgICAgICAgIGZpcnN0VGlja1ZhbHVlID0gZmlyc3RWYWwubWluWWVhciArIDE7IC8vIHB1c2ggdGhlIGZpcnN0IHRpY2sgaW4gdGhlIGFycmF5XG5cbiAgICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IGZpcnN0VGlja1Bvc2l0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIHllYXI6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgICAgbW9udGg6IFV0aWxzJDEubW9udGhNb2QoY3VycmVudE1vbnRoICsgMSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFZhbC5taW5EYXRlID09PSAxICYmIGZpcnN0VmFsLm1pbk1vbnRoID09PSAwKSB7XG4gICAgICAgICAgLy8gcHVzaCB0aGUgZmlyc3QgdGljayBpbiB0aGUgYXJyYXlcbiAgICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IGZpcnN0VGlja1Bvc2l0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIHllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgbW9udGg6IFV0aWxzJDEubW9udGhNb2QoY3VycmVudE1vbnRoICsgMSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB5ZWFyID0gZmlyc3RUaWNrVmFsdWU7XG4gICAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjsgLy8ga2VlcCBkcmF3aW5nIHJlc3Qgb2YgdGhlIHRpY2tzXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZlllYXJzOyBpKyspIHtcbiAgICAgICAgICB5ZWFyKys7XG4gICAgICAgICAgcG9zID0gZHQuZGV0ZXJtaW5lRGF5c09mWWVhcih5ZWFyIC0gMSkgKiBkYXlzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgdmFsdWU6IHllYXIsXG4gICAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICAgIG1vbnRoOiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2VuZXJhdGVNb250aFNjYWxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVNb250aFNjYWxlKF9yZWYyKSB7XG4gICAgICAgIHZhciBmaXJzdFZhbCA9IF9yZWYyLmZpcnN0VmFsLFxuICAgICAgICAgICAgY3VycmVudE1vbnRoRGF0ZSA9IF9yZWYyLmN1cnJlbnRNb250aERhdGUsXG4gICAgICAgICAgICBjdXJyZW50TW9udGggPSBfcmVmMi5jdXJyZW50TW9udGgsXG4gICAgICAgICAgICBjdXJyZW50WWVhciA9IF9yZWYyLmN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgZGF5c1dpZHRoT25YQXhpcyA9IF9yZWYyLmRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgICBudW1iZXJPZk1vbnRocyA9IF9yZWYyLm51bWJlck9mTW9udGhzO1xuICAgICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBjdXJyZW50TW9udGg7XG4gICAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZSh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB1bml0ID0gJ21vbnRoJztcbiAgICAgICAgdmFyIHlyQ291bnRlciA9IDA7XG5cbiAgICAgICAgaWYgKGZpcnN0VmFsLm1pbkRhdGUgPiAxKSB7XG4gICAgICAgICAgLy8gcmVtYWluaW5nRGF5c29mRmlyc3RNb250aCBpcyB1c2VkIHRvIHJlYWNodCB0aGUgMm5kIHRpY2sgcG9zaXRpb25cbiAgICAgICAgICB2YXIgcmVtYWluaW5nRGF5c09mRmlyc3RNb250aCA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhjdXJyZW50TW9udGggKyAxLCBmaXJzdFZhbC5taW5ZZWFyKSAtIGN1cnJlbnRNb250aERhdGUgKyAxOyAvLyBjYWxjdWxhdGUgdGhlIGZpcnN0IHRpY2sgcG9zaXRpb25cblxuICAgICAgICAgIGZpcnN0VGlja1Bvc2l0aW9uID0gcmVtYWluaW5nRGF5c09mRmlyc3RNb250aCAqIGRheXNXaWR0aE9uWEF4aXM7XG4gICAgICAgICAgZmlyc3RUaWNrVmFsdWUgPSBVdGlscyQxLm1vbnRoTW9kKGN1cnJlbnRNb250aCArIDEpO1xuICAgICAgICAgIHZhciB5ZWFyID0gY3VycmVudFllYXIgKyB5ckNvdW50ZXI7XG5cbiAgICAgICAgICB2YXIgX21vbnRoID0gVXRpbHMkMS5tb250aE1vZChmaXJzdFRpY2tWYWx1ZSk7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBmaXJzdFRpY2tWYWx1ZTsgLy8gaXQncyBKYW4sIHNvIHVwZGF0ZSB0aGUgeWVhclxuXG4gICAgICAgICAgaWYgKGZpcnN0VGlja1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICB1bml0ID0gJ3llYXInO1xuICAgICAgICAgICAgdmFsdWUgPSB5ZWFyO1xuICAgICAgICAgICAgX21vbnRoID0gMTtcbiAgICAgICAgICAgIHlyQ291bnRlciArPSAxO1xuICAgICAgICAgICAgeWVhciA9IHllYXIgKyB5ckNvdW50ZXI7XG4gICAgICAgICAgfSAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG5cbiAgICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IGZpcnN0VGlja1Bvc2l0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICBtb250aDogX21vbnRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHVzaCB0aGUgZmlyc3QgdGljayBpbiB0aGUgYXJyYXlcbiAgICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IGZpcnN0VGlja1Bvc2l0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIHllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgbW9udGg6IFV0aWxzJDEubW9udGhNb2QoY3VycmVudE1vbnRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vbnRoID0gZmlyc3RUaWNrVmFsdWUgKyAxO1xuICAgICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMTsgaSA8IG51bWJlck9mTW9udGhzOyBpKyssIGorKykge1xuICAgICAgICAgIG1vbnRoID0gVXRpbHMkMS5tb250aE1vZChtb250aCk7XG5cbiAgICAgICAgICBpZiAobW9udGggPT09IDApIHtcbiAgICAgICAgICAgIHVuaXQgPSAneWVhcic7XG4gICAgICAgICAgICB5ckNvdW50ZXIgKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF95ZWFyID0gdGhpcy5fZ2V0WWVhcihjdXJyZW50WWVhciwgbW9udGgsIHlyQ291bnRlcik7XG5cbiAgICAgICAgICBwb3MgPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGgsIF95ZWFyKSAqIGRheXNXaWR0aE9uWEF4aXMgKyBwb3M7XG4gICAgICAgICAgdmFyIG1vbnRoVmFsID0gbW9udGggPT09IDAgPyBfeWVhciA6IG1vbnRoO1xuICAgICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgdmFsdWU6IG1vbnRoVmFsLFxuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIHllYXI6IF95ZWFyLFxuICAgICAgICAgICAgbW9udGg6IG1vbnRoID09PSAwID8gMSA6IG1vbnRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbW9udGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZW5lcmF0ZURheVNjYWxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVEYXlTY2FsZShfcmVmMykge1xuICAgICAgICB2YXIgZmlyc3RWYWwgPSBfcmVmMy5maXJzdFZhbCxcbiAgICAgICAgICAgIGN1cnJlbnRNb250aCA9IF9yZWYzLmN1cnJlbnRNb250aCxcbiAgICAgICAgICAgIGN1cnJlbnRZZWFyID0gX3JlZjMuY3VycmVudFllYXIsXG4gICAgICAgICAgICBob3Vyc1dpZHRoT25YQXhpcyA9IF9yZWYzLmhvdXJzV2lkdGhPblhBeGlzLFxuICAgICAgICAgICAgbnVtYmVyT2ZEYXlzID0gX3JlZjMubnVtYmVyT2ZEYXlzO1xuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgICB2YXIgdW5pdCA9ICdkYXknO1xuICAgICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5EYXRlICsgMTtcbiAgICAgICAgdmFyIGRhdGUgPSBmaXJzdFRpY2tWYWx1ZTtcblxuICAgICAgICB2YXIgY2hhbmdlTW9udGggPSBmdW5jdGlvbiBjaGFuZ2VNb250aChkYXRlVmFsLCBtb250aCwgeWVhcikge1xuICAgICAgICAgIHZhciBtb250aGRheXMgPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGggKyAxLCB5ZWFyKTtcblxuICAgICAgICAgIGlmIChkYXRlVmFsID4gbW9udGhkYXlzKSB7XG4gICAgICAgICAgICBtb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgICAgIGRhdGUgPSAxO1xuICAgICAgICAgICAgdW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgICB2YWwgPSBtb250aDtcbiAgICAgICAgICAgIHJldHVybiBtb250aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZ0hvdXJzID0gMjQgLSBmaXJzdFZhbC5taW5Ib3VyO1xuICAgICAgICB2YXIgeXJDb3VudGVyID0gMDsgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgICAgdmFyIGZpcnN0VGlja1Bvc2l0aW9uID0gcmVtYWluaW5nSG91cnMgKiBob3Vyc1dpZHRoT25YQXhpcztcbiAgICAgICAgdmFyIHZhbCA9IGZpcnN0VGlja1ZhbHVlO1xuICAgICAgICB2YXIgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBjdXJyZW50TW9udGgsIGN1cnJlbnRZZWFyKTtcblxuICAgICAgICBpZiAoZmlyc3RWYWwubWluSG91ciA9PT0gMCAmJiBmaXJzdFZhbC5taW5EYXRlID09PSAxKSB7XG4gICAgICAgICAgLy8gdGhlIGZpcnN0IHZhbHVlIGlzIHRoZSBmaXJzdCBkYXkgb2YgbW9udGhcbiAgICAgICAgICBmaXJzdFRpY2tQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgdmFsID0gVXRpbHMkMS5tb250aE1vZChmaXJzdFZhbC5taW5Nb250aCk7XG4gICAgICAgICAgdW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgZGF0ZSA9IGZpcnN0VmFsLm1pbkRhdGU7IC8vIG51bWJlck9mRGF5cysrXG4gICAgICAgICAgLy8gcmVtb3ZlZCB0aGUgYWJvdmUgbGluZSB0byBmaXggaHR0cHM6Ly9naXRodWIuY29tL2FwZXhjaGFydHMvYXBleGNoYXJ0cy5qcy9pc3N1ZXMvMzA1I2lzc3VlY29tbWVudC0xMDE5NTIwNTEzXG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RWYWwubWluRGF0ZSAhPT0gMSAmJiBmaXJzdFZhbC5taW5Ib3VyID09PSAwICYmIGZpcnN0VmFsLm1pbk1pbnV0ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIGZpeGVzIGFwZXhjaGFydHMvYXBleGNoYXJ0cy5qcy9pc3N1ZXMvMTczMFxuICAgICAgICAgIGZpcnN0VGlja1Bvc2l0aW9uID0gMDtcbiAgICAgICAgICBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pbkRhdGU7XG4gICAgICAgICAgZGF0ZSA9IGZpcnN0VGlja1ZhbHVlO1xuICAgICAgICAgIHZhbCA9IGZpcnN0VGlja1ZhbHVlOyAvLyBpbiBjYXNlIGl0J3MgdGhlIGxhc3QgZGF0ZSBvZiBtb250aCwgd2UgbmVlZCB0byBjaGVjayBpdFxuXG4gICAgICAgICAgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBjdXJyZW50TW9udGgsIGN1cnJlbnRZZWFyKTtcbiAgICAgICAgfSAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG5cbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIHllYXI6IHRoaXMuX2dldFllYXIoY3VycmVudFllYXIsIG1vbnRoLCB5ckNvdW50ZXIpLFxuICAgICAgICAgIG1vbnRoOiBVdGlscyQxLm1vbnRoTW9kKG1vbnRoKSxcbiAgICAgICAgICBkYXk6IGRhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjsgLy8ga2VlcCBkcmF3aW5nIHJlc3Qgb2YgdGhlIHRpY2tzXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkRheXM7IGkrKykge1xuICAgICAgICAgIGRhdGUgKz0gMTtcbiAgICAgICAgICB1bml0ID0gJ2RheSc7XG4gICAgICAgICAgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBtb250aCwgdGhpcy5fZ2V0WWVhcihjdXJyZW50WWVhciwgbW9udGgsIHlyQ291bnRlcikpO1xuXG4gICAgICAgICAgdmFyIHllYXIgPSB0aGlzLl9nZXRZZWFyKGN1cnJlbnRZZWFyLCBtb250aCwgeXJDb3VudGVyKTtcblxuICAgICAgICAgIHBvcyA9IDI0ICogaG91cnNXaWR0aE9uWEF4aXMgKyBwb3M7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZGF0ZSA9PT0gMSA/IFV0aWxzJDEubW9udGhNb2QobW9udGgpIDogZGF0ZTtcbiAgICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgICAgbW9udGg6IFV0aWxzJDEubW9udGhNb2QobW9udGgpLFxuICAgICAgICAgICAgZGF5OiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdlbmVyYXRlSG91clNjYWxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVIb3VyU2NhbGUoX3JlZjQpIHtcbiAgICAgICAgdmFyIGZpcnN0VmFsID0gX3JlZjQuZmlyc3RWYWwsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IF9yZWY0LmN1cnJlbnREYXRlLFxuICAgICAgICAgICAgY3VycmVudE1vbnRoID0gX3JlZjQuY3VycmVudE1vbnRoLFxuICAgICAgICAgICAgY3VycmVudFllYXIgPSBfcmVmNC5jdXJyZW50WWVhcixcbiAgICAgICAgICAgIG1pbnV0ZXNXaWR0aE9uWEF4aXMgPSBfcmVmNC5taW51dGVzV2lkdGhPblhBeGlzLFxuICAgICAgICAgICAgbnVtYmVyT2ZIb3VycyA9IF9yZWY0Lm51bWJlck9mSG91cnM7XG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZSh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB5ckNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgdW5pdCA9ICdob3VyJztcblxuICAgICAgICB2YXIgY2hhbmdlRGF0ZSA9IGZ1bmN0aW9uIGNoYW5nZURhdGUoZGF0ZVZhbCwgbW9udGgpIHtcbiAgICAgICAgICB2YXIgbW9udGhkYXlzID0gZHQuZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoICsgMSwgY3VycmVudFllYXIpO1xuXG4gICAgICAgICAgaWYgKGRhdGVWYWwgPiBtb250aGRheXMpIHtcbiAgICAgICAgICAgIGRhdGUgPSAxO1xuICAgICAgICAgICAgbW9udGggPSBtb250aCArIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgICAgIGRhdGU6IGRhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjaGFuZ2VNb250aCA9IGZ1bmN0aW9uIGNoYW5nZU1vbnRoKGRhdGVWYWwsIG1vbnRoKSB7XG4gICAgICAgICAgdmFyIG1vbnRoZGF5cyA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhtb250aCArIDEsIGN1cnJlbnRZZWFyKTtcblxuICAgICAgICAgIGlmIChkYXRlVmFsID4gbW9udGhkYXlzKSB7XG4gICAgICAgICAgICBtb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgICAgIHJldHVybiBtb250aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH07IC8vIGZhY3RvciBpbiBtaW5TZWNvbmRzIGFzIHdlbGxcblxuXG4gICAgICAgIHZhciByZW1haW5pbmdNaW5zID0gNjAgLSAoZmlyc3RWYWwubWluTWludXRlICsgZmlyc3RWYWwubWluU2Vjb25kIC8gNjAuMCk7XG4gICAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IHJlbWFpbmluZ01pbnMgKiBtaW51dGVzV2lkdGhPblhBeGlzO1xuICAgICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5Ib3VyICsgMTtcbiAgICAgICAgdmFyIGhvdXIgPSBmaXJzdFRpY2tWYWx1ZTtcblxuICAgICAgICBpZiAocmVtYWluaW5nTWlucyA9PT0gNjApIHtcbiAgICAgICAgICBmaXJzdFRpY2tQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5Ib3VyO1xuICAgICAgICAgIGhvdXIgPSBmaXJzdFRpY2tWYWx1ZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0ZSA9IGN1cnJlbnREYXRlOyAvLyB3ZSBuZWVkIHRvIGFwcGx5IGRhdGUgc3dpdGNoaW5nIGxvZ2ljIGhlcmUgYXMgd2VsbCwgdG8gYXZvaWQgZHVwbGljYXRlZCBsYWJlbHNcblxuICAgICAgICBpZiAoaG91ciA+PSAyNCkge1xuICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgIGRhdGUgKz0gMTtcbiAgICAgICAgICB1bml0ID0gJ2RheSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hlY2tOZXh0TW9udGggPSBjaGFuZ2VEYXRlKGRhdGUsIGN1cnJlbnRNb250aCk7XG4gICAgICAgIHZhciBtb250aCA9IGNoZWNrTmV4dE1vbnRoLm1vbnRoO1xuICAgICAgICBtb250aCA9IGNoYW5nZU1vbnRoKGRhdGUsIG1vbnRoKTsgLy8gcHVzaCB0aGUgZmlyc3QgdGljayBpbiB0aGUgYXJyYXlcblxuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgICB2YWx1ZTogZmlyc3RUaWNrVmFsdWUsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgICAgaG91cjogaG91cixcbiAgICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcbiAgICAgICAgICBtb250aDogVXRpbHMkMS5tb250aE1vZChtb250aClcbiAgICAgICAgfSk7XG4gICAgICAgIGhvdXIrKztcbiAgICAgICAgdmFyIHBvcyA9IGZpcnN0VGlja1Bvc2l0aW9uOyAvLyBrZWVwIGRyYXdpbmcgcmVzdCBvZiB0aGUgdGlja3NcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mSG91cnM7IGkrKykge1xuICAgICAgICAgIHVuaXQgPSAnaG91cic7XG5cbiAgICAgICAgICBpZiAoaG91ciA+PSAyNCkge1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICBkYXRlICs9IDE7XG4gICAgICAgICAgICB1bml0ID0gJ2RheSc7XG5cbiAgICAgICAgICAgIHZhciBfY2hlY2tOZXh0TW9udGggPSBjaGFuZ2VEYXRlKGRhdGUsIG1vbnRoKTtcblxuICAgICAgICAgICAgbW9udGggPSBfY2hlY2tOZXh0TW9udGgubW9udGg7XG4gICAgICAgICAgICBtb250aCA9IGNoYW5nZU1vbnRoKGRhdGUsIG1vbnRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeWVhciA9IHRoaXMuX2dldFllYXIoY3VycmVudFllYXIsIG1vbnRoLCB5ckNvdW50ZXIpO1xuXG4gICAgICAgICAgcG9zID0gNjAgKiBtaW51dGVzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICAgIHZhciB2YWwgPSBob3VyID09PSAwID8gZGF0ZSA6IGhvdXI7XG4gICAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgICAgbW9udGg6IFV0aWxzJDEubW9udGhNb2QobW9udGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaG91cisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdlbmVyYXRlTWludXRlU2NhbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZU1pbnV0ZVNjYWxlKF9yZWY1KSB7XG4gICAgICAgIHZhciBjdXJyZW50TWlsbGlzZWNvbmQgPSBfcmVmNS5jdXJyZW50TWlsbGlzZWNvbmQsXG4gICAgICAgICAgICBjdXJyZW50U2Vjb25kID0gX3JlZjUuY3VycmVudFNlY29uZCxcbiAgICAgICAgICAgIGN1cnJlbnRNaW51dGUgPSBfcmVmNS5jdXJyZW50TWludXRlLFxuICAgICAgICAgICAgY3VycmVudEhvdXIgPSBfcmVmNS5jdXJyZW50SG91cixcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gX3JlZjUuY3VycmVudERhdGUsXG4gICAgICAgICAgICBjdXJyZW50TW9udGggPSBfcmVmNS5jdXJyZW50TW9udGgsXG4gICAgICAgICAgICBjdXJyZW50WWVhciA9IF9yZWY1LmN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgbWludXRlc1dpZHRoT25YQXhpcyA9IF9yZWY1Lm1pbnV0ZXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgICBzZWNvbmRzV2lkdGhPblhBeGlzID0gX3JlZjUuc2Vjb25kc1dpZHRoT25YQXhpcyxcbiAgICAgICAgICAgIG51bWJlck9mTWludXRlcyA9IF9yZWY1Lm51bWJlck9mTWludXRlcztcbiAgICAgICAgdmFyIHlyQ291bnRlciA9IDA7XG4gICAgICAgIHZhciB1bml0ID0gJ21pbnV0ZSc7XG4gICAgICAgIHZhciByZW1haW5pbmdTZWNzID0gNjAgLSBjdXJyZW50U2Vjb25kO1xuICAgICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSAocmVtYWluaW5nU2VjcyAtIGN1cnJlbnRNaWxsaXNlY29uZCAvIDEwMDApICogc2Vjb25kc1dpZHRoT25YQXhpcztcbiAgICAgICAgdmFyIG1pbnV0ZSA9IGN1cnJlbnRNaW51dGUgKyAxO1xuICAgICAgICB2YXIgZGF0ZSA9IGN1cnJlbnREYXRlO1xuICAgICAgICB2YXIgbW9udGggPSBjdXJyZW50TW9udGg7XG4gICAgICAgIHZhciB5ZWFyID0gY3VycmVudFllYXI7XG4gICAgICAgIHZhciBob3VyID0gY3VycmVudEhvdXI7XG4gICAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mTWludXRlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1pbnV0ZSA+PSA2MCkge1xuICAgICAgICAgICAgbWludXRlID0gMDtcbiAgICAgICAgICAgIGhvdXIgKz0gMTtcblxuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDI0KSB7XG4gICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgdmFsdWU6IG1pbnV0ZSxcbiAgICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICAgICAgbWludXRlOiBtaW51dGUsXG4gICAgICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgICAgICB5ZWFyOiB0aGlzLl9nZXRZZWFyKHllYXIsIG1vbnRoLCB5ckNvdW50ZXIpLFxuICAgICAgICAgICAgbW9udGg6IFV0aWxzJDEubW9udGhNb2QobW9udGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zICs9IG1pbnV0ZXNXaWR0aE9uWEF4aXM7XG4gICAgICAgICAgbWludXRlKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2VuZXJhdGVTZWNvbmRTY2FsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlU2Vjb25kU2NhbGUoX3JlZjYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRNaWxsaXNlY29uZCA9IF9yZWY2LmN1cnJlbnRNaWxsaXNlY29uZCxcbiAgICAgICAgICAgIGN1cnJlbnRTZWNvbmQgPSBfcmVmNi5jdXJyZW50U2Vjb25kLFxuICAgICAgICAgICAgY3VycmVudE1pbnV0ZSA9IF9yZWY2LmN1cnJlbnRNaW51dGUsXG4gICAgICAgICAgICBjdXJyZW50SG91ciA9IF9yZWY2LmN1cnJlbnRIb3VyLFxuICAgICAgICAgICAgY3VycmVudERhdGUgPSBfcmVmNi5jdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnRNb250aCA9IF9yZWY2LmN1cnJlbnRNb250aCxcbiAgICAgICAgICAgIGN1cnJlbnRZZWFyID0gX3JlZjYuY3VycmVudFllYXIsXG4gICAgICAgICAgICBzZWNvbmRzV2lkdGhPblhBeGlzID0gX3JlZjYuc2Vjb25kc1dpZHRoT25YQXhpcyxcbiAgICAgICAgICAgIG51bWJlck9mU2Vjb25kcyA9IF9yZWY2Lm51bWJlck9mU2Vjb25kcztcbiAgICAgICAgdmFyIHlyQ291bnRlciA9IDA7XG4gICAgICAgIHZhciB1bml0ID0gJ3NlY29uZCc7XG4gICAgICAgIHZhciByZW1haW5pbmdNaWxsaXNlY3MgPSAxMDAwIC0gY3VycmVudE1pbGxpc2Vjb25kO1xuICAgICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSByZW1haW5pbmdNaWxsaXNlY3MgLyAxMDAwICogc2Vjb25kc1dpZHRoT25YQXhpcztcbiAgICAgICAgdmFyIHNlY29uZCA9IGN1cnJlbnRTZWNvbmQgKyAxO1xuICAgICAgICB2YXIgbWludXRlID0gY3VycmVudE1pbnV0ZTtcbiAgICAgICAgdmFyIGRhdGUgPSBjdXJyZW50RGF0ZTtcbiAgICAgICAgdmFyIG1vbnRoID0gY3VycmVudE1vbnRoO1xuICAgICAgICB2YXIgeWVhciA9IGN1cnJlbnRZZWFyO1xuICAgICAgICB2YXIgaG91ciA9IGN1cnJlbnRIb3VyO1xuICAgICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZlNlY29uZHM7IGkrKykge1xuICAgICAgICAgIGlmIChzZWNvbmQgPj0gNjApIHtcbiAgICAgICAgICAgIG1pbnV0ZSsrO1xuICAgICAgICAgICAgc2Vjb25kID0gMDtcblxuICAgICAgICAgICAgaWYgKG1pbnV0ZSA+PSA2MCkge1xuICAgICAgICAgICAgICBob3VyKys7XG4gICAgICAgICAgICAgIG1pbnV0ZSA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDI0KSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgIHZhbHVlOiBzZWNvbmQsXG4gICAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgICAgaG91cjogaG91cixcbiAgICAgICAgICAgIG1pbnV0ZTogbWludXRlLFxuICAgICAgICAgICAgc2Vjb25kOiBzZWNvbmQsXG4gICAgICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgICAgICB5ZWFyOiB0aGlzLl9nZXRZZWFyKHllYXIsIG1vbnRoLCB5ckNvdW50ZXIpLFxuICAgICAgICAgICAgbW9udGg6IFV0aWxzJDEubW9udGhNb2QobW9udGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zICs9IHNlY29uZHNXaWR0aE9uWEF4aXM7XG4gICAgICAgICAgc2Vjb25kKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3JlYXRlUmF3RGF0ZVN0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhd0RhdGVTdHJpbmcodHMsIHZhbHVlKSB7XG4gICAgICAgIHZhciByYXcgPSB0cy55ZWFyO1xuXG4gICAgICAgIGlmICh0cy5tb250aCA9PT0gMCkge1xuICAgICAgICAgIC8vIGludmFsaWQgbW9udGgsIGNvcnJlY3QgaXRcbiAgICAgICAgICB0cy5tb250aCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByYXcgKz0gJy0nICsgKCcwJyArIHRzLm1vbnRoLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTsgLy8gdW5pdCBpcyBkYXlcblxuICAgICAgICBpZiAodHMudW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgICByYXcgKz0gdHMudW5pdCA9PT0gJ2RheScgPyAnLScgKyAoJzAnICsgdmFsdWUpLnNsaWNlKC0yKSA6ICctMDEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdyArPSAnLScgKyAoJzAnICsgKHRzLmRheSA/IHRzLmRheSA6ICcxJykpLnNsaWNlKC0yKTtcbiAgICAgICAgfSAvLyB1bml0IGlzIGhvdXJcblxuXG4gICAgICAgIGlmICh0cy51bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgICByYXcgKz0gdHMudW5pdCA9PT0gJ2hvdXInID8gJ1QnICsgKCcwJyArIHZhbHVlKS5zbGljZSgtMikgOiAnVDAwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXcgKz0gJ1QnICsgKCcwJyArICh0cy5ob3VyID8gdHMuaG91ciA6ICcwJykpLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cy51bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgIHJhdyArPSAnOicgKyAoJzAnICsgdmFsdWUpLnNsaWNlKC0yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXcgKz0gJzonICsgKHRzLm1pbnV0ZSA/ICgnMCcgKyB0cy5taW51dGUpLnNsaWNlKC0yKSA6ICcwMCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgcmF3ICs9ICc6JyArICgnMCcgKyB2YWx1ZSkuc2xpY2UoLTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdyArPSAnOjAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnV0Yykge1xuICAgICAgICAgIHJhdyArPSAnLjAwMFonO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9ybWF0RGF0ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXREYXRlcyhmaWx0ZXJlZFRpbWVTY2FsZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHJlZm9ybWF0dGVkVGltZXNjYWxlQXJyYXkgPSBmaWx0ZXJlZFRpbWVTY2FsZS5tYXAoZnVuY3Rpb24gKHRzKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdHMudmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUoX3RoaXMyLmN0eCk7XG5cbiAgICAgICAgICB2YXIgcmF3ID0gX3RoaXMyLmNyZWF0ZVJhd0RhdGVTdHJpbmcodHMsIHZhbHVlKTtcblxuICAgICAgICAgIHZhciBkYXRlVG9Gb3JtYXQgPSBkdC5nZXREYXRlKGR0LnBhcnNlRGF0ZShyYXcpKTtcblxuICAgICAgICAgIGlmICghX3RoaXMyLnV0Yykge1xuICAgICAgICAgICAgLy8gRml4ZXMgIzE3MjYsICMxNTQ0LCAjMTQ4NSwgIzEyNTVcbiAgICAgICAgICAgIGRhdGVUb0Zvcm1hdCA9IGR0LmdldERhdGUoZHQucGFyc2VEYXRlV2l0aFRpbWV6b25lKHJhdykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21Gb3JtYXQgPSAnZGQgTU1NJztcbiAgICAgICAgICAgIHZhciBkdEZvcm1hdHRlciA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5kYXRldGltZUZvcm1hdHRlcjtcbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAneWVhcicpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLnllYXI7XG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ21vbnRoJykgY3VzdG9tRm9ybWF0ID0gZHRGb3JtYXR0ZXIubW9udGg7XG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ2RheScpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLmRheTtcbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnaG91cicpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLmhvdXI7XG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ21pbnV0ZScpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLm1pbnV0ZTtcbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnc2Vjb25kJykgY3VzdG9tRm9ybWF0ID0gZHRGb3JtYXR0ZXIuc2Vjb25kO1xuICAgICAgICAgICAgdmFsdWUgPSBkdC5mb3JtYXREYXRlKGRhdGVUb0Zvcm1hdCwgY3VzdG9tRm9ybWF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBkdC5mb3JtYXREYXRlKGRhdGVUb0Zvcm1hdCwgdy5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGVTdHJpbmc6IHJhdyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0cy5wb3NpdGlvbixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHVuaXQ6IHRzLnVuaXQsXG4gICAgICAgICAgICB5ZWFyOiB0cy55ZWFyLFxuICAgICAgICAgICAgbW9udGg6IHRzLm1vbnRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWZvcm1hdHRlZFRpbWVzY2FsZUFycmF5O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVPdmVybGFwcGluZ1RTXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcHBpbmdUUyhhcnIpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIGVxdWFsTGFiZWxMZW5ndGhGbGFnID0gZmFsc2U7IC8vIFRoZXNlIGxhYmVscyBnb3Qgc2FtZSBsZW5ndGg/XG5cbiAgICAgICAgdmFyIGNvbnN0YW50TGFiZWxXaWR0aDsgLy8gSWYgdHJ1ZSwgd2hhdCBpcyB0aGUgY29uc3RhbnQgbGVuZ3RoIHRvIHVzZVxuXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID4gMCAmJiAvLyBjaGVjayBhcnIgbGVuZ3RoXG4gICAgICAgIGFyclswXS52YWx1ZSAmJiAvLyBjaGVjayBhcnJbMF0gY29udGFpbnMgdmFsdWVcbiAgICAgICAgYXJyLmV2ZXJ5KGZ1bmN0aW9uIChsYikge1xuICAgICAgICAgIHJldHVybiBsYi52YWx1ZS5sZW5ndGggPT09IGFyclswXS52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0pIC8vIGNoZWNrIGV2ZXJ5IGFyciBsYWJlbCB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgZmlyc3Qgb25lXG4gICAgICAgICkge1xuICAgICAgICAgIGVxdWFsTGFiZWxMZW5ndGhGbGFnID0gdHJ1ZTsgLy8gVGhlc2UgbGFiZWxzIGdvdCBzYW1lIGxlbmd0aFxuXG4gICAgICAgICAgY29uc3RhbnRMYWJlbFdpZHRoID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKGFyclswXS52YWx1ZSkud2lkdGg7IC8vIFRoZSBjb25zdGFudCBsYWJlbCB3aWR0aCB0byB1c2VcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0RHJhd25JbmRleCA9IDA7XG4gICAgICAgIHZhciBmaWx0ZXJlZEFycmF5ID0gYXJyLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIF90aGlzMy53LmNvbmZpZy54YXhpcy5sYWJlbHMuaGlkZU92ZXJsYXBwaW5nTGFiZWxzKSB7XG4gICAgICAgICAgICB2YXIgcHJldkxhYmVsV2lkdGggPSAhZXF1YWxMYWJlbExlbmd0aEZsYWcgLy8gaWYgdmFyeSBpbiBsYWJlbCBsZW5ndGhcbiAgICAgICAgICAgID8gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKGFycltsYXN0RHJhd25JbmRleF0udmFsdWUpLndpZHRoIC8vIGdldCBpbmRpdmlkdWFsIGxlbmd0aFxuICAgICAgICAgICAgOiBjb25zdGFudExhYmVsV2lkdGg7IC8vIGVsc2U6IHVzZSBjb25zdGFudCBsZW5ndGhcblxuICAgICAgICAgICAgdmFyIHByZXZQb3MgPSBhcnJbbGFzdERyYXduSW5kZXhdLnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGl0ZW0ucG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChwb3MgPiBwcmV2UG9zICsgcHJldkxhYmVsV2lkdGggKyAxMCkge1xuICAgICAgICAgICAgICBsYXN0RHJhd25JbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmaWx0ZXJlZEFycmF5ID0gZmlsdGVyZWRBcnJheS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gZiAhPT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZEFycmF5O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0WWVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRZZWFyKGN1cnJlbnRZZWFyLCBtb250aCwgeXJDb3VudGVyKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50WWVhciArIE1hdGguZmxvb3IobW9udGggLyAxMikgKyB5ckNvdW50ZXI7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVTY2FsZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBcGV4Q2hhcnRzIENvcmUgQ2xhc3MgcmVzcG9uc2libGUgZm9yIG1ham9yIGNhbGN1bGF0aW9ucyBhbmQgY3JlYXRpbmcgZWxlbWVudHMuXG4gICAqXG4gICAqIEBtb2R1bGUgQ29yZVxuICAgKiovXG5cbiAgdmFyIENvcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvcmUoZWwsIGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvcmUpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH0gLy8gZ2V0IGRhdGEgYW5kIHN0b3JlIGludG8gYXBwcm9wcmlhdGUgdmFyc1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29yZSwgW3tcbiAgICAgIGtleTogXCJzZXR1cEVsZW1lbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnOyAvLyBjb25zdCBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eClcblxuICAgICAgICB2YXIgY3QgPSBjbmYuY2hhcnQudHlwZTtcbiAgICAgICAgdmFyIGF4aXNDaGFydHNBcnJUeXBlcyA9IFsnbGluZScsICdhcmVhJywgJ2JhcicsICdyYW5nZUJhcicsICdyYW5nZUFyZWEnLCAnY2FuZGxlc3RpY2snLCAnYm94UGxvdCcsICdzY2F0dGVyJywgJ2J1YmJsZScsICdyYWRhcicsICdoZWF0bWFwJywgJ3RyZWVtYXAnXTtcbiAgICAgICAgdmFyIHh5Q2hhcnRzQXJyVHlwZXMgPSBbJ2xpbmUnLCAnYXJlYScsICdiYXInLCAncmFuZ2VCYXInLCAncmFuZ2VBcmVhJywgJ2NhbmRsZXN0aWNrJywgJ2JveFBsb3QnLCAnc2NhdHRlcicsICdidWJibGUnXTtcbiAgICAgICAgZ2wuYXhpc0NoYXJ0cyA9IGF4aXNDaGFydHNBcnJUeXBlcy5pbmRleE9mKGN0KSA+IC0xO1xuICAgICAgICBnbC54eUNoYXJ0cyA9IHh5Q2hhcnRzQXJyVHlwZXMuaW5kZXhPZihjdCkgPiAtMTtcbiAgICAgICAgZ2wuaXNCYXJIb3Jpem9udGFsID0gKGNuZi5jaGFydC50eXBlID09PSAnYmFyJyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ2JveFBsb3QnKSAmJiBjbmYucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWw7XG4gICAgICAgIGdsLmNoYXJ0Q2xhc3MgPSAnLmFwZXhjaGFydHMnICsgZ2wuY2hhcnRJRDtcbiAgICAgICAgZ2wuZG9tLmJhc2VFbCA9IHRoaXMuZWw7XG4gICAgICAgIGdsLmRvbS5lbFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZ2wuZG9tLmVsV3JhcCwge1xuICAgICAgICAgIGlkOiBnbC5jaGFydENsYXNzLnN1YnN0cmluZygxKSxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtY2FudmFzICcgKyBnbC5jaGFydENsYXNzLnN1YnN0cmluZygxKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChnbC5kb20uZWxXcmFwKTtcbiAgICAgICAgZ2wuZG9tLlBhcGVyID0gbmV3IHdpbmRvdy5TVkcuRG9jKGdsLmRvbS5lbFdyYXApO1xuICAgICAgICBnbC5kb20uUGFwZXIuYXR0cih7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXN2ZycsXG4gICAgICAgICAgJ3htbG5zOmRhdGEnOiAnQXBleENoYXJ0c05TJyxcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjbmYuY2hhcnQub2Zmc2V0WCwgXCIsIFwiKS5jb25jYXQoY25mLmNoYXJ0Lm9mZnNldFksIFwiKVwiKVxuICAgICAgICB9KTtcbiAgICAgICAgZ2wuZG9tLlBhcGVyLm5vZGUuc3R5bGUuYmFja2dyb3VuZCA9IGNuZi50aGVtZS5tb2RlID09PSAnZGFyaycgJiYgY25mLmNoYXJ0LmJhY2tncm91bmQgPT09ICd0cmFuc3BhcmVudCcgPyAncmdiYSgwLCAwLCAwLCAwLjgpJyA6IGNuZi5jaGFydC5iYWNrZ3JvdW5kO1xuICAgICAgICB0aGlzLnNldFNWR0RpbWVuc2lvbnMoKTsgLy8gYXBwZW5kIGZvcmVpZ25FbGVtZW50IChsZWdlbmQncyBwYXJlbnQpXG4gICAgICAgIC8vIGxlZ2VuZCBpcyBrZXB0IGluIGZvcmVpZ25FbGVtZW50IHRvIGJlIGluY2x1ZGVkIHdoaWxlIGV4cG9ydGluZ1xuICAgICAgICAvLyByZW1vdmluZyBmb3JlaWduRWxlbWVudCBhbmQgY3JlYXRpbmcgbGVnZW5kIHRocm91Z2ggSFRNTCB3aWxsIG5vdCByZW5kZXIgbGVnZW5kIGluIGV4cG9ydFxuXG4gICAgICAgIGdsLmRvbS5lbExlZ2VuZEZvcmVpZ24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZ2wuU1ZHTlMsICdmb3JlaWduT2JqZWN0Jyk7XG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGdsLmRvbS5lbExlZ2VuZEZvcmVpZ24sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IGdsLnN2Z1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogZ2wuc3ZnSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBnbC5kb20uZWxMZWdlbmRXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1sZWdlbmQnKTtcbiAgICAgICAgZ2wuZG9tLmVsTGVnZW5kV3JhcC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnKTtcbiAgICAgICAgZ2wuZG9tLmVsTGVnZW5kRm9yZWlnbi5hcHBlbmRDaGlsZChnbC5kb20uZWxMZWdlbmRXcmFwKTtcbiAgICAgICAgZ2wuZG9tLlBhcGVyLm5vZGUuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsTGVnZW5kRm9yZWlnbik7IC8vIHRoZSBlbEdyYXBoaWNhbCBpcyB0aGUgcGFyZW50IG9mIGFsbCBwcmltYXJ5IHZpc3VhbHNcblxuICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwgPSBnbC5kb20uUGFwZXIuZ3JvdXAoKS5hdHRyKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtaW5uZXIgYXBleGNoYXJ0cy1ncmFwaGljYWwnXG4gICAgICAgIH0pO1xuICAgICAgICBnbC5kb20uZWxEZWZzID0gZ2wuZG9tLlBhcGVyLmRlZnMoKTtcbiAgICAgICAgZ2wuZG9tLlBhcGVyLmFkZChnbC5kb20uZWxHcmFwaGljYWwpO1xuICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGdsLmRvbS5lbERlZnMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwbG90Q2hhcnRUeXBlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGxvdENoYXJ0VHlwZShzZXIsIHh5UmF0aW9zKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgICAgdmFyIGxpbmVTZXJpZXMgPSB7XG4gICAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgICBpOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXJlYVNlcmllcyA9IHtcbiAgICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICAgIGk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzY2F0dGVyU2VyaWVzID0ge1xuICAgICAgICAgIHNlcmllczogW10sXG4gICAgICAgICAgaTogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJ1YmJsZVNlcmllcyA9IHtcbiAgICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICAgIGk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb2x1bW5TZXJpZXMgPSB7XG4gICAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgICBpOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FuZGxlc3RpY2tTZXJpZXMgPSB7XG4gICAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgICBpOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYm94cGxvdFNlcmllcyA9IHtcbiAgICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICAgIGk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciByYW5nZUJhclNlcmllcyA9IHtcbiAgICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICAgIGk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciByYW5nZUFyZWFTZXJpZXMgPSB7XG4gICAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgICBzZXJpZXNSYW5nZUVuZDogW10sXG4gICAgICAgICAgaTogW11cbiAgICAgICAgfTtcbiAgICAgICAgZ2wuc2VyaWVzLm1hcChmdW5jdGlvbiAoc2VyaWUsIHN0KSB7XG4gICAgICAgICAgdmFyIGNvbWJvQ291bnQgPSAwOyAvLyBpZiB1c2VyIGhhcyBzcGVjaWZpZWQgYSBwYXJ0aWN1bGFyIHR5cGUgZm9yIHBhcnRpY3VsYXIgc2VyaWVzXG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNlcltzdF0udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChzZXJbc3RdLnR5cGUgPT09ICdjb2x1bW4nIHx8IHNlcltzdF0udHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgICAgICAgaWYgKGdsLnNlcmllcy5sZW5ndGggPiAxICYmIGNuZi5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIC8vIGhvcml6b250YWwgYmFycyBub3Qgc3VwcG9ydGVkIGluIG1peGVkIGNoYXJ0cywgaGVuY2Ugc2hvdyBhIHdhcm5pbmdcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0hvcml6b250YWwgYmFycyBhcmUgbm90IHN1cHBvcnRlZCBpbiBhIG1peGVkL2NvbWJvIGNoYXJ0LiBQbGVhc2UgdHVybiBvZmYgYHBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsYCcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29sdW1uU2VyaWVzLnNlcmllcy5wdXNoKHNlcmllKTtcbiAgICAgICAgICAgICAgY29sdW1uU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgICAgIGNvbWJvQ291bnQrKztcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLmNvbHVtblNlcmllcyA9IGNvbHVtblNlcmllcy5zZXJpZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgICAgICAgICAgIGFyZWFTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWUpO1xuICAgICAgICAgICAgICBhcmVhU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgICAgIGNvbWJvQ291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VyW3N0XS50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgbGluZVNlcmllcy5zZXJpZXMucHVzaChzZXJpZSk7XG4gICAgICAgICAgICAgIGxpbmVTZXJpZXMuaS5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgY29tYm9Db3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdzY2F0dGVyJykge1xuICAgICAgICAgICAgICBzY2F0dGVyU2VyaWVzLnNlcmllcy5wdXNoKHNlcmllKTtcbiAgICAgICAgICAgICAgc2NhdHRlclNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdidWJibGUnKSB7XG4gICAgICAgICAgICAgIGJ1YmJsZVNlcmllcy5zZXJpZXMucHVzaChzZXJpZSk7XG4gICAgICAgICAgICAgIGJ1YmJsZVNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgICAgICBjb21ib0NvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllcy5zZXJpZXMucHVzaChzZXJpZSk7XG4gICAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgICAgIGNvbWJvQ291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VyW3N0XS50eXBlID09PSAnYm94UGxvdCcpIHtcbiAgICAgICAgICAgICAgYm94cGxvdFNlcmllcy5zZXJpZXMucHVzaChzZXJpZSk7XG4gICAgICAgICAgICAgIGJveHBsb3RTZXJpZXMuaS5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgY29tYm9Db3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdyYW5nZUJhcicpIHtcbiAgICAgICAgICAgICAgcmFuZ2VCYXJTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWUpO1xuICAgICAgICAgICAgICByYW5nZUJhclNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgICAgICBjb21ib0NvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ3JhbmdlQXJlYScpIHtcbiAgICAgICAgICAgICAgcmFuZ2VBcmVhU2VyaWVzLnNlcmllcy5wdXNoKGdsLnNlcmllc1JhbmdlU3RhcnRbc3RdKTtcbiAgICAgICAgICAgICAgcmFuZ2VBcmVhU2VyaWVzLnNlcmllc1JhbmdlRW5kLnB1c2goZ2wuc2VyaWVzUmFuZ2VFbmRbc3RdKTtcbiAgICAgICAgICAgICAgcmFuZ2VBcmVhU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgICAgIGNvbWJvQ291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHVzZXIgaGFzIHNwZWNpZmllZCB0eXBlLCBidXQgaXQgaXMgbm90IHZhbGlkIChvdGhlciB0aGFuIGxpbmUvYXJlYS9jb2x1bW4pXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignWW91IGhhdmUgc3BlY2lmaWVkIGFuIHVucmVjb2duaXplZCBjaGFydCB0eXBlLiBBdmFpbGFibGUgdHlwZXMgZm9yIHRoaXMgcHJvcGVydHkgYXJlIGxpbmUvYXJlYS9jb2x1bW4vYmFyL3NjYXR0ZXIvYnViYmxlL2NhbmRsZXN0aWNrL2JveFBsb3QvcmFuZ2VCYXIvcmFuZ2VBcmVhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21ib0NvdW50ID4gMSkge1xuICAgICAgICAgICAgICBnbC5jb21ib0NoYXJ0cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWUpO1xuICAgICAgICAgICAgbGluZVNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgICAgdmFyIGJveENhbmRsZXN0aWNrID0gbmV3IEJveENhbmRsZVN0aWNrKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgIHRoaXMuY3R4LnBpZSA9IG5ldyBQaWUodGhpcy5jdHgpO1xuICAgICAgICB2YXIgcmFkaWFsQmFyID0gbmV3IFJhZGlhbCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LnJhbmdlQmFyID0gbmV3IFJhbmdlQmFyKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgIHZhciByYWRhciA9IG5ldyBSYWRhcih0aGlzLmN0eCk7XG4gICAgICAgIHZhciBlbEdyYXBoID0gW107XG5cbiAgICAgICAgaWYgKGdsLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgICAgaWYgKGFyZWFTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsR3JhcGgucHVzaChsaW5lLmRyYXcoYXJlYVNlcmllcy5zZXJpZXMsICdhcmVhJywgYXJlYVNlcmllcy5pKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbHVtblNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGJhclN0YWNrZWQgPSBuZXcgQmFyU3RhY2tlZCh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgICAgICAgICBlbEdyYXBoLnB1c2goYmFyU3RhY2tlZC5kcmF3KGNvbHVtblNlcmllcy5zZXJpZXMsIGNvbHVtblNlcmllcy5pKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmN0eC5iYXIgPSBuZXcgQmFyKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgICAgICAgIGVsR3JhcGgucHVzaCh0aGlzLmN0eC5iYXIuZHJhdyhjb2x1bW5TZXJpZXMuc2VyaWVzLCBjb2x1bW5TZXJpZXMuaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZUFyZWFTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsR3JhcGgucHVzaChsaW5lLmRyYXcocmFuZ2VBcmVhU2VyaWVzLnNlcmllcywgJ3JhbmdlQXJlYScsIHJhbmdlQXJlYVNlcmllcy5pLCByYW5nZUFyZWFTZXJpZXMuc2VyaWVzUmFuZ2VFbmQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGluZVNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZWxHcmFwaC5wdXNoKGxpbmUuZHJhdyhsaW5lU2VyaWVzLnNlcmllcywgJ2xpbmUnLCBsaW5lU2VyaWVzLmkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FuZGxlc3RpY2tTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsR3JhcGgucHVzaChib3hDYW5kbGVzdGljay5kcmF3KGNhbmRsZXN0aWNrU2VyaWVzLnNlcmllcywgJ2NhbmRsZXN0aWNrJywgY2FuZGxlc3RpY2tTZXJpZXMuaSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3hwbG90U2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbEdyYXBoLnB1c2goYm94Q2FuZGxlc3RpY2suZHJhdyhib3hwbG90U2VyaWVzLnNlcmllcywgJ2JveFBsb3QnLCBib3hwbG90U2VyaWVzLmkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFuZ2VCYXJTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsR3JhcGgucHVzaCh0aGlzLmN0eC5yYW5nZUJhci5kcmF3KHJhbmdlQmFyU2VyaWVzLnNlcmllcywgcmFuZ2VCYXJTZXJpZXMuaSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzY2F0dGVyU2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc2NhdHRlckxpbmUgPSBuZXcgTGluZSh0aGlzLmN0eCwgeHlSYXRpb3MsIHRydWUpO1xuICAgICAgICAgICAgZWxHcmFwaC5wdXNoKHNjYXR0ZXJMaW5lLmRyYXcoc2NhdHRlclNlcmllcy5zZXJpZXMsICdzY2F0dGVyJywgc2NhdHRlclNlcmllcy5pKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJ1YmJsZVNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJ1YmJsZUxpbmUgPSBuZXcgTGluZSh0aGlzLmN0eCwgeHlSYXRpb3MsIHRydWUpO1xuICAgICAgICAgICAgZWxHcmFwaC5wdXNoKGJ1YmJsZUxpbmUuZHJhdyhidWJibGVTZXJpZXMuc2VyaWVzLCAnYnViYmxlJywgYnViYmxlU2VyaWVzLmkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChjbmYuY2hhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgICAgIGVsR3JhcGggPSBsaW5lLmRyYXcoZ2wuc2VyaWVzLCAnbGluZScpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYXJlYSc6XG4gICAgICAgICAgICAgIGVsR3JhcGggPSBsaW5lLmRyYXcoZ2wuc2VyaWVzLCAnYXJlYScpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYmFyJzpcbiAgICAgICAgICAgICAgaWYgKGNuZi5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iYXJTdGFja2VkID0gbmV3IEJhclN0YWNrZWQodGhpcy5jdHgsIHh5UmF0aW9zKTtcblxuICAgICAgICAgICAgICAgIGVsR3JhcGggPSBfYmFyU3RhY2tlZC5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguYmFyID0gbmV3IEJhcih0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgICAgICAgICAgIGVsR3JhcGggPSB0aGlzLmN0eC5iYXIuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NhbmRsZXN0aWNrJzpcbiAgICAgICAgICAgICAgdmFyIGNhbmRsZVN0aWNrID0gbmV3IEJveENhbmRsZVN0aWNrKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgICAgICAgIGVsR3JhcGggPSBjYW5kbGVTdGljay5kcmF3KGdsLnNlcmllcywgJ2NhbmRsZXN0aWNrJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdib3hQbG90JzpcbiAgICAgICAgICAgICAgdmFyIGJveFBsb3QgPSBuZXcgQm94Q2FuZGxlU3RpY2sodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgICAgICAgICAgZWxHcmFwaCA9IGJveFBsb3QuZHJhdyhnbC5zZXJpZXMsIGNuZi5jaGFydC50eXBlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JhbmdlQmFyJzpcbiAgICAgICAgICAgICAgZWxHcmFwaCA9IHRoaXMuY3R4LnJhbmdlQmFyLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JhbmdlQXJlYSc6XG4gICAgICAgICAgICAgIGVsR3JhcGggPSBsaW5lLmRyYXcoZ2wuc2VyaWVzUmFuZ2VTdGFydCwgJ3JhbmdlQXJlYScsIHVuZGVmaW5lZCwgZ2wuc2VyaWVzUmFuZ2VFbmQpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnaGVhdG1hcCc6XG4gICAgICAgICAgICAgIHZhciBoZWF0bWFwID0gbmV3IEhlYXRNYXAodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgICAgICAgICAgZWxHcmFwaCA9IGhlYXRtYXAuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndHJlZW1hcCc6XG4gICAgICAgICAgICAgIHZhciB0cmVlbWFwID0gbmV3IFRyZWVtYXBDaGFydCh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgICAgICAgICBlbEdyYXBoID0gdHJlZW1hcC5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdwaWUnOlxuICAgICAgICAgICAgY2FzZSAnZG9udXQnOlxuICAgICAgICAgICAgY2FzZSAncG9sYXJBcmVhJzpcbiAgICAgICAgICAgICAgZWxHcmFwaCA9IHRoaXMuY3R4LnBpZS5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyYWRpYWxCYXInOlxuICAgICAgICAgICAgICBlbEdyYXBoID0gcmFkaWFsQmFyLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JhZGFyJzpcbiAgICAgICAgICAgICAgZWxHcmFwaCA9IHJhZGFyLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGVsR3JhcGggPSBsaW5lLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxHcmFwaDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0U1ZHRGltZW5zaW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNWR0RpbWVuc2lvbnMoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgICAgZ2wuc3ZnV2lkdGggPSBjbmYuY2hhcnQud2lkdGg7XG4gICAgICAgIGdsLnN2Z0hlaWdodCA9IGNuZi5jaGFydC5oZWlnaHQ7XG4gICAgICAgIHZhciBlbERpbSA9IFV0aWxzJDEuZ2V0RGltZW5zaW9ucyh0aGlzLmVsKTtcbiAgICAgICAgdmFyIHdpZHRoVW5pdCA9IGNuZi5jaGFydC53aWR0aC50b1N0cmluZygpLnNwbGl0KC9bMC05XSsvZykucG9wKCk7XG5cbiAgICAgICAgaWYgKHdpZHRoVW5pdCA9PT0gJyUnKSB7XG4gICAgICAgICAgaWYgKFV0aWxzJDEuaXNOdW1iZXIoZWxEaW1bMF0pKSB7XG4gICAgICAgICAgICBpZiAoZWxEaW1bMF0ud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgZWxEaW0gPSBVdGlscyQxLmdldERpbWVuc2lvbnModGhpcy5lbC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuc3ZnV2lkdGggPSBlbERpbVswXSAqIHBhcnNlSW50KGNuZi5jaGFydC53aWR0aCwgMTApIC8gMTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aFVuaXQgPT09ICdweCcgfHwgd2lkdGhVbml0ID09PSAnJykge1xuICAgICAgICAgIGdsLnN2Z1dpZHRoID0gcGFyc2VJbnQoY25mLmNoYXJ0LndpZHRoLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVpZ2h0VW5pdCA9IGNuZi5jaGFydC5oZWlnaHQudG9TdHJpbmcoKS5zcGxpdCgvWzAtOV0rL2cpLnBvcCgpO1xuXG4gICAgICAgIGlmIChnbC5zdmdIZWlnaHQgIT09ICdhdXRvJyAmJiBnbC5zdmdIZWlnaHQgIT09ICcnKSB7XG4gICAgICAgICAgaWYgKGhlaWdodFVuaXQgPT09ICclJykge1xuICAgICAgICAgICAgdmFyIGVsUGFyZW50RGltID0gVXRpbHMkMS5nZXREaW1lbnNpb25zKHRoaXMuZWwucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICBnbC5zdmdIZWlnaHQgPSBlbFBhcmVudERpbVsxXSAqIHBhcnNlSW50KGNuZi5jaGFydC5oZWlnaHQsIDEwKSAvIDEwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuc3ZnSGVpZ2h0ID0gcGFyc2VJbnQoY25mLmNoYXJ0LmhlaWdodCwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgZ2wuc3ZnSGVpZ2h0ID0gZ2wuc3ZnV2lkdGggLyAxLjYxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5zdmdIZWlnaHQgPSBnbC5zdmdXaWR0aCAvIDEuMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2wuc3ZnV2lkdGggPCAwKSBnbC5zdmdXaWR0aCA9IDA7XG4gICAgICAgIGlmIChnbC5zdmdIZWlnaHQgPCAwKSBnbC5zdmdIZWlnaHQgPSAwO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhnbC5kb20uUGFwZXIubm9kZSwge1xuICAgICAgICAgIHdpZHRoOiBnbC5zdmdXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGdsLnN2Z0hlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGVpZ2h0VW5pdCAhPT0gJyUnKSB7XG4gICAgICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2FwZXhjaGFydHMvYXBleGNoYXJ0cy5qcy9pc3N1ZXMvMjA1OVxuICAgICAgICAgIHZhciBvZmZzZXRZID0gY25mLmNoYXJ0LnNwYXJrbGluZS5lbmFibGVkID8gMCA6IGdsLmF4aXNDaGFydHMgPyBjbmYuY2hhcnQucGFyZW50SGVpZ2h0T2Zmc2V0IDogMDtcbiAgICAgICAgICBnbC5kb20uUGFwZXIubm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuc3R5bGUubWluSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0ICsgb2Zmc2V0WSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5kb20uZWxXcmFwLnN0eWxlLndpZHRoID0gZ2wuc3ZnV2lkdGggKyAncHgnO1xuICAgICAgICBnbC5kb20uZWxXcmFwLnN0eWxlLmhlaWdodCA9IGdsLnN2Z0hlaWdodCArICdweCc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNoaWZ0R3JhcGhQb3NpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0R3JhcGhQb3NpdGlvbigpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICAgIHZhciB0WSA9IGdsLnRyYW5zbGF0ZVk7XG4gICAgICAgIHZhciB0WCA9IGdsLnRyYW5zbGF0ZVg7XG4gICAgICAgIHZhciBzY2FsaW5nQXR0cnMgPSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB0WCArICcsICcgKyB0WSArICcpJ1xuICAgICAgICB9O1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhnbC5kb20uZWxHcmFwaGljYWwubm9kZSwgc2NhbGluZ0F0dHJzKTtcbiAgICAgIH0gLy8gVG8gcHJldmVudCBleHRyYSBzcGFjaW5ncyBpbiB0aGUgYm90dG9tIG9mIHRoZSBjaGFydCwgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZvciBwaWUvZG9udXQvcmFkaWFsYmFyIGNoYXJ0c1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc2l6ZU5vbkF4aXNDaGFydHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVOb25BeGlzQ2hhcnRzKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgICB2YXIgbGVnZW5kSGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIG9mZlkgPSB3LmNvbmZpZy5jaGFydC5zcGFya2xpbmUuZW5hYmxlZCA/IDEgOiAxNTtcbiAgICAgICAgb2ZmWSA9IG9mZlkgKyB3LmNvbmZpZy5ncmlkLnBhZGRpbmcuYm90dG9tO1xuXG4gICAgICAgIGlmICgody5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAndG9wJyB8fCB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdib3R0b20nKSAmJiB3LmNvbmZpZy5sZWdlbmQuc2hvdyAmJiAhdy5jb25maWcubGVnZW5kLmZsb2F0aW5nKSB7XG4gICAgICAgICAgbGVnZW5kSGVpZ2h0ID0gbmV3IExlZ2VuZCh0aGlzLmN0eCkubGVnZW5kSGVscGVycy5nZXRMZWdlbmRCQm94KCkuY2x3aCArIDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtcmFkaWFsYmFyLCAuYXBleGNoYXJ0cy1waWUnKTtcbiAgICAgICAgdmFyIGNoYXJ0SW5uZXJEaW1lbnNpb25zID0gdy5nbG9iYWxzLnJhZGlhbFNpemUgKiAyLjA1O1xuXG4gICAgICAgIGlmIChlbCAmJiAhdy5jb25maWcuY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQgJiYgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnN0YXJ0QW5nbGUgIT09IDApIHtcbiAgICAgICAgICB2YXIgZWxSYWRpYWxSZWN0ID0gVXRpbHMkMS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICAgICAgICAgIGNoYXJ0SW5uZXJEaW1lbnNpb25zID0gZWxSYWRpYWxSZWN0LmJvdHRvbTtcbiAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gZWxSYWRpYWxSZWN0LmJvdHRvbSAtIGVsUmFkaWFsUmVjdC50b3A7XG4gICAgICAgICAgY2hhcnRJbm5lckRpbWVuc2lvbnMgPSBNYXRoLm1heCh3Lmdsb2JhbHMucmFkaWFsU2l6ZSAqIDIuMDUsIG1heEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gY2hhcnRJbm5lckRpbWVuc2lvbnMgKyBnbC50cmFuc2xhdGVZICsgbGVnZW5kSGVpZ2h0ICsgb2ZmWTtcblxuICAgICAgICBpZiAoZ2wuZG9tLmVsTGVnZW5kRm9yZWlnbikge1xuICAgICAgICAgIGdsLmRvbS5lbExlZ2VuZEZvcmVpZ24uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBuZXdIZWlnaHQpO1xuICAgICAgICB9IC8vIGZpeCBhcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzMxMDUgKHdoZW4gJSBpcyBwcm92aWRlZCBpbiBoZWlnaHQsIGl0IGtlZXBzIGluY3JlYXNpbmcpXG5cblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuaGVpZ2h0ICYmIFN0cmluZyh3LmNvbmZpZy5jaGFydC5oZWlnaHQpLmluZGV4T2YoJyUnKSA+IDApIHJldHVybjtcbiAgICAgICAgZ2wuZG9tLmVsV3JhcC5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhnbC5kb20uUGFwZXIubm9kZSwge1xuICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBnbC5kb20uUGFwZXIubm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuc3R5bGUubWluSGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgKiogQWxsIHRoZSBjYWxjdWxhdGlvbnMgZm9yIHNldHRpbmcgcmFuZ2UgaW4gY2hhcnRzIHdpbGwgYmUgZG9uZSBoZXJlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb3JlQ2FsY3VsYXRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29yZUNhbGN1bGF0aW9ucygpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHRoaXMuY3R4KTtcbiAgICAgICAgcmFuZ2UuaW5pdCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXNldEdsb2JhbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEdsb2JhbHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlc2V0eHlWYWx1ZXMgPSBmdW5jdGlvbiByZXNldHh5VmFsdWVzKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy53LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdsb2JhbE9iaiA9IG5ldyBHbG9iYWxzKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgICBnbG9iYWxPYmouaW5pdEdsb2JhbFZhcnMoZ2wpO1xuICAgICAgICBnbC5zZXJpZXNYdmFsdWVzID0gcmVzZXR4eVZhbHVlcygpO1xuICAgICAgICBnbC5zZXJpZXNZdmFsdWVzID0gcmVzZXR4eVZhbHVlcygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc011bHRpcGxlWVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzTXVsdGlwbGVZKCkge1xuICAgICAgICAvLyB1c2VyIGhhcyBzdXBwbGllZCBhbiBhcnJheSBpbiB5YXhpcyBwcm9wZXJ0eS4gU28sIHR1cm4gb24gbXVsdGlwbGVZQXhpcyBmbGFnXG4gICAgICAgIGlmICh0aGlzLncuY29uZmlnLnlheGlzLmNvbnN0cnVjdG9yID09PSBBcnJheSAmJiB0aGlzLncuY29uZmlnLnlheGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLncuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInh5U2V0dGluZ3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB4eVNldHRpbmdzKCkge1xuICAgICAgICB2YXIgeHlSYXRpb3MgPSBudWxsO1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgICB2YXIgY3Jvc3NoYWlycyA9IG5ldyBDcm9zc2hhaXJzKHRoaXMuY3R4KTtcbiAgICAgICAgICAgIGNyb3NzaGFpcnMuZHJhd1hDcm9zc2hhaXJzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLmNyb3NzaGFpcnMucG9zaXRpb24gPT09ICdiYWNrJykge1xuICAgICAgICAgICAgdmFyIF9jcm9zc2hhaXJzID0gbmV3IENyb3NzaGFpcnModGhpcy5jdHgpO1xuXG4gICAgICAgICAgICBfY3Jvc3NoYWlycy5kcmF3WUNyb3NzaGFpcnMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LnRpbWVTY2FsZSA9IG5ldyBUaW1lU2NhbGUodGhpcy5jdHgpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWVTY2FsZSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUody5nbG9iYWxzLm1pblgpICYmIGlzRmluaXRlKHcuZ2xvYmFscy5tYXhYKSAmJiAhdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICBmb3JtYXR0ZWRUaW1lU2NhbGUgPSB0aGlzLmN0eC50aW1lU2NhbGUuY2FsY3VsYXRlVGltZVNjYWxlVGlja3Mody5nbG9iYWxzLm1pblgsIHcuZ2xvYmFscy5tYXhYKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICBmb3JtYXR0ZWRUaW1lU2NhbGUgPSB0aGlzLmN0eC50aW1lU2NhbGUuY2FsY3VsYXRlVGltZVNjYWxlVGlja3Mody5nbG9iYWxzLm1pblksIHcuZ2xvYmFscy5tYXhZKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdHgudGltZVNjYWxlLnJlY2FsY0RpbWVuc2lvbnNCYXNlZE9uRm9ybWF0KGZvcm1hdHRlZFRpbWVTY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgpO1xuICAgICAgICAgIHh5UmF0aW9zID0gY29yZVV0aWxzLmdldENhbGN1bGF0ZWRSYXRpb3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4eVJhdGlvcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXBkYXRlU291cmNlQ2hhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTb3VyY2VDaGFydCh0YXJnZXRDaGFydCkge1xuICAgICAgICB0aGlzLmN0eC53Lmdsb2JhbHMuc2VsZWN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuY3R4LnVwZGF0ZUhlbHBlcnMuX3VwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICBtaW46IHRhcmdldENoYXJ0LncuZ2xvYmFscy5taW5YLFxuICAgICAgICAgICAgICAgIG1heDogdGFyZ2V0Q2hhcnQudy5nbG9iYWxzLm1heFhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0dXBCcnVzaEhhbmRsZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEJydXNoSGFuZGxlcigpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIG9ubHkgZm9yIGJydXNoIGNoYXJ0c1xuXG4gICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuYnJ1c2guZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBpZiB1c2VyIGhhcyBub3QgZGVmaW5lZCBhIGN1c3RvbSBmdW5jdGlvbiBmb3Igc2VsZWN0aW9uIC0gd2UgaGFuZGxlIHRoZSBicnVzaCBjaGFydFxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbGVhdmUgaXQgdG8gdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBmdW5jdGlvbmFsaXR5IGZvciBzZWxlY3Rpb25cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0YXJnZXRzID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5jaGFydC5icnVzaC50YXJnZXRzKSB8fCBbdy5jb25maWcuY2hhcnQuYnJ1c2gudGFyZ2V0XTsgLy8gcmV0cm8gY29tcGF0aWJpbGl0eSB3aXRoIHNpbmdsZSB0YXJnZXQgb3B0aW9uXG5cbiAgICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldENoYXJ0ID0gQXBleENoYXJ0cy5nZXRDaGFydEJ5SUQodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldENoYXJ0LncuZ2xvYmFscy5icnVzaFNvdXJjZSA9IF90aGlzMi5jdHg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0Q2hhcnQudy5jb25maWcuY2hhcnQuZXZlbnRzLnpvb21lZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0YXJnZXRDaGFydC53LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi51cGRhdGVTb3VyY2VDaGFydCh0YXJnZXRDaGFydCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0Q2hhcnQudy5jb25maWcuY2hhcnQuZXZlbnRzLnNjcm9sbGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRhcmdldENoYXJ0LncuY29uZmlnLmNoYXJ0LmV2ZW50cy5zY3JvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIudXBkYXRlU291cmNlQ2hhcnQodGFyZ2V0Q2hhcnQpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uIChjaGFydCwgZSkge1xuICAgICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldENoYXJ0ID0gQXBleENoYXJ0cy5nZXRDaGFydEJ5SUQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgdmFyIHlheGlzID0gVXRpbHMkMS5jbG9uZSh3LmNvbmZpZy55YXhpcyk7XG5cbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmJydXNoLmF1dG9TY2FsZVlheGlzICYmIHRhcmdldENoYXJ0LncuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gbmV3IFJhbmdlJDEodGFyZ2V0Q2hhcnQpO1xuICAgICAgICAgICAgICAgIHlheGlzID0gc2NhbGUuYXV0b1NjYWxlWSh0YXJnZXRDaGFydCwgeWF4aXMsIGUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG11bHRpcGxlWWF4aXMgPSB0YXJnZXRDaGFydC53LmNvbmZpZy55YXhpcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhY2MpLCBbX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRhcmdldENoYXJ0LncuY29uZmlnLnlheGlzW2luZGV4XSksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBtaW46IHlheGlzWzBdLm1pbixcbiAgICAgICAgICAgICAgICAgIG1heDogeWF4aXNbMF0ubWF4XG4gICAgICAgICAgICAgICAgfSldKTtcbiAgICAgICAgICAgICAgfSwgW10pO1xuXG4gICAgICAgICAgICAgIHRhcmdldENoYXJ0LmN0eC51cGRhdGVIZWxwZXJzLl91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICAgICAgbWluOiBlLnhheGlzLm1pbixcbiAgICAgICAgICAgICAgICAgIG1heDogZS54YXhpcy5tYXhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHlheGlzOiBtdWx0aXBsZVlheGlzXG4gICAgICAgICAgICAgIH0sIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29yZTtcbiAgfSgpO1xuXG4gIHZhciBVcGRhdGVIZWxwZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcGRhdGVIZWxwZXJzKGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVwZGF0ZUhlbHBlcnMpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwcml2YXRlIG1ldGhvZCB0byB1cGRhdGUgT3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQSBuZXcgY29uZmlnIG9iamVjdCBjYW4gYmUgcGFzc2VkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZHJhdyAtIHNob3VsZCByZWRyYXcgZnJvbSBiZWdpbm5pbmcgb3Igc2hvdWxkIHVzZSBleGlzdGluZyBwYXRocyBhbmQgcmVkcmF3IGZyb20gdGhlcmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGUgLSBzaG91bGQgYW5pbWF0ZSBvciBub3Qgb24gdXBkYXRpbmcgT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlSW5pdGlhbENvbmZpZyAtIHNob3VsZCB1cGRhdGUgdGhlIGluaXRpYWwgY29uZmlnIG9yIG5vdFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVXBkYXRlSGVscGVycywgW3tcbiAgICAgIGtleTogXCJfdXBkYXRlT3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgcmVkcmF3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICAgIHZhciB1cGRhdGVTeW5jZWRDaGFydHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsQ29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGNoYXJ0cyA9IFtfdGhpcy5jdHhdO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVN5bmNlZENoYXJ0cykge1xuICAgICAgICAgICAgY2hhcnRzID0gX3RoaXMuY3R4LmdldFN5bmNlZENoYXJ0cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5jdHgudy5nbG9iYWxzLmlzRXhlY0NhbGxlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgY2FsbGVkIGV4ZWMgbWV0aG9kLCB3ZSBkb24ndCB3YW50IHRvIGdldCBncm91cGVkIGNoYXJ0cyBhcyB1c2VyIHNwZWNpZmljYWxseSBwcm92aWRlZCBhIGNoYXJ0SUQgdG8gdXBkYXRlXG4gICAgICAgICAgICBjaGFydHMgPSBbX3RoaXMuY3R4XTtcbiAgICAgICAgICAgIF90aGlzLmN0eC53Lmdsb2JhbHMuaXNFeGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNoLCBjaGFydEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdyA9IGNoLnc7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSA9IGFuaW1hdGU7XG5cbiAgICAgICAgICAgIGlmICghcmVkcmF3KSB7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5yZXNpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgIGNoLnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgX3R5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgY2guY29uZmlnID0gbmV3IENvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IENvcmVVdGlscy5leHRlbmRBcnJheVByb3BzKGNoLmNvbmZpZywgb3B0aW9ucywgdyk7IC8vIGZpeGVzICM5MTQsICM2MjNcblxuICAgICAgICAgICAgICBpZiAoY2gudy5nbG9iYWxzLmNoYXJ0SUQgIT09IF90aGlzLmN0eC53Lmdsb2JhbHMuY2hhcnRJRCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IG92ZXJ3cml0ZSBzZXJpZXMgb2Ygc3luY2hyb25pemVkIGNoYXJ0c1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnNlcmllcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHcuY29uZmlnID0gVXRpbHMkMS5leHRlbmQody5jb25maWcsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIGlmIChvdmVyd3JpdGVJbml0aWFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBmb3JnZXQgdGhlIGxhc3RYQXhpcyBhbmQgbGFzdFlBeGlzIGFzIHVzZXIgZm9yY2VmdWxseSBvdmVyd3JpdGVJbml0aWFsQ29uZmlnLiBJZiB3ZSBkbyBub3QgZG8gdGhpcywgYW5kIG5leHQgdGltZSB3aGVuIHVzZXIgem9vbXMgdGhlIGNoYXJ0IGFmdGVyIHNldHRpbmcgeWF4aXMubWluL21heCBvciB4YXhpcy5taW4vbWF4IC0gdGhlIHN0b3JlZCBsYXN0WEF4aXMgd2lsbCBuZXZlciBhbGxvdyB0aGUgY2hhcnQgdG8gdXNlIHRoZSB1cGRhdGVkIG1pbi9tYXggYnkgdXNlci5cbiAgICAgICAgICAgICAgICB3Lmdsb2JhbHMubGFzdFhBeGlzID0gb3B0aW9ucy54YXhpcyA/IFV0aWxzJDEuY2xvbmUob3B0aW9ucy54YXhpcykgOiBbXTtcbiAgICAgICAgICAgICAgICB3Lmdsb2JhbHMubGFzdFlBeGlzID0gb3B0aW9ucy55YXhpcyA/IFV0aWxzJDEuY2xvbmUob3B0aW9ucy55YXhpcykgOiBbXTsgLy8gQWZ0ZXIgZm9yZ2V0dGluZyBsYXN0QXhlcywgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBuZXcgY29uZmlnIGluIGluaXRpYWxDb25maWcvaW5pdGlhbFNlcmllc1xuXG4gICAgICAgICAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxDb25maWcgPSBVdGlscyQxLmV4dGVuZCh7fSwgdy5jb25maWcpO1xuICAgICAgICAgICAgICAgIHcuZ2xvYmFscy5pbml0aWFsU2VyaWVzID0gVXRpbHMkMS5jbG9uZSh3LmNvbmZpZy5zZXJpZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBjb2xsYXBzZWQgc2VyaWVzIGRhdGFcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IHcuY29uZmlnLnNlcmllc1t3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlc1tpXV07XG4gICAgICAgICAgICAgICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNbaV0uZGF0YSA9IHcuZ2xvYmFscy5heGlzQ2hhcnRzID8gc2VyaWVzLmRhdGEuc2xpY2UoKSA6IHNlcmllcztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3NlcmllcyA9IHcuY29uZmlnLnNlcmllc1t3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlc1tfaV1dO1xuICAgICAgICAgICAgICAgICAgICB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzW19pXS5kYXRhID0gdy5nbG9iYWxzLmF4aXNDaGFydHMgPyBfc2VyaWVzLmRhdGEuc2xpY2UoKSA6IF9zZXJpZXM7XG4gICAgICAgICAgICAgICAgICB9IC8vIEVuc3VyZSB0aGF0IGF1dG8tZ2VuZXJhdGVkIGF4ZXMgYXJlIHNjYWxlZCB0byB0aGUgdmlzaWJsZSBkYXRhXG5cblxuICAgICAgICAgICAgICAgICAgY2guc2VyaWVzLmVtcHR5Q29sbGFwc2VkU2VyaWVzKHcuY29uZmlnLnNlcmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaC51cGRhdGUob3B0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChjaGFydEluZGV4ID09PSBjaGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoY2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSBTZXJpZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHthcnJheX0gc2VyaWVzIC0gTmV3IHNlcmllcyB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBleGlzdGluZ1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZVNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTZXJpZXMobmV3U2VyaWVzLCBhbmltYXRlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsU2VyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIHcgPSBfdGhpczIudztcbiAgICAgICAgICB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgICAgICAgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICBfdGhpczIuY3R4LnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGV4aXN0aW5nU2VyaWVzOyAvLyBheGlzIGNoYXJ0c1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICBleGlzdGluZ1NlcmllcyA9IG5ld1Nlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fZXh0ZW5kU2VyaWVzKHMsIGkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChleGlzdGluZ1Nlcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmdTZXJpZXMgPSBbe1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3LmNvbmZpZy5zZXJpZXMgPSBleGlzdGluZ1NlcmllcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm9uLWF4aXMgY2hhcnQgKHBpZS9yYWRpYWxiYXIpXG4gICAgICAgICAgICB3LmNvbmZpZy5zZXJpZXMgPSBuZXdTZXJpZXMuc2xpY2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3ZlcndyaXRlSW5pdGlhbFNlcmllcykge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxDb25maWcuc2VyaWVzID0gVXRpbHMkMS5jbG9uZSh3LmNvbmZpZy5zZXJpZXMpO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxTZXJpZXMgPSBVdGlscyQxLmNsb25lKHcuY29uZmlnLnNlcmllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5jdHgudXBkYXRlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKF90aGlzMi5jdHgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2V4dGVuZFNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leHRlbmRTZXJpZXMocywgaSkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHNlciA9IHcuY29uZmlnLnNlcmllc1tpXTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB3LmNvbmZpZy5zZXJpZXNbaV0pLCB7fSwge1xuICAgICAgICAgIG5hbWU6IHMubmFtZSA/IHMubmFtZSA6IHNlciAmJiBzZXIubmFtZSxcbiAgICAgICAgICBjb2xvcjogcy5jb2xvciA/IHMuY29sb3IgOiBzZXIgJiYgc2VyLmNvbG9yLFxuICAgICAgICAgIHR5cGU6IHMudHlwZSA/IHMudHlwZSA6IHNlciAmJiBzZXIudHlwZSxcbiAgICAgICAgICBncm91cDogcy5ncm91cCA/IHMuZ3JvdXAgOiBzZXIgJiYgc2VyLmdyb3VwLFxuICAgICAgICAgIGRhdGE6IHMuZGF0YSA/IHMuZGF0YSA6IHNlciAmJiBzZXIuZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9nZ2xlRGF0YVBvaW50U2VsZWN0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlRGF0YVBvaW50U2VsZWN0aW9uKHNlcmllc0luZGV4LCBkYXRhUG9pbnRJbmRleCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIGVsUGF0aCA9IG51bGw7XG4gICAgICAgIHZhciBwYXJlbnQgPSBcIi5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChzZXJpZXNJbmRleCwgXCInXVwiKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICBlbFBhdGggPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdChcIlwiLmNvbmNhdChwYXJlbnQsIFwiIHBhdGhbaj0nXCIpLmNvbmNhdChkYXRhUG9pbnRJbmRleCwgXCInXSwgXCIpLmNvbmNhdChwYXJlbnQsIFwiIGNpcmNsZVtqPSdcIikuY29uY2F0KGRhdGFQb2ludEluZGV4LCBcIiddLCBcIikuY29uY2F0KHBhcmVudCwgXCIgcmVjdFtqPSdcIikuY29uY2F0KGRhdGFQb2ludEluZGV4LCBcIiddXCIpKS5tZW1iZXJzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRhdGFQb2ludEluZGV4IHdpbGwgYmUgdW5kZWZpbmVkIGhlcmUsIGhlbmNlIHVzaW5nIHNlcmllc0luZGV4XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhUG9pbnRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGVsUGF0aCA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiXCIuY29uY2F0KHBhcmVudCwgXCIgcGF0aFtqPSdcIikuY29uY2F0KHNlcmllc0luZGV4LCBcIiddXCIpKS5tZW1iZXJzWzBdO1xuXG4gICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BpZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BvbGFyQXJlYScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2RvbnV0Jykge1xuICAgICAgICAgICAgICB0aGlzLmN0eC5waWUucGllQ2xpY2tlZChzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsUGF0aCkge1xuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgICAgZ3JhcGhpY3MucGF0aE1vdXNlRG93bihlbFBhdGgsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybigndG9nZ2xlRGF0YVBvaW50U2VsZWN0aW9uOiBFbGVtZW50IG5vdCBmb3VuZCcpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsUGF0aC5ub2RlID8gZWxQYXRoLm5vZGUgOiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JjZVhBeGlzVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yY2VYQXhpc1VwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgbWlubWF4ID0gWydtaW4nLCAnbWF4J107XG4gICAgICAgIG1pbm1heC5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnhheGlzW2FdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdy5jb25maWcueGF4aXNbYV0gPSBvcHRpb25zLnhheGlzW2FdO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpc1thXSA9IG9wdGlvbnMueGF4aXNbYV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy54YXhpcy5jYXRlZ29yaWVzICYmIG9wdGlvbnMueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICB3LmNvbmZpZy54YXhpcy5jYXRlZ29yaWVzID0gb3B0aW9ucy54YXhpcy5jYXRlZ29yaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYykge1xuICAgICAgICAgIHZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyhvcHRpb25zKTtcbiAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdHMuY29udmVydENhdFRvTnVtZXJpY1hheGlzKG9wdGlvbnMsIHRoaXMuY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JjZVlBeGlzVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yY2VZQXhpc1VwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJ0ICYmIG9wdGlvbnMuY2hhcnQuc3RhY2tlZCAmJiBvcHRpb25zLmNoYXJ0LnN0YWNrVHlwZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy55YXhpcykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy55YXhpc1tpbmRleF0ubWluID0gMDtcbiAgICAgICAgICAgICAgb3B0aW9ucy55YXhpc1tpbmRleF0ubWF4ID0gMTAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMueWF4aXMubWluID0gMDtcbiAgICAgICAgICAgIG9wdGlvbnMueWF4aXMubWF4ID0gMTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldmVydHMgdGhlIHlheGlzIGFuZCB4YXhpcyBtaW4vbWF4IHZhbHVlcyB0byB3aGF0IGl0IHdhcyB3aGVuIHRoZSBjaGFydCB3YXMgZGVmaW5lZC5cbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gZml4ZXMgYW4gaW1wb3J0YW50IGJ1ZyB3aGVyZSBhIHVzZXIgbWlnaHQgbG9hZCBhIG5ldyBzZXJpZXMgYWZ0ZXIgem9vbWluZyBpbi9vdXQgb2YgcHJldmlvdXMgc2VyaWVzIHdoaWNoIHJlc3VsdGVkIGluIHdyb25nIG1pbi9tYXhcbiAgICAgICAqIEFsc28sIHRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBpbnRlcm5hbGx5IG9uIHpvb20vcGFuIC0gdGhlIHJlc2V0IHNob3VsZCBvbmx5IGhhcHBlbiB3aGVuIHVzZXIgY2FsbHMgdGhlIHVwZGF0ZVNlcmllcygpIGZ1bmN0aW9uIGV4dGVybmFsbHlcbiAgICAgICAqIFRoZSBmdW5jdGlvbiBhbHNvIGFjY2VwdHMgYW4gb2JqZWN0IHt4YXhpcywgeWF4aXN9IHdoaWNoIHdoZW4gcHJlc2VudCBpcyBzZXQgYXMgdGhlIG5ldyB4YXhpcy95YXhpc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnREZWZhdWx0QXhpc01pbk1heChvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgeGF4aXMgPSB3Lmdsb2JhbHMubGFzdFhBeGlzO1xuICAgICAgICB2YXIgeWF4aXMgPSB3Lmdsb2JhbHMubGFzdFlBeGlzO1xuXG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMueGF4aXMpIHtcbiAgICAgICAgICB4YXhpcyA9IG9wdHMueGF4aXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnlheGlzKSB7XG4gICAgICAgICAgeWF4aXMgPSBvcHRzLnlheGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdy5jb25maWcueGF4aXMubWluID0geGF4aXMubWluO1xuICAgICAgICB3LmNvbmZpZy54YXhpcy5tYXggPSB4YXhpcy5tYXg7XG5cbiAgICAgICAgdmFyIGdldExhc3RZQXhpcyA9IGZ1bmN0aW9uIGdldExhc3RZQXhpcyhpbmRleCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgeWF4aXNbaW5kZXhdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdy5jb25maWcueWF4aXNbaW5kZXhdLm1pbiA9IHlheGlzW2luZGV4XS5taW47XG4gICAgICAgICAgICB3LmNvbmZpZy55YXhpc1tpbmRleF0ubWF4ID0geWF4aXNbaW5kZXhdLm1heDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuem9vbWVkKSB7XG4gICAgICAgICAgICAvLyB1c2VyIGhhcyB6b29tZWQsIGNoZWNrIHRoZSBsYXN0IHlheGlzXG4gICAgICAgICAgICBnZXRMYXN0WUF4aXMoaW5kZXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VyIGhhc24ndCB6b29tZWQsIGNoZWNrIHRoZSBsYXN0IHlheGlzIGZpcnN0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHlheGlzW2luZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZ2V0TGFzdFlBeGlzKGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGlmIGxhc3QgeS1heGlzIGRvbid0IGV4aXN0LCBjaGVjayB0aGUgb3JpZ2luYWwgeWF4aXNcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczMuY3R4Lm9wdHMueWF4aXNbaW5kZXhdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHlheGUubWluID0gX3RoaXMzLmN0eC5vcHRzLnlheGlzW2luZGV4XS5taW47XG4gICAgICAgICAgICAgICAgeWF4ZS5tYXggPSBfdGhpczMuY3R4Lm9wdHMueWF4aXNbaW5kZXhdLm1heDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFVwZGF0ZUhlbHBlcnM7XG4gIH0oKTtcblxuICAoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpO1xuICAgICAgfSk7XG4gICAgICAvKiBiZWxvdyBjaGVjayBmaXhlcyAjNDEyICovXG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihleHBvcnRzKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJvb3QuZG9jdW1lbnQgPyBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpIDogZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgcmV0dXJuIGZhY3Rvcnkodywgdy5kb2N1bWVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LlNWRyA9IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudCk7XG4gICAgfVxuICB9KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgICAvLyBGaW5kIGdsb2JhbCByZWZlcmVuY2UgLSB1c2VzICd0aGlzJyBieSBkZWZhdWx0IHdoZW4gYXZhaWxhYmxlLFxuICAgIC8vIGZhbGxzIGJhY2sgdG8gJ3dpbmRvdycgb3RoZXJ3aXNlIChmb3IgYnVuZGxlcnMgbGlrZSBXZWJwYWNrKVxuICAgIHZhciBnbG9iYWxSZWYgPSB0eXBlb2YgdGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzIDogd2luZG93OyAvLyBUaGUgbWFpbiB3cmFwcGluZyBlbGVtZW50XG5cbiAgICB2YXIgU1ZHID0gZ2xvYmFsUmVmLlNWRyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoU1ZHLnN1cHBvcnRlZCkge1xuICAgICAgICBlbGVtZW50ID0gbmV3IFNWRy5Eb2MoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFTVkcucGFyc2VyLmRyYXcpIHtcbiAgICAgICAgICBTVkcucHJlcGFyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfTsgLy8gRGVmYXVsdCBuYW1lc3BhY2VzXG5cblxuICAgIFNWRy5ucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgU1ZHLnhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJztcbiAgICBTVkcueGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4gICAgU1ZHLnN2Z2pzID0gJ2h0dHA6Ly9zdmdqcy5kZXYnOyAvLyBTdmcgc3VwcG9ydCB0ZXN0XG5cbiAgICBTVkcuc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7IC8vICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmXG4gICAgICAvLyAgICAgISEgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRy5ucywnc3ZnJykuY3JlYXRlU1ZHUmVjdFxuICAgIH0oKTsgLy8gRG9uJ3QgYm90aGVyIHRvIGNvbnRpbnVlIGlmIFNWRyBpcyBub3Qgc3VwcG9ydGVkXG5cblxuICAgIGlmICghU1ZHLnN1cHBvcnRlZCkgcmV0dXJuIGZhbHNlOyAvLyBFbGVtZW50IGlkIHNlcXVlbmNlXG5cbiAgICBTVkcuZGlkID0gMTAwMDsgLy8gR2V0IG5leHQgbmFtZWQgZWxlbWVudCBpZFxuXG4gICAgU1ZHLmVpZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1N2Z2pzJyArIGNhcGl0YWxpemUobmFtZSkgKyBTVkcuZGlkKys7XG4gICAgfTsgLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXG5cblxuICAgIFNWRy5jcmVhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgLy8gY3JlYXRlIGVsZW1lbnRcbiAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsIG5hbWUpOyAvLyBhcHBseSB1bmlxdWUgaWRcblxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5laWQobmFtZSkpO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTsgLy8gTWV0aG9kIGZvciBleHRlbmRpbmcgb2JqZWN0c1xuXG5cbiAgICBTVkcuZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1vZHVsZXMsIG1ldGhvZHM7IC8vIEdldCBsaXN0IG9mIG1vZHVsZXNcblxuICAgICAgbW9kdWxlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gR2V0IG9iamVjdCB3aXRoIGV4dGVuc2lvbnNcblxuICAgICAgbWV0aG9kcyA9IG1vZHVsZXMucG9wKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2R1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChtb2R1bGVzW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIG1vZHVsZXNbaV0ucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE1ha2Ugc3VyZSBTVkcuU2V0IGluaGVyaXRzIGFueSBuZXdseSBhZGRlZCBtZXRob2RzXG5cblxuICAgICAgaWYgKFNWRy5TZXQgJiYgU1ZHLlNldC5pbmhlcml0KSB7XG4gICAgICAgIFNWRy5TZXQuaW5oZXJpdCgpO1xuICAgICAgfVxuICAgIH07IC8vIEludmVudCBuZXcgZWxlbWVudFxuXG5cbiAgICBTVkcuaW52ZW50ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgLy8gQ3JlYXRlIGVsZW1lbnQgaW5pdGlhbGl6ZXJcbiAgICAgIHZhciBpbml0aWFsaXplciA9IHR5cGVvZiBjb25maWcuY3JlYXRlID09PSAnZnVuY3Rpb24nID8gY29uZmlnLmNyZWF0ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoY29uZmlnLmNyZWF0ZSkpO1xuICAgICAgfTsgLy8gSW5oZXJpdCBwcm90b3R5cGVcblxuICAgICAgaWYgKGNvbmZpZy5pbmhlcml0KSB7XG4gICAgICAgIGluaXRpYWxpemVyLnByb3RvdHlwZSA9IG5ldyBjb25maWcuaW5oZXJpdCgpO1xuICAgICAgfSAvLyBFeHRlbmQgd2l0aCBtZXRob2RzXG5cblxuICAgICAgaWYgKGNvbmZpZy5leHRlbmQpIHtcbiAgICAgICAgU1ZHLmV4dGVuZChpbml0aWFsaXplciwgY29uZmlnLmV4dGVuZCk7XG4gICAgICB9IC8vIEF0dGFjaCBjb25zdHJ1Y3QgbWV0aG9kIHRvIHBhcmVudFxuXG5cbiAgICAgIGlmIChjb25maWcuY29uc3RydWN0KSB7XG4gICAgICAgIFNWRy5leHRlbmQoY29uZmlnLnBhcmVudCB8fCBTVkcuQ29udGFpbmVyLCBjb25maWcuY29uc3RydWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluaXRpYWxpemVyO1xuICAgIH07IC8vIEFkb3B0IGV4aXN0aW5nIHN2ZyBlbGVtZW50c1xuXG5cbiAgICBTVkcuYWRvcHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHByZXNlbmNlIG9mIG5vZGVcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7IC8vIG1ha2Ugc3VyZSBhIG5vZGUgaXNuJ3QgYWxyZWFkeSBhZG9wdGVkXG5cbiAgICAgIGlmIChub2RlLmluc3RhbmNlKSByZXR1cm4gbm9kZS5pbnN0YW5jZTsgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcblxuICAgICAgdmFyIGVsZW1lbnQ7IC8vIGFkb3B0IHdpdGggZWxlbWVudC1zcGVjaWZpYyBzZXR0aW5nc1xuXG4gICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICBlbGVtZW50ID0gbm9kZS5wYXJlbnROb2RlIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQgPyBuZXcgU1ZHLk5lc3RlZCgpIDogbmV3IFNWRy5Eb2MoKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSAnbGluZWFyR3JhZGllbnQnKSB7XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdsaW5lYXInKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSAncmFkaWFsR3JhZGllbnQnKSB7XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdyYWRpYWwnKTtcbiAgICAgIH0gZWxzZSBpZiAoU1ZHW2NhcGl0YWxpemUobm9kZS5ub2RlTmFtZSldKSB7XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHW2NhcGl0YWxpemUobm9kZS5ub2RlTmFtZSldKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gbmV3IFNWRy5FbGVtZW50KG5vZGUpO1xuICAgICAgfSAvLyBlbnN1cmUgcmVmZXJlbmNlc1xuXG5cbiAgICAgIGVsZW1lbnQudHlwZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICBlbGVtZW50Lm5vZGUgPSBub2RlO1xuICAgICAgbm9kZS5pbnN0YW5jZSA9IGVsZW1lbnQ7IC8vIFNWRy5DbGFzcyBzcGVjaWZpYyBwcmVwYXJhdGlvbnNcblxuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuRG9jKSB7XG4gICAgICAgIGVsZW1lbnQubmFtZXNwYWNlKCkuZGVmcygpO1xuICAgICAgfSAvLyBwdWxsIHN2Z2pzIGRhdGEgZnJvbSB0aGUgZG9tIChnZXRBdHRyaWJ1dGVOUyBkb2Vzbid0IHdvcmsgaW4gaHRtbDUpXG5cblxuICAgICAgZWxlbWVudC5zZXREYXRhKEpTT04ucGFyc2Uobm9kZS5nZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKSkgfHwge30pO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTsgLy8gSW5pdGlhbGl6ZSBwYXJzaW5nIGVsZW1lbnRcblxuXG4gICAgU1ZHLnByZXBhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTZWxlY3QgZG9jdW1lbnQgYm9keSBhbmQgY3JlYXRlIGludmlzaWJsZSBzdmcgZWxlbWVudFxuICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLFxuICAgICAgICAgIGRyYXcgPSAoYm9keSA/IG5ldyBTVkcuRG9jKGJvZHkpIDogU1ZHLmFkb3B0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkubmVzdGVkKCkpLnNpemUoMiwgMCk7IC8vIENyZWF0ZSBwYXJzZXIgb2JqZWN0XG5cbiAgICAgIFNWRy5wYXJzZXIgPSB7XG4gICAgICAgIGJvZHk6IGJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBkcmF3OiBkcmF3LnN0eWxlKCdvcGFjaXR5OjA7cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwJTt0b3A6LTEwMCU7b3ZlcmZsb3c6aGlkZGVuJykubm9kZSxcbiAgICAgICAgcG9seTogZHJhdy5wb2x5bGluZSgpLm5vZGUsXG4gICAgICAgIHBhdGg6IGRyYXcucGF0aCgpLm5vZGUsXG4gICAgICAgIG5hdGl2ZTogU1ZHLmNyZWF0ZSgnc3ZnJylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIFNWRy5wYXJzZXIgPSB7XG4gICAgICBuYXRpdmU6IFNWRy5jcmVhdGUoJ3N2ZycpXG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFTVkcucGFyc2VyLmRyYXcpIHtcbiAgICAgICAgU1ZHLnByZXBhcmUoKTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7IC8vIFN0b3JhZ2UgZm9yIHJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuICAgIFNWRy5yZWdleCA9IHtcbiAgICAgIC8vIFBhcnNlIHVuaXQgdmFsdWVcbiAgICAgIG51bWJlckFuZFVuaXQ6IC9eKFsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPykoW2EteiVdKikkL2ksXG4gICAgICAvLyBQYXJzZSBoZXggdmFsdWVcbiAgICAgIGhleDogL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaSxcbiAgICAgIC8vIFBhcnNlIHJnYiB2YWx1ZVxuICAgICAgcmdiOiAvcmdiXFwoKFxcZCspLChcXGQrKSwoXFxkKylcXCkvLFxuICAgICAgLy8gUGFyc2UgcmVmZXJlbmNlIGlkXG4gICAgICByZWZlcmVuY2U6IC8jKFthLXowLTlcXC1fXSspL2ksXG4gICAgICAvLyBzcGxpdHMgYSB0cmFuc2Zvcm1hdGlvbiBjaGFpblxuICAgICAgdHJhbnNmb3JtczogL1xcKVxccyosP1xccyovLFxuICAgICAgLy8gV2hpdGVzcGFjZVxuICAgICAgd2hpdGVzcGFjZTogL1xccy9nLFxuICAgICAgLy8gVGVzdCBoZXggdmFsdWVcbiAgICAgIGlzSGV4OiAvXiNbYS1mMC05XXszLDZ9JC9pLFxuICAgICAgLy8gVGVzdCByZ2IgdmFsdWVcbiAgICAgIGlzUmdiOiAvXnJnYlxcKC8sXG4gICAgICAvLyBUZXN0IGNzcyBkZWNsYXJhdGlvblxuICAgICAgaXNDc3M6IC9bXjpdKzpbXjtdKzs/LyxcbiAgICAgIC8vIFRlc3QgZm9yIGJsYW5rIHN0cmluZ1xuICAgICAgaXNCbGFuazogL14oXFxzKyk/JC8sXG4gICAgICAvLyBUZXN0IGZvciBudW1lcmljIHN0cmluZ1xuICAgICAgaXNOdW1iZXI6IC9eWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxuICAgICAgLy8gVGVzdCBmb3IgcGVyY2VudCB2YWx1ZVxuICAgICAgaXNQZXJjZW50OiAvXi0/W1xcZFxcLl0rJSQvLFxuICAgICAgLy8gVGVzdCBmb3IgaW1hZ2UgdXJsXG4gICAgICBpc0ltYWdlOiAvXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8c3ZnKShcXD9bXj1dKy4qKT8vaSxcbiAgICAgIC8vIHNwbGl0IGF0IHdoaXRlc3BhY2UgYW5kIGNvbW1hXG4gICAgICBkZWxpbWl0ZXI6IC9bXFxzLF0rLyxcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVnZXggYXJlIHVzZWQgdG8gcGFyc2UgdGhlIGQgYXR0cmlidXRlIG9mIGEgcGF0aFxuICAgICAgLy8gTWF0Y2hlcyBhbGwgaHlwaGVucyB3aGljaCBhcmUgbm90IGFmdGVyIGFuIGV4cG9uZW50XG4gICAgICBoeXBoZW46IC8oW15lXSlcXC0vZ2ksXG4gICAgICAvLyBSZXBsYWNlcyBhbmQgdGVzdHMgZm9yIGFsbCBwYXRoIGxldHRlcnNcbiAgICAgIHBhdGhMZXR0ZXJzOiAvW01MSFZDU1FUQVpdL2dpLFxuICAgICAgLy8geWVzIHdlIG5lZWQgdGhpcyBvbmUsIHRvb1xuICAgICAgaXNQYXRoTGV0dGVyOiAvW01MSFZDU1FUQVpdL2ksXG4gICAgICAvLyBtYXRjaGVzIDAuMTU0LjIzLjQ1XG4gICAgICBudW1iZXJzV2l0aERvdHM6IC8oKFxcZD9cXC5cXGQrKD86ZVsrLV0/XFxkKyk/KSgoPzpcXC5cXGQrKD86ZVsrLV0/XFxkKyk/KSspKSsvZ2ksXG4gICAgICAvLyBtYXRjaGVzIC5cbiAgICAgIGRvdHM6IC9cXC4vZ1xuICAgIH07XG4gICAgU1ZHLnV0aWxzID0ge1xuICAgICAgLy8gTWFwIGZ1bmN0aW9uXG4gICAgICBtYXA6IGZ1bmN0aW9uIG1hcChhcnJheSwgYmxvY2spIHtcbiAgICAgICAgdmFyIGlsID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goYmxvY2soYXJyYXlbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgLy8gRmlsdGVyIGZ1bmN0aW9uXG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgYmxvY2spIHtcbiAgICAgICAgdmFyIGlsID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGJsb2NrKGFycmF5W2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmlsdGVyU1ZHRWxlbWVudHM6IGZ1bmN0aW9uIGZpbHRlclNWR0VsZW1lbnRzKG5vZGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihub2RlcywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgU1ZHLmRlZmF1bHRzID0ge1xuICAgICAgLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICBhdHRyczoge1xuICAgICAgICAvLyBmaWxsIGFuZCBzdHJva2VcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAwLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ2J1dHQnLFxuICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAvLyBwb3NpdGlvblxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBjeDogMCxcbiAgICAgICAgY3k6IDAsXG4gICAgICAgIC8vIHNpemVcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgLy8gcmFkaXVzXG4gICAgICAgIHI6IDAsXG4gICAgICAgIHJ4OiAwLFxuICAgICAgICByeTogMCxcbiAgICAgICAgLy8gZ3JhZGllbnRcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAnc3RvcC1vcGFjaXR5JzogMSxcbiAgICAgICAgJ3N0b3AtY29sb3InOiAnIzAwMDAwMCcsXG4gICAgICAgIC8vIHRleHRcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICAgICAnZm9udC1mYW1pbHknOiAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZicsXG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdzdGFydCdcbiAgICAgIH1cbiAgICB9OyAvLyBNb2R1bGUgZm9yIGNvbG9yIGNvbnZlcnRpb25zXG5cbiAgICBTVkcuQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgIHZhciBtYXRjaDsgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuXG4gICAgICB0aGlzLnIgPSAwO1xuICAgICAgdGhpcy5nID0gMDtcbiAgICAgIHRoaXMuYiA9IDA7XG4gICAgICBpZiAoIWNvbG9yKSByZXR1cm47IC8vIHBhcnNlIGNvbG9yXG5cbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChTVkcucmVnZXguaXNSZ2IudGVzdChjb2xvcikpIHtcbiAgICAgICAgICAvLyBnZXQgcmdiIHZhbHVlc1xuICAgICAgICAgIG1hdGNoID0gU1ZHLnJlZ2V4LnJnYi5leGVjKGNvbG9yLnJlcGxhY2UoU1ZHLnJlZ2V4LndoaXRlc3BhY2UsICcnKSk7IC8vIHBhcnNlIG51bWVyaWMgdmFsdWVzXG5cbiAgICAgICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNIZXgudGVzdChjb2xvcikpIHtcbiAgICAgICAgICAvLyBnZXQgaGV4IHZhbHVlc1xuICAgICAgICAgIG1hdGNoID0gU1ZHLnJlZ2V4LmhleC5leGVjKGZ1bGxIZXgoY29sb3IpKTsgLy8gcGFyc2UgbnVtZXJpYyB2YWx1ZXNcblxuICAgICAgICAgIHRoaXMuciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQobWF0Y2hbMl0sIDE2KTtcbiAgICAgICAgICB0aGlzLmIgPSBwYXJzZUludChtYXRjaFszXSwgMTYpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YoY29sb3IpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLnIgPSBjb2xvci5yO1xuICAgICAgICB0aGlzLmcgPSBjb2xvci5nO1xuICAgICAgICB0aGlzLmIgPSBjb2xvci5iO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTVkcuZXh0ZW5kKFNWRy5Db2xvciwge1xuICAgICAgLy8gRGVmYXVsdCB0byBoZXggY29udmVyc2lvblxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgICAgfSxcbiAgICAgIC8vIEJ1aWxkIGhleCB2YWx1ZVxuICAgICAgdG9IZXg6IGZ1bmN0aW9uIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gJyMnICsgY29tcFRvSGV4KHRoaXMucikgKyBjb21wVG9IZXgodGhpcy5nKSArIGNvbXBUb0hleCh0aGlzLmIpO1xuICAgICAgfSxcbiAgICAgIC8vIEJ1aWxkIHJnYiB2YWx1ZVxuICAgICAgdG9SZ2I6IGZ1bmN0aW9uIHRvUmdiKCkge1xuICAgICAgICByZXR1cm4gJ3JnYignICsgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmJdLmpvaW4oKSArICcpJztcbiAgICAgIH0sXG4gICAgICAvLyBDYWxjdWxhdGUgdHJ1ZSBicmlnaHRuZXNzXG4gICAgICBicmlnaHRuZXNzOiBmdW5jdGlvbiBicmlnaHRuZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yIC8gMjU1ICogMC4zMCArIHRoaXMuZyAvIDI1NSAqIDAuNTkgKyB0aGlzLmIgLyAyNTUgKiAwLjExO1xuICAgICAgfSxcbiAgICAgIC8vIE1ha2UgY29sb3IgbW9ycGhhYmxlXG4gICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgoY29sb3IpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuQ29sb3IoY29sb3IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgbW9ycGhlZCBjb2xvciBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7IC8vIG5vcm1hbGlzZSBwb3NcblxuICAgICAgICBwb3MgPSBwb3MgPCAwID8gMCA6IHBvcyA+IDEgPyAxIDogcG9zOyAvLyBnZW5lcmF0ZSBtb3JwaGVkIGNvbG9yXG5cbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuQ29sb3Ioe1xuICAgICAgICAgIHI6IH5+KHRoaXMuciArICh0aGlzLmRlc3RpbmF0aW9uLnIgLSB0aGlzLnIpICogcG9zKSxcbiAgICAgICAgICBnOiB+fih0aGlzLmcgKyAodGhpcy5kZXN0aW5hdGlvbi5nIC0gdGhpcy5nKSAqIHBvcyksXG4gICAgICAgICAgYjogfn4odGhpcy5iICsgKHRoaXMuZGVzdGluYXRpb24uYiAtIHRoaXMuYikgKiBwb3MpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pOyAvLyBUZXN0ZXJzXG4gICAgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yIHN0cmluZ1xuXG4gICAgU1ZHLkNvbG9yLnRlc3QgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgIGNvbG9yICs9ICcnO1xuICAgICAgcmV0dXJuIFNWRy5yZWdleC5pc0hleC50ZXN0KGNvbG9yKSB8fCBTVkcucmVnZXguaXNSZ2IudGVzdChjb2xvcik7XG4gICAgfTsgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIHJnYiBvYmplY3RcblxuXG4gICAgU1ZHLkNvbG9yLmlzUmdiID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICByZXR1cm4gY29sb3IgJiYgdHlwZW9mIGNvbG9yLnIgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5nID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuYiA9PT0gJ251bWJlcic7XG4gICAgfTsgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yXG5cblxuICAgIFNWRy5Db2xvci5pc0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICByZXR1cm4gU1ZHLkNvbG9yLmlzUmdiKGNvbG9yKSB8fCBTVkcuQ29sb3IudGVzdChjb2xvcik7XG4gICAgfTsgLy8gTW9kdWxlIGZvciBhcnJheSBjb252ZXJzaW9uXG5cblxuICAgIFNWRy5BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgZmFsbGJhY2spIHtcbiAgICAgIGFycmF5ID0gKGFycmF5IHx8IFtdKS52YWx1ZU9mKCk7IC8vIGlmIGFycmF5IGlzIGVtcHR5IGFuZCBmYWxsYmFjayBpcyBwcm92aWRlZCwgdXNlIGZhbGxiYWNrXG5cbiAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMCAmJiBmYWxsYmFjaykge1xuICAgICAgICBhcnJheSA9IGZhbGxiYWNrLnZhbHVlT2YoKTtcbiAgICAgIH0gLy8gcGFyc2UgYXJyYXlcblxuXG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZShhcnJheSk7XG4gICAgfTtcblxuICAgIFNWRy5leHRlbmQoU1ZHLkFycmF5LCB7XG4gICAgICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5qb2luKCcgJyk7XG4gICAgICB9LFxuICAgICAgLy8gUmVhbCB2YWx1ZVxuICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9LFxuICAgICAgLy8gUGFyc2Ugd2hpdGVzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nXG4gICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJyYXkpIHtcbiAgICAgICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKCk7IC8vIGlmIGFscmVhZHkgaXMgYW4gYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXRcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHJldHVybiBhcnJheTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoYXJyYXkpO1xuICAgICAgfVxuICAgIH0pOyAvLyBQb2x5IHBvaW50cyBhcnJheVxuXG4gICAgU1ZHLlBvaW50QXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGZhbGxiYWNrKSB7XG4gICAgICBTVkcuQXJyYXkuY2FsbCh0aGlzLCBhcnJheSwgZmFsbGJhY2sgfHwgW1swLCAwXV0pO1xuICAgIH07IC8vIEluaGVyaXQgZnJvbSBTVkcuQXJyYXlcblxuXG4gICAgU1ZHLlBvaW50QXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheSgpO1xuICAgIFNWRy5Qb2ludEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5Qb2ludEFycmF5O1xuICAgIHZhciBwYXRoSGFuZGxlcnMgPSB7XG4gICAgICBNOiBmdW5jdGlvbiBNKGMsIHAsIHAwKSB7XG4gICAgICAgIHAueCA9IHAwLnggPSBjWzBdO1xuICAgICAgICBwLnkgPSBwMC55ID0gY1sxXTtcbiAgICAgICAgcmV0dXJuIFsnTScsIHAueCwgcC55XTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbiBMKGMsIHApIHtcbiAgICAgICAgcC54ID0gY1swXTtcbiAgICAgICAgcC55ID0gY1sxXTtcbiAgICAgICAgcmV0dXJuIFsnTCcsIGNbMF0sIGNbMV1dO1xuICAgICAgfSxcbiAgICAgIEg6IGZ1bmN0aW9uIEgoYywgcCkge1xuICAgICAgICBwLnggPSBjWzBdO1xuICAgICAgICByZXR1cm4gWydIJywgY1swXV07XG4gICAgICB9LFxuICAgICAgVjogZnVuY3Rpb24gVihjLCBwKSB7XG4gICAgICAgIHAueSA9IGNbMF07XG4gICAgICAgIHJldHVybiBbJ1YnLCBjWzBdXTtcbiAgICAgIH0sXG4gICAgICBDOiBmdW5jdGlvbiBDKGMsIHApIHtcbiAgICAgICAgcC54ID0gY1s0XTtcbiAgICAgICAgcC55ID0gY1s1XTtcbiAgICAgICAgcmV0dXJuIFsnQycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV1dO1xuICAgICAgfSxcbiAgICAgIFE6IGZ1bmN0aW9uIFEoYywgcCkge1xuICAgICAgICBwLnggPSBjWzJdO1xuICAgICAgICBwLnkgPSBjWzNdO1xuICAgICAgICByZXR1cm4gWydRJywgY1swXSwgY1sxXSwgY1syXSwgY1szXV07XG4gICAgICB9LFxuICAgICAgUzogZnVuY3Rpb24gUyhjLCBwKSB7XG4gICAgICAgIHAueCA9IGNbMl07XG4gICAgICAgIHAueSA9IGNbM107XG4gICAgICAgIHJldHVybiBbJ1MnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdXTtcbiAgICAgIH0sXG4gICAgICBaOiBmdW5jdGlvbiBaKGMsIHAsIHAwKSB7XG4gICAgICAgIHAueCA9IHAwLng7XG4gICAgICAgIHAueSA9IHAwLnk7XG4gICAgICAgIHJldHVybiBbJ1onXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBtbGh2cXRjc2EgPSAnbWxodnF0Y3Nheicuc3BsaXQoJycpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbWxodnF0Y3NhLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHBhdGhIYW5kbGVyc1ttbGh2cXRjc2FbaV1dID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjLCBwLCBwMCkge1xuICAgICAgICAgIGlmIChpID09ICdIJykgY1swXSA9IGNbMF0gKyBwLng7ZWxzZSBpZiAoaSA9PSAnVicpIGNbMF0gPSBjWzBdICsgcC55O2Vsc2UgaWYgKGkgPT0gJ0EnKSB7XG4gICAgICAgICAgICBjWzVdID0gY1s1XSArIHAueCwgY1s2XSA9IGNbNl0gKyBwLnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGMubGVuZ3RoOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICBjW2pdID0gY1tqXSArIChqICUgMiA/IHAueSA6IHAueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGhIYW5kbGVycyAmJiB0eXBlb2YgcGF0aEhhbmRsZXJzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNoZWNrIGZpeGVzIGplc3QgdW5pdCB0ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhIYW5kbGVyc1tpXShjLCBwLCBwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfShtbGh2cXRjc2FbaV0udG9VcHBlckNhc2UoKSk7XG4gICAgfSAvLyBQYXRoIHBvaW50cyBhcnJheVxuXG5cbiAgICBTVkcuUGF0aEFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBmYWxsYmFjaykge1xuICAgICAgU1ZHLkFycmF5LmNhbGwodGhpcywgYXJyYXksIGZhbGxiYWNrIHx8IFtbJ00nLCAwLCAwXV0pO1xuICAgIH07IC8vIEluaGVyaXQgZnJvbSBTVkcuQXJyYXlcblxuXG4gICAgU1ZHLlBhdGhBcnJheS5wcm90b3R5cGUgPSBuZXcgU1ZHLkFycmF5KCk7XG4gICAgU1ZHLlBhdGhBcnJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuUGF0aEFycmF5O1xuICAgIFNWRy5leHRlbmQoU1ZHLlBhdGhBcnJheSwge1xuICAgICAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9TdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBwYXRoIHN0cmluZ1xuICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cbiAgICAgICAgdmFyIGJveCA9IHRoaXMuYmJveCgpOyAvLyBnZXQgcmVsYXRpdmUgb2Zmc2V0XG5cbiAgICAgICAgeCAtPSBib3gueDtcbiAgICAgICAgeSAtPSBib3gueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IG1vcnBoZWQgcGF0aCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2VBcnJheSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbkFycmF5ID0gdGhpcy5kZXN0aW5hdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIGFycmF5ID0gW10sXG4gICAgICAgICAgICBwYXRoQXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheSgpLFxuICAgICAgICAgICAgaWwsXG4gICAgICAgICAgICBqbDsgLy8gQW5pbWF0ZSBoYXMgc3BlY2lmaWVkIGluIHRoZSBTVkcgc3BlY1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYXRocy5odG1sI1BhdGhFbGVtZW50XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc291cmNlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGFycmF5W2ldID0gW3NvdXJjZUFycmF5W2ldWzBdXTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqbCA9IHNvdXJjZUFycmF5W2ldLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIGFycmF5W2ldW2pdID0gc291cmNlQXJyYXlbaV1bal0gKyAoZGVzdGluYXRpb25BcnJheVtpXVtqXSAtIHNvdXJjZUFycmF5W2ldW2pdKSAqIHBvcztcbiAgICAgICAgICB9IC8vIEZvciB0aGUgdHdvIGZsYWdzIG9mIHRoZSBlbGxpcHRpY2FsIGFyYyBjb21tYW5kLCB0aGUgU1ZHIHNwZWMgc2F5OlxuICAgICAgICAgIC8vIEZsYWdzIGFuZCBib29sZWFucyBhcmUgaW50ZXJwb2xhdGVkIGFzIGZyYWN0aW9ucyBiZXR3ZWVuIHplcm8gYW5kIG9uZSwgd2l0aCBhbnkgbm9uLXplcm8gdmFsdWUgY29uc2lkZXJlZCB0byBiZSBhIHZhbHVlIG9mIG9uZS90cnVlXG4gICAgICAgICAgLy8gRWxsaXB0aWNhbCBhcmMgY29tbWFuZCBhcyBhbiBhcnJheSBmb2xsb3dlZCBieSBjb3JyZXNwb25kaW5nIGluZGV4ZXM6XG4gICAgICAgICAgLy8gWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuICAgICAgICAgIC8vICAgMCAgICAxICAgMiAgICAgICAgMyAgICAgICAgICAgICAgICAgNCAgICAgICAgICAgICA1ICAgICAgNiAgN1xuXG5cbiAgICAgICAgICBpZiAoYXJyYXlbaV1bMF0gPT09ICdBJykge1xuICAgICAgICAgICAgYXJyYXlbaV1bNF0gPSArKGFycmF5W2ldWzRdICE9IDApO1xuICAgICAgICAgICAgYXJyYXlbaV1bNV0gPSArKGFycmF5W2ldWzVdICE9IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEaXJlY3RseSBtb2RpZnkgdGhlIHZhbHVlIG9mIGEgcGF0aCBhcnJheSwgdGhpcyBpcyBkb25lIHRoaXMgd2F5IGZvciBwZXJmb3JtYW5jZVxuXG5cbiAgICAgICAgcGF0aEFycmF5LnZhbHVlID0gYXJyYXk7XG4gICAgICAgIHJldHVybiBwYXRoQXJyYXk7XG4gICAgICB9LFxuICAgICAgLy8gQWJzb2x1dGl6ZSBhbmQgcGFyc2UgcGF0aCB0byBhcnJheVxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGFycmF5KSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIHBhdGhhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBTVkcuUGF0aEFycmF5KSByZXR1cm4gYXJyYXkudmFsdWVPZigpOyAvLyBwcmVwYXJlIGZvciBwYXJzaW5nXG5cbiAgICAgICAgdmFyIHMsXG4gICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICBwYXJhbUNudCA9IHtcbiAgICAgICAgICAnTSc6IDIsXG4gICAgICAgICAgJ0wnOiAyLFxuICAgICAgICAgICdIJzogMSxcbiAgICAgICAgICAnVic6IDEsXG4gICAgICAgICAgJ0MnOiA2LFxuICAgICAgICAgICdTJzogNCxcbiAgICAgICAgICAnUSc6IDQsXG4gICAgICAgICAgJ1QnOiAyLFxuICAgICAgICAgICdBJzogNyxcbiAgICAgICAgICAnWic6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXkucmVwbGFjZShTVkcucmVnZXgubnVtYmVyc1dpdGhEb3RzLCBwYXRoUmVnUmVwbGFjZSkgLy8gY29udmVydCA0NS4xMjMuMTIzIHRvIDQ1LjEyMyAuMTIzXG4gICAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4LnBhdGhMZXR0ZXJzLCAnICQmICcpIC8vIHB1dCBzb21lIHJvb20gYmV0d2VlbiBsZXR0ZXJzIGFuZCBudW1iZXJzXG4gICAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4Lmh5cGhlbiwgJyQxIC0nKSAvLyBhZGQgc3BhY2UgYmVmb3JlIGh5cGhlblxuICAgICAgICAgIC50cmltKCkgLy8gdHJpbVxuICAgICAgICAgIC5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKTsgLy8gc3BsaXQgaW50byBhcnJheVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmNhbGwocHJldiwgY3Vycik7XG4gICAgICAgICAgfSwgW10pO1xuICAgICAgICB9IC8vIGFycmF5IG5vdyBpcyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBwYXJ0cyBvZiBhIHBhdGggZS5nLiBbJ00nLCAnMCcsICcwJywgJ0wnLCAnMzAnLCAnMzAnIC4uLl1cblxuXG4gICAgICAgIHZhciBhcnIgPSBbXSxcbiAgICAgICAgICAgIHAgPSBuZXcgU1ZHLlBvaW50KCksXG4gICAgICAgICAgICBwMCA9IG5ldyBTVkcuUG9pbnQoKSxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gVGVzdCBpZiB3ZSBoYXZlIGEgcGF0aCBsZXR0ZXJcbiAgICAgICAgICBpZiAoU1ZHLnJlZ2V4LmlzUGF0aExldHRlci50ZXN0KGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgICAgIHMgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICArK2luZGV4OyAvLyBJZiBsYXN0IGxldHRlciB3YXMgYSBtb3ZlIGNvbW1hbmQgYW5kIHdlIGdvdCBubyBuZXcsIGl0IGRlZmF1bHRzIHRvIFtMXWluZVxuICAgICAgICAgIH0gZWxzZSBpZiAocyA9PSAnTScpIHtcbiAgICAgICAgICAgIHMgPSAnTCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChzID09ICdtJykge1xuICAgICAgICAgICAgcyA9ICdsJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnIucHVzaChwYXRoSGFuZGxlcnNbc10uY2FsbChudWxsLCBhcnJheS5zbGljZShpbmRleCwgaW5kZXggPSBpbmRleCArIHBhcmFtQ250W3MudG9VcHBlckNhc2UoKV0pLm1hcChwYXJzZUZsb2F0KSwgcCwgcDApKTtcbiAgICAgICAgfSB3aGlsZSAobGVuID4gaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwYXRoXG4gICAgICBiYm94OiBmdW5jdGlvbiBiYm94KCkge1xuICAgICAgICBpZiAoIVNWRy5wYXJzZXIuZHJhdykge1xuICAgICAgICAgIFNWRy5wcmVwYXJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBTVkcucGFyc2VyLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIFNWRy5wYXJzZXIucGF0aC5nZXRCQm94KCk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZHVsZSBmb3IgdW5pdCBjb252ZXJ0aW9uc1xuXG4gICAgU1ZHLk51bWJlciA9IFNWRy5pbnZlbnQoe1xuICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUsIHVuaXQpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdCB8fCAnJzsgLy8gcGFyc2UgdmFsdWVcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIGVuc3VyZSBhIHZhbGlkIG51bWVyaWMgdmFsdWVcbiAgICAgICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpID8gMCA6ICFpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4IDogdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHVuaXQgPSB2YWx1ZS5tYXRjaChTVkcucmVnZXgubnVtYmVyQW5kVW5pdCk7XG5cbiAgICAgICAgICBpZiAodW5pdCkge1xuICAgICAgICAgICAgLy8gbWFrZSB2YWx1ZSBudW1lcmljXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdCh1bml0WzFdKTsgLy8gbm9ybWFsaXplXG5cbiAgICAgICAgICAgIGlmICh1bml0WzVdID09ICclJykge1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlIC89IDEwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pdFs1XSA9PSAncycpIHtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZSAqPSAxMDAwO1xuICAgICAgICAgICAgfSAvLyBzdG9yZSB1bml0XG5cblxuICAgICAgICAgICAgdGhpcy51bml0ID0gdW5pdFs1XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHRoaXMudW5pdCA9IHZhbHVlLnVuaXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQWRkIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyBTdHJpbmdhbGl6ZVxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLnVuaXQgPT0gJyUnID8gfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTYgOiB0aGlzLnVuaXQgPT0gJ3MnID8gdGhpcy52YWx1ZSAvIDFlMyA6IHRoaXMudmFsdWUpICsgdGhpcy51bml0O1xuICAgICAgICB9LFxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDb252ZXJ0IHRvIHByaW1pdGl2ZVxuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBZGQgbnVtYmVyXG4gICAgICAgIHBsdXM6IGZ1bmN0aW9uIHBsdXMobnVtYmVyKSB7XG4gICAgICAgICAgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyArIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3VidHJhY3QgbnVtYmVyXG4gICAgICAgIG1pbnVzOiBmdW5jdGlvbiBtaW51cyhudW1iZXIpIHtcbiAgICAgICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuICAgICAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzIC0gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNdWx0aXBseSBudW1iZXJcbiAgICAgICAgdGltZXM6IGZ1bmN0aW9uIHRpbWVzKG51bWJlcikge1xuICAgICAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgKiBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERpdmlkZSBudW1iZXJcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobnVtYmVyKSB7XG4gICAgICAgICAgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyAvIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ29udmVydCB0byBkaWZmZXJlbnQgdW5pdFxuICAgICAgICB0bzogZnVuY3Rpb24gdG8odW5pdCkge1xuICAgICAgICAgIHZhciBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcih0aGlzKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgdW5pdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG51bWJlci51bml0ID0gdW5pdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNYWtlIG51bWJlciBtb3JwaGFibGVcbiAgICAgICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKG51bWJlcikge1xuICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuXG4gICAgICAgICAgaWYgKG51bWJlci5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi52YWx1ZSArPSB0aGlzLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgbW9ycGhlZCBudW1iZXIgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBHZW5lcmF0ZSBuZXcgbW9ycGhlZCBudW1iZXJcblxuICAgICAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzLmRlc3RpbmF0aW9uKS5taW51cyh0aGlzKS50aW1lcyhwb3MpLnBsdXModGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuRWxlbWVudCA9IFNWRy5pbnZlbnQoe1xuICAgICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShub2RlKSB7XG4gICAgICAgIC8vIG1ha2Ugc3Ryb2tlIHZhbHVlIGFjY2Vzc2libGUgZHluYW1pY2FsbHlcbiAgICAgICAgdGhpcy5fc3Ryb2tlID0gU1ZHLmRlZmF1bHRzLmF0dHJzLnN0cm9rZTtcbiAgICAgICAgdGhpcy5fZXZlbnQgPSBudWxsOyAvLyBpbml0aWFsaXplIGRhdGEgb2JqZWN0XG5cbiAgICAgICAgdGhpcy5kb20gPSB7fTsgLy8gY3JlYXRlIGNpcmN1bGFyIHJlZmVyZW5jZVxuXG4gICAgICAgIGlmICh0aGlzLm5vZGUgPSBub2RlKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICB0aGlzLm5vZGUuaW5zdGFuY2UgPSB0aGlzOyAvLyBzdG9yZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZVxuXG4gICAgICAgICAgdGhpcy5fc3Ryb2tlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IHRoaXMuX3N0cm9rZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgICBleHRlbmQ6IHtcbiAgICAgICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgICAgICB4OiBmdW5jdGlvbiB4KF94KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIF94KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICAgICB5OiBmdW5jdGlvbiB5KF95KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigneScsIF95KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICAgICAgY3g6IGZ1bmN0aW9uIGN4KHgpIHtcbiAgICAgICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy54KCkgKyB0aGlzLndpZHRoKCkgLyAyIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcbiAgICAgICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy55KCkgKyB0aGlzLmhlaWdodCgpIC8gMiA6IHRoaXMueSh5IC0gdGhpcy5oZWlnaHQoKSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcbiAgICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueCh4KS55KHkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNb3ZlIGVsZW1lbnQgYnkgaXRzIGNlbnRlclxuICAgICAgICBjZW50ZXI6IGZ1bmN0aW9uIGNlbnRlcih4LCB5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gICAgICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd3aWR0aCcsIF93aWR0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAgICAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaGVpZ2h0JywgX2hlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBzaXplOiBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGgobmV3IFNWRy5OdW1iZXIocC53aWR0aCkpLmhlaWdodChuZXcgU1ZHLk51bWJlcihwLmhlaWdodCkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDbG9uZSBlbGVtZW50XG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShwYXJlbnQpIHtcbiAgICAgICAgICAvLyB3cml0ZSBkb20gZGF0YSB0byB0aGUgZG9tIHNvIHRoZSBjbG9uZSBjYW4gcGlja3VwIHRoZSBkYXRhXG4gICAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpOyAvLyBjbG9uZSBlbGVtZW50IGFuZCBhc3NpZ24gbmV3IGlkXG5cbiAgICAgICAgICB2YXIgY2xvbmUgPSBhc3NpZ25OZXdJZCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTsgLy8gaW5zZXJ0IHRoZSBjbG9uZSBpbiB0aGUgZ2l2ZW4gcGFyZW50IG9yIGFmdGVyIG15c2VsZlxuXG4gICAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50LmFkZChjbG9uZSk7ZWxzZSB0aGlzLmFmdGVyKGNsb25lKTtcbiAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSBlbGVtZW50XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlcGxhY2UgZWxlbWVudFxuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKGVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmFmdGVyKGVsZW1lbnQpLnJlbW92ZSgpO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LFxuICAgICAgICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBzZWxmXG4gICAgICAgIGFkZFRvOiBmdW5jdGlvbiBhZGRUbyhwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LnB1dCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gY29udGFpbmVyXG4gICAgICAgIHB1dEluOiBmdW5jdGlvbiBwdXRJbihwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmFkZCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IC8gc2V0IGlkXG4gICAgICAgIGlkOiBmdW5jdGlvbiBpZChfaWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcsIF9pZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNob3cgZWxlbWVudFxuICAgICAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJycpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBIaWRlIGVsZW1lbnRcbiAgICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIElzIGVsZW1lbnQgdmlzaWJsZT9cbiAgICAgICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScpICE9ICdub25lJztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJuIGlkIG9uIHN0cmluZyBjb252ZXJzaW9uXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm4gYXJyYXkgb2YgY2xhc3NlcyBvbiB0aGUgbm9kZVxuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgIHZhciBhdHRyID0gdGhpcy5hdHRyKCdjbGFzcycpO1xuICAgICAgICAgIHJldHVybiBhdHRyID09IG51bGwgPyBbXSA6IGF0dHIudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBjbGFzcyBleGlzdHMgb24gdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MobmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXMoKS5pbmRleE9mKG5hbWUpICE9IC0xO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKG5hbWUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuY2xhc3NlcygpO1xuICAgICAgICAgICAgYXJyYXkucHVzaChuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYXR0cignY2xhc3MnLCBhcnJheS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZW1vdmUgY2xhc3MgZnJvbSB0aGUgbm9kZVxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MobmFtZSkge1xuICAgICAgICAgIGlmICh0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIoJ2NsYXNzJywgdGhpcy5jbGFzc2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjICE9IG5hbWU7XG4gICAgICAgICAgICB9KS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUb2dnbGUgdGhlIHByZXNlbmNlIG9mIGEgY2xhc3Mgb24gdGhlIG5vZGVcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhuYW1lKSA/IHRoaXMucmVtb3ZlQ2xhc3MobmFtZSkgOiB0aGlzLmFkZENsYXNzKG5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgcmVmZXJlbmNlZCBlbGVtZW50IGZvcm0gYXR0cmlidXRlIHZhbHVlXG4gICAgICAgIHJlZmVyZW5jZTogZnVuY3Rpb24gcmVmZXJlbmNlKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gU1ZHLmdldCh0aGlzLmF0dHIoYXR0cikpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBwYXJlbnQgZWxlbWVudCBpbnN0YW5jZVxuICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCh0eXBlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7IC8vIGNoZWNrIGZvciBwYXJlbnRcblxuICAgICAgICAgIGlmICghcGFyZW50Lm5vZGUucGFyZW50Tm9kZSkgcmV0dXJuIG51bGw7IC8vIGdldCBwYXJlbnQgZWxlbWVudFxuXG4gICAgICAgICAgcGFyZW50ID0gU1ZHLmFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHBhcmVudDsgLy8gbG9vcCB0cm91Z2ggYW5jZXN0b3JzIGlmIHR5cGUgaXMgZ2l2ZW5cblxuICAgICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Lm5vZGUgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcmVudC5tYXRjaGVzKHR5cGUpIDogcGFyZW50IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm5vZGUucGFyZW50Tm9kZSB8fCBwYXJlbnQubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09ICcjZG9jdW1lbnQnKSByZXR1cm4gbnVsbDsgLy8gIzc1OSwgIzcyMFxuXG4gICAgICAgICAgICBwYXJlbnQgPSBTVkcuYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgcGFyZW50IGRvY3VtZW50XG4gICAgICAgIGRvYzogZnVuY3Rpb24gZG9jKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgU1ZHLkRvYyA/IHRoaXMgOiB0aGlzLnBhcmVudChTVkcuRG9jKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmV0dXJuIGFycmF5IG9mIGFsbCBhbmNlc3RvcnMgb2YgZ2l2ZW4gdHlwZSB1cCB0byB0aGUgcm9vdCBzdmdcbiAgICAgICAgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyh0eXBlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudHMgPSBbXSxcbiAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQodHlwZSk7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lm5vZGUpIGJyZWFrO1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgfSB3aGlsZSAocGFyZW50LnBhcmVudCk7XG5cbiAgICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbWF0Y2hlcyB0aGUgZWxlbWVudCB2cyBhIGNzcyBzZWxlY3RvclxuICAgICAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIF9tYXRjaGVzKHRoaXMubm9kZSwgc2VsZWN0b3IpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBzdmcgbm9kZSB0byBjYWxsIG5hdGl2ZSBzdmcgbWV0aG9kcyBvbiBpdFxuICAgICAgICBuYXRpdmU6IGZ1bmN0aW9uIG5hdGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJbXBvcnQgcmF3IHN2Z1xuICAgICAgICBzdmc6IGZ1bmN0aW9uIHN2Zyhfc3ZnKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHRlbXBvcmFyeSBob2xkZXJcbiAgICAgICAgICB2YXIgd2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N2ZycpOyAvLyBhY3QgYXMgYSBzZXR0ZXIgaWYgc3ZnIGlzIGdpdmVuXG5cbiAgICAgICAgICBpZiAoX3N2ZyAmJiB0aGlzIGluc3RhbmNlb2YgU1ZHLlBhcmVudCkge1xuICAgICAgICAgICAgLy8gZHVtcCByYXcgc3ZnXG4gICAgICAgICAgICB3ZWxsLmlubmVySFRNTCA9ICc8c3ZnPicgKyBfc3ZnLnJlcGxhY2UoL1xcbi8sICcnKS5yZXBsYWNlKC88KFtcXHc6LV0rKShbXjxdKz8pXFwvPi9nLCAnPCQxJDI+PC8kMT4nKSArICc8L3N2Zz4nOyAvLyB0cmFuc3BsYW50IG5vZGVzXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHdlbGwuZmlyc3RDaGlsZC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHdlbGwuZmlyc3RDaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlIGFjdCBhcyBhIGdldHRlclxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHdyYXBwaW5nIHN2ZyBlbGVtZW50IGluIGNhc2Ugb2YgcGFydGlhbCBjb250ZW50XG4gICAgICAgICAgICB3ZWxsLmFwcGVuZENoaWxkKF9zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdmcnKSk7IC8vIHdyaXRlIHN2Z2pzIGRhdGEgdG8gdGhlIGRvbVxuXG4gICAgICAgICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKCk7IC8vIGluc2VydCBhIGNvcHkgb2YgdGhpcyBub2RlXG5cbiAgICAgICAgICAgIF9zdmcuYXBwZW5kQ2hpbGQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSk7IC8vIHJldHVybiB0YXJnZXQgZWxlbWVudFxuXG5cbiAgICAgICAgICAgIHJldHVybiB3ZWxsLmlubmVySFRNTC5yZXBsYWNlKC9ePHN2Zz4vLCAnJykucmVwbGFjZSgvPFxcL3N2Zz4kLywgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cbiAgICAgICAgd3JpdGVEYXRhVG9Eb206IGZ1bmN0aW9uIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgICAgICAgIC8vIGR1bXAgdmFyaWFibGVzIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgaWYgKHRoaXMuZWFjaCB8fCB0aGlzLmxpbmVzKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSB0aGlzLmVhY2ggPyB0aGlzIDogdGhpcy5saW5lcygpO1xuICAgICAgICAgICAgZm4uZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gcmVtb3ZlIHByZXZpb3VzbHkgc2V0IGRhdGFcblxuXG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScpO1xuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZG9tKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRvbSkpO1xuICAgICAgICAgIH0gLy8gc2VlICM0MjhcblxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHNldCBnaXZlbiBkYXRhIHRvIHRoZSBlbGVtZW50cyBkYXRhIHByb3BlcnR5XG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEobykge1xuICAgICAgICAgIHRoaXMuZG9tID0gbztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaXM6IGZ1bmN0aW9uIGlzKG9iaikge1xuICAgICAgICAgIHJldHVybiBfaXModGhpcywgb2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5lYXNpbmcgPSB7XG4gICAgICAnLSc6IGZ1bmN0aW9uIF8ocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9LFxuICAgICAgJzw+JzogZnVuY3Rpb24gXyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJKSAvIDIgKyAwLjU7XG4gICAgICB9LFxuICAgICAgJz4nOiBmdW5jdGlvbiBfKHBvcykge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4ocG9zICogTWF0aC5QSSAvIDIpO1xuICAgICAgfSxcbiAgICAgICc8JzogZnVuY3Rpb24gXyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJIC8gMikgKyAxO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTVkcubW9ycGggPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1vcnBoT2JqKGZyb20sIHRvKS5hdChwb3MpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgU1ZHLlNpdHVhdGlvbiA9IFNWRy5pbnZlbnQoe1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobykge1xuICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJldmVyc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gbmV3IFNWRy5OdW1iZXIoby5kdXJhdGlvbikudmFsdWVPZigpO1xuICAgICAgICB0aGlzLmRlbGF5ID0gbmV3IFNWRy5OdW1iZXIoby5kZWxheSkudmFsdWVPZigpO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gK25ldyBEYXRlKCkgKyB0aGlzLmRlbGF5O1xuICAgICAgICB0aGlzLmZpbmlzaCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICAgICAgICB0aGlzLmVhc2UgPSBvLmVhc2U7IC8vIHRoaXMubG9vcCBpcyBpbmNyZW1lbnRlZCBmcm9tIDAgdG8gdGhpcy5sb29wc1xuICAgICAgICAvLyBpdCBpcyBhbHNvIGluY3JlbWVudGVkIHdoZW4gaW4gYW4gaW5maW5pdGUgbG9vcCAod2hlbiB0aGlzLmxvb3BzIGlzIHRydWUpXG5cbiAgICAgICAgdGhpcy5sb29wID0gMDtcbiAgICAgICAgdGhpcy5sb29wcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB7Ly8gZnVuY3Rpb25Ub0NhbGw6IFtsaXN0IG9mIG1vcnBoYWJsZSBvYmplY3RzXVxuICAgICAgICAgIC8vIGUuZy4gbW92ZTogW1NWRy5OdW1iZXIsIFNWRy5OdW1iZXJdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7Ly8gaG9sZHMgYWxsIGF0dHJpYnV0ZXMgd2hpY2ggYXJlIG5vdCByZXByZXNlbnRlZCBmcm9tIGEgZnVuY3Rpb24gc3ZnLmpzIHByb3ZpZGVzXG4gICAgICAgICAgLy8gZS5nLiBzb21lQXR0cjogU1ZHLk51bWJlclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHsvLyBob2xkcyBhbGwgc3R5bGVzIHdoaWNoIHNob3VsZCBiZSBhbmltYXRlZFxuICAgICAgICAgIC8vIGUuZy4gZmlsbC1jb2xvcjogU1ZHLkNvbG9yXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IFsvLyBob2xkcyBhbGwgdHJhbnNmb3JtYXRpb25zIGFzIHRyYW5zZm9ybWF0aW9uIG9iamVjdHNcbiAgICAgICAgICAvLyBlLmcuIFtTVkcuUm90YXRlLCBTVkcuVHJhbnNsYXRlLCBTVkcuTWF0cml4XVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLm9uY2UgPSB7Ly8gZnVuY3Rpb25zIHRvIGZpcmUgYXQgYSBzcGVjaWZpYyBwb3NpdGlvblxuICAgICAgICAgIC8vIGUuZy4gXCIwLjVcIjogZnVuY3Rpb24gZm9vKCl7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5GWCA9IFNWRy5pbnZlbnQoe1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl90YXJnZXQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNpdHVhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXR1YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RQb3MgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7IC8vIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBhbmltYXRpb24gaXMgaXRzIHBvc2l0aW9uIGluIHRoZSBjb250ZXh0IG9mIGl0cyBjb21wbGV0ZSBkdXJhdGlvbiAoaW5jbHVkaW5nIGRlbGF5IGFuZCBsb29wcylcbiAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgZGVsYXksIGFic1BvcyBpcyBiZWxvdyAwIGFuZCB3aGVuIHBlcmZvcm1pbmcgYSBsb29wLCBpdHMgdmFsdWUgaXMgYWJvdmUgMVxuXG4gICAgICAgIHRoaXMuYWJzUG9zID0gMDtcbiAgICAgICAgdGhpcy5fc3BlZWQgPSAxO1xuICAgICAgfSxcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2V0cyBvciByZXR1cm5zIHRoZSB0YXJnZXQgb2YgdGhpcyBhbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIG8gb2JqZWN0IHx8IG51bWJlciBJbiBjYXNlIG9mIE9iamVjdCBpdCBob2xkcyBhbGwgcGFyYW1ldGVycy4gSW4gY2FzZSBvZiBudW1iZXIgaXRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBlYXNlIGZ1bmN0aW9uIHx8IHN0cmluZyBGdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgdXNlZCBmb3IgZWFzaW5nIG9yIGVhc2luZyBrZXl3b3JkXG4gICAgICAgICAqIEBwYXJhbSBkZWxheSBOdW1iZXIgaW5kaWNhdGluZyB0aGUgZGVsYXkgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzXG4gICAgICAgICAqIEByZXR1cm4gdGFyZ2V0IHx8IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUobywgZWFzZSwgZGVsYXkpIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZihvKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGVhc2UgPSBvLmVhc2U7XG4gICAgICAgICAgICBkZWxheSA9IG8uZGVsYXk7XG4gICAgICAgICAgICBvID0gby5kdXJhdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2l0dWF0aW9uID0gbmV3IFNWRy5TaXR1YXRpb24oe1xuICAgICAgICAgICAgZHVyYXRpb246IG8gfHwgMTAwMCxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheSB8fCAwLFxuICAgICAgICAgICAgZWFzZTogU1ZHLmVhc2luZ1tlYXNlIHx8ICctJ10gfHwgZWFzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucXVldWUoc2l0dWF0aW9uKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBzZXRzIGEgZGVsYXkgYmVmb3JlIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHF1ZXVlIGlzIGNhbGxlZFxuICAgICAgICAqIEBwYXJhbSBkZWxheSBEdXJhdGlvbiBvZiBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgKiBAcmV0dXJuIHRoaXMudGFyZ2V0KClcbiAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgKiBzZXRzIG9yIHJldHVybnMgdGhlIHRhcmdldCBvZiB0aGlzIGFuaW1hdGlvblxuICAgICAgICAqIEBwYXJhbSBudWxsIHx8IHRhcmdldCBTVkcuRWxlbWVudCB3aGljaCBzaG91bGQgYmUgc2V0IGFzIG5ldyB0YXJnZXRcbiAgICAgICAgKiBAcmV0dXJuIHRhcmdldCB8fCB0aGlzXG4gICAgICAgICovXG4gICAgICAgIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KF90YXJnZXQpIHtcbiAgICAgICAgICBpZiAoX3RhcmdldCAmJiBfdGFyZ2V0IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IF90YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1cm5zIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBhdCBhIGdpdmVuIHRpbWVcbiAgICAgICAgdGltZVRvQWJzUG9zOiBmdW5jdGlvbiB0aW1lVG9BYnNQb3ModGltZXN0YW1wKSB7XG4gICAgICAgICAgcmV0dXJuICh0aW1lc3RhbXAgLSB0aGlzLnNpdHVhdGlvbi5zdGFydCkgLyAodGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldHVybnMgdGhlIHRpbWVzdGFtcCBmcm9tIGEgZ2l2ZW4gYWJzb2x1dGUgcG9zaXRvblxuICAgICAgICBhYnNQb3NUb1RpbWU6IGZ1bmN0aW9uIGFic1Bvc1RvVGltZShhYnNQb3MpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZCAqIGFic1BvcyArIHRoaXMuc2l0dWF0aW9uLnN0YXJ0O1xuICAgICAgICB9LFxuICAgICAgICAvLyBzdGFydHMgdGhlIGFuaW1hdGlvbmxvb3BcbiAgICAgICAgc3RhcnRBbmltRnJhbWU6IGZ1bmN0aW9uIHN0YXJ0QW5pbUZyYW1lKCkge1xuICAgICAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcCgpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGNhbmNlbHMgdGhlIGFuaW1hdGlvbmZyYW1lXG4gICAgICAgIHN0b3BBbmltRnJhbWU6IGZ1bmN0aW9uIHN0b3BBbmltRnJhbWUoKSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBraWNrcyBvZmYgdGhlIGFuaW1hdGlvbiAtIG9ubHkgZG9lcyBzb21ldGhpbmcgd2hlbiB0aGUgcXVldWUgaXMgY3VycmVudGx5IG5vdCBhY3RpdmUgYW5kIGF0IGxlYXN0IG9uZSBzaXR1YXRpb24gaXMgc2V0XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgICAvLyBkb250IHN0YXJ0IGlmIGFscmVhZHkgc3RhcnRlZFxuICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUgJiYgdGhpcy5zaXR1YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDdXJyZW50KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHN0YXJ0IHRoZSBjdXJyZW50IHNpdHVhdGlvblxuICAgICAgICBzdGFydEN1cnJlbnQ6IGZ1bmN0aW9uIHN0YXJ0Q3VycmVudCgpIHtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5zdGFydCA9ICtuZXcgRGF0ZSgpICsgdGhpcy5zaXR1YXRpb24uZGVsYXkgLyB0aGlzLl9zcGVlZDtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5maW5pc2ggPSB0aGlzLnNpdHVhdGlvbi5zdGFydCArIHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uIC8gdGhpcy5fc3BlZWQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdEFuaW1hdGlvbnMoKS5zdGVwKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogYWRkcyBhIGZ1bmN0aW9uIC8gU2l0dWF0aW9uIHRvIHRoZSBhbmltYXRpb24gcXVldWVcbiAgICAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gLyBzaXR1YXRpb24gdG8gYWRkXG4gICAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAgICovXG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZShmbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgfHwgZm4gaW5zdGFuY2VvZiBTVkcuU2l0dWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNpdHVhdGlvbnMucHVzaChmbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnNpdHVhdGlvbikgdGhpcy5zaXR1YXRpb24gPSB0aGlzLnNpdHVhdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBwdWxscyBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgcXVldWUgYW5kIGV4ZWN1dGUgaXRcbiAgICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICAgKi9cbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgICAgICAvLyBzdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICAgICAgdGhpcy5zdG9wKCk7IC8vIGdldCBuZXh0IGFuaW1hdGlvbiBmcm9tIHF1ZXVlXG5cbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IHRoaXMuc2l0dWF0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24gaW5zdGFuY2VvZiBTVkcuU2l0dWF0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCBhIFNWRy5TaXR1YXRpb24sIHRoZW4gaXQgaXMgYSBmdW5jdGlvbiwgd2UgZXhlY3V0ZSBpdFxuICAgICAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyB1cGRhdGVzIGFsbCBhbmltYXRpb25zIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50XG4gICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IHdoZW4gb25lIHByb3BlcnR5IGNvdWxkIGJlIGNoYW5nZWQgZnJvbSBhbm90aGVyIHByb3BlcnR5XG4gICAgICAgIGluaXRBbmltYXRpb25zOiBmdW5jdGlvbiBpbml0QW5pbWF0aW9ucygpIHtcbiAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgIHZhciBzID0gdGhpcy5zaXR1YXRpb247XG4gICAgICAgICAgaWYgKHMuaW5pdCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBpIGluIHMuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgc291cmNlID0gdGhpcy50YXJnZXQoKVtpXSgpO1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHMuYW5pbWF0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgICAgcy5hbmltYXRpb25zW2ldID0gW3MuYW5pbWF0aW9uc1tpXV07XG4gICAgICAgICAgICB9IC8vIGlmKHMuYW5pbWF0aW9uc1tpXS5sZW5ndGggPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyAgc291cmNlLmNvbmNhdCA9IHNvdXJjZS5jb25jYXQocy5hbmltYXRpb25zW2ldLnNsaWNlKHNvdXJjZS5sZW5ndGgsIHMuYW5pbWF0aW9uc1tpXS5sZW5ndGgpKVxuICAgICAgICAgICAgLy8gfVxuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzb3VyY2UubGVuZ3RoOyBqLS07KSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBjb25kaXRpb24gaXMgYmVjYXVzZSBzb21lIG1ldGhvZHMgcmV0dXJuIGEgbm9ybWFsIG51bWJlciBpbnN0ZWFkXG4gICAgICAgICAgICAgIC8vIG9mIGEgU1ZHLk51bWJlclxuICAgICAgICAgICAgICBpZiAocy5hbmltYXRpb25zW2ldW2pdIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICAgICAgICAgIHNvdXJjZVtqXSA9IG5ldyBTVkcuTnVtYmVyKHNvdXJjZVtqXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzLmFuaW1hdGlvbnNbaV1bal0gPSBzb3VyY2Vbal0ubW9ycGgocy5hbmltYXRpb25zW2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpIGluIHMuYXR0cnMpIHtcbiAgICAgICAgICAgIHMuYXR0cnNbaV0gPSBuZXcgU1ZHLk1vcnBoT2JqKHRoaXMudGFyZ2V0KCkuYXR0cihpKSwgcy5hdHRyc1tpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBzLnN0eWxlcykge1xuICAgICAgICAgICAgcy5zdHlsZXNbaV0gPSBuZXcgU1ZHLk1vcnBoT2JqKHRoaXMudGFyZ2V0KCkuc3R5bGUoaSksIHMuc3R5bGVzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzLmluaXRpYWxUcmFuc2Zvcm1hdGlvbiA9IHRoaXMudGFyZ2V0KCkubWF0cml4aWZ5KCk7XG4gICAgICAgICAgcy5pbml0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbnMgPSBbXTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJDdXJyZW50OiBmdW5jdGlvbiBjbGVhckN1cnJlbnQoKSB7XG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24gPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBzdG9wcyB0aGUgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICogQHBhcmFtIGp1bXBUb0VuZCBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbW1lZGlhdGVseS5cbiAgICAgICAgKiBAcGFyYW0gY2xlYXJRdWV1ZSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJlbW92ZSBxdWV1ZWQgYW5pbWF0aW9uIGFzIHdlbGwuXG4gICAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoanVtcFRvRW5kLCBjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoY2xlYXJRdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGp1bXBUb0VuZCAmJiB0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2l0dWF0aW9uIGlmIGl0IHdhcyBub3RcbiAgICAgICAgICAgICFhY3RpdmUgJiYgdGhpcy5zdGFydEN1cnJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuYXRFbmQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhckN1cnJlbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKGZuKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKSxcbiAgICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSkge1xuICAgICAgICAgICAgaWYgKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKSB7XG4gICAgICAgICAgICAgIGZuLmNhbGwodGhpcywgYyk7XG4gICAgICAgICAgICAgIHRoaXMub2ZmKCdmaW5pc2hlZC5meCcsIHdyYXBwZXIpOyAvLyBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMudGFyZ2V0KCkub24oJ2ZpbmlzaGVkLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBhZGRzIGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIG9uZSBhbmltYXRpb24gc3RlcCBpcyBwZXJmb3JtZWRcbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiBkdXJpbmcoZm4pIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMubGFzdCgpLFxuICAgICAgICAgICAgICB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwuc2l0dWF0aW9uID09IGMpIHtcbiAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBlLmRldGFpbC5wb3MsIFNWRy5tb3JwaChlLmRldGFpbC5wb3MpLCBlLmRldGFpbC5lYXNlZCwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTsgLy8gc2VlIGFib3ZlXG5cblxuICAgICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKS5vbignZHVyaW5nLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgICAgdGhpcy5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm9mZignZHVyaW5nLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBjYWxscyBhZnRlciBBTEwgYW5pbWF0aW9ucyBpbiB0aGUgcXVldWUgYXJlIGZpbmlzaGVkXG4gICAgICAgIGFmdGVyQWxsOiBmdW5jdGlvbiBhZnRlckFsbChmbikge1xuICAgICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcihlKSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgICAgfTsgLy8gc2VlIGFib3ZlXG5cblxuICAgICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpLm9uKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaXR1YXRpb25zLmxlbmd0aCA/IHRoaXMuc2l0dWF0aW9uc1t0aGlzLnNpdHVhdGlvbnMubGVuZ3RoIC0gMV0gOiB0aGlzLnNpdHVhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYWRkcyBvbmUgcHJvcGVydHkgdG8gdGhlIGFuaW1hdGlvbnNcbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQobWV0aG9kLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgdGhpcy5sYXN0KClbdHlwZSB8fCAnYW5pbWF0aW9ucyddW21ldGhvZF0gPSBhcmdzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogcGVyZm9ybSBvbmUgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICogIEBwYXJhbSBpZ25vcmVUaW1lIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGlnbm9yZSB0aW1lIGFuZCB1c2UgcG9zaXRpb24gZGlyZWN0bHkgb3IgcmVjYWxjdWxhdGUgcG9zaXRpb24gYmFzZWQgb24gdGltZVxuICAgICAgICAqICBAcmV0dXJuIHRoaXNcbiAgICAgICAgKi9cbiAgICAgICAgc3RlcDogZnVuY3Rpb24gc3RlcChpZ25vcmVUaW1lKSB7XG4gICAgICAgICAgLy8gY29udmVydCBjdXJyZW50IHRpbWUgdG8gYW4gYWJzb2x1dGUgcG9zaXRpb25cbiAgICAgICAgICBpZiAoIWlnbm9yZVRpbWUpIHRoaXMuYWJzUG9zID0gdGhpcy50aW1lVG9BYnNQb3MoK25ldyBEYXRlKCkpOyAvLyBUaGlzIHBhcnQgY29udmVydCBhbiBhYnNvbHV0ZSBwb3NpdGlvbiB0byBhIHBvc2l0aW9uXG5cbiAgICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ubG9vcHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgYWJzUG9zLCBhYnNQb3NJbnQsIGxhc3RMb29wOyAvLyBJZiB0aGUgYWJzb2x1dGUgcG9zaXRpb24gaXMgYmVsb3cgMCwgd2UganVzdCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgMFxuXG4gICAgICAgICAgICBhYnNQb3MgPSBNYXRoLm1heCh0aGlzLmFic1BvcywgMCk7XG4gICAgICAgICAgICBhYnNQb3NJbnQgPSBNYXRoLmZsb29yKGFic1Bvcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5sb29wcyA9PT0gdHJ1ZSB8fCBhYnNQb3NJbnQgPCB0aGlzLnNpdHVhdGlvbi5sb29wcykge1xuICAgICAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcyAtIGFic1Bvc0ludDtcbiAgICAgICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wO1xuICAgICAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5sb29wID0gYWJzUG9zSW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hYnNQb3MgPSB0aGlzLnNpdHVhdGlvbi5sb29wcztcbiAgICAgICAgICAgICAgdGhpcy5wb3MgPSAxOyAvLyBUaGUgLTEgaGVyZSBpcyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gdG9nZ2xlIHJldmVyc2VkIHdoZW4gYWxsIHRoZSBsb29wcyBoYXZlIGJlZW4gY29tcGxldGVkXG5cbiAgICAgICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wIC0gMTtcbiAgICAgICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcCA9IHRoaXMuc2l0dWF0aW9uLmxvb3BzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ucmV2ZXJzaW5nKSB7XG4gICAgICAgICAgICAgIC8vIFRvZ2dsZSByZXZlcnNlZCBpZiBhbiBvZGQgbnVtYmVyIG9mIGxvb3BzIGFzIG9jY3VyZWQgc2luY2UgdGhlIGxhc3QgY2FsbCBvZiBzdGVwXG4gICAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkID0gdGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQgIT0gQm9vbGVhbigodGhpcy5zaXR1YXRpb24ubG9vcCAtIGxhc3RMb29wKSAlIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbG9vcCwgdGhlIGFic29sdXRlIHBvc2l0aW9uIG11c3Qgbm90IGJlIGFib3ZlIDFcbiAgICAgICAgICAgIHRoaXMuYWJzUG9zID0gTWF0aC5taW4odGhpcy5hYnNQb3MsIDEpO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmFic1BvcztcbiAgICAgICAgICB9IC8vIHdoaWxlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBjYW4gYmUgYmVsb3cgMCwgdGhlIHBvc2l0aW9uIG11c3Qgbm90IGJlIGJlbG93IDBcblxuXG4gICAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCkgdGhpcy5wb3MgPSAxIC0gdGhpcy5wb3M7IC8vIGFwcGx5IGVhc2luZ1xuXG4gICAgICAgICAgdmFyIGVhc2VkID0gdGhpcy5zaXR1YXRpb24uZWFzZSh0aGlzLnBvcyk7IC8vIGNhbGwgb25jZS1jYWxsYmFja3NcblxuICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zaXR1YXRpb24ub25jZSkge1xuICAgICAgICAgICAgaWYgKGkgPiB0aGlzLmxhc3RQb3MgJiYgaSA8PSBlYXNlZCkge1xuICAgICAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5vbmNlW2ldLmNhbGwodGhpcy50YXJnZXQoKSwgdGhpcy5wb3MsIGVhc2VkKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBmaXJlIGR1cmluZyBjYWxsYmFjayB3aXRoIHBvc2l0aW9uLCBlYXNlZCBwb3NpdGlvbiBhbmQgY3VycmVudCBzaXR1YXRpb24gYXMgcGFyYW1ldGVyXG5cblxuICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkgdGhpcy50YXJnZXQoKS5maXJlKCdkdXJpbmcnLCB7XG4gICAgICAgICAgICBwb3M6IHRoaXMucG9zLFxuICAgICAgICAgICAgZWFzZWQ6IGVhc2VkLFxuICAgICAgICAgICAgZng6IHRoaXMsXG4gICAgICAgICAgICBzaXR1YXRpb246IHRoaXMuc2l0dWF0aW9uXG4gICAgICAgICAgfSk7IC8vIHRoZSB1c2VyIG1heSBjYWxsIHN0b3Agb3IgZmluaXNoIGluIHRoZSBkdXJpbmcgY2FsbGJhY2tcbiAgICAgICAgICAvLyBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBzdGlsbCBoYXZlIGEgdmFsaWQgc2l0dWF0aW9uXG5cbiAgICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IC8vIGFwcGx5IHRoZSBhY3R1YWwgYW5pbWF0aW9uIHRvIGV2ZXJ5IHByb3BlcnR5XG5cblxuICAgICAgICAgIHRoaXMuZWFjaEF0KCk7IC8vIGRvIGZpbmFsIGNvZGUgd2hlbiBzaXR1YXRpb24gaXMgZmluaXNoZWRcblxuICAgICAgICAgIGlmICh0aGlzLnBvcyA9PSAxICYmICF0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCB8fCB0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCAmJiB0aGlzLnBvcyA9PSAwKSB7XG4gICAgICAgICAgICAvLyBzdG9wIGFuaW1hdGlvbiBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbUZyYW1lKCk7IC8vIGZpcmUgZmluaXNoZWQgY2FsbGJhY2sgd2l0aCBjdXJyZW50IHNpdHVhdGlvbiBhcyBwYXJhbWV0ZXJcblxuICAgICAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdmaW5pc2hlZCcsIHtcbiAgICAgICAgICAgICAgZng6IHRoaXMsXG4gICAgICAgICAgICAgIHNpdHVhdGlvbjogdGhpcy5zaXR1YXRpb25cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdhbGxmaW5pc2hlZCcpOyAvLyBSZWNoZWNrIHRoZSBsZW5ndGggc2luY2UgdGhlIHVzZXIgbWF5IGNhbGwgYW5pbWF0ZSBpbiB0aGUgYWZ0ZXJBbGwgY2FsbGJhY2tcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCgpLm9mZignLmZ4Jyk7IC8vIHRoZXJlIHNob3VsZG50IGJlIGFueSBiaW5kaW5nIGxlZnQsIGJ1dCB0byBtYWtlIHN1cmUuLi5cblxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gc3RhcnQgbmV4dCBhbmltYXRpb25cblxuXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHRoaXMuZGVxdWV1ZSgpO2Vsc2UgdGhpcy5jbGVhckN1cnJlbnQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gd2UgY29udGludWUgYW5pbWF0aW5nIHdoZW4gd2UgYXJlIG5vdCBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0aGlzLnN0YXJ0QW5pbUZyYW1lKCk7XG4gICAgICAgICAgfSAvLyBzYXZlIGxhc3QgZWFzZWQgcG9zaXRpb24gZm9yIG9uY2UgY2FsbGJhY2sgdHJpZ2dlcmluZ1xuXG5cbiAgICAgICAgICB0aGlzLmxhc3RQb3MgPSBlYXNlZDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gY2FsY3VsYXRlcyB0aGUgc3RlcCBmb3IgZXZlcnkgcHJvcGVydHkgYW5kIGNhbGxzIGJsb2NrIHdpdGggaXRcbiAgICAgICAgZWFjaEF0OiBmdW5jdGlvbiBlYWNoQXQoKSB7XG4gICAgICAgICAgdmFyIGxlbixcbiAgICAgICAgICAgICAgYXQsXG4gICAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCgpLFxuICAgICAgICAgICAgICBzID0gdGhpcy5zaXR1YXRpb247IC8vIGFwcGx5IGFuaW1hdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB0cm91Z2ggYSBtZXRob2RcblxuICAgICAgICAgIGZvciAodmFyIGkgaW4gcy5hbmltYXRpb25zKSB7XG4gICAgICAgICAgICBhdCA9IFtdLmNvbmNhdChzLmFuaW1hdGlvbnNbaV0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFyZ2V0W2ldLmFwcGx5KHRhcmdldCwgYXQpO1xuICAgICAgICAgIH0gLy8gYXBwbHkgYW5pbWF0aW9uIHdoaWNoIGhhcyB0byBiZSBhcHBsaWVkIHdpdGggYXR0cigpXG5cblxuICAgICAgICAgIGZvciAodmFyIGkgaW4gcy5hdHRycykge1xuICAgICAgICAgICAgYXQgPSBbaV0uY29uY2F0KHMuYXR0cnNbaV0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFyZ2V0LmF0dHIuYXBwbHkodGFyZ2V0LCBhdCk7XG4gICAgICAgICAgfSAvLyBhcHBseSBhbmltYXRpb24gd2hpY2ggaGFzIHRvIGJlIGFwcGxpZWQgd2l0aCBzdHlsZSgpXG5cblxuICAgICAgICAgIGZvciAodmFyIGkgaW4gcy5zdHlsZXMpIHtcbiAgICAgICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLnN0eWxlc1tpXSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUuYXBwbHkodGFyZ2V0LCBhdCk7XG4gICAgICAgICAgfSAvLyBhbmltYXRlIGluaXRpYWxUcmFuc2Zvcm1hdGlvbiB3aGljaCBoYXMgdG8gYmUgY2hhaW5lZFxuXG5cbiAgICAgICAgICBpZiAocy50cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZ2V0IGluaXRpYWwgaW5pdGlhbFRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICBhdCA9IHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vIGdldCBuZXh0IHRyYW5zZm9ybWF0aW9uIGluIGNoYWluXG4gICAgICAgICAgICAgIHZhciBhID0gcy50cmFuc2Zvcm1zW2ldOyAvLyBtdWx0aXBseSBtYXRyaXggZGlyZWN0bHlcblxuICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFNWRy5NYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgYXQgPSBhdC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgpLm1vcnBoKGEpLmF0KHMuZWFzZSh0aGlzLnBvcykpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYXQgPSBhdC5tb3JwaChhKS5hdChzLmVhc2UodGhpcy5wb3MpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSAvLyB3aGVuIHRyYW5zZm9ybWF0aW9uIGlzIGFic29sdXRlIHdlIGhhdmUgdG8gcmVzZXQgdGhlIG5lZWRlZCB0cmFuc2Zvcm1hdGlvbiBmaXJzdFxuXG5cbiAgICAgICAgICAgICAgaWYgKCFhLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgYS51bmRvKGF0LmV4dHJhY3QoKSk7XG4gICAgICAgICAgICAgIH0gLy8gYW5kIHJlYXBwbHkgaXQgYWZ0ZXJcblxuXG4gICAgICAgICAgICAgIGF0ID0gYXQubXVsdGlwbHkoYS5hdChzLmVhc2UodGhpcy5wb3MpKSk7XG4gICAgICAgICAgICB9IC8vIHNldCBuZXcgbWF0cml4IG9uIGVsZW1lbnRcblxuXG4gICAgICAgICAgICB0YXJnZXQubWF0cml4KGF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYWRkcyBhbiBvbmNlLWNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIGFuZCBuZXZlciBhZ2FpblxuICAgICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKHBvcywgZm4sIGlzRWFzZWQpIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMubGFzdCgpO1xuICAgICAgICAgIGlmICghaXNFYXNlZCkgcG9zID0gYy5lYXNlKHBvcyk7XG4gICAgICAgICAgYy5vbmNlW3Bvc10gPSBmbjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX2NhbGxTdGFydDogZnVuY3Rpb24gX2NhbGxTdGFydCgpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyZW50OiBTVkcuRWxlbWVudCxcbiAgICAgIC8vIEFkZCBtZXRob2QgdG8gcGFyZW50IGVsZW1lbnRzXG4gICAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgICAgLy8gR2V0IGZ4IG1vZHVsZSBvciBjcmVhdGUgYSBuZXcgb25lLCB0aGVuIGFuaW1hdGUgd2l0aCBnaXZlbiBkdXJhdGlvbiBhbmQgZWFzZVxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKG8sIGVhc2UsIGRlbGF5KSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWCh0aGlzKSkpLmFuaW1hdGUobywgZWFzZSwgZGVsYXkpO1xuICAgICAgICB9LFxuICAgICAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkoX2RlbGF5KSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWCh0aGlzKSkpLmRlbGF5KF9kZWxheSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoanVtcFRvRW5kLCBjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZngpIHtcbiAgICAgICAgICAgIHRoaXMuZnguc3RvcChqdW1wVG9FbmQsIGNsZWFyUXVldWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgICAgdGhpcy5meC5maW5pc2goKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyBNb3JwaE9iaiBpcyB1c2VkIHdoZW5ldmVyIG5vIG1vcnBoYWJsZSBvYmplY3QgaXMgZ2l2ZW5cblxuICAgIFNWRy5Nb3JwaE9iaiA9IFNWRy5pbnZlbnQoe1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZnJvbSwgdG8pIHtcbiAgICAgICAgLy8gcHJlcGFyZSBjb2xvciBmb3IgbW9ycGhpbmdcbiAgICAgICAgaWYgKFNWRy5Db2xvci5pc0NvbG9yKHRvKSkgcmV0dXJuIG5ldyBTVkcuQ29sb3IoZnJvbSkubW9ycGgodG8pOyAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgbGlzdCBvZiB2YWx1ZXNcblxuICAgICAgICBpZiAoU1ZHLnJlZ2V4LmRlbGltaXRlci50ZXN0KGZyb20pKSB7XG4gICAgICAgICAgLy8gcHJlcGFyZSBwYXRoIGZvciBtb3JwaGluZ1xuICAgICAgICAgIGlmIChTVkcucmVnZXgucGF0aExldHRlcnMudGVzdChmcm9tKSkgcmV0dXJuIG5ldyBTVkcuUGF0aEFycmF5KGZyb20pLm1vcnBoKHRvKTsgLy8gcHJlcGFyZSB2YWx1ZSBsaXN0IGZvciBtb3JwaGluZ1xuICAgICAgICAgIGVsc2UgcmV0dXJuIG5ldyBTVkcuQXJyYXkoZnJvbSkubW9ycGgodG8pO1xuICAgICAgICB9IC8vIHByZXBhcmUgbnVtYmVyIGZvciBtb3JwaGluZ1xuXG5cbiAgICAgICAgaWYgKFNWRy5yZWdleC5udW1iZXJBbmRVbml0LnRlc3QodG8pKSByZXR1cm4gbmV3IFNWRy5OdW1iZXIoZnJvbSkubW9ycGgodG8pOyAvLyBwcmVwYXJlIGZvciBwbGFpbiBtb3JwaGluZ1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSBmcm9tO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gdG87XG4gICAgICB9LFxuICAgICAgZXh0ZW5kOiB7XG4gICAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MsIHJlYWwpIHtcbiAgICAgICAgICByZXR1cm4gcmVhbCA8IDEgPyB0aGlzLnZhbHVlIDogdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5leHRlbmQoU1ZHLkZYLCB7XG4gICAgICAvLyBBZGQgYW5pbWF0YWJsZSBhdHRyaWJ1dGVzXG4gICAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIHYsIHJlbGF0aXZlKSB7XG4gICAgICAgIC8vIGFwcGx5IGF0dHJpYnV0ZXMgaW5kaXZpZHVhbGx5XG4gICAgICAgIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIoa2V5LCBhW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZChhLCB2LCAnYXR0cnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEFkZCBhbmltYXRhYmxlIHBsb3RcbiAgICAgIHBsb3Q6IGZ1bmN0aW9uIHBsb3QoYSwgYiwgYywgZCkge1xuICAgICAgICAvLyBMaW5lcyBjYW4gYmUgcGxvdHRlZCB3aXRoIDQgYXJndW1lbnRzXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbG90KFthLCBiLCBjLCBkXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoJ3Bsb3QnLCBuZXcgKHRoaXMudGFyZ2V0KCkubW9ycGhBcnJheSkoYSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5Cb3ggPSBTVkcuaW52ZW50KHtcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKF90eXBlb2YoeCkgPT09ICdvYmplY3QnICYmICEoeCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSkge1xuICAgICAgICAgIC8vIGNocm9tZXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGhhcyBubyB4IGFuZCB5IHByb3BlcnR5XG4gICAgICAgICAgcmV0dXJuIFNWRy5Cb3guY2FsbCh0aGlzLCB4LmxlZnQgIT0gbnVsbCA/IHgubGVmdCA6IHgueCwgeC50b3AgIT0gbnVsbCA/IHgudG9wIDogeC55LCB4LndpZHRoLCB4LmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfSAvLyBhZGQgY2VudGVyLCByaWdodCwgYm90dG9tLi4uXG5cblxuICAgICAgICBmdWxsQm94KHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5CQm94ID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICAgIFNWRy5Cb3guYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTsgLy8gZ2V0IHZhbHVlcyBpZiBlbGVtZW50IGlzIGdpdmVuXG5cbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCkge1xuICAgICAgICAgIHZhciBib3g7IC8vIHllcyB0aGlzIGlzIHVnbHksIGJ1dCBGaXJlZm94IGNhbiBiZSBhIHBhaW4gd2hlbiBpdCBjb21lcyB0byBlbGVtZW50cyB0aGF0IGFyZSBub3QgeWV0IHJlbmRlcmVkXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBJRSAtIGl0IGRvZXMgbm90IHN1cHBvcnQgY29udGFpbnMoKSBmb3IgdG9wLWxldmVsIFNWR3NcbiAgICAgICAgICAgICAgdmFyIHRvcFBhcmVudCA9IGVsZW1lbnQubm9kZTtcblxuICAgICAgICAgICAgICB3aGlsZSAodG9wUGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0b3BQYXJlbnQgPSB0b3BQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0b3BQYXJlbnQgIT0gZG9jdW1lbnQpIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBub3QgaW4gdGhlIGRvbScpO1xuICAgICAgICAgICAgfSBlbHNlIHsvLyB0aGUgZWxlbWVudCBpcyBOT1QgaW4gdGhlIGRvbSwgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgLy8gZGlzYWJsaW5nIHRoZSBjaGVjayBiZWxvdyB3aGljaCBmaXhlcyBpc3N1ZSAjNzZcbiAgICAgICAgICAgICAgLy8gaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWxlbWVudC5ub2RlKSkgdGhyb3cgbmV3IEV4Y2VwdGlvbignRWxlbWVudCBub3QgaW4gdGhlIGRvbScpXG4gICAgICAgICAgICB9IC8vIGZpbmQgbmF0aXZlIGJib3hcblxuXG4gICAgICAgICAgICBib3ggPSBlbGVtZW50Lm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLlNoYXBlKSB7XG4gICAgICAgICAgICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXMgYXBleGNoYXJ0cy92dWUtYXBleGNoYXJ0cyAjMTRcbiAgICAgICAgICAgICAgICBTVkcucHJlcGFyZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGNsb25lID0gZWxlbWVudC5jbG9uZShTVkcucGFyc2VyLmRyYXcuaW5zdGFuY2UpLnNob3coKTtcblxuICAgICAgICAgICAgICBpZiAoY2xvbmUgJiYgY2xvbmUubm9kZSAmJiB0eXBlb2YgY2xvbmUubm9kZS5nZXRCQm94ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaGVjayBmaXhlcyBqZXN0IHVuaXQgdGVzdHNcbiAgICAgICAgICAgICAgICBib3ggPSBjbG9uZS5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjbG9uZSAmJiB0eXBlb2YgY2xvbmUucmVtb3ZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJveCA9IHtcbiAgICAgICAgICAgICAgICB4OiBlbGVtZW50Lm5vZGUuY2xpZW50TGVmdCxcbiAgICAgICAgICAgICAgICB5OiBlbGVtZW50Lm5vZGUuY2xpZW50VG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50Lm5vZGUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm5vZGUuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgU1ZHLkJveC5jYWxsKHRoaXMsIGJveCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBEZWZpbmUgYW5jZXN0b3JcbiAgICAgIGluaGVyaXQ6IFNWRy5Cb3gsXG4gICAgICAvLyBEZWZpbmUgUGFyZW50XG4gICAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgICAgLy8gQ29uc3RydWN0b3JcbiAgICAgIGNvbnN0cnVjdDoge1xuICAgICAgICAvLyBHZXQgYm91bmRpbmcgYm94XG4gICAgICAgIGJib3g6IGZ1bmN0aW9uIGJib3goKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuQkJveCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5CQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5CQm94O1xuICAgIFNWRy5NYXRyaXggPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemVcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHNvdXJjZSkge1xuICAgICAgICB2YXIgYmFzZSA9IGFycmF5VG9NYXRyaXgoWzEsIDAsIDAsIDEsIDAsIDBdKTsgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcblxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UgPT09IG51bGwgPyBiYXNlIDogc291cmNlIGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQgPyBzb3VyY2UubWF0cml4aWZ5KCkgOiB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IGFycmF5VG9NYXRyaXgoc291cmNlLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KSkgOiBhcmd1bWVudHMubGVuZ3RoID09IDYgPyBhcnJheVRvTWF0cml4KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBhcnJheVRvTWF0cml4KHNvdXJjZSkgOiBzb3VyY2UgJiYgX3R5cGVvZihzb3VyY2UpID09PSAnb2JqZWN0JyA/IHNvdXJjZSA6IGJhc2U7IC8vIG1lcmdlIHNvdXJjZVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBhYmNkZWYubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB0aGlzW2FiY2RlZltpXV0gPSBzb3VyY2VbYWJjZGVmW2ldXSAhPSBudWxsID8gc291cmNlW2FiY2RlZltpXV0gOiBiYXNlW2FiY2RlZltpXV07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBZGQgbWV0aG9kc1xuICAgICAgZXh0ZW5kOiB7XG4gICAgICAgIC8vIEV4dHJhY3QgaW5kaXZpZHVhbCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgZXh0cmFjdDogZnVuY3Rpb24gZXh0cmFjdCgpIHtcbiAgICAgICAgICAvLyBmaW5kIGRlbHRhIHRyYW5zZm9ybSBwb2ludHNcbiAgICAgICAgICB2YXIgcHggPSBkZWx0YVRyYW5zZm9ybVBvaW50KHRoaXMsIDAsIDEpO1xuICAgICAgICAgICAgICBkZWx0YVRyYW5zZm9ybVBvaW50KHRoaXMsIDEsIDApO1xuICAgICAgICAgICAgICB2YXIgc2tld1ggPSAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihweC55LCBweC54KSAtIDkwO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyB0cmFuc2xhdGlvblxuICAgICAgICAgICAgeDogdGhpcy5lLFxuICAgICAgICAgICAgeTogdGhpcy5mLFxuICAgICAgICAgICAgdHJhbnNmb3JtZWRYOiAodGhpcy5lICogTWF0aC5jb3Moc2tld1ggKiBNYXRoLlBJIC8gMTgwKSArIHRoaXMuZiAqIE1hdGguc2luKHNrZXdYICogTWF0aC5QSSAvIDE4MCkpIC8gTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYiAqIHRoaXMuYiksXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZFk6ICh0aGlzLmYgKiBNYXRoLmNvcyhza2V3WCAqIE1hdGguUEkgLyAxODApICsgdGhpcy5lICogTWF0aC5zaW4oLXNrZXdYICogTWF0aC5QSSAvIDE4MCkpIC8gTWF0aC5zcXJ0KHRoaXMuYyAqIHRoaXMuYyArIHRoaXMuZCAqIHRoaXMuZCksXG4gICAgICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICAgICAgcm90YXRpb246IHNrZXdYLFxuICAgICAgICAgICAgYTogdGhpcy5hLFxuICAgICAgICAgICAgYjogdGhpcy5iLFxuICAgICAgICAgICAgYzogdGhpcy5jLFxuICAgICAgICAgICAgZDogdGhpcy5kLFxuICAgICAgICAgICAgZTogdGhpcy5lLFxuICAgICAgICAgICAgZjogdGhpcy5mLFxuICAgICAgICAgICAgbWF0cml4OiBuZXcgU1ZHLk1hdHJpeCh0aGlzKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENsb25lIG1hdHJpeFxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNb3JwaCBvbmUgbWF0cml4IGludG8gYW5vdGhlclxuICAgICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgobWF0cml4KSB7XG4gICAgICAgICAgLy8gc3RvcmUgbmV3IGRlc3RpbmF0aW9uXG4gICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuTWF0cml4KG1hdHJpeCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE11bHRpcGxpZXMgYnkgZ2l2ZW4gbWF0cml4XG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5uYXRpdmUoKS5tdWx0aXBseShwYXJzZU1hdHJpeChtYXRyaXgpLm5hdGl2ZSgpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEludmVyc2VzIG1hdHJpeFxuICAgICAgICBpbnZlcnNlOiBmdW5jdGlvbiBpbnZlcnNlKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLmludmVyc2UoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRyYW5zbGF0ZSBtYXRyaXhcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLnRyYW5zbGF0ZSh4IHx8IDAsIHkgfHwgMCkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDb252ZXJ0IHRvIG5hdGl2ZSBTVkdNYXRyaXhcbiAgICAgICAgbmF0aXZlOiBmdW5jdGlvbiBuYXRpdmUoKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBtYXRyaXhcbiAgICAgICAgICB2YXIgbWF0cml4ID0gU1ZHLnBhcnNlci5uYXRpdmUuY3JlYXRlU1ZHTWF0cml4KCk7IC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgdmFsdWVzXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gYWJjZGVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBtYXRyaXhbYWJjZGVmW2ldXSA9IHRoaXNbYWJjZGVmW2ldXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9LFxuICAgICAgICAvLyBDb252ZXJ0IG1hdHJpeCB0byBzdHJpbmdcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgbWF0cml4IGRpcmVjdGx5LCBhdm9pZCB2YWx1ZXMgdGhhdCBhcmUgdG9vIHNtYWxsXG4gICAgICAgICAgcmV0dXJuICdtYXRyaXgoJyArIGZsb2F0MzJTdHJpbmcodGhpcy5hKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5iKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5jKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5kKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5lKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5mKSArICcpJztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIERlZmluZSBwYXJlbnRcbiAgICAgIHBhcmVudDogU1ZHLkVsZW1lbnQsXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIEdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgICBjdG06IGZ1bmN0aW9uIGN0bSgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldENUTSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgc2NyZWVuIG1hdHJpeFxuICAgICAgICBzY3JlZW5DVE06IGZ1bmN0aW9uIHNjcmVlbkNUTSgpIHtcbiAgICAgICAgICAvKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzQ0NTM3XG4gICAgICAgICAgICAgVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBGRiBkb2VzIG5vdCByZXR1cm4gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAgICAgICAgIGZvciB0aGUgaW5uZXIgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlbiBnZXRTY3JlZW5DVE0oKSBpcyBjYWxsZWQgb24gbmVzdGVkIHN2Z3MuXG4gICAgICAgICAgICAgSG93ZXZlciBhbGwgb3RoZXIgQnJvd3NlcnMgZG8gdGhhdCAqL1xuICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU1ZHLk5lc3RlZCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnJlY3QoMSwgMSk7XG4gICAgICAgICAgICB2YXIgbSA9IHJlY3Qubm9kZS5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICAgIHJlY3QucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgobSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuUG9pbnQgPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemVcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHgsIHkpIHtcbiAgICAgICAgdmFyIHNvdXJjZSxcbiAgICAgICAgICAgIGJhc2UgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07IC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG5cbiAgICAgICAgc291cmNlID0gQXJyYXkuaXNBcnJheSh4KSA/IHtcbiAgICAgICAgICB4OiB4WzBdLFxuICAgICAgICAgIHk6IHhbMV1cbiAgICAgICAgfSA6IF90eXBlb2YoeCkgPT09ICdvYmplY3QnID8ge1xuICAgICAgICAgIHg6IHgueCxcbiAgICAgICAgICB5OiB4LnlcbiAgICAgICAgfSA6IHggIT0gbnVsbCA/IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHkgIT0gbnVsbCA/IHkgOiB4XG4gICAgICAgIH0gOiBiYXNlOyAvLyBJZiB5IGhhcyBubyB2YWx1ZSwgdGhlbiB4IGlzIHVzZWQgaGFzIGl0cyB2YWx1ZVxuICAgICAgICAvLyBtZXJnZSBzb3VyY2VcblxuICAgICAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICAgICAgdGhpcy55ID0gc291cmNlLnk7XG4gICAgICB9LFxuICAgICAgLy8gQWRkIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyBDbG9uZSBwb2ludFxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1vcnBoIG9uZSBwb2ludCBpbnRvIGFub3RoZXJcbiAgICAgICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKHgsIHkpIHtcbiAgICAgICAgICAvLyBzdG9yZSBuZXcgZGVzdGluYXRpb25cbiAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5Qb2ludCh4LCB5KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAgIC8vIEdldCBwb2ludFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnQoeCwgeSkudHJhbnNmb3JtKHRoaXMuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgICAvLyBTZXQgc3ZnIGVsZW1lbnQgYXR0cmlidXRlXG4gICAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIHYsIG4pIHtcbiAgICAgICAgLy8gYWN0IGFzIGZ1bGwgZ2V0dGVyXG4gICAgICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgICAvLyBnZXQgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgICAgICBhID0ge307XG4gICAgICAgICAgdiA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgZm9yICh2YXIgbiA9IHYubGVuZ3RoIC0gMTsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgICAgIGFbdltuXS5ub2RlTmFtZV0gPSBTVkcucmVnZXguaXNOdW1iZXIudGVzdCh2W25dLm5vZGVWYWx1ZSkgPyBwYXJzZUZsb2F0KHZbbl0ubm9kZVZhbHVlKSA6IHZbbl0ubm9kZVZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoYSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gYXBwbHkgZXZlcnkgYXR0cmlidXRlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgICAgICAgZm9yICh2YXIgdl8gaW4gYSkge1xuICAgICAgICAgICAgdGhpcy5hdHRyKHZfLCBhW3ZfXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdmFsdWVcbiAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxuICAgICAgICAgIHYgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGEpO1xuICAgICAgICAgIHJldHVybiB2ID09IG51bGwgPyBTVkcuZGVmYXVsdHMuYXR0cnNbYV0gOiBTVkcucmVnZXguaXNOdW1iZXIudGVzdCh2KSA/IHBhcnNlRmxvYXQodikgOiB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEJVRyBGSVg6IHNvbWUgYnJvd3NlcnMgd2lsbCByZW5kZXIgYSBzdHJva2UgaWYgYSBjb2xvciBpcyBnaXZlbiBldmVuIHRob3VnaCBzdHJva2Ugd2lkdGggaXMgMFxuICAgICAgICAgIGlmIChhID09ICdzdHJva2Utd2lkdGgnKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIoJ3N0cm9rZScsIHBhcnNlRmxvYXQodikgPiAwID8gdGhpcy5fc3Ryb2tlIDogbnVsbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhID09ICdzdHJva2UnKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UgPSB2O1xuICAgICAgICAgIH0gLy8gY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnNcblxuXG4gICAgICAgICAgaWYgKGEgPT0gJ2ZpbGwnIHx8IGEgPT0gJ3N0cm9rZScpIHtcbiAgICAgICAgICAgIGlmIChTVkcucmVnZXguaXNJbWFnZS50ZXN0KHYpKSB7XG4gICAgICAgICAgICAgIHYgPSB0aGlzLmRvYygpLmRlZnMoKS5pbWFnZSh2LCAwLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTVkcuSW1hZ2UpIHtcbiAgICAgICAgICAgICAgdiA9IHRoaXMuZG9jKCkuZGVmcygpLnBhdHRlcm4oMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGVuc3VyZSBjb3JyZWN0IG51bWVyaWMgdmFsdWVzIChhbHNvIGFjY2VwdHMgTmFOIGFuZCBJbmZpbml0eSlcblxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdiA9IG5ldyBTVkcuTnVtYmVyKHYpO1xuICAgICAgICAgIH0gLy8gZW5zdXJlIGZ1bGwgaGV4IGNvbG9yXG4gICAgICAgICAgZWxzZSBpZiAoU1ZHLkNvbG9yLmlzQ29sb3IodikpIHtcbiAgICAgICAgICAgIHYgPSBuZXcgU1ZHLkNvbG9yKHYpO1xuICAgICAgICAgIH0gLy8gcGFyc2UgYXJyYXkgdmFsdWVzXG4gICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdiA9IG5ldyBTVkcuQXJyYXkodik7XG4gICAgICAgICAgfSAvLyBpZiB0aGUgcGFzc2VkIGF0dHJpYnV0ZSBpcyBsZWFkaW5nLi4uXG5cblxuICAgICAgICAgIGlmIChhID09ICdsZWFkaW5nJykge1xuICAgICAgICAgICAgLy8gLi4uIGNhbGwgdGhlIGxlYWRpbmcgbWV0aG9kIGluc3RlYWRcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYWRpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzZXQgZ2l2ZW4gYXR0cmlidXRlIG9uIG5vZGVcbiAgICAgICAgICAgIHR5cGVvZiBuID09PSAnc3RyaW5nJyA/IHRoaXMubm9kZS5zZXRBdHRyaWJ1dGVOUyhuLCBhLCB2LnRvU3RyaW5nKCkpIDogdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShhLCB2LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH0gLy8gcmVidWlsZCBpZiByZXF1aXJlZFxuXG5cbiAgICAgICAgICBpZiAodGhpcy5yZWJ1aWxkICYmIChhID09ICdmb250LXNpemUnIHx8IGEgPT0gJ3gnKSkge1xuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkKGEsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAgIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG8sIHJlbGF0aXZlKSB7XG4gICAgICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICBtYXRyaXg7XG4gICAvLyBhY3QgYXMgYSBnZXR0ZXJcblxuICAgICAgICBpZiAoX3R5cGVvZihvKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBnZXQgY3VycmVudCBtYXRyaXhcbiAgICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpLmV4dHJhY3QoKTtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbWF0cml4W29dIDogbWF0cml4O1xuICAgICAgICB9IC8vIGdldCBjdXJyZW50IG1hdHJpeFxuXG5cbiAgICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgodGFyZ2V0KTsgLy8gZW5zdXJlIHJlbGF0aXZlIGZsYWdcblxuICAgICAgICByZWxhdGl2ZSA9ICEhcmVsYXRpdmUgfHwgISFvLnJlbGF0aXZlOyAvLyBhY3Qgb24gbWF0cml4XG5cbiAgICAgICAgaWYgKG8uYSAhPSBudWxsKSB7XG4gICAgICAgICAgbWF0cml4ID0gcmVsYXRpdmUgLy8gcmVsYXRpdmVcbiAgICAgICAgICA/IG1hdHJpeC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeChvKSkgLy8gYWJzb2x1dGVcbiAgICAgICAgICA6IG5ldyBTVkcuTWF0cml4KG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgICAvLyBSZXNldCBhbGwgdHJhbnNmb3JtYXRpb25zXG4gICAgICB1bnRyYW5zZm9ybTogZnVuY3Rpb24gdW50cmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpO1xuICAgICAgfSxcbiAgICAgIC8vIG1lcmdlIHRoZSB3aG9sZSB0cmFuc2Zvcm1hdGlvbiBjaGFpbiBpbnRvIG9uZSBtYXRyaXggYW5kIHJldHVybnMgaXRcbiAgICAgIG1hdHJpeGlmeTogZnVuY3Rpb24gbWF0cml4aWZ5KCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gKHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJycpLnNwbGl0KFNWRy5yZWdleC50cmFuc2Zvcm1zKS5zbGljZSgwLCAtMSkubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAvLyBnZW5lcmF0ZSBrZXkgPT4gdmFsdWUgcGFpcnNcbiAgICAgICAgICB2YXIga3YgPSBzdHIudHJpbSgpLnNwbGl0KCcoJyk7XG4gICAgICAgICAgcmV0dXJuIFtrdlswXSwga3ZbMV0uc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgICAgfSldO1xuICAgICAgICB9KSAvLyBtZXJnZSBldmVyeSB0cmFuc2Zvcm1hdGlvbiBpbnRvIG9uZSBtYXRyaXhcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAobWF0cml4LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtWzBdID09ICdtYXRyaXgnKSByZXR1cm4gbWF0cml4Lm11bHRpcGx5KGFycmF5VG9NYXRyaXgodHJhbnNmb3JtWzFdKSk7XG4gICAgICAgICAgcmV0dXJuIG1hdHJpeFt0cmFuc2Zvcm1bMF1dLmFwcGx5KG1hdHJpeCwgdHJhbnNmb3JtWzFdKTtcbiAgICAgICAgfSwgbmV3IFNWRy5NYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9LFxuICAgICAgLy8gYWRkIGFuIGVsZW1lbnQgdG8gYW5vdGhlciBwYXJlbnQgd2l0aG91dCBjaGFuZ2luZyB0aGUgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzY3JlZW5cbiAgICAgIHRvUGFyZW50OiBmdW5jdGlvbiB0b1BhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gcGFyZW50KSByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIGN0bSA9IHRoaXMuc2NyZWVuQ1RNKCk7XG4gICAgICAgIHZhciBwQ3RtID0gcGFyZW50LnNjcmVlbkNUTSgpLmludmVyc2UoKTtcbiAgICAgICAgdGhpcy5hZGRUbyhwYXJlbnQpLnVudHJhbnNmb3JtKCkudHJhbnNmb3JtKHBDdG0ubXVsdGlwbHkoY3RtKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHNhbWUgYXMgYWJvdmUgd2l0aCBwYXJlbnQgZXF1YWxzIHJvb3Qtc3ZnXG4gICAgICB0b0RvYzogZnVuY3Rpb24gdG9Eb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUGFyZW50KHRoaXMuZG9jKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5UcmFuc2Zvcm1hdGlvbiA9IFNWRy5pbnZlbnQoe1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBpbnZlcnNlZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGludmVyc2VkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlICYmIF90eXBlb2Yoc291cmNlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW3RoaXMuYXJndW1lbnRzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludmVyc2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGludmVyc2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5pbnZlcnNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuVHJhbnNsYXRlID0gU1ZHLmludmVudCh7XG4gICAgICBwYXJlbnQ6IFNWRy5NYXRyaXgsXG4gICAgICBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb24sXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UsIGludmVyc2VkKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIH0sXG4gICAgICBleHRlbmQ6IHtcbiAgICAgICAgYXJndW1lbnRzOiBbJ3RyYW5zZm9ybWVkWCcsICd0cmFuc2Zvcm1lZFknXSxcbiAgICAgICAgbWV0aG9kOiAndHJhbnNsYXRlJ1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAgIC8vIER5bmFtaWMgc3R5bGUgZ2VuZXJhdG9yXG4gICAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUocywgdikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgLy8gZ2V0IGZ1bGwgc3R5bGVcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAvLyBhcHBseSBldmVyeSBzdHlsZSBpbmRpdmlkdWFsbHkgaWYgYW4gb2JqZWN0IGlzIHBhc3NlZFxuICAgICAgICAgIGlmIChfdHlwZW9mKHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh2YXIgdl8gaW4gcykge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlKHZfLCBzW3ZfXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNDc3MudGVzdChzKSkge1xuICAgICAgICAgICAgLy8gcGFyc2UgY3NzIHN0cmluZ1xuICAgICAgICAgICAgcyA9IHMuc3BsaXQoL1xccyo7XFxzKi8pIC8vIGZpbHRlciBvdXQgc3VmZml4IDsgYW5kIHN0dWZmIGxpa2UgOztcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICEhZTtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZS5zcGxpdCgvXFxzKjpcXHMqLyk7XG4gICAgICAgICAgICB9KTsgLy8gYXBwbHkgZXZlcnkgZGVmaW5pdGlvbiBpbmRpdmlkdWFsbHlcblxuICAgICAgICAgICAgd2hpbGUgKHYgPSBzLnBvcCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUodlswXSwgdlsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2UocyldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKHMpXSA9IHYgPT09IG51bGwgfHwgU1ZHLnJlZ2V4LmlzQmxhbmsudGVzdCh2KSA/ICcnIDogdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5QYXJlbnQgPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudCk7XG4gICAgICB9LFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuRWxlbWVudCxcbiAgICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgICBleHRlbmQ6IHtcbiAgICAgICAgLy8gUmV0dXJucyBhbGwgY2hpbGQgZWxlbWVudHNcbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBTVkcudXRpbHMubWFwKFNWRy51dGlscy5maWx0ZXJTVkdFbGVtZW50cyh0aGlzLm5vZGUuY2hpbGROb2RlcyksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBZGQgZ2l2ZW4gZWxlbWVudCBhdCBhIHBvc2l0aW9uXG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGVsZW1lbnQsIGkpIHtcbiAgICAgICAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudC5ub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubm9kZSAhPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbGVtZW50Lm5vZGUsIHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgYXMgYGFkZCgpYCBidXQgcmV0dXJucyB0aGUgYWRkZWQgZWxlbWVudCBpbnN0ZWFkXG4gICAgICAgIHB1dDogZnVuY3Rpb24gcHV0KGVsZW1lbnQsIGkpIHtcbiAgICAgICAgICB0aGlzLmFkZChlbGVtZW50LCBpKTtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgY2hpbGRcbiAgICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4KGVsZW1lbnQpID49IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxuICAgICAgICBpbmRleDogZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHRoaXMubm9kZS5jaGlsZE5vZGVzKS5pbmRleE9mKGVsZW1lbnQubm9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBhIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGkpIHtcbiAgICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGZpcnN0IGNoaWxkXG4gICAgICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoMCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCB0aGUgbGFzdCBjaGlsZFxuICAgICAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGRyZW4gYW5kIGludm9rZXMgYSBnaXZlbiBibG9ja1xuICAgICAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGJsb2NrLCBkZWVwKSB7XG4gICAgICAgICAgdmFyIGlsLFxuICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgICAgICAgIGJsb2NrLmFwcGx5KGNoaWxkcmVuW2ldLCBbaSwgY2hpbGRyZW5dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlZXAgJiYgY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTVkcuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuW2ldLmVhY2goYmxvY2ssIGRlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxuICAgICAgICByZW1vdmVFbGVtZW50OiBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudC5ub2RlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbnRhaW5lclxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuXG4gICAgICAgICAgd2hpbGUgKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgICB9IC8vIHJlbW92ZSBkZWZzIHJlZmVyZW5jZVxuXG5cbiAgICAgICAgICBkZWxldGUgdGhpcy5fZGVmcztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGRlZnNcbiAgICAgICAgZGVmczogZnVuY3Rpb24gZGVmcygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kb2MoKS5kZWZzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIHtcbiAgICAgIHVuZ3JvdXA6IGZ1bmN0aW9uIHVuZ3JvdXAocGFyZW50LCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDAgfHwgdGhpcyBpbnN0YW5jZW9mIFNWRy5EZWZzIHx8IHRoaXMubm9kZSA9PSBTVkcucGFyc2VyLmRyYXcpIHJldHVybiB0aGlzO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQgfHwgKHRoaXMgaW5zdGFuY2VvZiBTVkcuRG9jID8gdGhpcyA6IHRoaXMucGFyZW50KFNWRy5QYXJlbnQpKTtcbiAgICAgICAgZGVwdGggPSBkZXB0aCB8fCBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNWRy5EZWZzKSByZXR1cm4gdGhpcztcbiAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNWRy5QYXJlbnQpIHJldHVybiB0aGlzLnVuZ3JvdXAocGFyZW50LCBkZXB0aCAtIDEpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvUGFyZW50KHBhcmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGUuZmlyc3RDaGlsZCB8fCB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKHBhcmVudCwgZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5ncm91cChwYXJlbnQsIGRlcHRoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuQ29udGFpbmVyID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIC8vIEluaGVyaXQgZnJvbVxuICAgICAgaW5oZXJpdDogU1ZHLlBhcmVudFxuICAgIH0pO1xuICAgIFNWRy5WaWV3Qm94ID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBEZWZpbmUgcGFyZW50XG4gICAgICBwYXJlbnQ6IFNWRy5Db250YWluZXIsXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7fVxuICAgIH0pIC8vIEFkZCBldmVudHMgdG8gZWxlbWVudHNcbiAgICA7XG4gICAgWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgLy8gLCAnbW91c2VlbnRlcicgLT4gbm90IHN1cHBvcnRlZCBieSBJRVxuICAgIC8vICwgJ21vdXNlbGVhdmUnIC0+IG5vdCBzdXBwb3J0ZWQgYnkgSUVcbiAgICAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hsZWF2ZScsICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBhZGQgZXZlbnQgdG8gU1ZHLkVsZW1lbnRcbiAgICAgIFNWRy5FbGVtZW50LnByb3RvdHlwZVtldmVudF0gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICAvLyBiaW5kIGV2ZW50IHRvIGVsZW1lbnQgcmF0aGVyIHRoYW4gZWxlbWVudCBub2RlXG4gICAgICAgIFNWRy5vbih0aGlzLm5vZGUsIGV2ZW50LCBmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pOyAvLyBJbml0aWFsaXplIGxpc3RlbmVycyBzdGFja1xuXG4gICAgU1ZHLmxpc3RlbmVycyA9IFtdO1xuICAgIFNWRy5oYW5kbGVyTWFwID0gW107XG4gICAgU1ZHLmxpc3RlbmVySWQgPSAwOyAvLyBBZGQgZXZlbnQgYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5cbiAgICBTVkcub24gPSBmdW5jdGlvbiAobm9kZSwgZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XG4gICAgICAvLyBjcmVhdGUgbGlzdGVuZXIsIGdldCBvYmplY3QtaW5kZXhcbiAgICAgIHZhciBsID0gbGlzdGVuZXIuYmluZChiaW5kaW5nIHx8IG5vZGUuaW5zdGFuY2UgfHwgbm9kZSksXG4gICAgICAgICAgaW5kZXggPSAoU1ZHLmhhbmRsZXJNYXAuaW5kZXhPZihub2RlKSArIDEgfHwgU1ZHLmhhbmRsZXJNYXAucHVzaChub2RlKSkgLSAxLFxuICAgICAgICAgIGV2ID0gZXZlbnQuc3BsaXQoJy4nKVswXSxcbiAgICAgICAgICBucyA9IGV2ZW50LnNwbGl0KCcuJylbMV0gfHwgJyonOyAvLyBlbnN1cmUgdmFsaWQgb2JqZWN0XG5cbiAgICAgIFNWRy5saXN0ZW5lcnNbaW5kZXhdID0gU1ZHLmxpc3RlbmVyc1tpbmRleF0gfHwge307XG4gICAgICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gPSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gfHwge307XG4gICAgICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdID0gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSB8fCB7fTtcblxuICAgICAgaWYgKCFsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkKSB7XG4gICAgICAgIGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQgPSArK1NWRy5saXN0ZW5lcklkO1xuICAgICAgfSAvLyByZWZlcmVuY2UgbGlzdGVuZXJcblxuXG4gICAgICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdW2xpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWRdID0gbDsgLy8gYWRkIGxpc3RlbmVyXG5cbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldiwgbCwgb3B0aW9ucyB8fCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07IC8vIEFkZCBldmVudCB1bmJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxuXG5cbiAgICBTVkcub2ZmID0gZnVuY3Rpb24gKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGluZGV4ID0gU1ZHLmhhbmRsZXJNYXAuaW5kZXhPZihub2RlKSxcbiAgICAgICAgICBldiA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMF0sXG4gICAgICAgICAgbnMgPSBldmVudCAmJiBldmVudC5zcGxpdCgnLicpWzFdLFxuICAgICAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgICAgaWYgKGluZGV4ID09IC0xKSByZXR1cm47XG5cbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSBsaXN0ZW5lciA9IGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQ7XG4gICAgICAgIGlmICghbGlzdGVuZXIpIHJldHVybjsgLy8gcmVtb3ZlIGxpc3RlbmVyIHJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gJiYgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ10pIHtcbiAgICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXYsIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXSwgZmFsc2UpO1xuICAgICAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnMgfHwgJyonXVtsaXN0ZW5lcl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnMgJiYgZXYpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgbmFtZXNwYWNlZCBldmVudFxuICAgICAgICBpZiAoU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdICYmIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc10pIHtcbiAgICAgICAgICBmb3IgKHZhciBsaXN0ZW5lcl8gaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSkge1xuICAgICAgICAgICAgU1ZHLm9mZihub2RlLCBbZXYsIG5zXS5qb2luKCcuJyksIGxpc3RlbmVyXyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgbmFtZXNwYWNlXG4gICAgICAgIGZvciAodmFyIGV2ZW50XyBpbiBTVkcubGlzdGVuZXJzW2luZGV4XSkge1xuICAgICAgICAgIGZvciAodmFyIG5hbWVzcGFjZSBpbiBTVkcubGlzdGVuZXJzW2luZGV4XVtldmVudF9dKSB7XG4gICAgICAgICAgICBpZiAobnMgPT09IG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICBTVkcub2ZmKG5vZGUsIFtldmVudF8sIG5zXS5qb2luKCcuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldikge1xuICAgICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XG4gICAgICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0pIHtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lc3BhY2UgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdKSB7XG4gICAgICAgICAgICBTVkcub2ZmKG5vZGUsIFtldiwgbmFtZXNwYWNlXS5qb2luKCcuJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gbm9kZVxuICAgICAgICBmb3IgKHZhciBldmVudF8gaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF0pIHtcbiAgICAgICAgICBTVkcub2ZmKG5vZGUsIGV2ZW50Xyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF07XG4gICAgICAgIGRlbGV0ZSBTVkcuaGFuZGxlck1hcFtpbmRleF07XG4gICAgICB9XG4gICAgfTsgLy9cblxuXG4gICAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgICAgLy8gQmluZCBnaXZlbiBldmVudCB0byBsaXN0ZW5lclxuICAgICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50LCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucykge1xuICAgICAgICBTVkcub24odGhpcy5ub2RlLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxuICAgICAgb2ZmOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIFNWRy5vZmYodGhpcy5ub2RlLCBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBGaXJlIGdpdmVuIGV2ZW50XG4gICAgICBmaXJlOiBmdW5jdGlvbiBmaXJlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIERpc3BhdGNoIGV2ZW50XG4gICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudCkge1xuICAgICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChldmVudCA9IG5ldyBTVkcuQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudCA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBldmVudDogZnVuY3Rpb24gZXZlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuRGVmcyA9IFNWRy5pbnZlbnQoe1xuICAgICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgICBjcmVhdGU6ICdkZWZzJyxcbiAgICAgIC8vIEluaGVyaXQgZnJvbVxuICAgICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxuICAgIH0pO1xuICAgIFNWRy5HID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ2cnLFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICAgIHg6IGZ1bmN0aW9uIHgoX3gyKSB7XG4gICAgICAgICAgcmV0dXJuIF94MiA9PSBudWxsID8gdGhpcy50cmFuc2Zvcm0oJ3gnKSA6IHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgICAgIHg6IF94MiAtIHRoaXMueCgpXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuRG9jID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgdGhlIHByZXNlbmNlIG9mIGEgZG9tIGVsZW1lbnRcbiAgICAgICAgICBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCkgOiBlbGVtZW50OyAvLyBJZiB0aGUgdGFyZ2V0IGlzIGFuIHN2ZyBlbGVtZW50LCB1c2UgdGhhdCBlbGVtZW50IGFzIHRoZSBtYWluIHdyYXBwZXIuXG4gICAgICAgICAgLy8gVGhpcyBhbGxvd3Mgc3ZnLmpzIHRvIHdvcmsgd2l0aCBzdmcgZG9jdW1lbnRzIGFzIHdlbGwuXG5cbiAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnc3ZnJykpO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgdGhpcy5zaXplKCcxMDAlJywgJzEwMCUnKTtcbiAgICAgICAgICB9IC8vIHNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVzIGFuZCBlbnN1cmUgZGVmcyBub2RlXG5cblxuICAgICAgICAgIHRoaXMubmFtZXNwYWNlKCkuZGVmcygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyBBZGQgbmFtZXNwYWNlc1xuICAgICAgICBuYW1lc3BhY2U6IGZ1bmN0aW9uIG5hbWVzcGFjZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHtcbiAgICAgICAgICAgIHhtbG5zOiBTVkcubnMsXG4gICAgICAgICAgICB2ZXJzaW9uOiAnMS4xJ1xuICAgICAgICAgIH0pLmF0dHIoJ3htbG5zOnhsaW5rJywgU1ZHLnhsaW5rLCBTVkcueG1sbnMpLmF0dHIoJ3htbG5zOnN2Z2pzJywgU1ZHLnN2Z2pzLCBTVkcueG1sbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxuICAgICAgICBkZWZzOiBmdW5jdGlvbiBkZWZzKCkge1xuICAgICAgICAgIGlmICghdGhpcy5fZGVmcykge1xuICAgICAgICAgICAgdmFyIGRlZnM7IC8vIEZpbmQgb3IgY3JlYXRlIGEgZGVmcyBlbGVtZW50IGluIHRoaXMgaW5zdGFuY2VcblxuICAgICAgICAgICAgaWYgKGRlZnMgPSB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RlZnMnKVswXSkge1xuICAgICAgICAgICAgICB0aGlzLl9kZWZzID0gU1ZHLmFkb3B0KGRlZnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGVmcyA9IG5ldyBTVkcuRGVmcygpO1xuICAgICAgICAgICAgfSAvLyBNYWtlIHN1cmUgdGhlIGRlZnMgbm9kZSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBzdGFja1xuXG5cbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9kZWZzLm5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBjdXN0b20gcGFyZW50IG1ldGhvZFxuICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubm9kZS5wYXJlbnROb2RlIHx8IHRoaXMubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09ICcjZG9jdW1lbnQnKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIGRvYyBmcm9tIHRoZSBET01cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgICAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgfSAvLyByZW1vdmUgZGVmcyByZWZlcmVuY2VcblxuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2RlZnM7IC8vIGFkZCBiYWNrIHBhcnNlclxuXG4gICAgICAgICAgaWYgKFNWRy5wYXJzZXIuZHJhdyAmJiAhU1ZHLnBhcnNlci5kcmF3LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChTVkcucGFyc2VyLmRyYXcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUocGFyZW50KSB7XG4gICAgICAgICAgLy8gd3JpdGUgZG9tIGRhdGEgdG8gdGhlIGRvbSBzbyB0aGUgY2xvbmUgY2FuIHBpY2t1cCB0aGUgZGF0YVxuICAgICAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTsgLy8gZ2V0IHJlZmVyZW5jZSB0byBub2RlXG5cbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTsgLy8gY2xvbmUgZWxlbWVudCBhbmQgYXNzaWduIG5ldyBpZFxuXG4gICAgICAgICAgdmFyIGNsb25lID0gYXNzaWduTmV3SWQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpOyAvLyBpbnNlcnQgdGhlIGNsb25lIGluIHRoZSBnaXZlbiBwYXJlbnQgb3IgYWZ0ZXIgbXlzZWxmXG5cbiAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAocGFyZW50Lm5vZGUgfHwgcGFyZW50KS5hcHBlbmRDaGlsZChjbG9uZS5ub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZS5ub2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gIyMjIFRoaXMgbW9kdWxlIGFkZHMgYmFja3dhcmQgLyBmb3J3YXJkIGZ1bmN0aW9uYWxpdHkgdG8gZWxlbWVudHMuXG4gICAgLy9cblxuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHsvLyBHZXQgYWxsIHNpYmxpbmdzLCBpbmNsdWRpbmcgbXlzZWxmXG4gICAgfSk7XG4gICAgU1ZHLkdyYWRpZW50ID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHR5cGUpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUodHlwZSArICdHcmFkaWVudCcpKTsgLy8gc3RvcmUgdHlwZVxuXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB9LFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyBBZGQgYSBjb2xvciBzdG9wXG4gICAgICAgIGF0OiBmdW5jdGlvbiBhdChvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuU3RvcCgpKS51cGRhdGUob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFVwZGF0ZSBncmFkaWVudFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShibG9jaykge1xuICAgICAgICAgIC8vIHJlbW92ZSBhbGwgc3RvcHNcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7IC8vIGludm9rZSBwYXNzZWQgYmxvY2tcblxuICAgICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJldHVybiB0aGUgZmlsbCBpZFxuICAgICAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKCkge1xuICAgICAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGN1c3RvbSBhdHRyIHRvIGhhbmRsZSB0cmFuc2Zvcm1cbiAgICAgICAgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiLCBjKSB7XG4gICAgICAgICAgaWYgKGEgPT0gJ3RyYW5zZm9ybScpIGEgPSAnZ3JhZGllbnRUcmFuc2Zvcm0nO1xuICAgICAgICAgIHJldHVybiBTVkcuQ29udGFpbmVyLnByb3RvdHlwZS5hdHRyLmNhbGwodGhpcywgYSwgYiwgYyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBncmFkaWVudCBlbGVtZW50IGluIGRlZnNcbiAgICAgICAgZ3JhZGllbnQ6IGZ1bmN0aW9uIGdyYWRpZW50KHR5cGUsIGJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmdyYWRpZW50KHR5cGUsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyBBZGQgYW5pbWF0YWJsZSBtZXRob2RzIHRvIGJvdGggZ3JhZGllbnQgYW5kIGZ4IG1vZHVsZVxuXG4gICAgU1ZHLmV4dGVuZChTVkcuR3JhZGllbnQsIFNWRy5GWCwge1xuICAgICAgLy8gRnJvbSBwb3NpdGlvblxuICAgICAgZnJvbTogZnVuY3Rpb24gZnJvbSh4LCB5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGUgPT0gJ3JhZGlhbCcgPyB0aGlzLmF0dHIoe1xuICAgICAgICAgIGZ4OiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgICBmeTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgICAgfSkgOiB0aGlzLmF0dHIoe1xuICAgICAgICAgIHgxOiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgICB5MTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gVG8gcG9zaXRpb25cbiAgICAgIHRvOiBmdW5jdGlvbiB0byh4LCB5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGUgPT0gJ3JhZGlhbCcgPyB0aGlzLmF0dHIoe1xuICAgICAgICAgIGN4OiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgICBjeTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgICAgfSkgOiB0aGlzLmF0dHIoe1xuICAgICAgICAgIHgyOiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgICB5MjogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7IC8vIEJhc2UgZ3JhZGllbnQgZ2VuZXJhdGlvblxuXG4gICAgU1ZHLmV4dGVuZChTVkcuRGVmcywge1xuICAgICAgLy8gZGVmaW5lIGdyYWRpZW50XG4gICAgICBncmFkaWVudDogZnVuY3Rpb24gZ3JhZGllbnQodHlwZSwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuR3JhZGllbnQodHlwZSkpLnVwZGF0ZShibG9jayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLlN0b3AgPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgICAgY3JlYXRlOiAnc3RvcCcsXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5FbGVtZW50LFxuICAgICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyBhZGQgY29sb3Igc3RvcHNcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUobykge1xuICAgICAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ251bWJlcicgfHwgbyBpbnN0YW5jZW9mIFNWRy5OdW1iZXIpIHtcbiAgICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICAgIG9mZnNldDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICBjb2xvcjogYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgICBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSAvLyBzZXQgYXR0cmlidXRlc1xuXG5cbiAgICAgICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KTtcbiAgICAgICAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKTtcbiAgICAgICAgICBpZiAoby5vZmZzZXQgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBuZXcgU1ZHLk51bWJlcihvLm9mZnNldCkpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLlBhdHRlcm4gPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgICAgY3JlYXRlOiAncGF0dGVybicsXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgICAgZXh0ZW5kOiB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZmlsbCBpZFxuICAgICAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKCkge1xuICAgICAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknO1xuICAgICAgICB9LFxuICAgICAgICAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGJsb2NrKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGNvbnRlbnRcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7IC8vIGludm9rZSBwYXNzZWQgYmxvY2tcblxuICAgICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFsaWFzIHN0cmluZyBjb252ZXJ0aW9uIHRvIGZpbGxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxuICAgICAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIGIsIGMpIHtcbiAgICAgICAgICBpZiAoYSA9PSAndHJhbnNmb3JtJykgYSA9ICdwYXR0ZXJuVHJhbnNmb3JtJztcbiAgICAgICAgICByZXR1cm4gU1ZHLkNvbnRhaW5lci5wcm90b3R5cGUuYXR0ci5jYWxsKHRoaXMsIGEsIGIsIGMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICAgIGNvbnN0cnVjdDoge1xuICAgICAgICAvLyBDcmVhdGUgcGF0dGVybiBlbGVtZW50IGluIGRlZnNcbiAgICAgICAgcGF0dGVybjogZnVuY3Rpb24gcGF0dGVybih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wYXR0ZXJuKHdpZHRoLCBoZWlnaHQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcbiAgICAgIC8vIERlZmluZSBncmFkaWVudFxuICAgICAgcGF0dGVybjogZnVuY3Rpb24gcGF0dGVybih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5QYXR0ZXJuKCkpLnVwZGF0ZShibG9jaykuYXR0cih7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLlNoYXBlID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIC8vIEluaGVyaXQgZnJvbVxuICAgICAgaW5oZXJpdDogU1ZHLkVsZW1lbnRcbiAgICB9KTtcbiAgICBTVkcuU3ltYm9sID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ3N5bWJvbCcsXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgICAgLy8gY3JlYXRlIHN5bWJvbFxuICAgICAgICBzeW1ib2w6IGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TeW1ib2woKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuVXNlID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ3VzZScsXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgICBleHRlbmQ6IHtcbiAgICAgICAgLy8gVXNlIGVsZW1lbnQgYXMgYSByZWZlcmVuY2VcbiAgICAgICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudChfZWxlbWVudCwgZmlsZSkge1xuICAgICAgICAgIC8vIFNldCBsaW5lZCBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChmaWxlIHx8ICcnKSArICcjJyArIF9lbGVtZW50LCBTVkcueGxpbmspO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICAgIGNvbnN0cnVjdDoge1xuICAgICAgICAvLyBDcmVhdGUgYSB1c2UgZWxlbWVudFxuICAgICAgICB1c2U6IGZ1bmN0aW9uIHVzZShlbGVtZW50LCBmaWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVXNlKCkpLmVsZW1lbnQoZWxlbWVudCwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuUmVjdCA9IFNWRy5pbnZlbnQoe1xuICAgICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgICBjcmVhdGU6ICdyZWN0JyxcbiAgICAgIC8vIEluaGVyaXQgZnJvbVxuICAgICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICAgIGNvbnN0cnVjdDoge1xuICAgICAgICAvLyBDcmVhdGUgYSByZWN0IGVsZW1lbnRcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gcmVjdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUmVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLkNpcmNsZSA9IFNWRy5pbnZlbnQoe1xuICAgICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgICBjcmVhdGU6ICdjaXJjbGUnLFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBjaXJjbGUgZWxlbWVudCwgYmFzZWQgb24gZWxsaXBzZVxuICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQ2lyY2xlKCkpLnJ4KG5ldyBTVkcuTnVtYmVyKHNpemUpLmRpdmlkZSgyKSkubW92ZSgwLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5leHRlbmQoU1ZHLkNpcmNsZSwgU1ZHLkZYLCB7XG4gICAgICAvLyBSYWRpdXMgeCB2YWx1ZVxuICAgICAgcng6IGZ1bmN0aW9uIHJ4KF9yeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgX3J4KTtcbiAgICAgIH0sXG4gICAgICAvLyBBbGlhcyByYWRpdXMgeCB2YWx1ZVxuICAgICAgcnk6IGZ1bmN0aW9uIHJ5KF9yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yeChfcnkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5FbGxpcHNlID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ2VsbGlwc2UnLFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBlbGxpcHNlXG4gICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIGVsbGlwc2Uod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkVsbGlwc2UoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5tb3ZlKDAsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLmV4dGVuZChTVkcuRWxsaXBzZSwgU1ZHLlJlY3QsIFNWRy5GWCwge1xuICAgICAgLy8gUmFkaXVzIHggdmFsdWVcbiAgICAgIHJ4OiBmdW5jdGlvbiByeChfcngyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3J4JywgX3J4Mik7XG4gICAgICB9LFxuICAgICAgLy8gUmFkaXVzIHkgdmFsdWVcbiAgICAgIHJ5OiBmdW5jdGlvbiByeShfcnkyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3J5JywgX3J5Mik7XG4gICAgICB9XG4gICAgfSk7IC8vIEFkZCBjb21tb24gbWV0aG9kXG5cbiAgICBTVkcuZXh0ZW5kKFNWRy5DaXJjbGUsIFNWRy5FbGxpcHNlLCB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbiB4KF94Mykge1xuICAgICAgICByZXR1cm4gX3gzID09IG51bGwgPyB0aGlzLmN4KCkgLSB0aGlzLnJ4KCkgOiB0aGlzLmN4KF94MyArIHRoaXMucngoKSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICAgeTogZnVuY3Rpb24geShfeTIpIHtcbiAgICAgICAgcmV0dXJuIF95MiA9PSBudWxsID8gdGhpcy5jeSgpIC0gdGhpcy5yeSgpIDogdGhpcy5jeShfeTIgKyB0aGlzLnJ5KCkpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG4gICAgICBjeDogZnVuY3Rpb24gY3goeCkge1xuICAgICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5hdHRyKCdjeCcpIDogdGhpcy5hdHRyKCdjeCcsIHgpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgICBjeTogZnVuY3Rpb24gY3koeSkge1xuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5hdHRyKCdjeScpIDogdGhpcy5hdHRyKCdjeScsIHkpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gICAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoX3dpZHRoMikge1xuICAgICAgICByZXR1cm4gX3dpZHRoMiA9PSBudWxsID8gdGhpcy5yeCgpICogMiA6IHRoaXMucngobmV3IFNWRy5OdW1iZXIoX3dpZHRoMikuZGl2aWRlKDIpKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQyKSB7XG4gICAgICAgIHJldHVybiBfaGVpZ2h0MiA9PSBudWxsID8gdGhpcy5yeSgpICogMiA6IHRoaXMucnkobmV3IFNWRy5OdW1iZXIoX2hlaWdodDIpLmRpdmlkZSgyKSk7XG4gICAgICB9LFxuICAgICAgLy8gQ3VzdG9tIHNpemUgZnVuY3Rpb25cbiAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJ4KG5ldyBTVkcuTnVtYmVyKHAud2lkdGgpLmRpdmlkZSgyKSkucnkobmV3IFNWRy5OdW1iZXIocC5oZWlnaHQpLmRpdmlkZSgyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLkxpbmUgPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgICAgY3JlYXRlOiAnbGluZScsXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgICBleHRlbmQ6IHtcbiAgICAgICAgLy8gR2V0IGFycmF5XG4gICAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KFtbdGhpcy5hdHRyKCd4MScpLCB0aGlzLmF0dHIoJ3kxJyldLCBbdGhpcy5hdHRyKCd4MicpLCB0aGlzLmF0dHIoJ3kyJyldXSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBuYXRpdmUgcGxvdCgpIG1ldGhvZFxuICAgICAgICBwbG90OiBmdW5jdGlvbiBwbG90KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgaWYgKHgxID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB4MSA9IHtcbiAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4MSA9IG5ldyBTVkcuUG9pbnRBcnJheSh4MSkudG9MaW5lKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih4MSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICAgICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIodGhpcy5hcnJheSgpLm1vdmUoeCwgeSkudG9MaW5lKCkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIodGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpLnRvTGluZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbGluZSBlbGVtZW50XG4gICAgICAgIGxpbmU6IGZ1bmN0aW9uIGxpbmUoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgICAgICAvLyB4MSBpcyBub3QgbmVjZXNzYXJpbHkgYSBudW1iZXIsIGl0IGNhbiBhbHNvIGJlIGFuIGFycmF5LCBhIHN0cmluZyBhbmQgYSBTVkcuUG9pbnRBcnJheVxuICAgICAgICAgIHJldHVybiBTVkcuTGluZS5wcm90b3R5cGUucGxvdC5hcHBseSh0aGlzLnB1dChuZXcgU1ZHLkxpbmUoKSksIHgxICE9IG51bGwgPyBbeDEsIHkxLCB4MiwgeTJdIDogWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5Qb2x5bGluZSA9IFNWRy5pbnZlbnQoe1xuICAgICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgICBjcmVhdGU6ICdwb2x5bGluZScsXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5bGluZSBlbGVtZW50XG4gICAgICAgIHBvbHlsaW5lOiBmdW5jdGlvbiBwb2x5bGluZShwKSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUG9seWxpbmUoKSkucGxvdChwIHx8IG5ldyBTVkcuUG9pbnRBcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5Qb2x5Z29uID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ3BvbHlnb24nLFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XG4gICAgICAgIHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24ocCkge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlnb24oKSkucGxvdChwIHx8IG5ldyBTVkcuUG9pbnRBcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyBBZGQgcG9seWdvbi1zcGVjaWZpYyBmdW5jdGlvbnNcblxuICAgIFNWRy5leHRlbmQoU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwge1xuICAgICAgLy8gR2V0IGFycmF5XG4gICAgICBhcnJheTogZnVuY3Rpb24gYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBvaW50QXJyYXkodGhpcy5hdHRyKCdwb2ludHMnKSkpO1xuICAgICAgfSxcbiAgICAgIC8vIFBsb3QgbmV3IHBhdGhcbiAgICAgIHBsb3Q6IGZ1bmN0aW9uIHBsb3QocCkge1xuICAgICAgICByZXR1cm4gcCA9PSBudWxsID8gdGhpcy5hcnJheSgpIDogdGhpcy5jbGVhcigpLmF0dHIoJ3BvaW50cycsIHR5cGVvZiBwID09PSAnc3RyaW5nJyA/IHAgOiB0aGlzLl9hcnJheSA9IG5ldyBTVkcuUG9pbnRBcnJheShwKSk7XG4gICAgICB9LFxuICAgICAgLy8gQ2xlYXIgYXJyYXkgY2FjaGVcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2FycmF5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfSk7IC8vIHVuaWZ5IGFsbCBwb2ludCB0byBwb2ludCBlbGVtZW50c1xuXG4gICAgU1ZHLmV4dGVuZChTVkcuTGluZSwgU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwge1xuICAgICAgLy8gRGVmaW5lIG1vcnBoYWJsZSBhcnJheVxuICAgICAgbW9ycGhBcnJheTogU1ZHLlBvaW50QXJyYXksXG4gICAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuICAgICAgeDogZnVuY3Rpb24geChfeDQpIHtcbiAgICAgICAgcmV0dXJuIF94NCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZShfeDQsIHRoaXMuYmJveCgpLnkpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXG4gICAgICB5OiBmdW5jdGlvbiB5KF95Mykge1xuICAgICAgICByZXR1cm4gX3kzID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIF95Myk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGgzKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5iYm94KCk7XG4gICAgICAgIHJldHVybiBfd2lkdGgzID09IG51bGwgPyBiLndpZHRoIDogdGhpcy5zaXplKF93aWR0aDMsIGIuaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQzKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5iYm94KCk7XG4gICAgICAgIHJldHVybiBfaGVpZ2h0MyA9PSBudWxsID8gYi5oZWlnaHQgOiB0aGlzLnNpemUoYi53aWR0aCwgX2hlaWdodDMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5QYXRoID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ3BhdGgnLFxuICAgICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgICAgZXh0ZW5kOiB7XG4gICAgICAgIC8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcbiAgICAgICAgbW9ycGhBcnJheTogU1ZHLlBhdGhBcnJheSxcbiAgICAgICAgLy8gR2V0IGFycmF5XG4gICAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXkgfHwgKHRoaXMuX2FycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkodGhpcy5hdHRyKCdkJykpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGxvdCBuZXcgcGF0aFxuICAgICAgICBwbG90OiBmdW5jdGlvbiBwbG90KGQpIHtcbiAgICAgICAgICByZXR1cm4gZCA9PSBudWxsID8gdGhpcy5hcnJheSgpIDogdGhpcy5jbGVhcigpLmF0dHIoJ2QnLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogdGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheShkKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENsZWFyIGFycmF5IGNhY2hlXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYXJyYXk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZCkge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBhdGgoKSkucGxvdChkIHx8IG5ldyBTVkcuUGF0aEFycmF5KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLkltYWdlID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ2ltYWdlJyxcbiAgICAgIC8vIEluaGVyaXQgZnJvbVxuICAgICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyAocmUpbG9hZCBpbWFnZVxuICAgICAgICBsb2FkOiBmdW5jdGlvbiBsb2FkKHVybCkge1xuICAgICAgICAgIGlmICghdXJsKSByZXR1cm4gdGhpcztcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgIGltZyA9IG5ldyB3aW5kb3cuSW1hZ2UoKTsgLy8gcHJlbG9hZCBpbWFnZVxuXG4gICAgICAgICAgU1ZHLm9uKGltZywgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBTVkcub2ZmKGltZyk7XG4gICAgICAgICAgICB2YXIgcCA9IHNlbGYucGFyZW50KFNWRy5QYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChwID09PSBudWxsKSByZXR1cm47IC8vIGVuc3VyZSBpbWFnZSBzaXplXG5cbiAgICAgICAgICAgIGlmIChzZWxmLndpZHRoKCkgPT0gMCAmJiBzZWxmLmhlaWdodCgpID09IDApIHtcbiAgICAgICAgICAgICAgc2VsZi5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG4gICAgICAgICAgICB9IC8vIGVuc3VyZSBwYXR0ZXJuIHNpemUgaWYgbm90IHNldFxuXG5cbiAgICAgICAgICAgIGlmIChwICYmIHAud2lkdGgoKSA9PSAwICYmIHAuaGVpZ2h0KCkgPT0gMCkge1xuICAgICAgICAgICAgICBwLnNpemUoc2VsZi53aWR0aCgpLCBzZWxmLmhlaWdodCgpKTtcbiAgICAgICAgICAgIH0gLy8gY2FsbGJhY2tcblxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuX2xvYWRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzZWxmLl9sb2FkZWQuY2FsbChzZWxmLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGltZy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcmF0aW86IGltZy53aWR0aCAvIGltZy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgU1ZHLm9uKGltZywgJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIFNWRy5vZmYoaW1nKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLl9lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzZWxmLl9lcnJvci5jYWxsKHNlbGYsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCBpbWcuc3JjID0gdGhpcy5zcmMgPSB1cmwsIFNWRy54bGluayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZCBsb2FkZWQgY2FsbGJhY2tcbiAgICAgICAgbG9hZGVkOiBmdW5jdGlvbiBsb2FkZWQoX2xvYWRlZCkge1xuICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IF9sb2FkZWQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLl9lcnJvciA9IF9lcnJvcjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgICAgLy8gY3JlYXRlIGltYWdlIGVsZW1lbnQsIGxvYWQgaW1hZ2UgYW5kIHNldCBpdHMgc2l6ZVxuICAgICAgICBpbWFnZTogZnVuY3Rpb24gaW1hZ2Uoc291cmNlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuSW1hZ2UoKSkubG9hZChzb3VyY2UpLnNpemUod2lkdGggfHwgMCwgaGVpZ2h0IHx8IHdpZHRoIHx8IDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLlRleHQgPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCd0ZXh0JykpO1xuICAgICAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIoMS4zKTsgLy8gc3RvcmUgbGVhZGluZyB2YWx1ZSBmb3IgcmVidWlsZGluZ1xuXG4gICAgICAgIHRoaXMuX3JlYnVpbGQgPSB0cnVlOyAvLyBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlc1xuXG4gICAgICAgIHRoaXMuX2J1aWxkID0gZmFsc2U7IC8vIGRpc2FibGUgYnVpbGQgbW9kZSBmb3IgYWRkaW5nIG11bHRpcGxlIGxpbmVzXG4gICAgICAgIC8vIHNldCBkZWZhdWx0IGZvbnRcblxuICAgICAgICB0aGlzLmF0dHIoJ2ZvbnQtZmFtaWx5JywgU1ZHLmRlZmF1bHRzLmF0dHJzWydmb250LWZhbWlseSddKTtcbiAgICAgIH0sXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgICBleHRlbmQ6IHtcbiAgICAgICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgICAgICB4OiBmdW5jdGlvbiB4KF94NSkge1xuICAgICAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICAgICAgICBpZiAoX3g1ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgX3g1KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnRcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICAgICAgICBpZiAodHlwZW9mIF90ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIF90ZXh0ID0gJyc7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIC8vIGFkZCBuZXdsaW5lIGlmIGl0cyBub3QgdGhlIGZpcnN0IGNoaWxkIGFuZCBuZXdMaW5lZCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoaSAhPSAwICYmIGNoaWxkcmVuW2ldLm5vZGVUeXBlICE9IDMgJiYgU1ZHLmFkb3B0KGNoaWxkcmVuW2ldKS5kb20ubmV3TGluZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF90ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9IC8vIGFkZCBjb250ZW50IG9mIHRoaXMgbm9kZVxuXG5cbiAgICAgICAgICAgICAgX3RleHQgKz0gY2hpbGRyZW5baV0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgICAgICB9IC8vIHJlbW92ZSBleGlzdGluZyBjb250ZW50XG5cblxuICAgICAgICAgIHRoaXMuY2xlYXIoKS5idWlsZCh0cnVlKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgX3RleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgYmxvY2tcbiAgICAgICAgICAgIF90ZXh0LmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHRleHQgYW5kIG1ha2Ugc3VyZSB0ZXh0IGlzIG5vdCBibGFua1xuICAgICAgICAgICAgX3RleHQgPSBfdGV4dC5zcGxpdCgnXFxuJyk7IC8vIGJ1aWxkIG5ldyBsaW5lc1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBfdGV4dC5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMudHNwYW4oX3RleHRbaV0pLm5ld0xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGRpc2FibGUgYnVpbGQgbW9kZSBhbmQgcmVidWlsZCBsaW5lc1xuXG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChmYWxzZSkucmVidWlsZCgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTZXQgZm9udCBzaXplXG4gICAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUoX3NpemUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdmb250LXNpemUnLCBfc2l6ZSkucmVidWlsZCgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTZXQgLyBnZXQgbGVhZGluZ1xuICAgICAgICBsZWFkaW5nOiBmdW5jdGlvbiBsZWFkaW5nKHZhbHVlKSB7XG4gICAgICAgICAgLy8gYWN0IGFzIGdldHRlclxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb20ubGVhZGluZztcbiAgICAgICAgICB9IC8vIGFjdCBhcyBzZXR0ZXJcblxuXG4gICAgICAgICAgdGhpcy5kb20ubGVhZGluZyA9IG5ldyBTVkcuTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWJ1aWxkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBhbGwgdGhlIGZpcnN0IGxldmVsIGxpbmVzXG4gICAgICAgIGxpbmVzOiBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9ICh0aGlzLnRleHRQYXRoICYmIHRoaXMudGV4dFBhdGgoKSB8fCB0aGlzKS5ub2RlOyAvLyBmaWx0ZXIgdHNwYW5zIGFuZCBtYXAgdGhlbSB0byBTVkcuanMgaW5zdGFuY2VzXG5cbiAgICAgICAgICB2YXIgbGluZXMgPSBTVkcudXRpbHMubWFwKFNWRy51dGlscy5maWx0ZXJTVkdFbGVtZW50cyhub2RlLmNoaWxkTm9kZXMpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBTVkcuYWRvcHQoZWwpO1xuICAgICAgICAgIH0pOyAvLyByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgU1ZHLnNldFxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuU2V0KGxpbmVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcbiAgICAgICAgcmVidWlsZDogZnVuY3Rpb24gcmVidWlsZChfcmVidWlsZCkge1xuICAgICAgICAgIC8vIHN0b3JlIG5ldyByZWJ1aWxkIGZsYWcgaWYgZ2l2ZW5cbiAgICAgICAgICBpZiAodHlwZW9mIF9yZWJ1aWxkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYnVpbGQgPSBfcmVidWlsZDtcbiAgICAgICAgICB9IC8vIGRlZmluZSBwb3NpdGlvbiBvZiBhbGwgbGluZXNcblxuXG4gICAgICAgICAgaWYgKHRoaXMuX3JlYnVpbGQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBibGFua0xpbmVPZmZzZXQgPSAwLFxuICAgICAgICAgICAgICAgIGR5ID0gdGhpcy5kb20ubGVhZGluZyAqIG5ldyBTVkcuTnVtYmVyKHRoaXMuYXR0cignZm9udC1zaXplJykpO1xuICAgICAgICAgICAgdGhpcy5saW5lcygpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5kb20ubmV3TGluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYudGV4dFBhdGgoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKCd4Jywgc2VsZi5hdHRyKCd4JykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRleHQoKSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ICs9IGR5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmF0dHIoJ2R5JywgZHkgKyBibGFua0xpbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdyZWJ1aWxkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuYWJsZSAvIGRpc2FibGUgYnVpbGQgbW9kZVxuICAgICAgICBidWlsZDogZnVuY3Rpb24gYnVpbGQoX2J1aWxkKSB7XG4gICAgICAgICAgdGhpcy5fYnVpbGQgPSAhIV9idWlsZDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gb3ZlcndyaXRlIG1ldGhvZCBmcm9tIHBhcmVudCB0byBzZXQgZGF0YSBwcm9wZXJseVxuICAgICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKG8pIHtcbiAgICAgICAgICB0aGlzLmRvbSA9IG87XG4gICAgICAgICAgdGhpcy5kb20ubGVhZGluZyA9IG5ldyBTVkcuTnVtYmVyKG8ubGVhZGluZyB8fCAxLjMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICAgIGNvbnN0cnVjdDoge1xuICAgICAgICAvLyBDcmVhdGUgdGV4dCBlbGVtZW50XG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQoX3RleHQyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVGV4dCgpKS50ZXh0KF90ZXh0Mik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IGVsZW1lbnRcbiAgICAgICAgcGxhaW46IGZ1bmN0aW9uIHBsYWluKHRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5UZXh0KCkpLnBsYWluKHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLlRzcGFuID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ3RzcGFuJyxcbiAgICAgIC8vIEluaGVyaXQgZnJvbVxuICAgICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICAgIGV4dGVuZDoge1xuICAgICAgICAvLyBTZXQgdGV4dCBjb250ZW50XG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQoX3RleHQzKSB7XG4gICAgICAgICAgaWYgKF90ZXh0MyA9PSBudWxsKSByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50ICsgKHRoaXMuZG9tLm5ld0xpbmVkID8gJ1xcbicgOiAnJyk7XG4gICAgICAgICAgdHlwZW9mIF90ZXh0MyA9PT0gJ2Z1bmN0aW9uJyA/IF90ZXh0My5jYWxsKHRoaXMsIHRoaXMpIDogdGhpcy5wbGFpbihfdGV4dDMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTaG9ydGN1dCBkeFxuICAgICAgICBkeDogZnVuY3Rpb24gZHgoX2R4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHgnLCBfZHgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTaG9ydGN1dCBkeVxuICAgICAgICBkeTogZnVuY3Rpb24gZHkoX2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHknLCBfZHkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDcmVhdGUgbmV3IGxpbmVcbiAgICAgICAgbmV3TGluZTogZnVuY3Rpb24gbmV3TGluZSgpIHtcbiAgICAgICAgICAvLyBmZXRjaCB0ZXh0IHBhcmVudFxuICAgICAgICAgIHZhciB0ID0gdGhpcy5wYXJlbnQoU1ZHLlRleHQpOyAvLyBtYXJrIG5ldyBsaW5lXG5cbiAgICAgICAgICB0aGlzLmRvbS5uZXdMaW5lZCA9IHRydWU7IC8vIGFwcGx5IG5ldyBoecKhblxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHkodC5kb20ubGVhZGluZyAqIHQuYXR0cignZm9udC1zaXplJykpLmF0dHIoJ3gnLCB0LngoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuZXh0ZW5kKFNWRy5UZXh0LCBTVkcuVHNwYW4sIHtcbiAgICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IG5vZGVcbiAgICAgIHBsYWluOiBmdW5jdGlvbiBwbGFpbih0ZXh0KSB7XG4gICAgICAgIC8vIGNsZWFyIGlmIGJ1aWxkIG1vZGUgaXMgZGlzYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfSAvLyBjcmVhdGUgdGV4dCBub2RlXG5cblxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBDcmVhdGUgYSB0c3BhblxuICAgICAgdHNwYW46IGZ1bmN0aW9uIHRzcGFuKHRleHQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSAodGhpcy50ZXh0UGF0aCAmJiB0aGlzLnRleHRQYXRoKCkgfHwgdGhpcykubm9kZSxcbiAgICAgICAgICAgIHRzcGFuID0gbmV3IFNWRy5Uc3BhbigpOyAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG5cbiAgICAgICAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfSAvLyBhZGQgbmV3IHRzcGFuXG5cblxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRzcGFuLm5vZGUpO1xuICAgICAgICByZXR1cm4gdHNwYW4udGV4dCh0ZXh0KTtcbiAgICAgIH0sXG4gICAgICAvLyBDbGVhciBhbGwgbGluZXNcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSAodGhpcy50ZXh0UGF0aCAmJiB0aGlzLnRleHRQYXRoKCkgfHwgdGhpcykubm9kZTsgLy8gcmVtb3ZlIGV4aXN0aW5nIGNoaWxkIG5vZGVzXG5cbiAgICAgICAgd2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgbGVuZ3RoIG9mIHRleHQgZWxlbWVudFxuICAgICAgbGVuZ3RoOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLlRleHRQYXRoID0gU1ZHLmludmVudCh7XG4gICAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICAgIGNyZWF0ZTogJ3RleHRQYXRoJyxcbiAgICAgIC8vIEluaGVyaXQgZnJvbVxuICAgICAgaW5oZXJpdDogU1ZHLlBhcmVudCxcbiAgICAgIC8vIERlZmluZSBwYXJlbnQgY2xhc3NcbiAgICAgIHBhcmVudDogU1ZHLlRleHQsXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIG1vcnBoQXJyYXk6IFNWRy5QYXRoQXJyYXksXG4gICAgICAgIC8vIHJldHVybiB0aGUgYXJyYXkgb2YgdGhlIHBhdGggdHJhY2sgZWxlbWVudFxuICAgICAgICBhcnJheTogZnVuY3Rpb24gYXJyYXkoKSB7XG4gICAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFjaygpO1xuICAgICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmFycmF5KCkgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBQbG90IHBhdGggaWYgYW55XG4gICAgICAgIHBsb3Q6IGZ1bmN0aW9uIHBsb3QoZCkge1xuICAgICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2soKSxcbiAgICAgICAgICAgICAgcGF0aEFycmF5ID0gbnVsbDtcblxuICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgcGF0aEFycmF5ID0gdHJhY2sucGxvdChkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZCA9PSBudWxsID8gcGF0aEFycmF5IDogdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcbiAgICAgICAgdHJhY2s6IGZ1bmN0aW9uIHRyYWNrKCkge1xuICAgICAgICAgIHZhciBwYXRoID0gdGhpcy50ZXh0UGF0aCgpO1xuXG4gICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnJlZmVyZW5jZSgnaHJlZicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IHRoZSB0ZXh0UGF0aCBjaGlsZFxuICAgICAgICB0ZXh0UGF0aDogZnVuY3Rpb24gdGV4dFBhdGgoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9kZS5maXJzdENoaWxkICYmIHRoaXMubm9kZS5maXJzdENoaWxkLm5vZGVOYW1lID09ICd0ZXh0UGF0aCcpIHtcbiAgICAgICAgICAgIHJldHVybiBTVkcuYWRvcHQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5OZXN0ZWQgPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSk7XG4gICAgICAgIHRoaXMuc3R5bGUoJ292ZXJmbG93JywgJ3Zpc2libGUnKTtcbiAgICAgIH0sXG4gICAgICAvLyBJbmhlcml0IGZyb21cbiAgICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXN0ZWQgc3ZnIGRvY3VtZW50XG4gICAgICAgIG5lc3RlZDogZnVuY3Rpb24gbmVzdGVkKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk5lc3RlZCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyBEZWZpbmUgbGlzdCBvZiBhdmFpbGFibGUgYXR0cmlidXRlcyBmb3Igc3Ryb2tlIGFuZCBmaWxsXG5cbiAgICB2YXIgc3VnYXIgPSB7XG4gICAgICBzdHJva2U6IFsnY29sb3InLCAnd2lkdGgnLCAnb3BhY2l0eScsICdsaW5lY2FwJywgJ2xpbmVqb2luJywgJ21pdGVybGltaXQnLCAnZGFzaGFycmF5JywgJ2Rhc2hvZmZzZXQnXSxcbiAgICAgIGZpbGw6IFsnY29sb3InLCAnb3BhY2l0eScsICdydWxlJ10sXG4gICAgICBwcmVmaXg6IGZ1bmN0aW9uIHByZWZpeCh0LCBhKSB7XG4gICAgICAgIHJldHVybiBhID09ICdjb2xvcicgPyB0IDogdCArICctJyArIGE7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgc3VnYXIgZm9yIGZpbGwgYW5kIHN0cm9rZVxuICAgIDtcbiAgICBbJ2ZpbGwnLCAnc3Ryb2tlJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IHt9O1xuXG4gICAgICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbiAobykge1xuICAgICAgICBpZiAodHlwZW9mIG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnIHx8IFNWRy5Db2xvci5pc1JnYihvKSB8fCBvICYmIHR5cGVvZiBvLmZpbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmF0dHIobSwgbyk7XG4gICAgICAgIH0gZWxzZSAvLyBzZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSBzdWdhci5maWxsIGFuZCBzdWdhci5zdHJva2UgbGlzdFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdWdhclttXS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICBpZiAob1tzdWdhclttXVtpXV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cihzdWdhci5wcmVmaXgobSwgc3VnYXJbbV1baV0pLCBvW3N1Z2FyW21dW2ldXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRlgsIGV4dGVuc2lvbik7XG4gICAgfSk7XG4gICAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkZYLCB7XG4gICAgICAvLyBNYXAgdHJhbnNsYXRlIHRvIHRyYW5zZm9ybVxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBNYXAgbWF0cml4IHRvIHRyYW5zZm9ybVxuICAgICAgbWF0cml4OiBmdW5jdGlvbiBtYXRyaXgobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBuZXcgU1ZHLk1hdHJpeChhcmd1bWVudHMubGVuZ3RoID09IDYgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOiBtKSk7XG4gICAgICB9LFxuICAgICAgLy8gT3BhY2l0eVxuICAgICAgb3BhY2l0eTogZnVuY3Rpb24gb3BhY2l0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdvcGFjaXR5JywgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcbiAgICAgIGR4OiBmdW5jdGlvbiBkeCh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLngobmV3IFNWRy5OdW1iZXIoeCkucGx1cyh0aGlzIGluc3RhbmNlb2YgU1ZHLkZYID8gMCA6IHRoaXMueCgpKSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHkgYXhpc1xuICAgICAgZHk6IGZ1bmN0aW9uIGR5KHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueShuZXcgU1ZHLk51bWJlcih5KS5wbHVzKHRoaXMgaW5zdGFuY2VvZiBTVkcuRlggPyAwIDogdGhpcy55KCkpLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBTVkcuZXh0ZW5kKFNWRy5QYXRoLCB7XG4gICAgICAvLyBHZXQgcGF0aCBsZW5ndGhcbiAgICAgIGxlbmd0aDogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxuICAgICAgcG9pbnRBdDogZnVuY3Rpb24gcG9pbnRBdChsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgU1ZHLlNldCA9IFNWRy5pbnZlbnQoe1xuICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobWVtYmVycykge1xuICAgICAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxuICAgICAgICBBcnJheS5pc0FycmF5KG1lbWJlcnMpID8gdGhpcy5tZW1iZXJzID0gbWVtYmVycyA6IHRoaXMuY2xlYXIoKTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgICAgZXh0ZW5kOiB7XG4gICAgICAgIC8vIEFkZCBlbGVtZW50IHRvIHNldFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgICAgICB2YXIgaWwsXG4gICAgICAgICAgICAgIGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIHNldFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4KGVsZW1lbnQpOyAvLyByZW1vdmUgZ2l2ZW4gY2hpbGRcblxuICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbWVtYmVyc1xuICAgICAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGJsb2NrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGx5KHRoaXMubWVtYmVyc1tpXSwgW2ksIHRoaXMubWVtYmVyc10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXN0b3JlIHRvIGRlZmF1bHRzXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAvLyBpbml0aWFsaXplIHN0b3JlXG4gICAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIGEgc2V0XG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHByZXNlbnQgaW4gc2V0XG4gICAgICAgIGhhczogZnVuY3Rpb24gaGFzKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwO1xuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1bnMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudCBpbiBzZXRcbiAgICAgICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBtZW1iZXIgYXQgZ2l2ZW4gaW5kZXhcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnNbaV07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBmaXJzdCBtZW1iZXJcbiAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldCgwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGxhc3QgbWVtYmVyXG4gICAgICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubWVtYmVycy5sZW5ndGggLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgICAgY29uc3RydWN0OiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzZXRcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobWVtYmVycykge1xuICAgICAgICAgIHJldHVybiBuZXcgU1ZHLlNldChtZW1iZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFNWRy5GWC5TZXQgPSBTVkcuaW52ZW50KHtcbiAgICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc2V0KSB7XG4gICAgICAgIC8vIHN0b3JlIHJlZmVyZW5jZSB0byBzZXRcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICB9XG4gICAgfSk7IC8vIEFsaWFzIG1ldGhvZHNcblxuICAgIFNWRy5TZXQuaW5oZXJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtZXRob2RzID0gW107IC8vIGdhdGhlciBzaGFwZSBtZXRob2RzXG5cbiAgICAgIGZvciAodmFyIG0gaW4gU1ZHLlNoYXBlLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIFNWRy5TaGFwZS5wcm90b3R5cGVbbV0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFNWRy5TZXQucHJvdG90eXBlW21dICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbWV0aG9kcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFwcGx5IHNoYXBlIGFsaWFzc2VzXG5cblxuICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgU1ZHLlNldC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVtYmVyc1tpXSAmJiB0eXBlb2YgdGhpcy5tZW1iZXJzW2ldW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzW2ldW21ldGhvZF0uYXBwbHkodGhpcy5tZW1iZXJzW2ldLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtZXRob2QgPT0gJ2FuaW1hdGUnID8gdGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlguU2V0KHRoaXMpKSA6IHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9KTsgLy8gY2xlYXIgbWV0aG9kcyBmb3IgdGhlIG5leHQgcm91bmRcblxuICAgICAgbWV0aG9kcyA9IFtdOyAvLyBnYXRoZXIgZnggbWV0aG9kc1xuXG4gICAgICBmb3IgKHZhciBtIGluIFNWRy5GWC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBTVkcuRlgucHJvdG90eXBlW21dID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuRlguU2V0LnByb3RvdHlwZVttXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1ldGhvZHMucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhcHBseSBmeCBhbGlhc3Nlc1xuXG5cbiAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIFNWRy5GWC5TZXQucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5zZXQubWVtYmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNldC5tZW1iZXJzW2ldLmZ4W21ldGhvZF0uYXBwbHkodGhpcy5zZXQubWVtYmVyc1tpXS5meCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7fSk7XG4gICAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgICAgLy8gUmVtZW1iZXIgYXJiaXRyYXJ5IGRhdGFcbiAgICAgIHJlbWVtYmVyOiBmdW5jdGlvbiByZW1lbWJlcihrLCB2KSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGV2ZXJ5IGl0ZW0gaW4gYW4gb2JqZWN0IGluZGl2aWR1YWxseVxuICAgICAgICBpZiAoX3R5cGVvZihhcmd1bWVudHNbMF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHZfIGluIGspIHtcbiAgICAgICAgICAgIHRoaXMucmVtZW1iZXIodl8sIGtbdl9dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcmV0cmlldmUgbWVtb3J5XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lbW9yeSgpW2tdO1xuICAgICAgICB9IC8vIHN0b3JlIG1lbW9yeVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1lbW9yeSgpW2tdID0gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEVyYXNlIGEgZ2l2ZW4gbWVtb3J5XG4gICAgICBmb3JnZXQ6IGZ1bmN0aW9uIGZvcmdldCgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHRoaXMuX21lbW9yeSA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1lbW9yeSgpW2FyZ3VtZW50c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gSW5pdGlhbGl6ZSBvciByZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxuICAgICAgbWVtb3J5OiBmdW5jdGlvbiBtZW1vcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZW1vcnkgfHwgKHRoaXMuX21lbW9yeSA9IHt9KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTWV0aG9kIGZvciBnZXR0aW5nIGFuIGVsZW1lbnQgYnkgaWRcblxuICAgIFNWRy5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRGcm9tUmVmZXJlbmNlKGlkKSB8fCBpZCk7XG4gICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpO1xuICAgIH07IC8vIFNlbGVjdCBlbGVtZW50cyBieSBxdWVyeSBzdHJpbmdcblxuXG4gICAgU1ZHLnNlbGVjdCA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyZW50KSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5TZXQoU1ZHLnV0aWxzLm1hcCgocGFyZW50IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFNWRy5hZG9wdChub2RlKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgU1ZHLmV4dGVuZChTVkcuUGFyZW50LCB7XG4gICAgICAvLyBTY29wZWQgc2VsZWN0IG1ldGhvZFxuICAgICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIFNWRy5zZWxlY3QocXVlcnksIHRoaXMubm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwYXRoUmVnUmVwbGFjZShhLCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyArIGQucmVwbGFjZShTVkcucmVnZXguZG90cywgJyAuJyk7XG4gICAgfSAvLyBjcmVhdGVzIGRlZXAgY2xvbmUgb2YgYXJyYXlcblxuXG4gICAgZnVuY3Rpb24gX2lzKGVsLCBvYmopIHtcbiAgICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIG9iajtcbiAgICB9IC8vIHRlc3RzIGlmIGEgZ2l2ZW4gc2VsZWN0b3IgbWF0Y2hlcyBhbiBlbGVtZW50XG5cblxuICAgIGZ1bmN0aW9uIF9tYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIChlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm9NYXRjaGVzU2VsZWN0b3IpLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgICB9IC8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxuXG5cbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uocykge1xuICAgICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gICAgICAgIHJldHVybiBnLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9IC8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG5cblxuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICAgICAgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpO1xuICAgIH0gLy8gRW5zdXJlIHRvIHNpeC1iYXNlZCBoZXhcblxuXG4gICAgZnVuY3Rpb24gZnVsbEhleChoZXgpIHtcbiAgICAgIHJldHVybiBoZXgubGVuZ3RoID09IDQgPyBbJyMnLCBoZXguc3Vic3RyaW5nKDEsIDIpLCBoZXguc3Vic3RyaW5nKDEsIDIpLCBoZXguc3Vic3RyaW5nKDIsIDMpLCBoZXguc3Vic3RyaW5nKDIsIDMpLCBoZXguc3Vic3RyaW5nKDMsIDQpLCBoZXguc3Vic3RyaW5nKDMsIDQpXS5qb2luKCcnKSA6IGhleDtcbiAgICB9IC8vIENvbXBvbmVudCB0byBoZXggdmFsdWVcblxuXG4gICAgZnVuY3Rpb24gY29tcFRvSGV4KGNvbXApIHtcbiAgICAgIHZhciBoZXggPSBjb21wLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG4gICAgfSAvLyBDYWxjdWxhdGUgcHJvcG9ydGlvbmFsIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIHdoZW4gbmVjZXNzYXJ5XG5cblxuICAgIGZ1bmN0aW9uIHByb3BvcnRpb25hbFNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIGJveCA9IGVsZW1lbnQuYmJveCgpO1xuXG4gICAgICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICogaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAqIHdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSAvLyBEZWx0YSB0cmFuc2Zvcm0gcG9pbnRcblxuXG4gICAgZnVuY3Rpb24gZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHgsIHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKiBtYXRyaXguYSArIHkgKiBtYXRyaXguYyArIDAsXG4gICAgICAgIHk6IHggKiBtYXRyaXguYiArIHkgKiBtYXRyaXguZCArIDBcbiAgICAgIH07XG4gICAgfSAvLyBNYXAgbWF0cml4IGFycmF5IHRvIG9iamVjdFxuXG5cbiAgICBmdW5jdGlvbiBhcnJheVRvTWF0cml4KGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IGFbMF0sXG4gICAgICAgIGI6IGFbMV0sXG4gICAgICAgIGM6IGFbMl0sXG4gICAgICAgIGQ6IGFbM10sXG4gICAgICAgIGU6IGFbNF0sXG4gICAgICAgIGY6IGFbNV1cbiAgICAgIH07XG4gICAgfSAvLyBQYXJzZSBtYXRyaXggaWYgcmVxdWlyZWRcblxuXG4gICAgZnVuY3Rpb24gcGFyc2VNYXRyaXgobWF0cml4KSB7XG4gICAgICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBTVkcuTWF0cml4KSkge1xuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeChtYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0gLy8gQWRkIGNlbnRyZSBwb2ludCB0byB0cmFuc2Zvcm0gb2JqZWN0XG5cblxuICAgIGZ1bmN0aW9uIGFycmF5VG9TdHJpbmcoYSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYS5sZW5ndGgsIHMgPSAnJzsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcyArPSBhW2ldWzBdO1xuXG4gICAgICAgIGlmIChhW2ldWzFdICE9IG51bGwpIHtcbiAgICAgICAgICBzICs9IGFbaV1bMV07XG5cbiAgICAgICAgICBpZiAoYVtpXVsyXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIHMgKz0gYVtpXVsyXTtcblxuICAgICAgICAgICAgaWYgKGFbaV1bM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzNdO1xuICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzRdO1xuXG4gICAgICAgICAgICAgIGlmIChhW2ldWzVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgICBzICs9IGFbaV1bNV07XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgICAgcyArPSBhW2ldWzZdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFbaV1bN10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgICAgICBzICs9IGFbaV1bN107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzICsgJyAnO1xuICAgIH0gLy8gRGVlcCBuZXcgaWQgYXNzaWdubWVudFxuXG5cbiAgICBmdW5jdGlvbiBhc3NpZ25OZXdJZChub2RlKSB7XG4gICAgICAvLyBkbyB0aGUgc2FtZSBmb3IgU1ZHIGNoaWxkIG5vZGVzIGFzIHdlbGxcbiAgICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICAgICAgYXNzaWduTmV3SWQobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpLmlkKFNWRy5laWQobm9kZS5ub2RlTmFtZSkpO1xuICAgIH0gLy8gQWRkIG1vcmUgYm91bmRpbmcgYm94IHByb3BlcnRpZXNcblxuXG4gICAgZnVuY3Rpb24gZnVsbEJveChiKSB7XG4gICAgICBpZiAoYi54ID09IG51bGwpIHtcbiAgICAgICAgYi54ID0gMDtcbiAgICAgICAgYi55ID0gMDtcbiAgICAgICAgYi53aWR0aCA9IDA7XG4gICAgICAgIGIuaGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgYi53ID0gYi53aWR0aDtcbiAgICAgIGIuaCA9IGIuaGVpZ2h0O1xuICAgICAgYi54MiA9IGIueCArIGIud2lkdGg7XG4gICAgICBiLnkyID0gYi55ICsgYi5oZWlnaHQ7XG4gICAgICBiLmN4ID0gYi54ICsgYi53aWR0aCAvIDI7XG4gICAgICBiLmN5ID0gYi55ICsgYi5oZWlnaHQgLyAyO1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSAvLyBHZXQgaWQgZnJvbSByZWZlcmVuY2Ugc3RyaW5nXG5cblxuICAgIGZ1bmN0aW9uIGlkRnJvbVJlZmVyZW5jZSh1cmwpIHtcbiAgICAgIHZhciBtID0gKHVybCB8fCAnJykudG9TdHJpbmcoKS5tYXRjaChTVkcucmVnZXgucmVmZXJlbmNlKTtcbiAgICAgIGlmIChtKSByZXR1cm4gbVsxXTtcbiAgICB9IC8vIElmIHZhbHVlcyBsaWtlIDFlLTg4IGFyZSBwYXNzZWQsIHRoaXMgaXMgbm90IGEgdmFsaWQgMzIgYml0IGZsb2F0LFxuICAgIC8vIGJ1dCBpbiB0aG9zZSBjYXNlcywgd2UgYXJlIHNvIGNsb3NlIHRvIDAgdGhhdCAwIHdvcmtzIHdlbGwhXG5cblxuICAgIGZ1bmN0aW9uIGZsb2F0MzJTdHJpbmcodikge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHYpID4gMWUtMzcgPyB2IDogMDtcbiAgICB9IC8vIENyZWF0ZSBtYXRyaXggYXJyYXkgZm9yIGxvb3BpbmdcblxuXG4gICAgdmFyIGFiY2RlZiA9ICdhYmNkZWYnLnNwbGl0KCcnKTsgLy8gQWRkIEN1c3RvbUV2ZW50IHRvIElFOSBhbmQgSUUxMFxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIENvZGUgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50XG4gICAgICB2YXIgQ3VzdG9tRXZlbnRQb2x5ID0gZnVuY3Rpb24gQ3VzdG9tRXZlbnRQb2x5KGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgICBkZXRhaWw6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICBlLmluaXRDdXN0b21FdmVudChldmVudCwgb3B0aW9ucy5idWJibGVzLCBvcHRpb25zLmNhbmNlbGFibGUsIG9wdGlvbnMuZGV0YWlsKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9O1xuXG4gICAgICBDdXN0b21FdmVudFBvbHkucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICAgIFNWRy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50UG9seTtcbiAgICB9IGVsc2Uge1xuICAgICAgU1ZHLkN1c3RvbUV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBTVkc7XG4gIH0pO1xuXG4gIC8qISBzdmcuZmlsdGVyLmpzIC0gdjIuMC4yIC0gMjAxNi0wMi0yNFxyXG4gICogaHR0cHM6Ly9naXRodWIuY29tL3dvdXQvc3ZnLmZpbHRlci5qc1xyXG4gICogQ29weXJpZ2h0IChjKSAyMDE2IFdvdXQgRmllcmVuczsgTGljZW5zZWQgTUlUICovXHJcbiAgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8vIE1haW4gZmlsdGVyIGNsYXNzXHJcbiAgICBTVkcuRmlsdGVyID0gU1ZHLmludmVudCh7XHJcbiAgICAgIGNyZWF0ZTogJ2ZpbHRlcicsXHJcbiAgICAgIGluaGVyaXQ6IFNWRy5QYXJlbnQsXHJcbiAgICAgIGV4dGVuZDoge1xyXG4gICAgICAgIC8vIFN0YXRpYyBzdHJpbmdzXHJcbiAgICAgICAgc291cmNlOiAgICAgICAgICAgJ1NvdXJjZUdyYXBoaWMnLFxyXG4gICAgICAgIHNvdXJjZUFscGhhOiAgICAgICdTb3VyY2VBbHBoYScsXHJcbiAgICAgICAgYmFja2dyb3VuZDogICAgICAgJ0JhY2tncm91bmRJbWFnZScsXHJcbiAgICAgICAgYmFja2dyb3VuZEFscGhhOiAgJ0JhY2tncm91bmRBbHBoYScsXHJcbiAgICAgICAgZmlsbDogICAgICAgICAgICAgJ0ZpbGxQYWludCcsXHJcbiAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgJ1N0cm9rZVBhaW50JyxcclxuXHJcbiAgICAgICAgYXV0b1NldEluOiB0cnVlLFxyXG4gICAgICAgIC8vIEN1c3RvbSBwdXQgbWV0aG9kIGZvciBsZWFuZXIgY29kZVxyXG4gICAgICAgIHB1dDogZnVuY3Rpb24oZWxlbWVudCwgaSkge1xyXG4gICAgICAgICAgdGhpcy5hZGQoZWxlbWVudCwgaSk7XHJcblxyXG4gICAgICAgICAgaWYoIWVsZW1lbnQuYXR0cignaW4nKSAmJiB0aGlzLmF1dG9TZXRJbil7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYXR0cignaW4nLHRoaXMuc291cmNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKCFlbGVtZW50LmF0dHIoJ3Jlc3VsdCcpKXtcclxuICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdyZXN1bHQnLGVsZW1lbnQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBlbGVtZW50XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBCbGVuZCBlZmZlY3RcclxuICAgICAgICBibGVuZDogZnVuY3Rpb24oaW4xLCBpbjIsIG1vZGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkJsZW5kRWZmZWN0KGluMSwgaW4yLCBtb2RlKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIENvbG9yTWF0cml4IGVmZmVjdFxyXG4gICAgICAgIGNvbG9yTWF0cml4OiBmdW5jdGlvbih0eXBlLCB2YWx1ZXMpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkNvbG9yTWF0cml4RWZmZWN0KHR5cGUsIHZhbHVlcykpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBDb252b2x2ZU1hdHJpeCBlZmZlY3RcclxuICAgICAgICBjb252b2x2ZU1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Db252b2x2ZU1hdHJpeEVmZmVjdChtYXRyaXgpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQ29tcG9uZW50VHJhbnNmZXIgZWZmZWN0XHJcbiAgICAgICAgY29tcG9uZW50VHJhbnNmZXI6IGZ1bmN0aW9uKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkNvbXBvbmVudFRyYW5zZmVyRWZmZWN0KGNvbXBvbmVudHMpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQ29tcG9zaXRlIGVmZmVjdFxyXG4gICAgICAgIGNvbXBvc2l0ZTogZnVuY3Rpb24oaW4xLCBpbjIsIG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Db21wb3NpdGVFZmZlY3QoaW4xLCBpbjIsIG9wZXJhdG9yKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIEZsb29kIGVmZmVjdFxyXG4gICAgICAgIGZsb29kOiBmdW5jdGlvbihjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRmxvb2RFZmZlY3QoY29sb3IsIG9wYWNpdHkpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gT2Zmc2V0IGVmZmVjdFxyXG4gICAgICAgIG9mZnNldDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuT2Zmc2V0RWZmZWN0KHgseSkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBJbWFnZSBlZmZlY3RcclxuICAgICAgICBpbWFnZTogZnVuY3Rpb24oc3JjKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5JbWFnZUVmZmVjdChzcmMpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gTWVyZ2UgZWZmZWN0XHJcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgLy9wYXNzIHRoZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2Ugd2UgZG9udCBrbm93IGlmIHRoZSB1c2VyIGdhdmUgdXMgYW4gYXJyYXkgYXMgdGhlIGZpcnN0IGFyZ3VlbW50IG9yIHdldGhlciB0aGV5IGxpc3RlZCB0aGUgZWZmZWN0cyBpbiB0aGUgYXJndW1lbnRzXHJcbiAgICAgICAgICB2YXIgYXJncyA9IFt1bmRlZmluZWRdO1xyXG4gICAgICAgICAgZm9yKHZhciBpIGluIGFyZ3VtZW50cykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IChTVkcuTWVyZ2VFZmZlY3QuYmluZC5hcHBseShTVkcuTWVyZ2VFZmZlY3QsYXJncykpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gR2F1c3NpYW4gQmx1ciBlZmZlY3RcclxuICAgICAgICBnYXVzc2lhbkJsdXI6IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuR2F1c3NpYW5CbHVyRWZmZWN0KHgseSkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBNb3JwaG9sb2d5IGVmZmVjdFxyXG4gICAgICAgIG1vcnBob2xvZ3k6IGZ1bmN0aW9uKG9wZXJhdG9yLHJhZGl1cyl7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Nb3JwaG9sb2d5RWZmZWN0KG9wZXJhdG9yLHJhZGl1cykpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBEaWZmdXNlTGlnaHRpbmcgZWZmZWN0XHJcbiAgICAgICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRGlmZnVzZUxpZ2h0aW5nRWZmZWN0KHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsa2VybmVsVW5pdExlbmd0aCkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBEaXNwbGFjZW1lbnRNYXAgZWZmZWN0XHJcbiAgICAgICAgZGlzcGxhY2VtZW50TWFwOiBmdW5jdGlvbihpbjEsaW4yLHNjYWxlLHhDaGFubmVsU2VsZWN0b3IseUNoYW5uZWxTZWxlY3Rvcil7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5EaXNwbGFjZW1lbnRNYXBFZmZlY3QoaW4xLGluMixzY2FsZSx4Q2hhbm5lbFNlbGVjdG9yLHlDaGFubmVsU2VsZWN0b3IpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gU3BlY3VsYXJMaWdodGluZyBlZmZlY3RcclxuICAgICAgICBzcGVjdWxhckxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TcGVjdWxhckxpZ2h0aW5nRWZmZWN0KHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxrZXJuZWxVbml0TGVuZ3RoKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRpbGUgZWZmZWN0XHJcbiAgICAgICAgdGlsZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRpbGVFZmZlY3QoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBUdXJidWxlbmNlIGVmZmVjdFxyXG4gICAgICAgIHR1cmJ1bGVuY2U6IGZ1bmN0aW9uKGJhc2VGcmVxdWVuY3ksbnVtT2N0YXZlcyxzZWVkLHN0aXRjaFRpbGVzLHR5cGUpe1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVHVyYnVsZW5jZUVmZmVjdChiYXNlRnJlcXVlbmN5LG51bU9jdGF2ZXMsc2VlZCxzdGl0Y2hUaWxlcyx0eXBlKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIERlZmF1bHQgc3RyaW5nIHZhbHVlXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmF0dHIoJ2lkJykgKyAnKSdcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vYWRkIC5maWx0ZXIgZnVuY3Rpb25cclxuICAgIFNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcclxuICAgICAgLy8gRGVmaW5lIGZpbHRlclxyXG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMucHV0KG5ldyBTVkcuRmlsdGVyKTtcclxuXHJcbiAgICAgICAgLyogaW52b2tlIHBhc3NlZCBibG9jayAqL1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICBibG9jay5jYWxsKGZpbHRlciwgZmlsdGVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZpbHRlclxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFNWRy5leHRlbmQoU1ZHLkNvbnRhaW5lciwge1xyXG4gICAgICAvLyBEZWZpbmUgZmlsdGVyIG9uIGRlZnNcclxuICAgICAgZmlsdGVyOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5maWx0ZXIoYmxvY2spXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkcsIFNWRy5OZXN0ZWQsIHtcclxuICAgICAgLy8gQ3JlYXRlIGZpbHRlciBlbGVtZW50IGluIGRlZnMgYW5kIHN0b3JlIHJlZmVyZW5jZVxyXG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJlciA9IGJsb2NrIGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQgP1xyXG4gICAgICAgICAgYmxvY2sgOiB0aGlzLmRvYygpLmZpbHRlcihibG9jayk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZG9jKCkgJiYgdGhpcy5maWx0ZXJlci5kb2MoKSAhPT0gdGhpcy5kb2MoKSl7XHJcbiAgICAgICAgICB0aGlzLmRvYygpLmRlZnMoKS5hZGQodGhpcy5maWx0ZXJlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmF0dHIoJ2ZpbHRlcicsIHRoaXMuZmlsdGVyZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJlclxyXG4gICAgICB9LFxyXG4gICAgICAvLyBSZW1vdmUgZmlsdGVyXHJcbiAgICAgIHVuZmlsdGVyOiBmdW5jdGlvbihyZW1vdmUpIHtcclxuICAgICAgICAvKiBhbHNvIHJlbW92ZSB0aGUgZmlsdGVyIG5vZGUgKi9cclxuICAgICAgICBpZiAodGhpcy5maWx0ZXJlciAmJiByZW1vdmUgPT09IHRydWUpXHJcbiAgICAgICAgICB0aGlzLmZpbHRlcmVyLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAvKiBkZWxldGUgcmVmZXJlbmNlIHRvIGZpbHRlcmVyICovXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyZXI7XHJcblxyXG4gICAgICAgIC8qIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICovXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZmlsdGVyJywgbnVsbClcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIFNWRy5FZmZlY3QgY2xhc3NcclxuICAgIFNWRy5FZmZlY3QgPSBTVkcuaW52ZW50KHtcclxuICAgICAgY3JlYXRlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcclxuICAgICAgfSxcclxuICAgICAgaW5oZXJpdDogU1ZHLkVsZW1lbnQsXHJcbiAgICAgIGV4dGVuZDoge1xyXG4gICAgICAgIC8vIFNldCBpbiBhdHRyaWJ1dGVcclxuICAgICAgICBpbjogZnVuY3Rpb24oZWZmZWN0KSB7XHJcbiAgICAgICAgICByZXR1cm4gZWZmZWN0ID09IG51bGw/IHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5zZWxlY3QoJ1tyZXN1bHQ9XCInK3RoaXMuYXR0cignaW4nKSsnXCJdJykuZ2V0KDApIHx8IHRoaXMuYXR0cignaW4nKSA6IHRoaXMuYXR0cignaW4nLCBlZmZlY3QpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBOYW1lZCByZXN1bHRcclxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsPyB0aGlzLmF0dHIoJ3Jlc3VsdCcpIDogdGhpcy5hdHRyKCdyZXN1bHQnLHJlc3VsdClcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFN0cmluZ2lmaWNhdGlvblxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBjcmVhdGUgY2xhc3MgZm9yIHBhcmVudCBlZmZlY3RzIGxpa2UgbWVyZ2VcclxuICAgIC8vIEluaGVyaXQgZnJvbSBTVkcuUGFyZW50XHJcbiAgICBTVkcuUGFyZW50RWZmZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGluaGVyaXQ6IFNWRy5QYXJlbnQsXHJcbiAgICAgIGV4dGVuZDoge1xyXG4gICAgICAgIC8vIFNldCBpbiBhdHRyaWJ1dGVcclxuICAgICAgICBpbjogZnVuY3Rpb24oZWZmZWN0KSB7XHJcbiAgICAgICAgICByZXR1cm4gZWZmZWN0ID09IG51bGw/IHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5zZWxlY3QoJ1tyZXN1bHQ9XCInK3RoaXMuYXR0cignaW4nKSsnXCJdJykuZ2V0KDApIHx8IHRoaXMuYXR0cignaW4nKSA6IHRoaXMuYXR0cignaW4nLCBlZmZlY3QpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBOYW1lZCByZXN1bHRcclxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsPyB0aGlzLmF0dHIoJ3Jlc3VsdCcpIDogdGhpcy5hdHRyKCdyZXN1bHQnLHJlc3VsdClcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFN0cmluZ2lmaWNhdGlvblxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL2NoYWluaW5nXHJcbiAgICB2YXIgY2hhaW5pbmdFZmZlY3RzID0ge1xyXG4gICAgICAvLyBCbGVuZCBlZmZlY3RcclxuICAgICAgYmxlbmQ6IGZ1bmN0aW9uKGluMiwgbW9kZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYmxlbmQodGhpcywgaW4yLCBtb2RlKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgICAgfSxcclxuICAgICAgLy8gQ29sb3JNYXRyaXggZWZmZWN0XHJcbiAgICAgIGNvbG9yTWF0cml4OiBmdW5jdGlvbih0eXBlLCB2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmNvbG9yTWF0cml4KHR5cGUsIHZhbHVlcykuaW4odGhpcylcclxuICAgICAgfSxcclxuICAgICAgLy8gQ29udm9sdmVNYXRyaXggZWZmZWN0XHJcbiAgICAgIGNvbnZvbHZlTWF0cml4OiBmdW5jdGlvbihtYXRyaXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmNvbnZvbHZlTWF0cml4KG1hdHJpeCkuaW4odGhpcylcclxuICAgICAgfSxcclxuICAgICAgLy8gQ29tcG9uZW50VHJhbnNmZXIgZWZmZWN0XHJcbiAgICAgIGNvbXBvbmVudFRyYW5zZmVyOiBmdW5jdGlvbihjb21wb25lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5jb21wb25lbnRUcmFuc2Zlcihjb21wb25lbnRzKS5pbih0aGlzKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBDb21wb3NpdGUgZWZmZWN0XHJcbiAgICAgIGNvbXBvc2l0ZTogZnVuY3Rpb24oaW4yLCBvcGVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuY29tcG9zaXRlKHRoaXMsIGluMiwgb3BlcmF0b3IpIC8vcGFzcyB0aGlzIGFzIHRoZSBmaXJzdCBpbnB1dFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBGbG9vZCBlZmZlY3RcclxuICAgICAgZmxvb2Q6IGZ1bmN0aW9uKGNvbG9yLCBvcGFjaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5mbG9vZChjb2xvciwgb3BhY2l0eSkgLy90aGlzIGVmZmVjdCBkb250IGhhdmUgaW5wdXRzXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIE9mZnNldCBlZmZlY3RcclxuICAgICAgb2Zmc2V0OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5vZmZzZXQoeCx5KS5pbih0aGlzKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBJbWFnZSBlZmZlY3RcclxuICAgICAgaW1hZ2U6IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuaW1hZ2Uoc3JjKSAvL3RoaXMgZWZmZWN0IGRvbnQgaGF2ZSBpbnB1dHNcclxuICAgICAgfSxcclxuICAgICAgLy8gTWVyZ2UgZWZmZWN0XHJcbiAgICAgIG1lcmdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLm1lcmdlLmFwcGx5KHRoaXMucGFyZW50KCksW3RoaXNdLmNvbmNhdChhcmd1bWVudHMpKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcclxuICAgICAgfSxcclxuICAgICAgLy8gR2F1c3NpYW4gQmx1ciBlZmZlY3RcclxuICAgICAgZ2F1c3NpYW5CbHVyOiBmdW5jdGlvbih4LHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmdhdXNzaWFuQmx1cih4LHkpLmluKHRoaXMpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIE1vcnBob2xvZ3kgZWZmZWN0XHJcbiAgICAgIG1vcnBob2xvZ3k6IGZ1bmN0aW9uKG9wZXJhdG9yLHJhZGl1cyl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5tb3JwaG9sb2d5KG9wZXJhdG9yLHJhZGl1cykuaW4odGhpcylcclxuICAgICAgfSxcclxuICAgICAgLy8gRGlmZnVzZUxpZ2h0aW5nIGVmZmVjdFxyXG4gICAgICBkaWZmdXNlTGlnaHRpbmc6IGZ1bmN0aW9uKHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5kaWZmdXNlTGlnaHRpbmcoc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxrZXJuZWxVbml0TGVuZ3RoKS5pbih0aGlzKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBEaXNwbGFjZW1lbnRNYXAgZWZmZWN0XHJcbiAgICAgIGRpc3BsYWNlbWVudE1hcDogZnVuY3Rpb24oaW4yLHNjYWxlLHhDaGFubmVsU2VsZWN0b3IseUNoYW5uZWxTZWxlY3Rvcil7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5kaXNwbGFjZW1lbnRNYXAodGhpcyxpbjIsc2NhbGUseENoYW5uZWxTZWxlY3Rvcix5Q2hhbm5lbFNlbGVjdG9yKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgICAgfSxcclxuICAgICAgLy8gU3BlY3VsYXJMaWdodGluZyBlZmZlY3RcclxuICAgICAgc3BlY3VsYXJMaWdodGluZzogZnVuY3Rpb24oc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuc3BlY3VsYXJMaWdodGluZyhzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsa2VybmVsVW5pdExlbmd0aCkuaW4odGhpcylcclxuICAgICAgfSxcclxuICAgICAgLy8gVGlsZSBlZmZlY3RcclxuICAgICAgdGlsZTogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnRpbGUoKS5pbih0aGlzKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBUdXJidWxlbmNlIGVmZmVjdFxyXG4gICAgICB0dXJidWxlbmNlOiBmdW5jdGlvbihiYXNlRnJlcXVlbmN5LG51bU9jdGF2ZXMsc2VlZCxzdGl0Y2hUaWxlcyx0eXBlKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnR1cmJ1bGVuY2UoYmFzZUZyZXF1ZW5jeSxudW1PY3RhdmVzLHNlZWQsc3RpdGNoVGlsZXMsdHlwZSkuaW4odGhpcylcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNWRy5leHRlbmQoU1ZHLkVmZmVjdCxjaGFpbmluZ0VmZmVjdHMpO1xyXG4gICAgU1ZHLmV4dGVuZChTVkcuUGFyZW50RWZmZWN0LGNoYWluaW5nRWZmZWN0cyk7XHJcblxyXG4gICAgLy9jcmVhIGNsYXNzIGZvciBjaGlsZCBlZmZlY3RzLCBsaWtlIE1lcmdlTm9kZSwgRnVuY1IgYW5kIGxpZ2h0c1xyXG4gICAgU1ZHLkNoaWxkRWZmZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGluaGVyaXQ6IFNWRy5FbGVtZW50LFxyXG4gICAgICBleHRlbmQ6IHtcclxuICAgICAgaW46IGZ1bmN0aW9uKGVmZmVjdCl7XHJcbiAgICAgICAgdGhpcy5hdHRyKCdpbicsZWZmZWN0KTtcclxuICAgICAgfVxyXG4gICAgICAvL2RvbnQgaW5jbHVkZSBhbnkgXCJyZXN1bHRcIiBmdW5jdGlvbnMgYmVjYXVzZSB0aGVzZSB0eXBlcyBvZiBub2RlcyBkb250IGhhdmUgdGhlbVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYWxsIGRpZmZlcmVudCBlZmZlY3RzXHJcbiAgICB2YXIgZWZmZWN0cyA9IHtcclxuICAgICAgYmxlbmQ6IGZ1bmN0aW9uKGluMSxpbjIsbW9kZSl7XHJcbiAgICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICAgIGluOiBpbjEsXHJcbiAgICAgICAgICBpbjI6IGluMixcclxuICAgICAgICAgIG1vZGU6IG1vZGUgfHwgJ25vcm1hbCdcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgY29sb3JNYXRyaXg6IGZ1bmN0aW9uKHR5cGUsdmFsdWVzKXtcclxuICAgICAgICBpZiAodHlwZSA9PSAnbWF0cml4JylcclxuICAgICAgICAgIHZhbHVlcyA9IG5vcm1hbGlzZU1hdHJpeCh2YWx1ZXMpO1xyXG5cclxuICAgICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgICAgdHlwZTogICB0eXBlXHJcbiAgICAgICAgLCB2YWx1ZXM6IHR5cGVvZiB2YWx1ZXMgPT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdmFsdWVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbnZvbHZlTWF0cml4OiBmdW5jdGlvbihtYXRyaXgpe1xyXG4gICAgICAgIG1hdHJpeCA9IG5vcm1hbGlzZU1hdHJpeChtYXRyaXgpO1xyXG5cclxuICAgICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgICAgb3JkZXI6ICAgICAgICBNYXRoLnNxcnQobWF0cml4LnNwbGl0KCcgJykubGVuZ3RoKVxyXG4gICAgICAgICwga2VybmVsTWF0cml4OiBtYXRyaXhcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgY29tcG9zaXRlOiBmdW5jdGlvbihpbjEsIGluMiwgb3BlcmF0b3Ipe1xyXG4gICAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgICBpbjogaW4xLFxyXG4gICAgICAgICAgaW4yOiBpbjIsXHJcbiAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3JcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgZmxvb2Q6IGZ1bmN0aW9uKGNvbG9yLG9wYWNpdHkpe1xyXG4gICAgICAgIHRoaXMuYXR0cignZmxvb2QtY29sb3InLGNvbG9yKTtcclxuICAgICAgICBpZihvcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignZmxvb2Qtb3BhY2l0eScsb3BhY2l0eSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIG9mZnNldDogZnVuY3Rpb24oeCx5KXtcclxuICAgICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgICAgZHg6IHgsXHJcbiAgICAgICAgICBkeTogeVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBpbWFnZTogZnVuY3Rpb24oc3JjKXtcclxuICAgICAgICB0aGlzLmF0dHIoJ2hyZWYnLCBzcmMsIFNWRy54bGluayk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRpc3BsYWNlbWVudE1hcDogZnVuY3Rpb24oaW4xLGluMixzY2FsZSx4Q2hhbm5lbFNlbGVjdG9yLHlDaGFubmVsU2VsZWN0b3Ipe1xyXG4gICAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgICBpbjogaW4xLFxyXG4gICAgICAgICAgaW4yOiBpbjIsXHJcbiAgICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICB4Q2hhbm5lbFNlbGVjdG9yOiB4Q2hhbm5lbFNlbGVjdG9yLFxyXG4gICAgICAgICAgeUNoYW5uZWxTZWxlY3RvcjogeUNoYW5uZWxTZWxlY3RvclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBnYXVzc2lhbkJsdXI6IGZ1bmN0aW9uKHgseSl7XHJcbiAgICAgICAgaWYoeCAhPSBudWxsIHx8IHkgIT0gbnVsbClcclxuICAgICAgICAgIHRoaXMuYXR0cignc3RkRGV2aWF0aW9uJywgbGlzdFN0cmluZyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5hdHRyKCdzdGREZXZpYXRpb24nLCAnMCAwJyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIG1vcnBob2xvZ3k6IGZ1bmN0aW9uKG9wZXJhdG9yLHJhZGl1cyl7XHJcbiAgICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcclxuICAgICAgICAgIHJhZGl1czogcmFkaXVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbGU6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICB9LFxyXG4gICAgICB0dXJidWxlbmNlOiBmdW5jdGlvbihiYXNlRnJlcXVlbmN5LG51bU9jdGF2ZXMsc2VlZCxzdGl0Y2hUaWxlcyx0eXBlKXtcclxuICAgICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgICAgbnVtT2N0YXZlczogbnVtT2N0YXZlcyxcclxuICAgICAgICAgIHNlZWQ6IHNlZWQsXHJcbiAgICAgICAgICBzdGl0Y2hUaWxlczogc3RpdGNoVGlsZXMsXHJcbiAgICAgICAgICBiYXNlRnJlcXVlbmN5OiBiYXNlRnJlcXVlbmN5LFxyXG4gICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbGwgcGFyZW50IGVmZmVjdHNcclxuICAgIHZhciBwYXJlbnRFZmZlY3RzID0ge1xyXG4gICAgICBtZXJnZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgY2hpbGRyZW47XHJcblxyXG4gICAgICAgIC8vdGVzdCB0byBzZWUgaWYgd2UgaGF2ZSBhIHNldFxyXG4gICAgICAgIGlmKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFNWRy5TZXQpe1xyXG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmVhY2goZnVuY3Rpb24oaSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuTWVyZ2VOb2RlKVxyXG4gICAgICAgICAgICAgIHRoYXQucHV0KHRoaXMpO1xyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuRWZmZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50RWZmZWN0KVxyXG4gICAgICAgICAgICAgIHRoYXQucHV0KG5ldyBTVkcuTWVyZ2VOb2RlKHRoaXMpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5IHVzZSBpdFxyXG4gICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKVxyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgaWYoY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTVkcuTWVyZ2VOb2RlKXtcclxuICAgICAgICAgICAgICB0aGlzLnB1dChjaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB0aGlzLnB1dChuZXcgU1ZHLk1lcmdlTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY29tcG9uZW50VHJhbnNmZXI6IGZ1bmN0aW9uKGNvbXBvbnRlbnRzKXtcclxuICAgICAgICAvKiBjcmVhdGUgcmdiIHNldCAqL1xyXG4gICAgICAgIHRoaXMucmdiID0gbmV3IFNWRy5TZXRcclxuXHJcbiAgICAgICAgLyogY3JlYXRlIGNvbXBvbmVudHMgKi9cclxuICAgICAgICA7KFsncicsICdnJywgJ2InLCAnYSddKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgIC8qIGNyZWF0ZSBjb21wb25lbnQgKi9cclxuICAgICAgICAgIHRoaXNbY10gPSBuZXcgU1ZHWydGdW5jJyArIGMudG9VcHBlckNhc2UoKV0oJ2lkZW50aXR5Jyk7XHJcblxyXG4gICAgICAgICAgLyogc3RvcmUgY29tcG9uZW50IGluIHNldCAqL1xyXG4gICAgICAgICAgdGhpcy5yZ2IuYWRkKHRoaXNbY10pO1xyXG5cclxuICAgICAgICAgIC8qIGFkZCBjb21wb25lbnQgbm9kZSAqL1xyXG4gICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXNbY10ubm9kZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTsgLy9sb3N0IGNvbnRleHQgaW4gZm9yZWFjaFxyXG5cclxuICAgICAgICAvKiBzZXQgY29tcG9uZW50cyAqL1xyXG4gICAgICAgIGlmIChjb21wb250ZW50cykge1xyXG4gICAgICAgICAgaWYgKGNvbXBvbnRlbnRzLnJnYikge1xyXG4gIChbJ3InLCAnZycsICdiJ10pLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG4gICAgICAgICAgICAgIHRoaXNbY10uYXR0cihjb21wb250ZW50cy5yZ2IpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgICAgZGVsZXRlIGNvbXBvbnRlbnRzLnJnYjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvKiBzZXQgaW5kaXZpZHVhbCBjb21wb25lbnRzICovXHJcbiAgICAgICAgICBmb3IgKHZhciBjIGluIGNvbXBvbnRlbnRzKVxyXG4gICAgICAgICAgICB0aGlzW2NdLmF0dHIoY29tcG9udGVudHNbY10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgICBzdXJmYWNlU2NhbGU6IHN1cmZhY2VTY2FsZSxcclxuICAgICAgICAgIGRpZmZ1c2VDb25zdGFudDogZGlmZnVzZUNvbnN0YW50LFxyXG4gICAgICAgICAga2VybmVsVW5pdExlbmd0aDoga2VybmVsVW5pdExlbmd0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBzcGVjdWxhckxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICAgIHN1cmZhY2VTY2FsZTogc3VyZmFjZVNjYWxlLFxyXG4gICAgICAgICAgZGlmZnVzZUNvbnN0YW50OiBkaWZmdXNlQ29uc3RhbnQsXHJcbiAgICAgICAgICBzcGVjdWxhckV4cG9uZW50OiBzcGVjdWxhckV4cG9uZW50LFxyXG4gICAgICAgICAga2VybmVsVW5pdExlbmd0aDoga2VybmVsVW5pdExlbmd0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDcmVhdGUgY2hpbGQgZWZmZWN0cyBsaWtlIFBvaW50TGlnaHQgYW5kIE1lcmdlTm9kZVxyXG4gICAgdmFyIGNoaWxkRWZmZWN0cyA9IHtcclxuICAgICAgZGlzdGFudExpZ2h0OiBmdW5jdGlvbihhemltdXRoLCBlbGV2YXRpb24pe1xyXG4gICAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgICBhemltdXRoOiBhemltdXRoLFxyXG4gICAgICAgICAgZWxldmF0aW9uOiBlbGV2YXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgcG9pbnRMaWdodDogZnVuY3Rpb24oeCx5LHope1xyXG4gICAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgeTogeSxcclxuICAgICAgICAgIHo6IHpcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgc3BvdExpZ2h0OiBmdW5jdGlvbih4LHkseixwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0Wil7XHJcbiAgICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgejogeixcclxuICAgICAgICAgIHBvaW50c0F0WDogcG9pbnRzQXRYLFxyXG4gICAgICAgICAgcG9pbnRzQXRZOiBwb2ludHNBdFksXHJcbiAgICAgICAgICBwb2ludHNBdFo6IHBvaW50c0F0WlxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBtZXJnZU5vZGU6IGZ1bmN0aW9uKGluMSl7XHJcbiAgICAgICAgdGhpcy5hdHRyKCdpbicsaW4xKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBjb21wb250ZW50IGZ1bmN0aW9uc1xyXG4gICAgOyhbJ3InLCAnZycsICdiJywgJ2EnXSkuZm9yRWFjaChmdW5jdGlvbihjKSB7XHJcbiAgICAgIC8qIGNyZWF0ZSBjbGFzcyAqL1xyXG4gICAgICBjaGlsZEVmZmVjdHNbJ0Z1bmMnICsgYy50b1VwcGVyQ2FzZSgpXSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICB0aGlzLmF0dHIoJ3R5cGUnLHR5cGUpO1xyXG5cclxuICAgICAgICAvLyB0YWtlIGRpZmZlbnQgYXJndW1lbnRzIGJhc2VkIG9uIHRoZSB0eXBlXHJcbiAgICAgICAgc3dpdGNoKHR5cGUpe1xyXG4gICAgICAgICAgY2FzZSAndGFibGUnOlxyXG4gICAgICAgICAgICB0aGlzLmF0dHIoJ3RhYmxlVmFsdWVzJyxhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnbGluZWFyJzpcclxuICAgICAgICAgICAgdGhpcy5hdHRyKCdzbG9wZScsYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKCdpbnRlcmNlcHQnLGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICdnYW1tYSc6XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cignYW1wbGl0dWRlJyxhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoJ2V4cG9uZW50Jyxhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoJ29mZnNldCcsYXJndW1lbnRzWzJdKTtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL2NyZWF0ZSBlZmZlY3RzXHJcbiAgICBmb3JlYWNoKGVmZmVjdHMsZnVuY3Rpb24oZWZmZWN0LGkpe1xyXG5cclxuICAgICAgLyogY2FwaXRhbGl6ZSBuYW1lICovXHJcbiAgICAgIHZhciBuYW1lID0gaS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGkuc2xpY2UoMSk7XHJcbiAgICAgIHZhciBwcm90byA9IHt9O1xyXG5cclxuICAgICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICAgIFNWR1tuYW1lICsgJ0VmZmVjdCddID0gU1ZHLmludmVudCh7XHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIC8vY2FsbCBzdXBlclxyXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ2ZlJyArIG5hbWUpKTtcclxuXHJcbiAgICAgICAgICAvL2NhbGwgY29uc3RydWN0b3IgZm9yIHRoaXMgZWZmZWN0XHJcbiAgICAgICAgICBlZmZlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgIC8vc2V0IHRoZSByZXN1bHRcclxuICAgICAgICAgIHRoaXMucmVzdWx0KHRoaXMuYXR0cignaWQnKSArICdPdXQnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaGVyaXQ6IFNWRy5FZmZlY3QsXHJcbiAgICAgICAgZXh0ZW5kOiBwcm90b1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vY3JlYXRlIHBhcmVudCBlZmZlY3RzXHJcbiAgICBmb3JlYWNoKHBhcmVudEVmZmVjdHMsZnVuY3Rpb24oZWZmZWN0LGkpe1xyXG5cclxuICAgICAgLyogY2FwaXRhbGl6ZSBuYW1lICovXHJcbiAgICAgIHZhciBuYW1lID0gaS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGkuc2xpY2UoMSk7XHJcbiAgICAgIHZhciBwcm90byA9IHt9O1xyXG5cclxuICAgICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICAgIFNWR1tuYW1lICsgJ0VmZmVjdCddID0gU1ZHLmludmVudCh7XHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIC8vY2FsbCBzdXBlclxyXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ2ZlJyArIG5hbWUpKTtcclxuXHJcbiAgICAgICAgICAvL2NhbGwgY29uc3RydWN0b3IgZm9yIHRoaXMgZWZmZWN0XHJcbiAgICAgICAgICBlZmZlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgIC8vc2V0IHRoZSByZXN1bHRcclxuICAgICAgICAgIHRoaXMucmVzdWx0KHRoaXMuYXR0cignaWQnKSArICdPdXQnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaGVyaXQ6IFNWRy5QYXJlbnRFZmZlY3QsXHJcbiAgICAgICAgZXh0ZW5kOiBwcm90b1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vY3JlYXRlIGNoaWxkIGVmZmVjdHNcclxuICAgIGZvcmVhY2goY2hpbGRFZmZlY3RzLGZ1bmN0aW9uKGVmZmVjdCxpKXtcclxuXHJcbiAgICAgIC8qIGNhcGl0YWxpemUgbmFtZSAqL1xyXG4gICAgICB2YXIgbmFtZSA9IGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpO1xyXG4gICAgICB2YXIgcHJvdG8gPSB7fTtcclxuXHJcbiAgICAgIC8qIGNyZWF0ZSBjbGFzcyAqL1xyXG4gICAgICBTVkdbbmFtZV0gPSBTVkcuaW52ZW50KHtcclxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgLy9jYWxsIHN1cGVyXHJcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnZmUnICsgbmFtZSkpO1xyXG5cclxuICAgICAgICAgIC8vY2FsbCBjb25zdHJ1Y3RvciBmb3IgdGhpcyBlZmZlY3RcclxuICAgICAgICAgIGVmZmVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmhlcml0OiBTVkcuQ2hpbGRFZmZlY3QsXHJcbiAgICAgICAgZXh0ZW5kOiBwcm90b1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVmZmVjdC1zcGVjaWZpYyBleHRlbnNpb25zXHJcbiAgICBTVkcuZXh0ZW5kKFNWRy5NZXJnZUVmZmVjdCx7XHJcbiAgICAgIGluOiBmdW5jdGlvbihlZmZlY3Qpe1xyXG4gICAgICAgIGlmKGVmZmVjdCBpbnN0YW5jZW9mIFNWRy5NZXJnZU5vZGUpXHJcbiAgICAgICAgICB0aGlzLmFkZChlZmZlY3QsMCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5hZGQobmV3IFNWRy5NZXJnZU5vZGUoZWZmZWN0KSwwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBTVkcuZXh0ZW5kKFNWRy5Db21wb3NpdGVFZmZlY3QsU1ZHLkJsZW5kRWZmZWN0LFNWRy5EaXNwbGFjZW1lbnRNYXBFZmZlY3Qse1xyXG4gICAgICBpbjI6IGZ1bmN0aW9uKGVmZmVjdCl7XHJcbiAgICAgICAgICByZXR1cm4gZWZmZWN0ID09IG51bGw/IHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5zZWxlY3QoJ1tyZXN1bHQ9XCInK3RoaXMuYXR0cignaW4yJykrJ1wiXScpLmdldCgwKSB8fCB0aGlzLmF0dHIoJ2luMicpIDogdGhpcy5hdHRyKCdpbjInLCBlZmZlY3QpXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFByZXNldHNcclxuICAgIFNWRy5maWx0ZXIgPSB7XHJcbiAgICAgIHNlcGlhdG9uZTogIFsgLjM0MywgLjY2OSwgLjExOSwgMCwgMFxyXG4gICAgICAgICAgICAgICAgICAsIC4yNDksIC42MjYsIC4xMzAsIDAsIDBcclxuICAgICAgICAgICAgICAgICAgLCAuMTcyLCAuMzM0LCAuMTExLCAwLCAwXHJcbiAgICAgICAgICAgICAgICAgICwgLjAwMCwgLjAwMCwgLjAwMCwgMSwgMCBdXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEhlbHBlcnNcclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZU1hdHJpeChtYXRyaXgpIHtcclxuICAgICAgLyogY29udmVydCBwb3NzaWJsZSBhcnJheSB2YWx1ZSB0byBzdHJpbmcgKi9cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSlcclxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLkFycmF5KG1hdHJpeCk7XHJcblxyXG4gICAgICAvKiBlbnN1cmUgdGhlcmUgYXJlIG5vIGxlYWRpbmcsIHRhaWxpbmcgb3IgZG91YmxlIHNwYWNlcyAqL1xyXG4gICAgICByZXR1cm4gbWF0cml4LnRvU3RyaW5nKCkucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlzdFN0cmluZyhsaXN0KSB7XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcclxuICAgICAgICByZXR1cm4gbGlzdFxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aCwgcyA9IFtdOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIHMucHVzaChsaXN0W2ldKTtcclxuXHJcbiAgICAgIHJldHVybiBzLmpvaW4oJyAnKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZvcmVhY2goKXsgLy9sb29wcyB0aHJvdWdoIG11dGlwbGUgb2JqZWN0c1xyXG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbigpe307XHJcbiAgICAgIGlmKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSA9PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdO1xyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsYXJndW1lbnRzLmxlbmd0aC0xLDEpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvcih2YXIgayBpbiBhcmd1bWVudHMpe1xyXG4gICAgICAgIGZvcih2YXIgaSBpbiBhcmd1bWVudHNba10pe1xyXG4gICAgICAgICAgZm4oYXJndW1lbnRzW2tdW2ldLGksYXJndW1lbnRzW2tdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSkuY2FsbCh1bmRlZmluZWQpO1xuXG4gIChmdW5jdGlvbigpIHtcclxuXHJcbiAgU1ZHLmV4dGVuZChTVkcuUGF0aEFycmF5LCB7XHJcbiAgICBtb3JwaDogZnVuY3Rpb24oYXJyYXkpIHtcclxuXHJcbiAgICAgIHZhciBzdGFydEFyciA9IHRoaXMudmFsdWVcclxuICAgICAgICAsICBkZXN0QXJyID0gdGhpcy5wYXJzZShhcnJheSk7XHJcblxyXG4gICAgICB2YXIgc3RhcnRPZmZzZXRNID0gMFxyXG4gICAgICAgICwgIGRlc3RPZmZzZXRNID0gMDtcclxuXHJcbiAgICAgIHZhciBzdGFydE9mZnNldE5leHRNID0gZmFsc2VcclxuICAgICAgICAsICBkZXN0T2Zmc2V0TmV4dE0gPSBmYWxzZTtcclxuXHJcbiAgICAgIHdoaWxlKHRydWUpe1xyXG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgaXMgbm8gTSBhbnltb3JlXHJcbiAgICAgICAgaWYoc3RhcnRPZmZzZXRNID09PSBmYWxzZSAmJiBkZXN0T2Zmc2V0TSA9PT0gZmFsc2UpIGJyZWFrXHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIG5leHQgTSBpbiBwYXRoIGFycmF5XHJcbiAgICAgICAgc3RhcnRPZmZzZXROZXh0TSA9IGZpbmROZXh0TShzdGFydEFyciwgc3RhcnRPZmZzZXRNID09PSBmYWxzZSA/IGZhbHNlIDogc3RhcnRPZmZzZXRNKzEpO1xyXG4gICAgICAgICBkZXN0T2Zmc2V0TmV4dE0gPSBmaW5kTmV4dE0oIGRlc3RBcnIsICBkZXN0T2Zmc2V0TSA9PT0gZmFsc2UgPyBmYWxzZSA6ICBkZXN0T2Zmc2V0TSsxKTtcclxuXHJcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBhZGQgb25lIE0gdG8gdGhlIHN0YXJ0QXJyYXlcclxuICAgICAgICBpZihzdGFydE9mZnNldE0gPT09IGZhbHNlKXtcclxuICAgICAgICAgIHZhciBiYm94ID0gbmV3IFNWRy5QYXRoQXJyYXkocmVzdWx0LnN0YXJ0KS5iYm94KCk7XHJcblxyXG4gICAgICAgICAgLy8gd2hlbiB0aGUgbGFzdCBibG9jayBoYWQgbm8gYm91bmRpbmcgYm94IHdlIHNpbXBseSB0YWtlIHRoZSBmaXJzdCBNIHdlIGdvdFxyXG4gICAgICAgICAgaWYoYmJveC5oZWlnaHQgPT0gMCB8fCBiYm94LndpZHRoID09IDApe1xyXG4gICAgICAgICAgICBzdGFydE9mZnNldE0gPSAgc3RhcnRBcnIucHVzaChzdGFydEFyclswXSkgLSAxO1xyXG4gICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3ZSB0YWtlIHRoZSBtaWRkbGUgb2YgdGhlIGJib3ggaW5zdGVhZCB3aGVuIHdlIGdvdCBvbmVcclxuICAgICAgICAgICAgc3RhcnRPZmZzZXRNID0gc3RhcnRBcnIucHVzaCggWydNJywgYmJveC54ICsgYmJveC53aWR0aC8yLCBiYm94LnkgKyBiYm94LmhlaWdodC8yIF0gKSAtIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBoYXZlIHRvIGFkZCBvbmUgTSB0byB0aGUgZGVzdEFycmF5XHJcbiAgICAgICAgaWYoIGRlc3RPZmZzZXRNID09PSBmYWxzZSl7XHJcbiAgICAgICAgICB2YXIgYmJveCA9IG5ldyBTVkcuUGF0aEFycmF5KHJlc3VsdC5kZXN0KS5iYm94KCk7XHJcblxyXG4gICAgICAgICAgaWYoYmJveC5oZWlnaHQgPT0gMCB8fCBiYm94LndpZHRoID09IDApe1xyXG4gICAgICAgICAgICBkZXN0T2Zmc2V0TSA9ICBkZXN0QXJyLnB1c2goZGVzdEFyclswXSkgLSAxO1xyXG4gICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICBkZXN0T2Zmc2V0TSA9ICBkZXN0QXJyLnB1c2goIFsnTScsIGJib3gueCArIGJib3gud2lkdGgvMiwgYmJveC55ICsgYmJveC5oZWlnaHQvMiBdICkgLSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIGJsb2NrIGZyb20gTSB0byBuZXh0IE1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlQmxvY2soc3RhcnRBcnIsIHN0YXJ0T2Zmc2V0TSwgc3RhcnRPZmZzZXROZXh0TSwgZGVzdEFyciwgZGVzdE9mZnNldE0sIGRlc3RPZmZzZXROZXh0TSk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYXJyYXlzIHRvIHRoZWlyIG5ldyB2YWx1ZXNcclxuICAgICAgICBzdGFydEFyciA9IHN0YXJ0QXJyLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0TSkuY29uY2F0KHJlc3VsdC5zdGFydCwgc3RhcnRPZmZzZXROZXh0TSA9PT0gZmFsc2UgPyBbXSA6IHN0YXJ0QXJyLnNsaWNlKHN0YXJ0T2Zmc2V0TmV4dE0pKTtcclxuICAgICAgICAgZGVzdEFyciA9ICBkZXN0QXJyLnNsaWNlKDAsICBkZXN0T2Zmc2V0TSkuY29uY2F0KHJlc3VsdC5kZXN0ICwgIGRlc3RPZmZzZXROZXh0TSA9PT0gZmFsc2UgPyBbXSA6ICBkZXN0QXJyLnNsaWNlKCBkZXN0T2Zmc2V0TmV4dE0pKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIG9mZnNldHNcclxuICAgICAgICBzdGFydE9mZnNldE0gPSBzdGFydE9mZnNldE5leHRNID09PSBmYWxzZSA/IGZhbHNlIDogc3RhcnRPZmZzZXRNICsgcmVzdWx0LnN0YXJ0Lmxlbmd0aDtcclxuICAgICAgICAgZGVzdE9mZnNldE0gPSAgZGVzdE9mZnNldE5leHRNID09PSBmYWxzZSA/IGZhbHNlIDogIGRlc3RPZmZzZXRNICsgcmVzdWx0LmRlc3QubGVuZ3RoO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29weSBiYWNrIGFycmF5c1xyXG4gICAgICB0aGlzLnZhbHVlID0gc3RhcnRBcnI7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLlBhdGhBcnJheSgpO1xyXG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLnZhbHVlID0gZGVzdEFycjtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG5cclxuXHJcbiAgLy8gc29ycnkgZm9yIHRoZSBsb25nIGRlY2xhcmF0aW9uXHJcbiAgLy8gc2xpY2VzIG91dCBvbmUgYmxvY2sgKGZyb20gTSB0byBNKSBhbmQgc3luY3Jvbml6ZSBpdCBzbyB0aGUgdHlwZXMgYW5kIGxlbmd0aCBtYXRjaFxyXG4gIGZ1bmN0aW9uIGhhbmRsZUJsb2NrKHN0YXJ0QXJyLCBzdGFydE9mZnNldE0sIHN0YXJ0T2Zmc2V0TmV4dE0sIGRlc3RBcnIsIGRlc3RPZmZzZXRNLCBkZXN0T2Zmc2V0TmV4dE0sIHVuZGVmaW5lZCQxKXtcclxuXHJcbiAgICAvLyBzbGljZSBvdXQgdGhlIGJsb2NrIHdlIG5lZWRcclxuICAgIHZhciBzdGFydEFyclRlbXAgPSBzdGFydEFyci5zbGljZShzdGFydE9mZnNldE0sIHN0YXJ0T2Zmc2V0TmV4dE0gfHwgdW5kZWZpbmVkJDEpXHJcbiAgICAgICwgIGRlc3RBcnJUZW1wID0gIGRlc3RBcnIuc2xpY2UoIGRlc3RPZmZzZXRNLCAgZGVzdE9mZnNldE5leHRNIHx8IHVuZGVmaW5lZCQxKTtcclxuXHJcbiAgICB2YXIgaSA9IDBcclxuICAgICAgLCBwb3NTdGFydCA9IHtwb3M6WzAsMF0sIHN0YXJ0OlswLDBdfVxyXG4gICAgICAsIHBvc0Rlc3QgID0ge3BvczpbMCwwXSwgc3RhcnQ6WzAsMF19O1xyXG5cclxuICAgIGRve1xyXG5cclxuICAgICAgLy8gY29udmVydCBzaG9ydGhhbmQgdHlwZXMgdG8gbG9uZyBmb3JtXHJcbiAgICAgIHN0YXJ0QXJyVGVtcFtpXSA9IHNpbXBseWZ5LmNhbGwocG9zU3RhcnQsIHN0YXJ0QXJyVGVtcFtpXSk7XHJcbiAgICAgICBkZXN0QXJyVGVtcFtpXSA9IHNpbXBseWZ5LmNhbGwocG9zRGVzdCAsICBkZXN0QXJyVGVtcFtpXSk7XHJcblxyXG4gICAgICAvLyBjaGVjayBpZiBib3RoIHNoYXBlIHR5cGVzIG1hdGNoXHJcbiAgICAgIC8vIDIgZWxsaXB0aWNhbCBhcmMgY3VydmUgY29tbWFuZHMgKCdBJyksIGFyZSBjb25zaWRlcmVkIGRpZmZlcmVudCBpZiB0aGVcclxuICAgICAgLy8gZmxhZ3MgKGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnKSBkb24ndCBtYXRjaFxyXG4gICAgICBpZihzdGFydEFyclRlbXBbaV1bMF0gIT0gZGVzdEFyclRlbXBbaV1bMF0gfHwgc3RhcnRBcnJUZW1wW2ldWzBdID09ICdNJyB8fFxyXG4gICAgICAgICAgKHN0YXJ0QXJyVGVtcFtpXVswXSA9PSAnQScgJiZcclxuICAgICAgICAgICAgKHN0YXJ0QXJyVGVtcFtpXVs0XSAhPSBkZXN0QXJyVGVtcFtpXVs0XSB8fCBzdGFydEFyclRlbXBbaV1bNV0gIT0gZGVzdEFyclRlbXBbaV1bNV0pXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKSB7XHJcblxyXG4gICAgICAgIC8vIGlmIG5vdCwgY29udmVydCBzaGFwZXMgdG8gYmV6aWVyZVxyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoc3RhcnRBcnJUZW1wLCBbaSwgMV0uY29uY2F0KHRvQmV6aWVyZS5jYWxsKHBvc1N0YXJ0LCBzdGFydEFyclRlbXBbaV0pKSk7XHJcbiAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoZGVzdEFyclRlbXAsIFtpLCAxXS5jb25jYXQodG9CZXppZXJlLmNhbGwocG9zRGVzdCwgZGVzdEFyclRlbXBbaV0pKSk7XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBvbmx5IHVwZGF0ZSBwb3NpdGlvbnMgb3RoZXJ3aXNlXHJcbiAgICAgICAgc3RhcnRBcnJUZW1wW2ldID0gc2V0UG9zQW5kUmVmbGVjdGlvbi5jYWxsKHBvc1N0YXJ0LCBzdGFydEFyclRlbXBbaV0pO1xyXG4gICAgICAgICBkZXN0QXJyVGVtcFtpXSA9IHNldFBvc0FuZFJlZmxlY3Rpb24uY2FsbChwb3NEZXN0ICwgIGRlc3RBcnJUZW1wW2ldKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdlIGFyZSBhdCB0aGUgZW5kIGF0IGJvdGggYXJyYXlzLiBzdG9wIGhlcmVcclxuICAgICAgaWYoKytpID09IHN0YXJ0QXJyVGVtcC5sZW5ndGggJiYgaSA9PSBkZXN0QXJyVGVtcC5sZW5ndGgpIGJyZWFrXHJcblxyXG4gICAgICAvLyBkZXN0QXJyYXkgaXMgbG9uZ2VyLiBBZGQgb25lIGVsZW1lbnRcclxuICAgICAgaWYoaSA9PSBzdGFydEFyclRlbXAubGVuZ3RoKXtcclxuICAgICAgICBzdGFydEFyclRlbXAucHVzaChbXHJcbiAgICAgICAgICAnQycsXHJcbiAgICAgICAgICBwb3NTdGFydC5wb3NbMF0sXHJcbiAgICAgICAgICBwb3NTdGFydC5wb3NbMV0sXHJcbiAgICAgICAgICBwb3NTdGFydC5wb3NbMF0sXHJcbiAgICAgICAgICBwb3NTdGFydC5wb3NbMV0sXHJcbiAgICAgICAgICBwb3NTdGFydC5wb3NbMF0sXHJcbiAgICAgICAgICBwb3NTdGFydC5wb3NbMV0sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHN0YXJ0QXJyIGlzIGxvbmdlci4gQWRkIG9uZSBlbGVtZW50XHJcbiAgICAgIGlmKGkgPT0gZGVzdEFyclRlbXAubGVuZ3RoKXtcclxuICAgICAgICBkZXN0QXJyVGVtcC5wdXNoKFtcclxuICAgICAgICAgICdDJyxcclxuICAgICAgICAgIHBvc0Rlc3QucG9zWzBdLFxyXG4gICAgICAgICAgcG9zRGVzdC5wb3NbMV0sXHJcbiAgICAgICAgICBwb3NEZXN0LnBvc1swXSxcclxuICAgICAgICAgIHBvc0Rlc3QucG9zWzFdLFxyXG4gICAgICAgICAgcG9zRGVzdC5wb3NbMF0sXHJcbiAgICAgICAgICBwb3NEZXN0LnBvc1sxXVxyXG4gICAgICAgIF0pO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgIH13aGlsZSh0cnVlKVxyXG5cclxuICAgIC8vIHJldHVybiB0aGUgdXBkYXRlZCBibG9ja1xyXG4gICAgcmV0dXJuIHtzdGFydDpzdGFydEFyclRlbXAsIGRlc3Q6ZGVzdEFyclRlbXB9XHJcbiAgfVxyXG5cclxuICAvLyBjb252ZXJ0cyBzaG9ydGhhbmQgdHlwZXMgdG8gbG9uZyBmb3JtXHJcbiAgZnVuY3Rpb24gc2ltcGx5ZnkodmFsKXtcclxuXHJcbiAgICBzd2l0Y2godmFsWzBdKXtcclxuICAgICAgY2FzZSAneic6IC8vIHNob3J0aGFuZCBsaW5lIHRvIHN0YXJ0XHJcbiAgICAgIGNhc2UgJ1onOlxyXG4gICAgICAgIHZhbFswXSA9ICdMJztcclxuICAgICAgICB2YWxbMV0gPSB0aGlzLnN0YXJ0WzBdO1xyXG4gICAgICAgIHZhbFsyXSA9IHRoaXMuc3RhcnRbMV07XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnSCc6IC8vIHNob3J0aGFuZCBob3Jpem9udGFsIGxpbmVcclxuICAgICAgICB2YWxbMF0gPSAnTCc7XHJcbiAgICAgICAgdmFsWzJdID0gdGhpcy5wb3NbMV07XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnVic6IC8vIHNob3J0aGFuZCB2ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgdmFsWzBdID0gJ0wnO1xyXG4gICAgICAgIHZhbFsyXSA9IHZhbFsxXTtcclxuICAgICAgICB2YWxbMV0gPSB0aGlzLnBvc1swXTtcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdUJzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpYyBiZXppZXJlXHJcbiAgICAgICAgdmFsWzBdID0gJ1EnO1xyXG4gICAgICAgIHZhbFszXSA9IHZhbFsxXTtcclxuICAgICAgICB2YWxbNF0gPSB2YWxbMl07XHJcbiAgICAgICAgdmFsWzFdID0gdGhpcy5yZWZsZWN0aW9uWzFdO1xyXG4gICAgICAgIHZhbFsyXSA9IHRoaXMucmVmbGVjdGlvblswXTtcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllcmVcclxuICAgICAgICB2YWxbMF0gPSAnQyc7XHJcbiAgICAgICAgdmFsWzZdID0gdmFsWzRdO1xyXG4gICAgICAgIHZhbFs1XSA9IHZhbFszXTtcclxuICAgICAgICB2YWxbNF0gPSB2YWxbMl07XHJcbiAgICAgICAgdmFsWzNdID0gdmFsWzFdO1xyXG4gICAgICAgIHZhbFsyXSA9IHRoaXMucmVmbGVjdGlvblsxXTtcclxuICAgICAgICB2YWxbMV0gPSB0aGlzLnJlZmxlY3Rpb25bMF07XHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsXHJcblxyXG4gIH1cclxuXHJcbiAgLy8gdXBkYXRlcyByZWZsZWN0aW9uIHBvaW50IGFuZCBjdXJyZW50IHBvc2l0aW9uXHJcbiAgZnVuY3Rpb24gc2V0UG9zQW5kUmVmbGVjdGlvbih2YWwpe1xyXG5cclxuICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xyXG5cclxuICAgIHRoaXMucG9zID0gWyB2YWxbbGVuLTJdLCB2YWxbbGVuLTFdIF07XHJcblxyXG4gICAgaWYoJ1NDUVQnLmluZGV4T2YodmFsWzBdKSAhPSAtMSlcclxuICAgICAgdGhpcy5yZWZsZWN0aW9uID0gWyAyICogdGhpcy5wb3NbMF0gLSB2YWxbbGVuLTRdLCAyICogdGhpcy5wb3NbMV0gLSB2YWxbbGVuLTNdIF07XHJcblxyXG4gICAgcmV0dXJuIHZhbFxyXG4gIH1cclxuXHJcbiAgLy8gY29udmVydHMgYWxsIHR5cGVzIHRvIGN1YmljIGJlemllcmVcclxuICBmdW5jdGlvbiB0b0JlemllcmUodmFsKXtcclxuICAgIHZhciByZXRWYWwgPSBbdmFsXTtcclxuXHJcbiAgICBzd2l0Y2godmFsWzBdKXtcclxuICAgICAgY2FzZSAnTSc6IC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIE1cclxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSBbdmFsWzFdLCB2YWxbMl1dO1xyXG4gICAgICAgIHJldHVybiByZXRWYWxcclxuICAgICAgY2FzZSAnTCc6XHJcbiAgICAgICAgdmFsWzVdID0gdmFsWzNdID0gdmFsWzFdO1xyXG4gICAgICAgIHZhbFs2XSA9IHZhbFs0XSA9IHZhbFsyXTtcclxuICAgICAgICB2YWxbMV0gPSB0aGlzLnBvc1swXTtcclxuICAgICAgICB2YWxbMl0gPSB0aGlzLnBvc1sxXTtcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdRJzpcclxuICAgICAgICB2YWxbNl0gPSB2YWxbNF07XHJcbiAgICAgICAgdmFsWzVdID0gdmFsWzNdO1xyXG4gICAgICAgIHZhbFs0XSA9IHZhbFs0XSAqIDEvMyArIHZhbFsyXSAqIDIvMztcclxuICAgICAgICB2YWxbM10gPSB2YWxbM10gKiAxLzMgKyB2YWxbMV0gKiAyLzM7XHJcbiAgICAgICAgdmFsWzJdID0gdGhpcy5wb3NbMV0gKiAxLzMgKyB2YWxbMl0gKiAyLzM7XHJcbiAgICAgICAgdmFsWzFdID0gdGhpcy5wb3NbMF0gKiAxLzMgKyB2YWxbMV0gKiAyLzM7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnQSc6XHJcbiAgICAgICAgcmV0VmFsID0gYXJjVG9CZXppZXJlKHRoaXMucG9zLCB2YWwpO1xyXG4gICAgICAgIHZhbCA9IHJldFZhbFswXTtcclxuICAgICAgICBicmVha1xyXG4gICAgfVxyXG5cclxuICAgIHZhbFswXSA9ICdDJztcclxuICAgIHRoaXMucG9zID0gW3ZhbFs1XSwgdmFsWzZdXTtcclxuICAgIHRoaXMucmVmbGVjdGlvbiA9IFsyICogdmFsWzVdIC0gdmFsWzNdLCAyICogdmFsWzZdIC0gdmFsWzRdXTtcclxuXHJcbiAgICByZXR1cm4gcmV0VmFsXHJcblxyXG4gIH1cclxuXHJcbiAgLy8gZmluZHMgdGhlIG5leHQgcG9zaXRpb24gb2YgdHlwZSBNXHJcbiAgZnVuY3Rpb24gZmluZE5leHRNKGFyciwgb2Zmc2V0KXtcclxuXHJcbiAgICBpZihvZmZzZXQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICBmb3IodmFyIGkgPSBvZmZzZXQsIGxlbiA9IGFyci5sZW5ndGg7aSA8IGxlbjsrK2kpe1xyXG5cclxuICAgICAgaWYoYXJyW2ldWzBdID09ICdNJykgcmV0dXJuIGlcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIC8vIENvbnZlcnQgYW4gYXJjIHNlZ21lbnQgaW50byBlcXVpdmFsZW50IGN1YmljIEJlemllciBjdXJ2ZXNcclxuICAvLyBEZXBlbmRpbmcgb24gdGhlIGFyYywgdXAgdG8gNCBjdXJ2ZXMgbWlnaHQgYmUgdXNlZCB0byByZXByZXNlbnQgaXQgc2luY2UgYVxyXG4gIC8vIGN1cnZlIGdpdmVzIGEgZ29vZCBhcHByb3hpbWF0aW9uIGZvciBvbmx5IGEgcXVhcnRlciBvZiBhbiBlbGxpcHNlXHJcbiAgLy8gVGhlIGN1cnZlcyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkgb2YgU1ZHIGN1cnZlIGNvbW1hbmRzOlxyXG4gIC8vIFsgWydDJywgeDEsIHkxLCB4MiwgeTIsIHgsIHldIC4uLiBdXHJcbiAgZnVuY3Rpb24gYXJjVG9CZXppZXJlKHBvcywgdmFsKSB7XHJcbiAgICAgIC8vIFBhcmFtZXRlcnMgZXh0cmFjdGlvbiwgaGFuZGxlIG91dC1vZi1yYW5nZSBwYXJhbWV0ZXJzIGFzIHNwZWNpZmllZCBpbiB0aGUgU1ZHIHNwZWNcclxuICAgICAgLy8gU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNPdXRPZlJhbmdlUGFyYW1ldGVyc1xyXG4gICAgICB2YXIgcnggPSBNYXRoLmFicyh2YWxbMV0pLCByeSA9IE1hdGguYWJzKHZhbFsyXSksIHhBeGlzUm90YXRpb24gPSB2YWxbM10gJSAzNjBcclxuICAgICAgICAsIGxhcmdlQXJjRmxhZyA9IHZhbFs0XSwgc3dlZXBGbGFnID0gdmFsWzVdLCB4ID0gdmFsWzZdLCB5ID0gdmFsWzddXHJcbiAgICAgICAgLCBBID0gbmV3IFNWRy5Qb2ludChwb3MpLCBCID0gbmV3IFNWRy5Qb2ludCh4LCB5KVxyXG4gICAgICAgICwgcHJpbWVkQ29vcmQsIGxhbWJkYSwgbWF0LCBrLCBjLCBjU3F1YXJlLCB0LCBPLCBPQSwgT0IsIHRldGFTdGFydCwgdGV0YUVuZFxyXG4gICAgICAgICwgZGVsdGFUZXRhLCBuYlNlY3RvcnMsIGYsIGFyY1NlZ1BvaW50cywgYW5nbGUsIHNpbkFuZ2xlLCBjb3NBbmdsZSwgcHQsIGksIGlsXHJcbiAgICAgICAgLCByZXRWYWwgPSBbXSwgeDEsIHkxLCB4MiwgeTI7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgcmFkaWkgYXJlIG5vbi16ZXJvXHJcbiAgICAgIGlmKHJ4ID09PSAwIHx8IHJ5ID09PSAwIHx8IChBLnggPT09IEIueCAmJiBBLnkgPT09IEIueSkpIHtcclxuICAgICAgICAvLyB0cmVhdCB0aGlzIGFyYyBhcyBhIHN0cmFpZ2h0IGxpbmUgc2VnbWVudFxyXG4gICAgICAgIHJldHVybiBbWydDJywgQS54LCBBLnksIEIueCwgQi55LCBCLngsIEIueV1dXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVuc3VyZSByYWRpaSBhcmUgbGFyZ2UgZW5vdWdoIHVzaW5nIHRoZSBhbGdvcml0aG0gcHJvdmlkZWQgaW4gdGhlIFNWRyBzcGVjXHJcbiAgICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjQ29ycmVjdGlvbk91dE9mUmFuZ2VSYWRpaVxyXG4gICAgICBwcmltZWRDb29yZCA9IG5ldyBTVkcuUG9pbnQoKEEueC1CLngpLzIsIChBLnktQi55KS8yKS50cmFuc2Zvcm0obmV3IFNWRy5NYXRyaXgoKS5yb3RhdGUoeEF4aXNSb3RhdGlvbikpO1xyXG4gICAgICBsYW1iZGEgPSAocHJpbWVkQ29vcmQueCAqIHByaW1lZENvb3JkLngpIC8gKHJ4ICogcngpICsgKHByaW1lZENvb3JkLnkgKiBwcmltZWRDb29yZC55KSAvIChyeSAqIHJ5KTtcclxuICAgICAgaWYobGFtYmRhID4gMSkge1xyXG4gICAgICAgIGxhbWJkYSA9IE1hdGguc3FydChsYW1iZGEpO1xyXG4gICAgICAgIHJ4ID0gbGFtYmRhKnJ4O1xyXG4gICAgICAgIHJ5ID0gbGFtYmRhKnJ5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUbyBzaW1wbGlmeSBjYWxjdWxhdGlvbnMsIHdlIG1ha2UgdGhlIGFyYyBwYXJ0IG9mIGEgdW5pdCBjaXJjbGUgKHJheW9uIGlzIDEpIGluc3RlYWQgb2YgYW4gZWxsaXBzZVxyXG4gICAgICBtYXQgPSBuZXcgU1ZHLk1hdHJpeCgpLnJvdGF0ZSh4QXhpc1JvdGF0aW9uKS5zY2FsZSgxL3J4LCAxL3J5KS5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xyXG4gICAgICBBID0gQS50cmFuc2Zvcm0obWF0KTtcclxuICAgICAgQiA9IEIudHJhbnNmb3JtKG1hdCk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpc3RhbmNlIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIGZpbmFsIHBvaW50IG9mIHRoZSBhcmNcclxuICAgICAgayA9IFtCLngtQS54LCBCLnktQS55XTtcclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIGxlbmd0aCBvZiB0aGUgY2hvcmQgZm9ybWVkIGJ5IEEgYW5kIEJcclxuICAgICAgY1NxdWFyZSA9IGtbMF0qa1swXSArIGtbMV0qa1sxXTtcclxuICAgICAgYyA9IE1hdGguc3FydChjU3F1YXJlKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmF0aW9zIG9mIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaXN0YW5jZSBvbiB0aGUgbGVuZ3RoIG9mIHRoZSBjaG9yZFxyXG4gICAgICBrWzBdIC89IGM7XHJcbiAgICAgIGtbMV0gLz0gYztcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY2lyY2xlIGNlbnRlciBhbmQgdGhlIGNob3JkIG1pZHBvaW50XHJcbiAgICAgIC8vIHVzaW5nIHRoaXMgZm9ybXVsYTogdCA9IHNxcnQocl4yIC0gY14yIC8gNClcclxuICAgICAgLy8gd2hlcmUgdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY2lybGUgY2VudGVyIGFuZCB0aGUgY2hvcmQgbWlkcG9pbnQsXHJcbiAgICAgIC8vICAgICAgIHIgaXMgdGhlIHJheW9uIG9mIHRoZSBjaXJjbGUgYW5kIGMgaXMgdGhlIGNob3JkIGxlbmd0aFxyXG4gICAgICAvLyBGcm9tOiBodHRwOi8vd3d3LmFqZGVzaWduZXIuY29tL3BocGNpcmNsZS9jaXJjbGVfc2VnbWVudF9jaG9yZF90LnBocFxyXG4gICAgICAvLyBCZWNhdXNlIG9mIHRoZSBpbXByZWNpc2lvbiBvZiBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBjU3F1YXJlIG1pZ2h0IGVuZFxyXG4gICAgICAvLyB1cCBiZWluZyBzbGlnaHRseSBhYm92ZSA0IHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBhIG5lZ2F0aXZlIHJhZGljYW5kXHJcbiAgICAgIC8vIFRvIHByZXZlbnQgdGhhdCwgYSB0ZXN0IGlzIG1hZGUgYmVmb3JlIGNvbXB1dGluZyB0aGUgc3F1YXJlIHJvb3RcclxuICAgICAgdCA9IChjU3F1YXJlIDwgNCkgPyBNYXRoLnNxcnQoMSAtIGNTcXVhcmUvNCkgOiAwO1xyXG5cclxuICAgICAgLy8gRm9yIG1vc3Qgc2l0dWF0aW9ucywgdGhlcmUgYXJlIGFjdHVhbGx5IHR3byBkaWZmZXJlbnQgZWxsaXBzZXMgdGhhdFxyXG4gICAgICAvLyBzYXRpc2Z5IHRoZSBjb25zdHJhaW50cyBpbXBvc2VkIGJ5IHRoZSBwb2ludHMgQSBhbmQgQiwgdGhlIHJhZGlpIHJ4IGFuZCByeSxcclxuICAgICAgLy8gYW5kIHRoZSB4QXhpc1JvdGF0aW9uXHJcbiAgICAgIC8vIFdoZW4gdGhlIGZsYWdzIGxhcmdlQXJjRmxhZyBhbmQgc3dlZXBGbGFnIGFyZSBlcXVhbCwgaXQgbWVhbnMgdGhhdCB0aGVcclxuICAgICAgLy8gc2Vjb25kIGVsbGlwc2UgaXMgdXNlZCBhcyBhIHNvbHV0aW9uXHJcbiAgICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhRWxsaXB0aWNhbEFyY0NvbW1hbmRzXHJcbiAgICAgIGlmKGxhcmdlQXJjRmxhZyA9PT0gc3dlZXBGbGFnKSB7XHJcbiAgICAgICAgICB0ICo9IC0xO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBmcm9tIHRoZSBtaWRwb2ludCBvZiB0aGUgY2hvcmRcclxuICAgICAgLy8gVGhpcyBpcyBkb25lIGJ5IG11bHRpcGx5aW5nIHRoZSByYXRpb3MgY2FsY3VsYXRlZCBwcmV2aW91c2x5IGJ5IHRoZSBkaXN0YW5jZSBiZXR3ZWVuXHJcbiAgICAgIC8vIHRoZSBjaXJjbGUgY2VudGVyIGFuZCB0aGUgY2hvcmQgbWlkcG9pbnQgYW5kIHVzaW5nIHRoZXNlIHZhbHVlcyB0byBnbyBmcm9tIHRoZSBtaWRwb2ludFxyXG4gICAgICAvLyB0byB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuICAgICAgLy8gVGhlIG5lZ2F0aXZlIG9mIHRoZSB2ZXJ0aWNhbCBkaXN0YW5jZSByYXRpbyBpcyB1c2VkIHRvIG1vZGlmeSB0aGUgeCBjb29yZGluYXRlIHdoaWxlXHJcbiAgICAgIC8vIHRoZSBob3Jpem9udGFsIGRpc3RhbmNlIHJhdGlvIGlzIHVzZWQgdG8gbW9kaWZ5IHRoZSB5IGNvb3JkaW5hdGVcclxuICAgICAgLy8gVGhhdCBpcyBiZWNhdXNlIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBjaG9yZCBhbmQgcGVycGVuZGljdWxhclxyXG4gICAgICAvLyBsaW5lcyBhcmUgbmVnYXRpdmUgcmVjaXByb2NhbHNcclxuICAgICAgTyA9IG5ldyBTVkcuUG9pbnQoKEIueCtBLngpLzIgKyB0Ki1rWzFdLCAoQi55K0EueSkvMiArIHQqa1swXSk7XHJcbiAgICAgIC8vIE1vdmUgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGF0IHRoZSBvcmlnaW5cclxuICAgICAgT0EgPSBuZXcgU1ZHLlBvaW50KEEueC1PLngsIEEueS1PLnkpO1xyXG4gICAgICBPQiA9IG5ldyBTVkcuUG9pbnQoQi54LU8ueCwgQi55LU8ueSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgYW5nbGVcclxuICAgICAgdGV0YVN0YXJ0ID0gTWF0aC5hY29zKE9BLngvTWF0aC5zcXJ0KE9BLngqT0EueCArIE9BLnkqT0EueSkpO1xyXG4gICAgICBpZiAoT0EueSA8IDApIHtcclxuICAgICAgICB0ZXRhU3RhcnQgKj0gLTE7XHJcbiAgICAgIH1cclxuICAgICAgdGV0YUVuZCA9IE1hdGguYWNvcyhPQi54L01hdGguc3FydChPQi54Kk9CLnggKyBPQi55Kk9CLnkpKTtcclxuICAgICAgaWYgKE9CLnkgPCAwKSB7XHJcbiAgICAgICAgdGV0YUVuZCAqPSAtMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgc3dlZXAtZmxhZyBpcyAnMScsIHRoZW4gdGhlIGFyYyB3aWxsIGJlIGRyYXduIGluIGEgXCJwb3NpdGl2ZS1hbmdsZVwiIGRpcmVjdGlvbixcclxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGVuZCBhbmdsZSBpcyBhYm92ZSB0aGUgc3RhcnQgYW5nbGVcclxuICAgICAgaWYgKHN3ZWVwRmxhZyAmJiB0ZXRhU3RhcnQgPiB0ZXRhRW5kKSB7XHJcbiAgICAgICAgdGV0YUVuZCArPSAyKk1hdGguUEk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgc3dlZXAtZmxhZyBpcyAnMCcsIHRoZW4gdGhlIGFyYyB3aWxsIGJlIGRyYXduIGluIGEgXCJuZWdhdGl2ZS1hbmdsZVwiIGRpcmVjdGlvbixcclxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGVuZCBhbmdsZSBpcyBiZWxvdyB0aGUgc3RhcnQgYW5nbGVcclxuICAgICAgaWYgKCFzd2VlcEZsYWcgJiYgdGV0YVN0YXJ0IDwgdGV0YUVuZCkge1xyXG4gICAgICAgIHRldGFFbmQgLT0gMipNYXRoLlBJO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBudW1iZXIgb2YgQmV6aWVyIGN1cnZlcyB0aGF0IGFyZSByZXF1aXJlZCB0byByZXByZXNlbnQgdGhlIGFyY1xyXG4gICAgICAvLyBBIGN1YmljIEJlemllciBjdXJ2ZSBnaXZlcyBhIGdvb2QgZW5vdWdoIGFwcHJveGltYXRpb24gd2hlbiByZXByZXNlbnRpbmcgYXQgbW9zdCBhIHF1YXJ0ZXIgb2YgYSBjaXJjbGVcclxuICAgICAgbmJTZWN0b3JzID0gTWF0aC5jZWlsKE1hdGguYWJzKHRldGFTdGFydC10ZXRhRW5kKSAqIDIvTWF0aC5QSSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludHMgb2YgYWxsIHRoZSBCZXppZXIgY3VydmVzIHJlcXVpcmVkIHRvIHJlcHJlc2VudCB0aGUgYXJjXHJcbiAgICAgIC8vIEZvciBhbiBpbi1kZXB0aCBleHBsYW5hdGlvbiBvZiB0aGlzIHBhcnQgc2VlOiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI2NpcmNsZXNfY3ViaWNcclxuICAgICAgYXJjU2VnUG9pbnRzID0gW107XHJcbiAgICAgIGFuZ2xlID0gdGV0YVN0YXJ0O1xyXG4gICAgICBkZWx0YVRldGEgPSAodGV0YUVuZC10ZXRhU3RhcnQpL25iU2VjdG9ycztcclxuICAgICAgZiA9IDQqTWF0aC50YW4oZGVsdGFUZXRhLzQpLzM7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gbmJTZWN0b3JzOyBpKyspIHsgLy8gVGhlIDw9IGlzIGJlY2F1c2UgYSBCZXppZXIgY3VydmUgaGF2ZSBhIHN0YXJ0IGFuZCBhIGVuZHBvaW50XHJcbiAgICAgICAgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgICAgIHB0ID0gbmV3IFNWRy5Qb2ludChPLngrY29zQW5nbGUsIE8ueStzaW5BbmdsZSk7XHJcbiAgICAgICAgYXJjU2VnUG9pbnRzW2ldID0gW25ldyBTVkcuUG9pbnQocHQueCtmKnNpbkFuZ2xlLCBwdC55LWYqY29zQW5nbGUpLCBwdCwgbmV3IFNWRy5Qb2ludChwdC54LWYqc2luQW5nbGUsIHB0LnkrZipjb3NBbmdsZSldO1xyXG5cclxuICAgICAgICBhbmdsZSArPSBkZWx0YVRldGE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBvZiB0aGUgZmlyc3Qgc2VnbWVudCBwb2ludCBhbmQgcmVtb3ZlIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvZiB0aGUgbGFzdCBzZWdtZW50IHBvaW50XHJcbiAgICAgIC8vIFRoZXNlIHR3byBjb250cm9sIHBvaW50cyBhcmUgbm90IHVzZWQgaW4gdGhlIGFwcHJveGltYXRpb24gb2YgdGhlIGFyYywgdGhhdCBpcyB3aHkgdGhleSBhcmUgcmVtb3ZlZFxyXG4gICAgICBhcmNTZWdQb2ludHNbMF1bMF0gPSBhcmNTZWdQb2ludHNbMF1bMV0uY2xvbmUoKTtcclxuICAgICAgYXJjU2VnUG9pbnRzW2FyY1NlZ1BvaW50cy5sZW5ndGgtMV1bMl0gPSBhcmNTZWdQb2ludHNbYXJjU2VnUG9pbnRzLmxlbmd0aC0xXVsxXS5jbG9uZSgpO1xyXG5cclxuICAgICAgLy8gUmV2ZXJ0IHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGF0IHdhcyBhcHBsaWVkIHRvIG1ha2UgdGhlIGFyYyBwYXJ0IG9mIGEgdW5pdCBjaXJjbGUgaW5zdGVhZCBvZiBhbiBlbGxpcHNlXHJcbiAgICAgIG1hdCA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKHhBeGlzUm90YXRpb24pLnNjYWxlKHJ4LCByeSkucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcclxuICAgICAgZm9yIChpID0gMCwgaWwgPSBhcmNTZWdQb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICAgIGFyY1NlZ1BvaW50c1tpXVswXSA9IGFyY1NlZ1BvaW50c1tpXVswXS50cmFuc2Zvcm0obWF0KTtcclxuICAgICAgICBhcmNTZWdQb2ludHNbaV1bMV0gPSBhcmNTZWdQb2ludHNbaV1bMV0udHJhbnNmb3JtKG1hdCk7XHJcbiAgICAgICAgYXJjU2VnUG9pbnRzW2ldWzJdID0gYXJjU2VnUG9pbnRzW2ldWzJdLnRyYW5zZm9ybShtYXQpO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8gQ29udmVydCB0aGUgc2VnbWVudHMgcG9pbnRzIHRvIFNWRyBjdXJ2ZSBjb21tYW5kc1xyXG4gICAgICBmb3IgKGkgPSAxLCBpbCA9IGFyY1NlZ1BvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgICAgcHQgPSBhcmNTZWdQb2ludHNbaS0xXVsyXTtcclxuICAgICAgICB4MSA9IHB0Lng7XHJcbiAgICAgICAgeTEgPSBwdC55O1xyXG5cclxuICAgICAgICBwdCA9IGFyY1NlZ1BvaW50c1tpXVswXTtcclxuICAgICAgICB4MiA9IHB0Lng7XHJcbiAgICAgICAgeTIgPSBwdC55O1xyXG5cclxuICAgICAgICBwdCA9IGFyY1NlZ1BvaW50c1tpXVsxXTtcclxuICAgICAgICB4ID0gcHQueDtcclxuICAgICAgICB5ID0gcHQueTtcclxuXHJcbiAgICAgICAgcmV0VmFsLnB1c2goWydDJywgeDEsIHkxLCB4MiwgeTIsIHgsIHldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJldFZhbFxyXG4gIH1cclxuICB9KCkpO1xuXG4gIC8qISBzdmcuZHJhZ2dhYmxlLmpzIC0gdjIuMi4yIC0gMjAxOS0wMS0wOFxyXG4gICogaHR0cHM6Ly9naXRodWIuY29tL3N2Z2RvdGpzL3N2Zy5kcmFnZ2FibGUuanNcclxuICAqIENvcHlyaWdodCAoYykgMjAxOSBXb3V0IEZpZXJlbnM7IExpY2Vuc2VkIE1JVCAqL1xyXG4gIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvLyBjcmVhdGVzIGhhbmRsZXIsIHNhdmVzIGl0XHJcbiAgICBmdW5jdGlvbiBEcmFnSGFuZGxlcihlbCl7XHJcbiAgICAgIGVsLnJlbWVtYmVyKCdfZHJhZ2dhYmxlJywgdGhpcyk7XHJcbiAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gU2V0cyBuZXcgcGFyYW1ldGVyLCBzdGFydHMgZHJhZ2dpbmdcclxuICAgIERyYWdIYW5kbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oY29uc3RyYWludCwgdmFsKXtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgdGhpcy5jb25zdHJhaW50ID0gY29uc3RyYWludDtcclxuICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcclxuICAgICAgdGhpcy5lbC5vbignbW91c2Vkb3duLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuc3RhcnQoZSk7IH0pO1xyXG4gICAgICB0aGlzLmVsLm9uKCd0b3VjaHN0YXJ0LmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuc3RhcnQoZSk7IH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0cmFuc2Zvcm1zIG9uZSBwb2ludCBmcm9tIHNjcmVlbiB0byB1c2VyIGNvb3Jkc1xyXG4gICAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24oZXZlbnQsIG9mZnNldCl7XHJcbiAgICAgICAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSB8fCBldmVudDtcclxuICAgICAgICB0aGlzLnAueCA9IHRvdWNoZXMuY2xpZW50WCAtIChvZmZzZXQgfHwgMCk7XHJcbiAgICAgICAgdGhpcy5wLnkgPSB0b3VjaGVzLmNsaWVudFk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucC5tYXRyaXhUcmFuc2Zvcm0odGhpcy5tKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBnZXRzIGVsZW1lbnRzIGJvdW5kaW5nIGJveCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgb2YgZ3JvdXBzLCBuZXN0ZWQgYW5kIHVzZVxyXG4gICAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgdmFyIGJveCA9IHRoaXMuZWwuYmJveCgpO1xyXG5cclxuICAgICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5OZXN0ZWQpIGJveCA9IHRoaXMuZWwucmJveCgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZWwgaW5zdGFuY2VvZiBTVkcuRyB8fCB0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLlVzZSB8fCB0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLk5lc3RlZCkge1xyXG4gICAgICAgIGJveC54ID0gdGhpcy5lbC54KCk7XHJcbiAgICAgICAgYm94LnkgPSB0aGlzLmVsLnkoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGJveFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBzdGFydCBkcmFnZ2luZ1xyXG4gICAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oZSl7XHJcblxyXG4gICAgICAvLyBjaGVjayBmb3IgbGVmdCBidXR0b25cclxuICAgICAgaWYoZS50eXBlID09ICdjbGljayd8fCBlLnR5cGUgPT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09ICdtb3VzZW1vdmUnKXtcclxuICAgICAgICBpZigoZS53aGljaCB8fCBlLmJ1dHRvbnMpICE9IDEpe1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBmaXJlIGJlZm9yZWRyYWcgZXZlbnRcclxuICAgICAgdGhpcy5lbC5maXJlKCdiZWZvcmVkcmFnJywgeyBldmVudDogZSwgaGFuZGxlcjogdGhpcyB9KTtcclxuICAgICAgaWYodGhpcy5lbC5ldmVudCgpLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIHByZXZlbnQgYnJvd3NlciBkcmFnIGJlaGF2aW9yIGFzIHNvb24gYXMgcG9zc2libGVcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgLy8gcHJldmVudCBwcm9wYWdhdGlvbiB0byBhIHBhcmVudCB0aGF0IG1pZ2h0IGFsc28gaGF2ZSBkcmFnZ2luZyBlbmFibGVkXHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAvLyBzZWFyY2ggZm9yIHBhcmVudCBvbiB0aGUgZmx5IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gY2FsbFxyXG4gICAgICAvLyBkcmFnZ2FibGUoKSBldmVuIHdoZW4gZWxlbWVudCBpcyBub3QgaW4gdGhlIGRvbSBjdXJyZW50bHlcclxuICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLmVsLnBhcmVudChTVkcuTmVzdGVkKSB8fCB0aGlzLmVsLnBhcmVudChTVkcuRG9jKTtcclxuICAgICAgdGhpcy5wID0gdGhpcy5wYXJlbnQubm9kZS5jcmVhdGVTVkdQb2ludCgpO1xyXG5cclxuICAgICAgLy8gc2F2ZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAgICB0aGlzLm0gPSB0aGlzLmVsLm5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpO1xyXG5cclxuICAgICAgdmFyIGJveCA9IHRoaXMuZ2V0QkJveCgpO1xyXG5cclxuICAgICAgdmFyIGFuY2hvck9mZnNldDtcclxuXHJcbiAgICAgIC8vIGZpeCB0ZXh0LWFuY2hvciBpbiB0ZXh0LWVsZW1lbnQgKCMzNylcclxuICAgICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5UZXh0KXtcclxuICAgICAgICBhbmNob3JPZmZzZXQgPSB0aGlzLmVsLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgIHN3aXRjaCh0aGlzLmVsLmF0dHIoJ3RleHQtYW5jaG9yJykpe1xyXG4gICAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgYW5jaG9yT2Zmc2V0IC89IDI7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICdzdGFydCc6XHJcbiAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdGFydFBvaW50cyA9IHtcclxuICAgICAgICAvLyBXZSB0YWtlIGFic29sdXRlIGNvb3JkaW5hdGVzIHNpbmNlIHdlIGFyZSBqdXN0IHVzaW5nIGEgZGVsdGEgaGVyZVxyXG4gICAgICAgIHBvaW50OiB0aGlzLnRyYW5zZm9ybVBvaW50KGUsIGFuY2hvck9mZnNldCksXHJcbiAgICAgICAgYm94OiAgIGJveCxcclxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMuZWwudHJhbnNmb3JtKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGFkZCBkcmFnIGFuZCBlbmQgZXZlbnRzIHRvIHdpbmRvd1xyXG4gICAgICBTVkcub24od2luZG93LCAnbW91c2Vtb3ZlLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuZHJhZyhlKTsgfSk7XHJcbiAgICAgIFNWRy5vbih3aW5kb3csICd0b3VjaG1vdmUuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5kcmFnKGUpOyB9KTtcclxuICAgICAgU1ZHLm9uKHdpbmRvdywgJ21vdXNldXAuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5lbmQoZSk7IH0pO1xyXG4gICAgICBTVkcub24od2luZG93LCAndG91Y2hlbmQuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5lbmQoZSk7IH0pO1xyXG5cclxuICAgICAgLy8gZmlyZSBkcmFnc3RhcnQgZXZlbnRcclxuICAgICAgdGhpcy5lbC5maXJlKCdkcmFnc3RhcnQnLCB7ZXZlbnQ6IGUsIHA6IHRoaXMuc3RhcnRQb2ludHMucG9pbnQsIG06IHRoaXMubSwgaGFuZGxlcjogdGhpc30pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICAgIHZhciBib3ggPSB0aGlzLmdldEJCb3goKVxyXG4gICAgICAgICwgcCAgID0gdGhpcy50cmFuc2Zvcm1Qb2ludChlKVxyXG4gICAgICAgICwgeCAgID0gdGhpcy5zdGFydFBvaW50cy5ib3gueCArIHAueCAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueFxyXG4gICAgICAgICwgeSAgID0gdGhpcy5zdGFydFBvaW50cy5ib3gueSArIHAueSAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueVxyXG4gICAgICAgICwgYyAgID0gdGhpcy5jb25zdHJhaW50XHJcbiAgICAgICAgLCBneCAgPSBwLnggLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnhcclxuICAgICAgICAsIGd5ICA9IHAueSAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueTtcclxuXHJcbiAgICAgIHRoaXMuZWwuZmlyZSgnZHJhZ21vdmUnLCB7XHJcbiAgICAgICAgICBldmVudDogZVxyXG4gICAgICAgICwgcDogcFxyXG4gICAgICAgICwgbTogdGhpcy5tXHJcbiAgICAgICAgLCBoYW5kbGVyOiB0aGlzXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYodGhpcy5lbC5ldmVudCgpLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybiBwXHJcblxyXG4gICAgICAvLyBtb3ZlIHRoZSBlbGVtZW50IHRvIGl0cyBuZXcgcG9zaXRpb24sIGlmIHBvc3NpYmxlIGJ5IGNvbnN0cmFpbnRcclxuICAgICAgaWYgKHR5cGVvZiBjID09ICdmdW5jdGlvbicpIHtcclxuXHJcbiAgICAgICAgdmFyIGNvb3JkID0gYy5jYWxsKHRoaXMuZWwsIHgsIHksIHRoaXMubSk7XHJcblxyXG4gICAgICAgIC8vIGJvb2wsIGp1c3Qgc2hvdyB1cyBpZiBtb3ZlbWVudCBpcyBhbGxvd2VkIG9yIG5vdFxyXG4gICAgICAgIGlmICh0eXBlb2YgY29vcmQgPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICBjb29yZCA9IHtcclxuICAgICAgICAgICAgeDogY29vcmQsXHJcbiAgICAgICAgICAgIHk6IGNvb3JkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgdHJ1ZSwgd2UganVzdCBtb3ZlLiBJZiAhZmFsc2UgaXRzIGEgbnVtYmVyIGFuZCB3ZSBtb3ZlIGl0IHRoZXJlXHJcbiAgICAgICAgaWYgKGNvb3JkLnggPT09IHRydWUpIHtcclxuICAgICAgICAgIHRoaXMuZWwueCh4KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvb3JkLnggIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICB0aGlzLmVsLngoY29vcmQueCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29vcmQueSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgdGhpcy5lbC55KHkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29vcmQueSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgIHRoaXMuZWwueShjb29yZC55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgIC8vIGtlZXAgZWxlbWVudCB3aXRoaW4gY29uc3RyYWluZWQgYm94XHJcbiAgICAgICAgaWYgKGMubWluWCAhPSBudWxsICYmIHggPCBjLm1pblgpIHtcclxuICAgICAgICAgIHggPSBjLm1pblg7XHJcbiAgICAgICAgICBneCA9IHggLSB0aGlzLnN0YXJ0UG9pbnRzLmJveC54O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYy5tYXhYICE9IG51bGwgJiYgeCA+IGMubWF4WCAtIGJveC53aWR0aCkge1xyXG4gICAgICAgICAgeCA9IGMubWF4WCAtIGJveC53aWR0aDtcclxuICAgICAgICAgIGd4ID0geCAtIHRoaXMuc3RhcnRQb2ludHMuYm94Lng7XHJcbiAgICAgICAgfSBpZiAoYy5taW5ZICE9IG51bGwgJiYgeSA8IGMubWluWSkge1xyXG4gICAgICAgICAgeSA9IGMubWluWTtcclxuICAgICAgICAgIGd5ID0geSAtIHRoaXMuc3RhcnRQb2ludHMuYm94Lnk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjLm1heFkgIT0gbnVsbCAmJiB5ID4gYy5tYXhZIC0gYm94LmhlaWdodCkge1xyXG4gICAgICAgICAgeSA9IGMubWF4WSAtIGJveC5oZWlnaHQ7XHJcbiAgICAgICAgICBneSA9IHkgLSB0aGlzLnN0YXJ0UG9pbnRzLmJveC55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGMuc25hcFRvR3JpZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICB4ID0geCAtICh4ICUgYy5zbmFwVG9HcmlkKTtcclxuICAgICAgICAgIHkgPSB5IC0gKHkgJSBjLnNuYXBUb0dyaWQpO1xyXG4gICAgICAgICAgZ3ggPSBneCAtIChneCAlIGMuc25hcFRvR3JpZCk7XHJcbiAgICAgICAgICBneSA9IGd5IC0gKGd5ICUgYy5zbmFwVG9HcmlkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZWwgaW5zdGFuY2VvZiBTVkcuRylcclxuICAgICAgICAgIHRoaXMuZWwubWF0cml4KHRoaXMuc3RhcnRQb2ludHMudHJhbnNmb3JtKS50cmFuc2Zvcm0oe3g6Z3gsIHk6IGd5fSwgdHJ1ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5lbC5tb3ZlKHgsIHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzbyB3ZSBjYW4gdXNlIGl0IGluIHRoZSBlbmQtbWV0aG9kLCB0b29cclxuICAgICAgcmV0dXJuIHBcclxuICAgIH07XHJcblxyXG4gICAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGUpe1xyXG5cclxuICAgICAgLy8gZmluYWwgZHJhZ1xyXG4gICAgICB2YXIgcCA9IHRoaXMuZHJhZyhlKTtcclxuXHJcbiAgICAgIC8vIGZpcmUgZHJhZ2VuZCBldmVudFxyXG4gICAgICB0aGlzLmVsLmZpcmUoJ2RyYWdlbmQnLCB7IGV2ZW50OiBlLCBwOiBwLCBtOiB0aGlzLm0sIGhhbmRsZXI6IHRoaXMgfSk7XHJcblxyXG4gICAgICAvLyB1bmJpbmQgZXZlbnRzXHJcbiAgICAgIFNWRy5vZmYod2luZG93LCAnbW91c2Vtb3ZlLmRyYWcnKTtcclxuICAgICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaG1vdmUuZHJhZycpO1xyXG4gICAgICBTVkcub2ZmKHdpbmRvdywgJ21vdXNldXAuZHJhZycpO1xyXG4gICAgICBTVkcub2ZmKHdpbmRvdywgJ3RvdWNoZW5kLmRyYWcnKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAgICAgLy8gTWFrZSBlbGVtZW50IGRyYWdnYWJsZVxyXG4gICAgICAvLyBDb25zdHJhaW50IG1pZ2h0IGJlIGFuIG9iamVjdCAoYXMgZGVzY3JpYmVkIGluIHJlYWRtZS5tZCkgb3IgYSBmdW5jdGlvbiBpbiB0aGUgZm9ybSBcImZ1bmN0aW9uICh4LCB5KVwiIHRoYXQgZ2V0cyBjYWxsZWQgYmVmb3JlIGV2ZXJ5IG1vdmUuXHJcbiAgICAgIC8vIFRoZSBmdW5jdGlvbiBjYW4gcmV0dXJuIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0ge3gsIHl9LCB0byB3aGljaCB0aGUgZWxlbWVudCB3aWxsIGJlIG1vdmVkLiBcIkZhbHNlXCIgc2tpcHMgbW92aW5nLCB0cnVlIG1vdmVzIHRvIHJhdyB4LCB5LlxyXG4gICAgICBkcmFnZ2FibGU6IGZ1bmN0aW9uKHZhbHVlLCBjb25zdHJhaW50KSB7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoZSBwYXJhbWV0ZXJzIGFuZCByZWFzc2lnbiBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBjb25zdHJhaW50ID0gdmFsdWU7XHJcbiAgICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZHJhZ0hhbmRsZXIgPSB0aGlzLnJlbWVtYmVyKCdfZHJhZ2dhYmxlJykgfHwgbmV3IERyYWdIYW5kbGVyKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBXaGVuIG5vIHBhcmFtZXRlciBpcyBnaXZlbiwgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYodmFsdWUpIGRyYWdIYW5kbGVyLmluaXQoY29uc3RyYWludCB8fCB7fSwgdmFsdWUpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5vZmYoJ21vdXNlZG93bi5kcmFnJyk7XHJcbiAgICAgICAgICB0aGlzLm9mZigndG91Y2hzdGFydC5kcmFnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gIH0pLmNhbGwodW5kZWZpbmVkKTtcblxuICAoZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gU2VsZWN0SGFuZGxlcihlbCkge1xyXG5cclxuICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICBlbC5yZW1lbWJlcignX3NlbGVjdEhhbmRsZXInLCB0aGlzKTtcclxuICAgICAgdGhpcy5wb2ludFNlbGVjdGlvbiA9IHtpc1NlbGVjdGVkOiBmYWxzZX07XHJcbiAgICAgIHRoaXMucmVjdFNlbGVjdGlvbiA9IHtpc1NlbGVjdGVkOiBmYWxzZX07XHJcblxyXG4gICAgICAvLyBoZWxwZXIgbGlzdCB3aXRoIHBvc2l0aW9uIHNldHRpbmdzIG9mIGVhY2ggdHlwZSBvZiBwb2ludFxyXG4gICAgICB0aGlzLnBvaW50c0xpc3QgPSB7XHJcbiAgICAgICAgbHQ6IFsgMCwgMCBdLFxyXG4gICAgICAgIHJ0OiBbICd3aWR0aCcsIDAgXSxcclxuICAgICAgICByYjogWyAnd2lkdGgnLCAnaGVpZ2h0JyBdLFxyXG4gICAgICAgIGxiOiBbIDAsICdoZWlnaHQnIF0sXHJcbiAgICAgICAgdDogWyAnd2lkdGgnLCAwIF0sXHJcbiAgICAgICAgcjogWyAnd2lkdGgnLCAnaGVpZ2h0JyBdLFxyXG4gICAgICAgIGI6IFsgJ3dpZHRoJywgJ2hlaWdodCcgXSxcclxuICAgICAgICBsOiBbIDAsICdoZWlnaHQnIF1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgcG9pbnQgY29vcmRpbmF0ZXMgYmFzZWQgb24gc2V0dGluZ3MgYWJvdmUgYW5kIGFuIG9iamVjdCAoYmJveCBpbiBvdXIgY2FzZSlcclxuICAgICAgdGhpcy5wb2ludENvb3JkID0gZnVuY3Rpb24gKHNldHRpbmcsIG9iamVjdCwgaXNQb2ludENlbnRlcmVkKSB7XHJcbiAgICAgICAgdmFyIGNvb3JkID0gdHlwZW9mIHNldHRpbmcgIT09ICdzdHJpbmcnID8gc2V0dGluZyA6IG9iamVjdFtzZXR0aW5nXTtcclxuICAgICAgICAvLyBUb3AsIGJvdHRvbSwgcmlnaHQgYW5kIGxlZnQgcG9pbnRzIGFyZSBwbGFjZWQgaW4gdGhlIGNlbnRlciBvZiBlbGVtZW50IHdpZHRoL2hlaWdodFxyXG4gICAgICAgIHJldHVybiBpc1BvaW50Q2VudGVyZWQgPyBjb29yZCAvIDIgOiBjb29yZFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5wb2ludENvb3JkcyA9IGZ1bmN0aW9uIChwb2ludCwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5wb2ludHNMaXN0W3BvaW50XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHg6IHRoaXMucG9pbnRDb29yZChzZXR0aW5nc1swXSwgb2JqZWN0LCAocG9pbnQgPT09ICd0JyB8fCBwb2ludCA9PT0gJ2InKSksXHJcbiAgICAgICAgICB5OiB0aGlzLnBvaW50Q29vcmQoc2V0dGluZ3NbMV0sIG9iamVjdCwgKHBvaW50ID09PSAncicgfHwgcG9pbnQgPT09ICdsJykpXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gIH1cclxuXHJcbiAgU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG5cclxuICAgICAgdmFyIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuICAgICAgdGhpcy5vcHRpb25zID0ge307XHJcblxyXG4gICAgICAvLyBzdG9yZSBkZWZhdWx0cyBsaXN0IG9mIHBvaW50cyBpbiBvcmRlciB0byB2ZXJpZnkgdXNlcnMgY29uZmlnXHJcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmVsLnNlbGVjdGl6ZS5kZWZhdWx0cy5wb2ludHM7XHJcblxyXG4gICAgICAvLyBNZXJnaW5nIHRoZSBkZWZhdWx0cyBhbmQgdGhlIG9wdGlvbnMtb2JqZWN0IHRvZ2V0aGVyXHJcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5lbC5zZWxlY3RpemUuZGVmYXVsdHMpIHtcclxuICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9IHRoaXMuZWwuc2VsZWN0aXplLmRlZmF1bHRzW2ldO1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHByZXBhcmUgJiB2YWxpZGF0ZSBsaXN0IG9mIHBvaW50cyB0byBiZSBhZGRlZCAob3IgZXhjbHVkZWQpXHJcbiAgICAgIHZhciBwb2ludHNMaXN0cyA9IFsncG9pbnRzJywgJ3BvaW50c0V4Y2x1ZGUnXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgaW4gcG9pbnRzTGlzdHMpIHtcclxuICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zW3BvaW50c0xpc3RzW2ldXTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBpZiAob3B0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gaWYgc2V0IGFzIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgbGlzdCA9PiBjb252ZXJ0IGl0IGludG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uLnNwbGl0KC9cXHMqLFxccyovaSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb24gPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdib29sZWFuJyAmJiBwb2ludHNMaXN0c1tpXSA9PT0gJ3BvaW50cycpIHtcclxuICAgICAgICAgIC8vIHRoaXMgaXMgbm90IG5lZWRlZCwgYnV0IGxldCdzIGhhdmUgaXQgZm9yIGxlZ2FjeSBzdXBwb3J0XHJcbiAgICAgICAgICBvcHRpb24gPSBvcHRpb24gPyBwb2ludHMgOiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub3B0aW9uc1twb2ludHNMaXN0c1tpXV0gPSBvcHRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGludGVyc2VjdCBjb3JyZWN0IGFsbCBwb2ludHMgb3B0aW9ucyB3aXRoIHVzZXJzIGNvbmZpZyAoZXhjbHVkZSB1bndhbnRlZCBwb2ludHMpXHJcbiAgICAgIC8vIEVTNSAtPiBOTyBhcnJvdyBmdW5jdGlvbnMgbm9yIEFycmF5LmluY2x1ZGVzKClcclxuICAgICAgdGhpcy5vcHRpb25zLnBvaW50cyA9IFsgcG9pbnRzLCB0aGlzLm9wdGlvbnMucG9pbnRzIF0ucmVkdWNlKFxyXG4gICAgICAgIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICByZXR1cm4gYS5maWx0ZXIoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihjKSA+IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gZXhjbHVkZSBwb2ludHNFeGNsdWRlLCBpZiB3YW50ZWRcclxuICAgICAgdGhpcy5vcHRpb25zLnBvaW50cyA9IFsgdGhpcy5vcHRpb25zLnBvaW50cywgdGhpcy5vcHRpb25zLnBvaW50c0V4Y2x1ZGUgXS5yZWR1Y2UoXHJcbiAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgIHJldHVybiBhLmZpbHRlcihcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gYi5pbmRleE9mKGMpIDwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5lbC5wYXJlbnQoKTtcclxuICAgICAgdGhpcy5uZXN0ZWQgPSAodGhpcy5uZXN0ZWQgfHwgdGhpcy5wYXJlbnQuZ3JvdXAoKSk7XHJcbiAgICAgIHRoaXMubmVzdGVkLm1hdHJpeChuZXcgU1ZHLk1hdHJpeCh0aGlzLmVsKS50cmFuc2xhdGUoYmJveC54LCBiYm94LnkpKTtcclxuXHJcbiAgICAgIC8vIFdoZW4gZGVlcFNlbGVjdCBpcyBlbmFibGVkIGFuZCB0aGUgZWxlbWVudCBpcyBhIGxpbmUvcG9seWxpbmUvcG9seWdvbiwgZHJhdyBvbmx5IHBvaW50cyBmb3IgbW92aW5nXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcFNlbGVjdCAmJiBbJ2xpbmUnLCAncG9seWxpbmUnLCAncG9seWdvbiddLmluZGV4T2YodGhpcy5lbC50eXBlKSAhPT0gLTEpIHtcclxuICAgICAgICAgIHRoaXMuc2VsZWN0UG9pbnRzKHZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuc2VsZWN0UmVjdCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMub2JzZXJ2ZSgpO1xyXG4gICAgICB0aGlzLmNsZWFudXAoKTtcclxuXHJcbiAgfTtcclxuXHJcbiAgU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuc2VsZWN0UG9pbnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICB0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQgPSB2YWx1ZTtcclxuXHJcbiAgICAgIC8vIFdoZW4gc2V0IGlzIGFscmVhZHkgdGhlcmUgd2UgZG9udCBoYXZlIHRvIGNyZWF0ZSBvbmVcclxuICAgICAgaWYgKHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0KSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIG91ciBzZXQgb2YgZWxlbWVudHNcclxuICAgICAgdGhpcy5wb2ludFNlbGVjdGlvbi5zZXQgPSB0aGlzLnBhcmVudC5zZXQoKTtcclxuICAgICAgLy8gZHJhdyB0aGUgcG9pbnRzIGFuZCBtYXJrIHRoZSBlbGVtZW50IGFzIHNlbGVjdGVkXHJcbiAgICAgIHRoaXMuZHJhd1BvaW50cygpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gIH07XHJcblxyXG4gIC8vIGNyZWF0ZSB0aGUgcG9pbnQtYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIDIgcG9pbnRzIG9mIGEgbGluZSBvciBzaW1wbHkgdGhlIHBvaW50cy1hcnJheSBvZiBwb2x5bGluZS9wb2x5Z29uXHJcbiAgU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuZ2V0UG9pbnRBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmVsLmFycmF5KCkudmFsdWVPZigpLm1hcChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgIHJldHVybiBbZWxbMF0gLSBiYm94LngsIGVsWzFdIC0gYmJveC55XTtcclxuICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gRHJhd3MgYSBwb2ludHNcclxuICBTZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5kcmF3UG9pbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgdmFyIF90aGlzID0gdGhpcywgYXJyYXkgPSB0aGlzLmdldFBvaW50QXJyYXkoKTtcclxuXHJcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IG9mIHBvaW50c1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHJcbiAgICAgICAgICB2YXIgY3VycmllZEV2ZW50ID0gKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICBldiA9IGV2IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQgPyBldi5wcmV2ZW50RGVmYXVsdCgpIDogZXYucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICB2YXIgeCA9IGV2LnBhZ2VYIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB5ID0gZXYucGFnZVkgfHwgZXYudG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgICAgICAgX3RoaXMuZWwuZmlyZSgncG9pbnQnLCB7eDogeCwgeTogeSwgaTogaywgZXZlbnQ6IGV2fSk7XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0pKGkpO1xyXG5cclxuICAgICAgICAgIC8vIGFkZCBldmVyeSBwb2ludCB0byB0aGUgc2V0XHJcbiAgICAgICAgICAvLyBhZGQgY3NzLWNsYXNzZXMgYW5kIGEgdG91Y2hzdGFydC1ldmVudCB3aGljaCBmaXJlcyBvdXIgZXZlbnQgZm9yIG1vdmluZyBwb2ludHNcclxuICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuZHJhd1BvaW50KGFycmF5W2ldWzBdLCBhcnJheVtpXVsxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX3BvaW50JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCBjdXJyaWVkRXZlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBjdXJyaWVkRXZlbnQpO1xyXG4gICAgICAgICAgdGhpcy5wb2ludFNlbGVjdGlvbi5zZXQuYWRkKHBvaW50KTtcclxuICAgICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFRoZSBmdW5jdGlvbiB0byBkcmF3IHNpbmdsZSBwb2ludFxyXG4gIFNlbGVjdEhhbmRsZXIucHJvdG90eXBlLmRyYXdQb2ludCA9IGZ1bmN0aW9uIChjeCwgY3kpIHtcclxuICAgICAgdmFyIHBvaW50VHlwZSA9IHRoaXMub3B0aW9ucy5wb2ludFR5cGU7XHJcblxyXG4gICAgICBzd2l0Y2ggKHBvaW50VHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAnY2lyY2xlJzpcclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3Q2lyY2xlKGN4LCBjeSk7XHJcbiAgICAgICAgICBjYXNlICdyZWN0JzpcclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3UmVjdChjeCwgY3kpO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRUeXBlLmNhbGwodGhpcywgY3gsIGN5KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biAnICsgcG9pbnRUeXBlICsgJyBwb2ludCB0eXBlIScpO1xyXG4gICAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVGhlIGZ1bmN0aW9uIHRvIGRyYXcgdGhlIGNpcmNsZSBwb2ludFxyXG4gIFNlbGVjdEhhbmRsZXIucHJvdG90eXBlLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiAoY3gsIGN5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnBvaW50U2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNlbnRlcihjeCwgY3kpO1xyXG4gIH07XHJcblxyXG4gIC8vIFRoZSBmdW5jdGlvbiB0byBkcmF3IHRoZSByZWN0IHBvaW50XHJcbiAgU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuZHJhd1JlY3QgPSBmdW5jdGlvbiAoY3gsIGN5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5lc3RlZC5yZWN0KHRoaXMub3B0aW9ucy5wb2ludFNpemUsIHRoaXMub3B0aW9ucy5wb2ludFNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jZW50ZXIoY3gsIGN5KTtcclxuICB9O1xyXG5cclxuICAvLyBldmVyeSB0aW1lIGEgcG9pbnQgaXMgbW92ZWQsIHdlIGhhdmUgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2Ygb3VyIHBvaW50XHJcbiAgU2VsZWN0SGFuZGxlci5wcm90b3R5cGUudXBkYXRlUG9pbnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuZ2V0UG9pbnRBcnJheSgpO1xyXG5cclxuICAgICAgdGhpcy5wb2ludFNlbGVjdGlvbi5zZXQuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuY3goKSA9PT0gYXJyYXlbaV1bMF0gJiYgdGhpcy5jeSgpID09PSBhcnJheVtpXVsxXSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuY2VudGVyKGFycmF5W2ldWzBdLCBhcnJheVtpXVsxXSk7XHJcbiAgICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIFNlbGVjdEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVJlY3RTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuXHJcbiAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDApLmF0dHIoe1xyXG4gICAgICAgICAgd2lkdGg6IGJib3gud2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGJib3guaGVpZ2h0XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gc2V0LmdldCgxKSBpcyBhbHdheXMgaW4gdGhlIHVwcGVyIGxlZnQgY29ybmVyLiBubyBuZWVkIHRvIG1vdmUgaXRcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50LCBpbmRleCkge1xyXG4gICAgICAgICAgdmFyIGNvb3JkcyA9IF90aGlzLnBvaW50Q29vcmRzKHBvaW50LCBiYm94KTtcclxuXHJcbiAgICAgICAgICBfdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoaW5kZXggKyAxKS5jZW50ZXIoY29vcmRzLngsIGNvb3Jkcy55KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yb3RhdGlvblBvaW50KSB7XHJcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldChsZW5ndGggLSAxKS5jZW50ZXIoYmJveC53aWR0aCAvIDIsIDIwKTtcclxuICAgICAgfVxyXG4gIH07XHJcblxyXG4gIFNlbGVjdEhhbmRsZXIucHJvdG90eXBlLnNlbGVjdFJlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuXHJcbiAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5pc1NlbGVjdGVkID0gdmFsdWU7XHJcblxyXG4gICAgICAvLyB3aGVuIHNldCBpcyBhbHJlYWR5IHBcclxuICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldCA9IHRoaXMucmVjdFNlbGVjdGlvbi5zZXQgfHwgdGhpcy5wYXJlbnQuc2V0KCk7XHJcblxyXG4gICAgICAvLyBoZWxwZXJGdW5jdGlvbiB0byBjcmVhdGUgYSBtb3VzZS1kb3duIGZ1bmN0aW9uIHdoaWNoIHRyaWdnZXJzIHRoZSBldmVudCBzcGVjaWZpZWQgaW4gYGV2ZW50TmFtZWBcclxuICAgICAgZnVuY3Rpb24gZ2V0TW9zZURvd25GdW5jKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgIGV2ID0gZXYgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0ID8gZXYucHJldmVudERlZmF1bHQoKSA6IGV2LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAgIHZhciB4ID0gZXYucGFnZVggfHwgZXYudG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgICB2YXIgeSA9IGV2LnBhZ2VZIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgICAgX3RoaXMuZWwuZmlyZShldmVudE5hbWUsIHt4OiB4LCB5OiB5LCBldmVudDogZXZ9KTtcclxuICAgICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VsZWN0aW9uLXJlY3RhbmdsZSBhbmQgYWRkIHRoZSBjc3MtY2xhc3NcclxuICAgICAgaWYgKCF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgwKSkge1xyXG4gICAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQucmVjdChiYm94LndpZHRoLCBiYm94LmhlaWdodCkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzUmVjdCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEcmF3IFBvaW50cyBhdCB0aGUgZWRnZXMsIGlmIGVuYWJsZWRcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb2ludHMubGVuZ3RoICYmIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQubGVuZ3RoKCkgPCAyKSB7XHJcbiAgICAgICAgICB2YXIgZW5hbWUgPVwidG91Y2hzdGFydFwiLCBtbmFtZSA9IFwibW91c2Vkb3duXCI7XHJcblxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgIHZhciBjb29yZHMgPSBfdGhpcy5wb2ludENvb3Jkcyhwb2ludCwgYmJveCk7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBwb2ludEVsZW1lbnQgPSBfdGhpcy5kcmF3UG9pbnQoY29vcmRzLngsIGNvb3Jkcy55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIF90aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnXycgKyBwb2ludClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24obW5hbWUsIGdldE1vc2VEb3duRnVuYyhwb2ludCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMocG9pbnQpKTtcclxuICAgICAgICAgICAgICBfdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQocG9pbnRFbGVtZW50KTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5hZGRDbGFzcyhfdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkcmF3IHJvdGF0aW9uUGludCwgaWYgZW5hYmxlZFxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0aW9uUG9pbnQgJiYgKCh0aGlzLm9wdGlvbnMucG9pbnRzICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCg5KSkgfHwgKCF0aGlzLm9wdGlvbnMucG9pbnRzICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgxKSkpKSB7XHJcblxyXG4gICAgICAgICAgdmFyIGN1cnJpZWRFdmVudCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgIGV2ID0gZXYgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0ID8gZXYucHJldmVudERlZmF1bHQoKSA6IGV2LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAgIHZhciB4ID0gZXYucGFnZVggfHwgZXYudG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgICB2YXIgeSA9IGV2LnBhZ2VZIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgICAgX3RoaXMuZWwuZmlyZSgncm90Jywge3g6IHgsIHk6IHksIGV2ZW50OiBldn0pO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB2YXIgcG9pbnRFbGVtZW50ID0gdGhpcy5kcmF3UG9pbnQoYmJveC53aWR0aCAvIDIsIDIwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcm90JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oXCJ0b3VjaHN0YXJ0XCIsIGN1cnJpZWRFdmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZWRvd25cIiwgY3VycmllZEV2ZW50KTtcclxuICAgICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHBvaW50RWxlbWVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIHZhciBiYm94ID0gdGhpcy5lbC5iYm94KCk7XHJcbiAgICAgIHRoaXMubmVzdGVkLm1hdHJpeChuZXcgU1ZHLk1hdHJpeCh0aGlzLmVsKS50cmFuc2xhdGUoYmJveC54LCBiYm94LnkpKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVSZWN0U2VsZWN0aW9uKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgIHRoaXMudXBkYXRlUG9pbnRTZWxlY3Rpb24oKTtcclxuICAgICAgfVxyXG5cclxuICB9O1xyXG5cclxuICBTZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKE11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgIGlmICh0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCB8fCB0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICB0aGlzLm9ic2VydmVySW5zdCA9IHRoaXMub2JzZXJ2ZXJJbnN0IHx8IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlcigpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJJbnN0Lm9ic2VydmUodGhpcy5lbC5ub2RlLCB7YXR0cmlidXRlczogdHJ1ZX0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVySW5zdC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVySW5zdDtcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5lbC5vZmYoJ0RPTUF0dHJNb2RpZmllZC5zZWxlY3QnKTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5yZWN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQgfHwgdGhpcy5wb2ludFNlbGVjdGlvbi5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5lbC5vbignRE9NQXR0ck1vZGlmaWVkLnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlcigpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgfTtcclxuXHJcbiAgU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgIGlmICghdGhpcy5yZWN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQgJiYgdGhpcy5yZWN0U2VsZWN0aW9uLnNldCkge1xyXG4gICAgICAgICAgLy8gc3RvcCB3YXRjaGluZyB0aGUgZWxlbWVudCwgcmVtb3ZlIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuY2xlYXIoKTtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCAmJiB0aGlzLnBvaW50U2VsZWN0aW9uLnNldCkge1xyXG4gICAgICAgICAgLy8gUmVtb3ZlIGFsbCBwb2ludHMsIGNsZWFyIHRoZSBzZXQsIHN0b3Agd2F0Y2hpbmcgdGhlIGVsZW1lbnRcclxuICAgICAgICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldC5jbGVhcigpO1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCAmJiAhdGhpcy5yZWN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgIHRoaXMubmVzdGVkLnJlbW92ZSgpO1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMubmVzdGVkO1xyXG5cclxuICAgICAgfVxyXG4gIH07XHJcblxyXG5cclxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgICAgIC8vIFNlbGVjdCBlbGVtZW50IHdpdGggbW91c2VcclxuICAgICAgc2VsZWN0aXplOiBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAvLyBDaGVjayB0aGUgcGFyYW1ldGVycyBhbmQgcmVhc3NpZ24gaWYgbmVlZGVkXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIHNlbGVjdEhhbmRsZXIgPSB0aGlzLnJlbWVtYmVyKCdfc2VsZWN0SGFuZGxlcicpIHx8IG5ldyBTZWxlY3RIYW5kbGVyKHRoaXMpO1xyXG5cclxuICAgICAgICAgIHNlbGVjdEhhbmRsZXIuaW5pdCh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHZhbHVlLCBvcHRpb25zIHx8IHt9KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgIH1cclxuICB9KTtcclxuXHJcbiAgU1ZHLkVsZW1lbnQucHJvdG90eXBlLnNlbGVjdGl6ZS5kZWZhdWx0cyA9IHtcclxuICAgICAgcG9pbnRzOiBbJ2x0JywgJ3J0JywgJ3JiJywgJ2xiJywgJ3QnLCAncicsICdiJywgJ2wnXSwgICAgLy8gd2hpY2ggcG9pbnRzIHRvIGRyYXcsIGRlZmF1bHQgYWxsXHJcbiAgICAgIHBvaW50c0V4Y2x1ZGU6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzaWVyIG9wdGlvbiBpZiB0byBleGNsdWRlIGZldyB0aGFuIHJld3JpdGUgYWxsXHJcbiAgICAgIGNsYXNzUmVjdDogJ3N2Z19zZWxlY3RfYm91bmRpbmdSZWN0JywgICAgLy8gQ3NzLWNsYXNzIGFkZGVkIHRvIHRoZSByZWN0XHJcbiAgICAgIGNsYXNzUG9pbnRzOiAnc3ZnX3NlbGVjdF9wb2ludHMnLCAgICAgICAgLy8gQ3NzLWNsYXNzIGFkZGVkIHRvIHRoZSBwb2ludHNcclxuICAgICAgcG9pbnRTaXplOiA3LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaXplIG9mIHBvaW50XHJcbiAgICAgIHJvdGF0aW9uUG9pbnQ6IHRydWUsICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJ1ZSwgcm90YXRpb24gcG9pbnQgaXMgZHJhd24uIE5lZWRlZCBmb3Igcm90YXRpb24hXHJcbiAgICAgIGRlZXBTZWxlY3Q6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJ1ZSwgbW92aW5nIG9mIHNpbmdsZSBwb2ludHMgaXMgcG9zc2libGUgKG9ubHkgbGluZSwgcG9seWxpbmUsIHBvbHlvbilcclxuICAgICAgcG9pbnRUeXBlOiAnY2lyY2xlJyAgICAgICAgICAgICAgICAgICAgICAvLyBQb2ludCB0eXBlOiBjaXJjbGUgb3IgcmVjdCwgZGVmYXVsdCBjaXJjbGVcclxuICB9O1xuICB9KCkpO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXIoZWwpIHtcclxuXHJcbiAgICAgICAgICBlbC5yZW1lbWJlcignX3Jlc2l6ZUhhbmRsZXInLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmVsID0gZWw7XHJcbiAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZUNhbGwgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5wID0gZWwuZG9jKCkubm9kZS5jcmVhdGVTVkdQb2ludCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKHgsIHksIG0pe1xyXG5cclxuICAgICAgICAgIHRoaXMucC54ID0geCAtICh0aGlzLm9mZnNldC54IC0gd2luZG93LnBhZ2VYT2Zmc2V0KTtcclxuICAgICAgICAgIHRoaXMucC55ID0geSAtICh0aGlzLm9mZnNldC55IC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wLm1hdHJpeFRyYW5zZm9ybShtIHx8IHRoaXMubSk7XHJcblxyXG4gICAgICB9O1xyXG5cclxuICAgICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuX2V4dHJhY3RQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAvLyBFeHRyYWN0IGEgcG9zaXRpb24gZnJvbSBhIG1vdXNlL3RvdWNoIGV2ZW50LlxyXG4gICAgICAgICAgLy8gUmV0dXJucyB7IHg6IC4uLCB5OiAuLiB9XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFggIT0gbnVsbCA/IGV2ZW50LmNsaWVudFggOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFgsXHJcbiAgICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WSAhPSBudWxsID8gZXZlbnQuY2xpZW50WSA6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gJ3N0b3AnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG5cclxuICAgICAgICAgIC8vIE1lcmdlIG9wdGlvbnMgYW5kIGRlZmF1bHRzXHJcbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZWwucmVzaXplLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID0gdGhpcy5lbC5yZXNpemUuZGVmYXVsdHNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2ldICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBXZSBsaXN0ZW4gdG8gYWxsIHRoZXNlIGV2ZW50cyB3aGljaCBhcmUgc3BlY2lmeWluZyBkaWZmZXJlbnQgZWRnZXNcclxuICAgICAgICAgIHRoaXMuZWwub24oJ2x0LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgIC8vIExlZnQtVG9wXHJcbiAgICAgICAgICB0aGlzLmVsLm9uKCdydC5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBSaWdodC1Ub3BcclxuICAgICAgICAgIHRoaXMuZWwub24oJ3JiLnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgIC8vIFJpZ2h0LUJvdHRvbVxyXG4gICAgICAgICAgdGhpcy5lbC5vbignbGIucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgLy8gTGVmdC1Cb3R0b21cclxuXHJcbiAgICAgICAgICB0aGlzLmVsLm9uKCd0LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgICAvLyBUb3BcclxuICAgICAgICAgIHRoaXMuZWwub24oJ3IucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIFJpZ2h0XHJcbiAgICAgICAgICB0aGlzLmVsLm9uKCdiLnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgICAvLyBCb3R0b21cclxuICAgICAgICAgIHRoaXMuZWwub24oJ2wucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIExlZnRcclxuXHJcbiAgICAgICAgICB0aGlzLmVsLm9uKCdyb3QucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAvLyBSb3RhdGlvblxyXG5cclxuICAgICAgICAgIHRoaXMuZWwub24oJ3BvaW50LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgLy8gUG9pbnQtTW92aW5nXHJcblxyXG4gICAgICAgICAgLy8gVGhpcyBjYWxsIGVuc3VyZXMsIHRoYXQgdGhlIHBsdWdpbiByZWFjdHMgdG8gYSBjaGFuZ2Ugb2Ygc25hcFRvR3JpZCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHRoaXMuZWwub2ZmKCdsdC5yZXNpemUnKTtcclxuICAgICAgICAgIHRoaXMuZWwub2ZmKCdydC5yZXNpemUnKTtcclxuICAgICAgICAgIHRoaXMuZWwub2ZmKCdyYi5yZXNpemUnKTtcclxuICAgICAgICAgIHRoaXMuZWwub2ZmKCdsYi5yZXNpemUnKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmVsLm9mZigndC5yZXNpemUnKTtcclxuICAgICAgICAgIHRoaXMuZWwub2ZmKCdyLnJlc2l6ZScpO1xyXG4gICAgICAgICAgdGhpcy5lbC5vZmYoJ2IucmVzaXplJyk7XHJcbiAgICAgICAgICB0aGlzLmVsLm9mZignbC5yZXNpemUnKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmVsLm9mZigncm90LnJlc2l6ZScpO1xyXG5cclxuICAgICAgICAgIHRoaXMuZWwub2ZmKCdwb2ludC5yZXNpemUnKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfTtcclxuXHJcbiAgICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgdGhpcy5tID0gdGhpcy5lbC5ub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKTtcclxuICAgICAgICAgIHRoaXMub2Zmc2V0ID0geyB4OiB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB9O1xyXG5cclxuICAgICAgICAgIHZhciB0eFB0ID0gdGhpcy5fZXh0cmFjdFBvc2l0aW9uKGV2ZW50LmRldGFpbC5ldmVudCk7XHJcbiAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgICAgICAgdHlwZTogdGhpcy5lbC50eXBlLCAvLyB0aGUgdHlwZSBvZiBlbGVtZW50XHJcbiAgICAgICAgICAgICAgcDogdGhpcy50cmFuc2Zvcm1Qb2ludCh0eFB0LngsIHR4UHQueSksXHJcbiAgICAgICAgICAgICAgeDogZXZlbnQuZGV0YWlsLngsICAgICAgLy8geC1wb3NpdGlvbiBvZiB0aGUgbW91c2Ugd2hlbiByZXNpemluZyBzdGFydGVkXHJcbiAgICAgICAgICAgICAgeTogZXZlbnQuZGV0YWlsLnksICAgICAgLy8geS1wb3NpdGlvbiBvZiB0aGUgbW91c2Ugd2hlbiByZXNpemluZyBzdGFydGVkXHJcbiAgICAgICAgICAgICAgYm94OiB0aGlzLmVsLmJib3goKSwgICAgLy8gVGhlIGJvdW5kaW5nLWJveCBvZiB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLmVsLnRyYW5zZm9ybSgpLnJvdGF0aW9uICAvLyBUaGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgZm9udC1zaXplIHBhcmFtZXRlciBpZiB0aGUgZWxlbWVudCB0eXBlIGlzIHRleHRcclxuICAgICAgICAgIGlmICh0aGlzLmVsLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmZvbnRTaXplID0gdGhpcy5lbC5hdHRyKClbXCJmb250LXNpemVcIl07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gdGhlIGktcGFyYW0gaW4gdGhlIGV2ZW50IGhvbGRzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnQgd2hpY2ggaXMgbW92ZWQsIHdoZW4gdXNpbmcgYGRlZXBTZWxlY3RgXHJcbiAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLmkgIT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBvaW50IGFycmF5XHJcbiAgICAgICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5lbC5hcnJheSgpLnZhbHVlT2YoKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgaW5kZXggYW5kIHRoZSBwb2ludCB3aGljaCBpcyBtb3ZlZFxyXG4gICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5pID0gZXZlbnQuZGV0YWlsLmk7XHJcbiAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzID0gW2FycmF5W2V2ZW50LmRldGFpbC5pXVswXSwgYXJyYXlbZXZlbnQuZGV0YWlsLmldWzFdXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBMZXRzIGNoZWNrIHdoaWNoIGVkZ2Ugb2YgdGhlIGJvdW5kaW5nLWJveCB3YXMgY2xpY2tlZCBhbmQgcmVzaXplIHRoZSB0aGlzLmVsIGFjY29yZGluZyB0byB0aGlzXHJcbiAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTGVmdC1Ub3AtRWRnZVxyXG4gICAgICAgICAgICAgIGNhc2UgJ2x0JzpcclxuICAgICAgICAgICAgICAgICAgLy8gV2UgYnVpbGQgYSBjYWxjdWxhdGluZyBmdW5jdGlvbiBmb3IgZXZlcnkgY2FzZSB3aGljaCBnaXZlcyB1cyB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSB0aGlzLmVsXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcm9jZWR1cmUgaXMgYWx3YXlzIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB3ZSBzbmFwIHRoZSBlZGdlIHRvIHRoZSBnaXZlbiBncmlkIChzbmFwcGluZyB0byAxcHggZ3JpZCBpcyBub3JtYWwgcmVzaXppbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBjaGVjayBpZiB0aGUgbmV3IGhlaWdodCBhbmQgd2lkdGggc3RpbGwgdmFsaWQgKD4gMClcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC0gc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmlmIHZhbGlkLCB3ZSByZXNpemUgdGhlIHRoaXMuZWwgKHdoaWNoIGNhbiBpbmNsdWRlIG1vdmluZyBiZWNhdXNlIHRoZSBjb29yZC1zeXN0ZW0gc3RhcnRzIGF0IHRoZSBsZWZ0LXRvcCBhbmQgdGhpcyBlZGdlIGlzIG1vdmluZyBzb21ldGltZXMgd2hlbiByZXNpemVkKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIGJ1dCBmaXJzdCBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyB0ZXh0IGJveCwgc28gd2UgY2FuIGNoYW5nZSB0aGUgZm9udCBzaXplIGluc3RlYWQgb2ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLmF0dHIoXCJmb250LXNpemVcIiwgdGhpcy5wYXJhbWV0ZXJzLmZvbnRTaXplIC0gc25hcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXAgPSB0aGlzLmNoZWNrQXNwZWN0UmF0aW8oc25hcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyBzbmFwWzFdKS5zaXplKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAtIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmlnaHQtVG9wXHJcbiAgICAgICAgICAgICAgY2FzZSAncnQnOlxyXG4gICAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMSA8PCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCAtIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3gueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgKyBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCwgdGhpcy5wYXJhbWV0ZXJzLmJveC55ICsgc25hcFsxXSkuc2l6ZSh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJpZ2h0LUJvdHRvbVxyXG4gICAgICAgICAgICAgIGNhc2UgJ3JiJzpcclxuICAgICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggKyBzbmFwWzBdID4gMCAmJiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5hdHRyKFwiZm9udC1zaXplXCIsIHRoaXMucGFyYW1ldGVycy5mb250U2l6ZSArIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzbmFwID0gdGhpcy5jaGVja0FzcGVjdFJhdGlvKHNuYXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54LCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpLnNpemUodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCArIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0ICsgc25hcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAvLyBMZWZ0LUJvdHRvbVxyXG4gICAgICAgICAgICAgIGNhc2UgJ2xiJzpcclxuICAgICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdID4gMCAmJiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5hdHRyKFwiZm9udC1zaXplXCIsIHRoaXMucGFyYW1ldGVycy5mb250U2l6ZSAtIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzbmFwID0gdGhpcy5jaGVja0FzcGVjdFJhdGlvKHNuYXAsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS5zaXplKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgLy8gVG9wXHJcbiAgICAgICAgICAgICAgY2FzZSAndCc6XHJcbiAgICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAxIDw8IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSBmb250LXJlc2l6aW5nIGlmIGl0IGlzIG5vdCBmcm9tIHRoZSBjb3JuZXIgb2YgYm91bmRpbmctYm94XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54LCB0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyBzbmFwWzFdKS5oZWlnaHQodGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJpZ2h0XHJcbiAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSkud2lkdGgodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCArIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgLy8gQm90dG9tXHJcbiAgICAgICAgICAgICAgY2FzZSAnYic6XHJcbiAgICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54LCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpLmhlaWdodCh0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgLy8gTGVmdFxyXG4gICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIHNuYXBbMF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS53aWR0aCh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC0gc25hcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSb3RhdGlvblxyXG4gICAgICAgICAgICAgIGNhc2UgJ3JvdCc6XHJcbiAgICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHllcyB0aGlzIGlzIGtpbmRhIHN0dXBpZCBidXQgd2UgbmVlZCB0aGUgbW91c2UgY29vcmRzIGJhY2suLi5cclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0ge3g6IGRpZmZYICsgdGhpcy5wYXJhbWV0ZXJzLnAueCwgeTogZGlmZlkgKyB0aGlzLnBhcmFtZXRlcnMucC55fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBtaW51cyBtaWRkbGVcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBzQW5nbGUgPSBNYXRoLmF0YW4yKCh0aGlzLnBhcmFtZXRlcnMucC55IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC55IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLyAyKSwgKHRoaXMucGFyYW1ldGVycy5wLnggLSB0aGlzLnBhcmFtZXRlcnMuYm94LnggLSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC8gMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGVuZCBtaW51cyBtaWRkbGVcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBwQW5nbGUgPSBNYXRoLmF0YW4yKChjdXJyZW50LnkgLSB0aGlzLnBhcmFtZXRlcnMuYm94LnkgLSB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAvIDIpLCAoY3VycmVudC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAvIDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLnBhcmFtZXRlcnMucm90YXRpb24gKyAocEFuZ2xlIC0gc0FuZ2xlKSAqIDE4MCAvIE1hdGguUEkgKyB0aGlzLm9wdGlvbnMuc25hcFRvQW5nbGUgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbW92ZSB0aGUgZWxlbWVudCB0byB0aGUgY2VudGVyIG9mIHRoZSBib3ggZmlyc3QgYW5kIGNoYW5nZSB0aGUgcm90YXRpb24gYWZ0ZXJ3YXJkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSByb3RhdGlvbiBhbHdheXMgd29ya3MgYXJvdW5kIGEgcm90YXRpb24tY2VudGVyLCB3aGljaCBpcyBjaGFuZ2VkIHdoZW4gbW92aW5nIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIHNldCB0aGUgbmV3IHJvdGF0aW9uIGNlbnRlciB0byB0aGUgY2VudGVyIG9mIHRoZSBib3guXHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLmNlbnRlcih0aGlzLnBhcmFtZXRlcnMuYm94LmN4LCB0aGlzLnBhcmFtZXRlcnMuYm94LmN5KS5yb3RhdGUoYW5nbGUgLSAoYW5nbGUgJSB0aGlzLm9wdGlvbnMuc25hcFRvQW5nbGUpLCB0aGlzLnBhcmFtZXRlcnMuYm94LmN4LCB0aGlzLnBhcmFtZXRlcnMuYm94LmN5KTtcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE1vdmluZyBvbmUgc2luZ2xlIFBvaW50IChuZWVkZWQgd2hlbiBhbiBlbGVtZW50IGlzIGRlZXBTZWxlY3RlZCB3aGljaCBtZWFucyB5b3UgY2FuIG1vdmUgZXZlcnkgc2luZ2xlIHBvaW50IG9mIHRoZSBvYmplY3QpXHJcbiAgICAgICAgICAgICAgY2FzZSAncG9pbnQnOlxyXG4gICAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHBpbmcgdGhlIHBvaW50IHRvIHRoZSBncmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIHRoaXMucGFyYW1ldGVycy5wb2ludENvb3Jkc1swXSwgdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBvaW50IGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmVsLmFycmF5KCkudmFsdWVPZigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBtb3ZlZCBwb2ludCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3RoaXMucGFyYW1ldGVycy5pXVswXSA9IHRoaXMucGFyYW1ldGVycy5wb2ludENvb3Jkc1swXSArIHNuYXBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICBhcnJheVt0aGlzLnBhcmFtZXRlcnMuaV1bMV0gPSB0aGlzLnBhcmFtZXRlcnMucG9pbnRDb29yZHNbMV0gKyBzbmFwWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCBwbG90IHRoZSBuZXcgdGhpcy5lbFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5wbG90KGFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLmVsLmZpcmUoJ3Jlc2l6ZXN0YXJ0Jywge2R4OiB0aGlzLnBhcmFtZXRlcnMueCwgZHk6IHRoaXMucGFyYW1ldGVycy55LCBldmVudDogZXZlbnR9KTtcclxuICAgICAgICAgIC8vIFdoZW4gcmVzaXppbmcgc3RhcnRlZCwgd2UgaGF2ZSB0byByZWdpc3RlciBldmVudHMgZm9yLi4uXHJcbiAgICAgICAgICAvLyBUb3VjaGVzLlxyXG4gICAgICAgICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNobW92ZS5yZXNpemUnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKGUgfHwgd2luZG93LmV2ZW50KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNoZW5kLnJlc2l6ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIF90aGlzLmRvbmUoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgLy8gTW91c2UuXHJcbiAgICAgICAgICBTVkcub24od2luZG93LCAnbW91c2Vtb3ZlLnJlc2l6ZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKGUgfHwgd2luZG93LmV2ZW50KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgU1ZHLm9uKHdpbmRvdywgJ21vdXNldXAucmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIF90aGlzLmRvbmUoKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFRoZSB1cGRhdGUtZnVuY3Rpb24gcmVkcmF3cyB0aGUgZWxlbWVudCBldmVyeSB0aW1lIHRoZSBtb3VzZSBpcyBtb3ZpbmdcclxuICAgICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFldmVudCkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RVcGRhdGVDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FsYyh0aGlzLmxhc3RVcGRhdGVDYWxsWzBdLCB0aGlzLmxhc3RVcGRhdGVDYWxsWzFdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBtb3VzZXBvc2l0aW9uIGF0IHN0YXJ0IGFuZCBub3dcclxuICAgICAgICAgIHZhciB0eFB0ID0gdGhpcy5fZXh0cmFjdFBvc2l0aW9uKGV2ZW50KTtcclxuICAgICAgICAgIHZhciBwID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh0eFB0LngsIHR4UHQueSk7XHJcblxyXG4gICAgICAgICAgdmFyIGRpZmZYID0gcC54IC0gdGhpcy5wYXJhbWV0ZXJzLnAueCxcclxuICAgICAgICAgICAgICBkaWZmWSA9IHAueSAtIHRoaXMucGFyYW1ldGVycy5wLnk7XHJcblxyXG4gICAgICAgICAgdGhpcy5sYXN0VXBkYXRlQ2FsbCA9IFtkaWZmWCwgZGlmZlldO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHBvc2l0aW9uIGFuZCBoZWlnaHQgLyB3aWR0aCBvZiB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgdGhpcy5jYWxjKGRpZmZYLCBkaWZmWSk7XHJcblxyXG4gICAgICAgICAvLyBFbWl0IGFuIGV2ZW50IHRvIHNheSB3ZSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICB0aGlzLmVsLmZpcmUoJ3Jlc2l6aW5nJywge2R4OiBkaWZmWCwgZHk6IGRpZmZZLCBldmVudDogZXZlbnR9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIElzIGNhbGxlZCBvbiBtb3VzZXVwLlxyXG4gICAgICAvLyBSZW1vdmVzIHRoZSB1cGRhdGUtZnVuY3Rpb24gZnJvbSB0aGUgbW91c2Vtb3ZlIGV2ZW50XHJcbiAgICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVDYWxsID0gbnVsbDtcclxuICAgICAgICAgIFNWRy5vZmYod2luZG93LCAnbW91c2Vtb3ZlLnJlc2l6ZScpO1xyXG4gICAgICAgICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZXVwLnJlc2l6ZScpO1xyXG4gICAgICAgICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaG1vdmUucmVzaXplJyk7XHJcbiAgICAgICAgICBTVkcub2ZmKHdpbmRvdywgJ3RvdWNoZW5kLnJlc2l6ZScpO1xyXG4gICAgICAgICAgdGhpcy5lbC5maXJlKCdyZXNpemVkb25lJyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBUaGUgZmxhZyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSByZXNpemluZyBpcyB1c2VkIHdpdGggYSBsZWZ0LVBvaW50IChmaXJzdCBiaXQpIGFuZCB0b3AtcG9pbnQgKHNlY29uZCBiaXQpXHJcbiAgICAgIC8vIEluIHRoaXMgY2FzZXMgdGhlIHRlbXAtdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGRpZmZlcmVudGx5XHJcbiAgICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLnNuYXBUb0dyaWQgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZLCBmbGFnLCBwb2ludENvb3Jkc1kpIHtcclxuXHJcbiAgICAgICAgICB2YXIgdGVtcDtcclxuXHJcbiAgICAgICAgICAvLyBJZiBgcG9pbnRDb29yZHNZYCBpcyBnaXZlbiwgYSBzaW5nbGUgUG9pbnQgaGFzIHRvIGJlIHNuYXBwZWQgKGRlZXBTZWxlY3QpLiBUaGF0J3Mgd2h5IHdlIG5lZWQgYSBkaWZmZXJlbnQgdGVtcC12YWx1ZVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBwb2ludENvb3Jkc1kgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGZsYWcgPSBwb2ludENvb3Jkc1ggaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgICAgdGVtcCA9IFsoZmxhZyArIGRpZmZYKSAlIHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkLCAocG9pbnRDb29yZHNZICsgZGlmZlkpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWRdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBXZSBjaGVjayBpZiB0aGUgZmxhZyBpcyBzZXQgYW5kIGlmIG5vdCB3ZSBzZXQgYSBkZWZhdWx0LXZhbHVlIChib3RoIGJpdHMgc2V0IC0gd2hpY2ggbWVhbnMgdXBwZXItbGVmdC1lZGdlKVxyXG4gICAgICAgICAgICAgIGZsYWcgPSBmbGFnID09IG51bGwgPyAxIHwgMSA8PCAxIDogZmxhZztcclxuICAgICAgICAgICAgICB0ZW1wID0gWyh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBkaWZmWCArIChmbGFnICYgMSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoKSkgJSB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZCwgKHRoaXMucGFyYW1ldGVycy5ib3gueSArIGRpZmZZICsgKGZsYWcgJiAoMSA8PCAxKSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCkpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWRdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmKGRpZmZYIDwgMCkge1xyXG4gICAgICAgICAgICAgIHRlbXBbMF0gLT0gdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihkaWZmWSA8IDApIHtcclxuICAgICAgICAgICAgICB0ZW1wWzFdIC09IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRpZmZYIC09IChNYXRoLmFicyh0ZW1wWzBdKSA8IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkIC8gMiA/XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFswXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFswXSAtIChkaWZmWCA8IDAgPyAtdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQgOiB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZCkpO1xyXG4gICAgICAgICAgZGlmZlkgLT0gKE1hdGguYWJzKHRlbXBbMV0pIDwgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQgLyAyID9cclxuICAgICAgICAgICAgICAgICAgICB0ZW1wWzFdIDpcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wWzFdIC0gKGRpZmZZIDwgMCA/IC10aGlzLm9wdGlvbnMuc25hcFRvR3JpZCA6IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkKSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludFRvQm94KGRpZmZYLCBkaWZmWSwgZmxhZywgcG9pbnRDb29yZHNZKTtcclxuXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBrZWVwIGVsZW1lbnQgd2l0aGluIGNvbnN0cmFpbmVkIGJveFxyXG4gICAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJhaW50VG9Cb3ggPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZLCBmbGFnLCBwb2ludENvb3Jkc1kpIHtcclxuICAgICAgICAgIC8vcmV0dXJuIFtkaWZmWCwgZGlmZlldXHJcbiAgICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucy5jb25zdHJhaW50IHx8IHt9O1xyXG4gICAgICAgICAgdmFyIG9yZ1gsIG9yZ1k7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBwb2ludENvb3Jkc1kgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIG9yZ1ggPSBmbGFnO1xyXG4gICAgICAgICAgICBvcmdZID0gcG9pbnRDb29yZHNZO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3JnWCA9IHRoaXMucGFyYW1ldGVycy5ib3gueCArIChmbGFnICYgMSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoKTtcclxuICAgICAgICAgICAgb3JnWSA9IHRoaXMucGFyYW1ldGVycy5ib3gueSArIChmbGFnICYgKDE8PDEpID8gMCA6IHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGMubWluWCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWCArIGRpZmZYIDwgYy5taW5YKSB7XHJcbiAgICAgICAgICAgIGRpZmZYID0gYy5taW5YIC0gb3JnWDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGMubWF4WCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWCArIGRpZmZYID4gYy5tYXhYKSB7XHJcbiAgICAgICAgICAgIGRpZmZYID0gYy5tYXhYIC0gb3JnWDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGMubWluWSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWSArIGRpZmZZIDwgYy5taW5ZKSB7XHJcbiAgICAgICAgICAgIGRpZmZZID0gYy5taW5ZIC0gb3JnWTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGMubWF4WSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWSArIGRpZmZZID4gYy5tYXhZKSB7XHJcbiAgICAgICAgICAgIGRpZmZZID0gYy5tYXhZIC0gb3JnWTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gW2RpZmZYLCBkaWZmWV07XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5jaGVja0FzcGVjdFJhdGlvID0gZnVuY3Rpb24gKHNuYXAsIGlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2F2ZUFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIHVwZGF0ZWRTbmFwID0gc25hcC5zbGljZSgpO1xyXG4gICAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAvIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0O1xyXG4gICAgICAgICAgdmFyIG5ld1cgPSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXTtcclxuICAgICAgICAgIHZhciBuZXdIID0gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdO1xyXG4gICAgICAgICAgdmFyIG5ld0FzcGVjdFJhdGlvID0gbmV3VyAvIG5ld0g7XHJcblxyXG4gICAgICAgICAgaWYgKG5ld0FzcGVjdFJhdGlvIDwgYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgICAvLyBIZWlnaHQgaXMgdG9vIGJpZy4gQWRhcHQgaXRcclxuICAgICAgICAgICAgICB1cGRhdGVkU25hcFsxXSA9IG5ld1cgLyBhc3BlY3RSYXRpbyAtIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0O1xyXG4gICAgICAgICAgICAgIGlzUmV2ZXJzZSAmJiAodXBkYXRlZFNuYXBbMV0gPSAtdXBkYXRlZFNuYXBbMV0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdBc3BlY3RSYXRpbyA+IGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2lkdGggaXMgdG9vIGJpZy4gQWRhcHQgaXRcclxuICAgICAgICAgICAgICB1cGRhdGVkU25hcFswXSA9IHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBuZXdIICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgaXNSZXZlcnNlICYmICh1cGRhdGVkU25hcFswXSA9IC11cGRhdGVkU25hcFswXSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWRTbmFwO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gICAgICAgICAgLy8gUmVzaXplIGVsZW1lbnQgd2l0aCBtb3VzZVxyXG4gICAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgICAodGhpcy5yZW1lbWJlcignX3Jlc2l6ZUhhbmRsZXInKSB8fCBuZXcgUmVzaXplSGFuZGxlcih0aGlzKSkuaW5pdChvcHRpb25zIHx8IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBTVkcuRWxlbWVudC5wcm90b3R5cGUucmVzaXplLmRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgc25hcFRvQW5nbGU6IDAuMSwgICAgICAgLy8gU3BlY2lmaWVzIHRoZSBzcGVlZCB0aGUgcm90YXRpb24gaXMgaGFwcGVuaW5nIHdoZW4gbW92aW5nIHRoZSBtb3VzZVxyXG4gICAgICAgICAgc25hcFRvR3JpZDogMSwgICAgICAgICAgLy8gU25hcHMgdG8gYSBncmlkIG9mIGBzbmFwVG9HcmlkYCBQaXhlbHNcclxuICAgICAgICAgIGNvbnN0cmFpbnQ6IHt9LCAgICAgICAgIC8vIGtlZXAgZWxlbWVudCB3aXRoaW4gY29uc3RyYWluZWQgYm94XHJcbiAgICAgICAgICBzYXZlQXNwZWN0UmF0aW86IGZhbHNlICAvLyBTYXZlIGFzcGVjdCByYXRpbyB3aGVuIHJlc2l6aW5nIHVzaW5nIGx0LCBydCwgcmIgb3IgbGIgcG9pbnRzXHJcbiAgICAgIH07XHJcblxyXG4gIH0pLmNhbGwodGhpcyk7XG4gIH0oKSk7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cuQXBleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuQXBleCA9IHt9O1xuICB9XG5cbiAgdmFyIEluaXRDdHhWYXJpYWJsZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluaXRDdHhWYXJpYWJsZXMoY3R4KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5pdEN0eFZhcmlhYmxlcyk7XG5cbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEluaXRDdHhWYXJpYWJsZXMsIFt7XG4gICAgICBrZXk6IFwiaW5pdE1vZHVsZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0TW9kdWxlcygpIHtcbiAgICAgICAgdGhpcy5jdHgucHVibGljTWV0aG9kcyA9IFsndXBkYXRlT3B0aW9ucycsICd1cGRhdGVTZXJpZXMnLCAnYXBwZW5kRGF0YScsICdyZXBsYWNlRGF0YScgLCAnYXBwZW5kU2VyaWVzJywgJ2lzU2VyaWVzSGlkZGVuJywgJ3RvZ2dsZVNlcmllcycsICdzaG93U2VyaWVzJywgJ2hpZGVTZXJpZXMnLCAnc2V0TG9jYWxlJywgJ3Jlc2V0U2VyaWVzJywgJ3pvb21YJywgJ3RvZ2dsZURhdGFQb2ludFNlbGVjdGlvbicsICdkYXRhVVJJJywgJ2V4cG9ydFRvQ1NWJywgJ2FkZFhheGlzQW5ub3RhdGlvbicsICdhZGRZYXhpc0Fubm90YXRpb24nLCAnYWRkUG9pbnRBbm5vdGF0aW9uJywgJ2NsZWFyQW5ub3RhdGlvbnMnLCAncmVtb3ZlQW5ub3RhdGlvbicsICdwYXBlcicsICdkZXN0cm95J107XG4gICAgICAgIHRoaXMuY3R4LmV2ZW50TGlzdCA9IFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZWxlYXZlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNobGVhdmUnLCAnbW91c2V1cCcsICd0b3VjaGVuZCddO1xuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC5heGVzID0gbmV3IEF4ZXModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC5jb3JlID0gbmV3IENvcmUodGhpcy5jdHguZWwsIHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5jdHguY29uZmlnID0gbmV3IENvbmZpZyh7fSk7XG4gICAgICAgIHRoaXMuY3R4LmRhdGEgPSBuZXcgRGF0YSh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LmdyaWQgPSBuZXcgR3JpZCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LmdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5jdHguY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LmNyb3NzaGFpcnMgPSBuZXcgQ3Jvc3NoYWlycyh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LmV2ZW50cyA9IG5ldyBFdmVudHModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC5leHBvcnRzID0gbmV3IEV4cG9ydHModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC5sb2NhbGl6YXRpb24gPSBuZXcgTG9jYWxpemF0aW9uKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5jdHgub3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuY3R4LnJlc3BvbnNpdmUgPSBuZXcgUmVzcG9uc2l2ZSh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LnNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC50aGVtZSA9IG5ldyBUaGVtZSh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LmZvcm1hdHRlcnMgPSBuZXcgRm9ybWF0dGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LnRpdGxlU3VidGl0bGUgPSBuZXcgVGl0bGVTdWJ0aXRsZSh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC50b29sYmFyID0gbmV3IFRvb2xiYXIodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC50b29sdGlwID0gbmV3IFRvb2x0aXAodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC5kaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC51cGRhdGVIZWxwZXJzID0gbmV3IFVwZGF0ZUhlbHBlcnModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC56b29tUGFuU2VsZWN0aW9uID0gbmV3IFpvb21QYW5TZWxlY3Rpb24odGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC53Lmdsb2JhbHMudG9vbHRpcCA9IG5ldyBUb29sdGlwKHRoaXMuY3R4KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5pdEN0eFZhcmlhYmxlcztcbiAgfSgpO1xuXG4gIHZhciBEZXN0cm95ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXN0cm95KGN0eCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlc3Ryb3kpO1xuXG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHRoaXMudyA9IGN0eC53O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEZXN0cm95LCBbe1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoX3JlZikge1xuICAgICAgICB2YXIgaXNVcGRhdGluZyA9IF9yZWYuaXNVcGRhdGluZztcblxuICAgICAgICBpZiAodGhpcy5jdHguem9vbVBhblNlbGVjdGlvbikge1xuICAgICAgICAgIHRoaXMuY3R4Lnpvb21QYW5TZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3R4LnRvb2xiYXIpIHtcbiAgICAgICAgICB0aGlzLmN0eC50b29sYmFyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC5heGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdHguYW5ub3RhdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC5jb3JlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdHguZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4LmdyaWQgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC5zZXJpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC5yZXNwb25zaXZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdHgudGhlbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC5mb3JtYXR0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdHgudGl0bGVTdWJ0aXRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4LmxlZ2VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4LmRpbWVuc2lvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC5vcHRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdHguY3Jvc3NoYWlycyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4Lnpvb21QYW5TZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC51cGRhdGVIZWxwZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdHgudG9vbGJhciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4LmxvY2FsaXphdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4LncuZ2xvYmFscy50b29sdGlwID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGVhckRvbUVsZW1lbnRzKHtcbiAgICAgICAgICBpc1VwZGF0aW5nOiBpc1VwZGF0aW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJraWxsU1ZHXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbFNWRyhkcmF3KSB7XG4gICAgICAgIGRyYXcuZWFjaChmdW5jdGlvbiAoaSwgY2hpbGRyZW4pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCcqJyk7XG4gICAgICAgICAgdGhpcy5vZmYoKTtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIGRyYXcudW5ncm91cCgpO1xuICAgICAgICBkcmF3LmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyRG9tRWxlbWVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckRvbUVsZW1lbnRzKF9yZWYyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGlzVXBkYXRpbmcgPSBfcmVmMi5pc1VwZGF0aW5nO1xuICAgICAgICB2YXIgZWxTVkcgPSB0aGlzLncuZ2xvYmFscy5kb20uUGFwZXIubm9kZTsgLy8gZml4ZXMgYXBleGNoYXJ0cy5qcyMxNjU0ICYgdnVlLWFwZXhjaGFydHMjMjU2XG5cbiAgICAgICAgaWYgKGVsU1ZHLnBhcmVudE5vZGUgJiYgZWxTVkcucGFyZW50Tm9kZS5wYXJlbnROb2RlICYmICFpc1VwZGF0aW5nKSB7XG4gICAgICAgICAgZWxTVkcucGFyZW50Tm9kZS5wYXJlbnROb2RlLnN0eWxlLm1pbkhlaWdodCA9ICd1bnNldCc7XG4gICAgICAgIH0gLy8gZGV0YWNoIHJvb3QgZXZlbnRcblxuXG4gICAgICAgIHZhciBiYXNlRWwgPSB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsO1xuXG4gICAgICAgIGlmIChiYXNlRWwpIHtcbiAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FwZXhjaGFydHMvdnVlLWFwZXhjaGFydHMvaXNzdWVzLzI3NVxuICAgICAgICAgIHRoaXMuY3R4LmV2ZW50TGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgYmFzZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmN0eC5ldmVudHMuZG9jdW1lbnRFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9tRWxzID0gdGhpcy53Lmdsb2JhbHMuZG9tO1xuXG4gICAgICAgIGlmICh0aGlzLmN0eC5lbCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBhbGwgY2hpbGQgZWxlbWVudHMgLSByZXNldHRpbmcgdGhlIHdob2xlIGNoYXJ0XG4gICAgICAgICAgd2hpbGUgKHRoaXMuY3R4LmVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmVsLnJlbW92ZUNoaWxkKHRoaXMuY3R4LmVsLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMua2lsbFNWRyhkb21FbHMuUGFwZXIpO1xuICAgICAgICBkb21FbHMuUGFwZXIucmVtb3ZlKCk7XG4gICAgICAgIGRvbUVscy5lbFdyYXAgPSBudWxsO1xuICAgICAgICBkb21FbHMuZWxHcmFwaGljYWwgPSBudWxsO1xuICAgICAgICBkb21FbHMuZWxMZWdlbmRXcmFwID0gbnVsbDtcbiAgICAgICAgZG9tRWxzLmVsTGVnZW5kRm9yZWlnbiA9IG51bGw7XG4gICAgICAgIGRvbUVscy5iYXNlRWwgPSBudWxsO1xuICAgICAgICBkb21FbHMuZWxHcmlkUmVjdCA9IG51bGw7XG4gICAgICAgIGRvbUVscy5lbEdyaWRSZWN0TWFzayA9IG51bGw7XG4gICAgICAgIGRvbUVscy5lbEdyaWRSZWN0TWFya2VyTWFzayA9IG51bGw7XG4gICAgICAgIGRvbUVscy5lbEZvcmVjYXN0TWFzayA9IG51bGw7XG4gICAgICAgIGRvbUVscy5lbE5vbkZvcmVjYXN0TWFzayA9IG51bGw7XG4gICAgICAgIGRvbUVscy5lbERlZnMgPSBudWxsO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEZXN0cm95O1xuICB9KCk7XG5cbiAgLy8gSGVscGVycyB0byByZWFjdCB0byBlbGVtZW50IHJlc2l6ZXMsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBjYXVzZWQgdGhlbVxuICAvLyBUT0RPIEN1cnJlbnRseSB0aGlzIGNyZWF0ZXMgYSBuZXcgUmVzaXplT2JzZXJ2ZXIgZXZlcnkgdGltZSB3ZSB3YW50IHRvIG9ic2VydmUgYW4gZWxlbWVudCBmb3IgcmVzaXplc1xuICAvLyBJZGVhbGx5LCB3ZSBzaG91bGQgYmUgYWJsZSB0byB1c2UgYSBzaW5nbGUgb2JzZXJ2ZXIgZm9yIGFsbCBlbGVtZW50c1xuICB2YXIgcm9zID0gbmV3IFdlYWtNYXAoKTsgLy8gTWFwIGNhbGxiYWNrcyB0byBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMgZm9yIGVhc3kgcmVtb3ZhbFxuXG4gIGZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKGVsLCBmbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgIGlmIChlbC5ub2RlVHlwZSAhPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgZWxSZWN0LndpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIGlmIGVsUmVjdC53aWR0aD0wLCB0aGUgY2hhcnQgaXMgbm90IHJlbmRlcmVkIGF0IGFsbFxuICAgICAgICAvLyAoaXQgaGFzIGVpdGhlciBkaXNwbGF5IG5vbmUgb3IgaGlkZGVuIGluIGEgZGlmZmVyZW50IHRhYilcbiAgICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2FwZXhjaGFydHMvYXBleGNoYXJ0cy5qcy9pc3N1ZXMvMjgyNVxuICAgICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy8yOTkxXG4gICAgICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzI5OTJcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIC8vIFJPcyBmaXJlIGltbWVkaWF0ZWx5IGFmdGVyIGJlaW5nIGNyZWF0ZWQsXG4gICAgICAvLyBwZXIgc3BlYzogaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3Jlc2l6ZS1vYnNlcnZlci8jcmVmLWZvci1lbGVtZW50JUUyJTkxJUEzXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IHRoYXQgc28gd2UganVzdCBkaXNjYXJkIHRoZSBmaXJzdCBydW5cbiAgICAgIGlmIChjYWxsZWQpIHtcbiAgICAgICAgZm4uY2FsbChlbCwgcik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgLy8gRG9jdW1lbnQgZnJhZ21lbnQsIG9ic2VydmUgY2hpbGRyZW4gaW5zdGVhZCAobmVlZGVkIGZvciBTaGFkb3cgRE9NLCBzZWUgIzEzMzIpXG4gICAgICBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiByby5vYnNlcnZlKGMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvLm9ic2VydmUoZWwpO1xuICAgIH1cblxuICAgIHJvcy5zZXQoZm4sIHJvKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZXNpemVMaXN0ZW5lcihlbCwgZm4pIHtcbiAgICB2YXIgcm8gPSByb3MuZ2V0KGZuKTtcblxuICAgIGlmIChybykge1xuICAgICAgcm8uZGlzY29ubmVjdCgpO1xuICAgICAgcm9zLmRlbGV0ZShmbik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNzc18yNDh6ID0gXCJAa2V5ZnJhbWVzIG9wYXF1ZSB7XFxuICAwJSB7XFxuICAgICAgb3BhY2l0eTogMFxcbiAgfVxcblxcbiAgdG8ge1xcbiAgICAgIG9wYWNpdHk6IDFcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyByZXNpemVhbmltIHtcXG4gIDAlLHRvIHtcXG4gICAgICBvcGFjaXR5OiAwXFxuICB9XFxufVxcblxcbi5hcGV4Y2hhcnRzLWNhbnZhcyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1jYW52YXMgOjotd2Via2l0LXNjcm9sbGJhciB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICB3aWR0aDogNnB4XFxufVxcblxcbi5hcGV4Y2hhcnRzLWNhbnZhcyA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsLjUpO1xcbiAgYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDI1NSwyNTUsMjU1LC41KTtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDI1NSwyNTUsMjU1LC41KVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1pbm5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmVcXG59XFxuXFxuLmFwZXhjaGFydHMtdGV4dCB0c3BhbiB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdFxcbn1cXG5cXG4ubGVnZW5kLW1vdXNlb3Zlci1pbmFjdGl2ZSB7XFxuICB0cmFuc2l0aW9uOiAuMTVzIGVhc2UgYWxsO1xcbiAgb3BhY2l0eTogLjJcXG59XFxuXFxuLmFwZXhjaGFydHMtbGVnZW5kLXRleHQge1xcbiAgcGFkZGluZy1sZWZ0OiAxNXB4O1xcbiAgbWFyZ2luLWxlZnQ6IC0xNXB4O1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkIHtcXG4gIG9wYWNpdHk6IDBcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcCB7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBib3gtc2hhZG93OiAycHggMnB4IDZweCAtNHB4ICM5OTk7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBsZWZ0OiA2MnB4O1xcbiAgb3BhY2l0eTogMDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAyMHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHotaW5kZXg6IDEyO1xcbiAgdHJhbnNpdGlvbjogLjE1cyBlYXNlIGFsbFxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLmFwZXhjaGFydHMtYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDE7XFxuICB0cmFuc2l0aW9uOiAuMTVzIGVhc2UgYWxsXFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAuYXBleGNoYXJ0cy10aGVtZS1saWdodCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZTNlM2UzO1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwuOTYpXFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAuYXBleGNoYXJ0cy10aGVtZS1kYXJrIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgYmFja2dyb3VuZDogcmdiYSgzMCwzMCwzMCwuOClcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcCAqIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGl0bGUge1xcbiAgcGFkZGluZzogNnB4O1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgbWFyZ2luLWJvdHRvbTogNHB4XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAuYXBleGNoYXJ0cy10aGVtZS1saWdodCAuYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlIHtcXG4gIGJhY2tncm91bmQ6ICNlY2VmZjE7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZFxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLmFwZXhjaGFydHMtdGhlbWUtZGFyayAuYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsLjcpO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICMzMzNcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LWdvYWxzLXZhbHVlLC5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC15LXZhbHVlLC5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBmb250LXdlaWdodDogNjAwXFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1nb2Fscy1sYWJlbDplbXB0eSwuYXBleGNoYXJ0cy10b29sdGlwLXRleHQtZ29hbHMtdmFsdWU6ZW1wdHksLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXktbGFiZWw6ZW1wdHksLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXktdmFsdWU6ZW1wdHksLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXotdmFsdWU6ZW1wdHksLmFwZXhjaGFydHMtdG9vbHRpcC10aXRsZTplbXB0eSB7XFxuICBkaXNwbGF5OiBub25lXFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1nb2Fscy1sYWJlbCwuYXBleGNoYXJ0cy10b29sdGlwLXRleHQtZ29hbHMtdmFsdWUge1xcbiAgcGFkZGluZzogNnB4IDAgNXB4XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtZ29hbHMtZ3JvdXAsLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LWdvYWxzLWxhYmVsLC5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1nb2Fscy12YWx1ZSB7XFxuICBkaXNwbGF5OiBmbGV4XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1nb2Fscy1sYWJlbDpub3QoOmVtcHR5KSwuYXBleGNoYXJ0cy10b29sdGlwLXRleHQtZ29hbHMtdmFsdWU6bm90KDplbXB0eSkge1xcbiAgbWFyZ2luLXRvcDogLTZweFxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLW1hcmtlciB7XFxuICB3aWR0aDogMTJweDtcXG4gIGhlaWdodDogMTJweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogMDtcXG4gIG1hcmdpbi1yaWdodDogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJVxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cCB7XFxuICBwYWRkaW5nOiAwIDEwcHg7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGp1c3RpZnktY29udGVudDogbGVmdDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXJcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAuYXBleGNoYXJ0cy1hY3RpdmUgLmFwZXhjaGFydHMtdG9vbHRpcC1tYXJrZXIge1xcbiAgb3BhY2l0eTogMVxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cC5hcGV4Y2hhcnRzLWFjdGl2ZSwuYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cDpsYXN0LWNoaWxkIHtcXG4gIHBhZGRpbmctYm90dG9tOiA0cHhcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAtaGlkZGVuIHtcXG4gIG9wYWNpdHk6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBhZGRpbmc6IDAhaW1wb3J0YW50XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAteS1ncm91cCB7XFxuICBwYWRkaW5nOiA2cHggMCA1cHhcXG59XFxuXFxuLmFwZXhjaGFydHMtY3VzdG9tLXRvb2x0aXAsLmFwZXhjaGFydHMtdG9vbHRpcC1ib3gge1xcbiAgcGFkZGluZzogNHB4IDhweFxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLWJveFBsb3Qge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLWJveD5kaXYge1xcbiAgbWFyZ2luOiA0cHggMFxcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLWJveCBzcGFuLnZhbHVlIHtcXG4gIGZvbnQtd2VpZ2h0OiA3MDBcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1yYW5nZWJhciB7XFxuICBwYWRkaW5nOiA1cHggOHB4XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtcmFuZ2ViYXIgLmNhdGVnb3J5IHtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBjb2xvcjogIzc3N1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXJhbmdlYmFyIC5zZXJpZXMtbmFtZSB7XFxuICBmb250LXdlaWdodDogNzAwO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tYm90dG9tOiA1cHhcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLC5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCB7XFxuICBvcGFjaXR5OiAwO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBjb2xvcjogIzM3M2QzZjtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDEwO1xcbiAgYmFja2dyb3VuZDogI2VjZWZmMTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM5MGE0YWVcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwIHtcXG4gIHBhZGRpbmc6IDlweCAxMHB4O1xcbiAgdHJhbnNpdGlvbjogLjE1cyBlYXNlIGFsbFxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAuYXBleGNoYXJ0cy10aGVtZS1kYXJrIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsLjcpO1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgwLDAsMCwuNSk7XFxuICBjb2xvcjogI2ZmZlxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXA6YWZ0ZXIsLmFwZXhjaGFydHMteGF4aXN0b29sdGlwOmJlZm9yZSB7XFxuICBsZWZ0OiA1MCU7XFxuICBib3JkZXI6IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgaGVpZ2h0OiAwO1xcbiAgd2lkdGg6IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXA6YWZ0ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci13aWR0aDogNnB4O1xcbiAgbWFyZ2luLWxlZnQ6IC02cHhcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwOmJlZm9yZSB7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXdpZHRoOiA3cHg7XFxuICBtYXJnaW4tbGVmdDogLTdweFxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tOmFmdGVyLC5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC1ib3R0b206YmVmb3JlIHtcXG4gIGJvdHRvbTogMTAwJVxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdG9wOmFmdGVyLC5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3A6YmVmb3JlIHtcXG4gIHRvcDogMTAwJVxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tOmFmdGVyIHtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNlY2VmZjFcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogIzkwYTRhZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tLmFwZXhjaGFydHMtdGhlbWUtZGFyazphZnRlciwuYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tLmFwZXhjaGFydHMtdGhlbWUtZGFyazpiZWZvcmUge1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogcmdiYSgwLDAsMCwuNSlcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLXRvcDphZnRlciB7XFxuICBib3JkZXItdG9wLWNvbG9yOiAjZWNlZmYxXFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3A6YmVmb3JlIHtcXG4gIGJvcmRlci10b3AtY29sb3I6ICM5MGE0YWVcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLXRvcC5hcGV4Y2hhcnRzLXRoZW1lLWRhcms6YWZ0ZXIsLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLXRvcC5hcGV4Y2hhcnRzLXRoZW1lLWRhcms6YmVmb3JlIHtcXG4gIGJvcmRlci10b3AtY29sb3I6IHJnYmEoMCwwLDAsLjUpXFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC5hcGV4Y2hhcnRzLWFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogLjE1cyBlYXNlIGFsbFxcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAge1xcbiAgcGFkZGluZzogNHB4IDEwcHhcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLmFwZXhjaGFydHMtdGhlbWUtZGFyayB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLC43KTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwwLDAsLjUpO1xcbiAgY29sb3I6ICNmZmZcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwOmFmdGVyLC5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcDpiZWZvcmUge1xcbiAgdG9wOiA1MCU7XFxuICBib3JkZXI6IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgaGVpZ2h0OiAwO1xcbiAgd2lkdGg6IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YWZ0ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci13aWR0aDogNnB4O1xcbiAgbWFyZ2luLXRvcDogLTZweFxcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItd2lkdGg6IDdweDtcXG4gIG1hcmdpbi10b3A6IC03cHhcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YWZ0ZXIsLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YmVmb3JlIHtcXG4gIGxlZnQ6IDEwMCVcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLXJpZ2h0OmFmdGVyLC5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcbiAgcmlnaHQ6IDEwMCVcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YWZ0ZXIge1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6ICNlY2VmZjFcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YmVmb3JlIHtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiAjOTBhNGFlXFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0LmFwZXhjaGFydHMtdGhlbWUtZGFyazphZnRlciwuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtbGVmdC5hcGV4Y2hhcnRzLXRoZW1lLWRhcms6YmVmb3JlIHtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiByZ2JhKDAsMCwwLC41KVxcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHQ6YWZ0ZXIge1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjZWNlZmYxXFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjOTBhNGFlXFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodC5hcGV4Y2hhcnRzLXRoZW1lLWRhcms6YWZ0ZXIsLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLXJpZ2h0LmFwZXhjaGFydHMtdGhlbWUtZGFyazpiZWZvcmUge1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLC41KVxcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAuYXBleGNoYXJ0cy1hY3RpdmUge1xcbiAgb3BhY2l0eTogMVxcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmVcXG59XFxuXFxuLmFwZXhjaGFydHMteGNyb3NzaGFpcnMsLmFwZXhjaGFydHMteWNyb3NzaGFpcnMge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogLjE1cyBlYXNlIGFsbFxcbn1cXG5cXG4uYXBleGNoYXJ0cy14Y3Jvc3NoYWlycy5hcGV4Y2hhcnRzLWFjdGl2ZSwuYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy5hcGV4Y2hhcnRzLWFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogLjE1cyBlYXNlIGFsbFxcbn1cXG5cXG4uYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy1oaWRkZW4ge1xcbiAgb3BhY2l0eTogMFxcbn1cXG5cXG4uYXBleGNoYXJ0cy1zZWxlY3Rpb24tcmVjdCB7XFxuICBjdXJzb3I6IG1vdmVcXG59XFxuXFxuLnN2Z19zZWxlY3RfYm91bmRpbmdSZWN0LC5zdmdfc2VsZWN0X3BvaW50c19yb3Qge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBvcGFjaXR5OiAwO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuXFxufVxcblxcbi5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0K2cgLnN2Z19zZWxlY3RfYm91bmRpbmdSZWN0LC5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0K2cgLnN2Z19zZWxlY3RfcG9pbnRzX3JvdCB7XFxuICBvcGFjaXR5OiAwO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuXFxufVxcblxcbi5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0K2cgLnN2Z19zZWxlY3RfcG9pbnRzX2wsLmFwZXhjaGFydHMtc2VsZWN0aW9uLXJlY3QrZyAuc3ZnX3NlbGVjdF9wb2ludHNfciB7XFxuICBjdXJzb3I6IGV3LXJlc2l6ZTtcXG4gIG9wYWNpdHk6IDE7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlXFxufVxcblxcbi5zdmdfc2VsZWN0X3BvaW50cyB7XFxuICBmaWxsOiAjZWZlZmVmO1xcbiAgc3Ryb2tlOiAjMzMzO1xcbiAgcng6IDJcXG59XFxuXFxuLmFwZXhjaGFydHMtc3ZnLmFwZXhjaGFydHMtem9vbWFibGUuaG92ZXJpbmctem9vbSB7XFxuICBjdXJzb3I6IGNyb3NzaGFpclxcbn1cXG5cXG4uYXBleGNoYXJ0cy1zdmcuYXBleGNoYXJ0cy16b29tYWJsZS5ob3ZlcmluZy1wYW4ge1xcbiAgY3Vyc29yOiBtb3ZlXFxufVxcblxcbi5hcGV4Y2hhcnRzLW1lbnUtaWNvbiwuYXBleGNoYXJ0cy1wYW4taWNvbiwuYXBleGNoYXJ0cy1yZXNldC1pY29uLC5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uLC5hcGV4Y2hhcnRzLXRvb2xiYXItY3VzdG9tLWljb24sLmFwZXhjaGFydHMtem9vbS1pY29uLC5hcGV4Y2hhcnRzLXpvb21pbi1pY29uLC5hcGV4Y2hhcnRzLXpvb21vdXQtaWNvbiB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbiAgY29sb3I6ICM2ZTgxOTI7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXJcXG59XFxuXFxuLmFwZXhjaGFydHMtbWVudS1pY29uIHN2ZywuYXBleGNoYXJ0cy1yZXNldC1pY29uIHN2ZywuYXBleGNoYXJ0cy16b29tLWljb24gc3ZnLC5hcGV4Y2hhcnRzLXpvb21pbi1pY29uIHN2ZywuYXBleGNoYXJ0cy16b29tb3V0LWljb24gc3ZnIHtcXG4gIGZpbGw6ICM2ZTgxOTJcXG59XFxuXFxuLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24gc3ZnIHtcXG4gIGZpbGw6ICM0NDQ7XFxuICB0cmFuc2Zvcm06IHNjYWxlKC43NilcXG59XFxuXFxuLmFwZXhjaGFydHMtdGhlbWUtZGFyayAuYXBleGNoYXJ0cy1tZW51LWljb24gc3ZnLC5hcGV4Y2hhcnRzLXRoZW1lLWRhcmsgLmFwZXhjaGFydHMtcGFuLWljb24gc3ZnLC5hcGV4Y2hhcnRzLXRoZW1lLWRhcmsgLmFwZXhjaGFydHMtcmVzZXQtaWNvbiBzdmcsLmFwZXhjaGFydHMtdGhlbWUtZGFyayAuYXBleGNoYXJ0cy1zZWxlY3Rpb24taWNvbiBzdmcsLmFwZXhjaGFydHMtdGhlbWUtZGFyayAuYXBleGNoYXJ0cy10b29sYmFyLWN1c3RvbS1pY29uIHN2ZywuYXBleGNoYXJ0cy10aGVtZS1kYXJrIC5hcGV4Y2hhcnRzLXpvb20taWNvbiBzdmcsLmFwZXhjaGFydHMtdGhlbWUtZGFyayAuYXBleGNoYXJ0cy16b29taW4taWNvbiBzdmcsLmFwZXhjaGFydHMtdGhlbWUtZGFyayAuYXBleGNoYXJ0cy16b29tb3V0LWljb24gc3ZnIHtcXG4gIGZpbGw6ICNmM2Y0ZjVcXG59XFxuXFxuLmFwZXhjaGFydHMtY2FudmFzIC5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbi5hcGV4Y2hhcnRzLXNlbGVjdGVkIHN2ZywuYXBleGNoYXJ0cy1jYW52YXMgLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24uYXBleGNoYXJ0cy1zZWxlY3RlZCBzdmcsLmFwZXhjaGFydHMtY2FudmFzIC5hcGV4Y2hhcnRzLXpvb20taWNvbi5hcGV4Y2hhcnRzLXNlbGVjdGVkIHN2ZyB7XFxuICBmaWxsOiAjMDA4ZmZiXFxufVxcblxcbi5hcGV4Y2hhcnRzLXRoZW1lLWxpZ2h0IC5hcGV4Y2hhcnRzLW1lbnUtaWNvbjpob3ZlciBzdmcsLmFwZXhjaGFydHMtdGhlbWUtbGlnaHQgLmFwZXhjaGFydHMtcmVzZXQtaWNvbjpob3ZlciBzdmcsLmFwZXhjaGFydHMtdGhlbWUtbGlnaHQgLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb246bm90KC5hcGV4Y2hhcnRzLXNlbGVjdGVkKTpob3ZlciBzdmcsLmFwZXhjaGFydHMtdGhlbWUtbGlnaHQgLmFwZXhjaGFydHMtem9vbS1pY29uOm5vdCguYXBleGNoYXJ0cy1zZWxlY3RlZCk6aG92ZXIgc3ZnLC5hcGV4Y2hhcnRzLXRoZW1lLWxpZ2h0IC5hcGV4Y2hhcnRzLXpvb21pbi1pY29uOmhvdmVyIHN2ZywuYXBleGNoYXJ0cy10aGVtZS1saWdodCAuYXBleGNoYXJ0cy16b29tb3V0LWljb246aG92ZXIgc3ZnIHtcXG4gIGZpbGw6ICMzMzNcXG59XFxuXFxuLmFwZXhjaGFydHMtbWVudS1pY29uLC5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1yZXNldC1pY29uIHtcXG4gIG1hcmdpbi1sZWZ0OiA1cHhcXG59XFxuXFxuLmFwZXhjaGFydHMtbWVudS1pY29uLC5hcGV4Y2hhcnRzLXJlc2V0LWljb24sLmFwZXhjaGFydHMtem9vbS1pY29uIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoLjg1KVxcbn1cXG5cXG4uYXBleGNoYXJ0cy16b29taW4taWNvbiwuYXBleGNoYXJ0cy16b29tb3V0LWljb24ge1xcbiAgdHJhbnNmb3JtOiBzY2FsZSguNylcXG59XFxuXFxuLmFwZXhjaGFydHMtem9vbW91dC1pY29uIHtcXG4gIG1hcmdpbi1yaWdodDogM3B4XFxufVxcblxcbi5hcGV4Y2hhcnRzLXBhbi1pY29uIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoLjYyKTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDFweDtcXG4gIHRvcDogMFxcbn1cXG5cXG4uYXBleGNoYXJ0cy1wYW4taWNvbiBzdmcge1xcbiAgZmlsbDogI2ZmZjtcXG4gIHN0cm9rZTogIzZlODE5MjtcXG4gIHN0cm9rZS13aWR0aDogMlxcbn1cXG5cXG4uYXBleGNoYXJ0cy1wYW4taWNvbi5hcGV4Y2hhcnRzLXNlbGVjdGVkIHN2ZyB7XFxuICBzdHJva2U6ICMwMDhmZmJcXG59XFxuXFxuLmFwZXhjaGFydHMtcGFuLWljb246bm90KC5hcGV4Y2hhcnRzLXNlbGVjdGVkKTpob3ZlciBzdmcge1xcbiAgc3Ryb2tlOiAjMzMzXFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2xiYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTE7XFxuICBtYXgtd2lkdGg6IDE3NnB4O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiAwIDZweCAycHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlclxcbn1cXG5cXG4uYXBleGNoYXJ0cy1tZW51IHtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEwMCU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgcGFkZGluZzogM3B4O1xcbiAgcmlnaHQ6IDEwcHg7XFxuICBvcGFjaXR5OiAwO1xcbiAgbWluLXdpZHRoOiAxMTBweDtcXG4gIHRyYW5zaXRpb246IC4xNXMgZWFzZSBhbGw7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1tZW51LmFwZXhjaGFydHMtbWVudS1vcGVuIHtcXG4gIG9wYWNpdHk6IDE7XFxuICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgdHJhbnNpdGlvbjogLjE1cyBlYXNlIGFsbFxcbn1cXG5cXG4uYXBleGNoYXJ0cy1tZW51LWl0ZW0ge1xcbiAgcGFkZGluZzogNnB4IDdweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGN1cnNvcjogcG9pbnRlclxcbn1cXG5cXG4uYXBleGNoYXJ0cy10aGVtZS1saWdodCAuYXBleGNoYXJ0cy1tZW51LWl0ZW06aG92ZXIge1xcbiAgYmFja2dyb3VuZDogI2VlZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy10aGVtZS1kYXJrIC5hcGV4Y2hhcnRzLW1lbnUge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwuNyk7XFxuICBjb2xvcjogI2ZmZlxcbn1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjc2OHB4KSB7XFxuICAuYXBleGNoYXJ0cy1jYW52YXM6aG92ZXIgLmFwZXhjaGFydHMtdG9vbGJhciB7XFxuICAgICAgb3BhY2l0eTogMVxcbiAgfVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1jYW52YXMgLmFwZXhjaGFydHMtZWxlbWVudC1oaWRkZW4sLmFwZXhjaGFydHMtZGF0YWxhYmVsLmFwZXhjaGFydHMtZWxlbWVudC1oaWRkZW4sLmFwZXhjaGFydHMtaGlkZSAuYXBleGNoYXJ0cy1zZXJpZXMtcG9pbnRzIHtcXG4gIG9wYWNpdHk6IDBcXG59XFxuXFxuLmFwZXhjaGFydHMtaGlkZGVuLWVsZW1lbnQtc2hvd24ge1xcbiAgb3BhY2l0eTogMTtcXG4gIHRyYW5zaXRpb246IDAuMjVzIGVhc2UgYWxsO1xcbn1cXG4uYXBleGNoYXJ0cy1kYXRhbGFiZWwsLmFwZXhjaGFydHMtZGF0YWxhYmVsLWxhYmVsLC5hcGV4Y2hhcnRzLWRhdGFsYWJlbC12YWx1ZSwuYXBleGNoYXJ0cy1kYXRhbGFiZWxzLC5hcGV4Y2hhcnRzLXBpZS1sYWJlbCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1waWUtbGFiZWwtZGVsYXkge1xcbiAgb3BhY2l0eTogMDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBvcGFxdWU7XFxuICBhbmltYXRpb24tZHVyYXRpb246IC4zcztcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGZvcndhcmRzO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1hbm5vdGF0aW9uLXJlY3QsLmFwZXhjaGFydHMtYXJlYS1zZXJpZXMgLmFwZXhjaGFydHMtYXJlYSwuYXBleGNoYXJ0cy1hcmVhLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXIubm8tcG9pbnRlci1ldmVudHMsLmFwZXhjaGFydHMtZ3JpZGxpbmUsLmFwZXhjaGFydHMtbGluZSwuYXBleGNoYXJ0cy1saW5lLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXIubm8tcG9pbnRlci1ldmVudHMsLmFwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbi1sYWJlbCwuYXBleGNoYXJ0cy1yYWRhci1zZXJpZXMgcGF0aCwuYXBleGNoYXJ0cy1yYWRhci1zZXJpZXMgcG9seWdvbiwuYXBleGNoYXJ0cy10b29sYmFyIHN2ZywuYXBleGNoYXJ0cy10b29sdGlwIC5hcGV4Y2hhcnRzLW1hcmtlciwuYXBleGNoYXJ0cy14YXhpcy1hbm5vdGF0aW9uLWxhYmVsLC5hcGV4Y2hhcnRzLXlheGlzLWFubm90YXRpb24tbGFiZWwsLmFwZXhjaGFydHMtem9vbS1yZWN0IHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lXFxufVxcblxcbi5hcGV4Y2hhcnRzLW1hcmtlciB7XFxuICB0cmFuc2l0aW9uOiAuMTVzIGVhc2UgYWxsXFxufVxcblxcbi5yZXNpemUtdHJpZ2dlcnMge1xcbiAgYW5pbWF0aW9uOiAxbXMgcmVzaXplYW5pbTtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIG9wYWNpdHk6IDA7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIG92ZXJmbG93OiBoaWRkZW5cXG59XFxuXFxuLmNvbnRyYWN0LXRyaWdnZXI6YmVmb3JlLC5yZXNpemUtdHJpZ2dlcnMsLnJlc2l6ZS10cmlnZ2Vycz5kaXYge1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwXFxufVxcblxcbi5yZXNpemUtdHJpZ2dlcnM+ZGl2IHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZDogI2VlZTtcXG4gIG92ZXJmbG93OiBhdXRvXFxufVxcblxcbi5jb250cmFjdC10cmlnZ2VyOmJlZm9yZSB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgd2lkdGg6IDIwMCU7XFxuICBoZWlnaHQ6IDIwMCVcXG59XFxuXFxuLmFwZXhjaGFydHMtYmFyLWdvYWxzLW1hcmtlcnN7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy1iYXItc2hhZG93c3tcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lXFxufVxcblxcbi5hcGV4Y2hhcnRzLXJhbmdlYmFyLWdvYWxzLW1hcmtlcnN7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZVxcbn1cIjtcblxuICAvKipcbiAgICpcbiAgICogQG1vZHVsZSBBcGV4Q2hhcnRzXG4gICAqKi9cblxuICB2YXIgQXBleENoYXJ0cyQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcGV4Q2hhcnRzKGVsLCBvcHRzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBleENoYXJ0cyk7XG5cbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICB0aGlzLmN0eCA9IHRoaXM7IC8vIFBhc3MgdGhlIHVzZXIgc3VwcGxpZWQgb3B0aW9ucyB0byB0aGUgQmFzZSBDbGFzcyB3aGVyZSB0aGVzZSBvcHRpb25zIHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBkZWZhdWx0cy4gVGhlIHJldHVybmVkIG9iamVjdCBmcm9tIEJhc2UgQ2xhc3Mgd2lsbCBiZWNvbWUgdGhlIGNvbmZpZyBvYmplY3QgaW4gdGhlIGVudGlyZSBjb2RlYmFzZS5cblxuICAgICAgdGhpcy53ID0gbmV3IEJhc2Uob3B0cykuaW5pdCgpO1xuICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgdGhpcy53Lmdsb2JhbHMuY3VpZCA9IFV0aWxzJDEucmFuZG9tSWQoKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLmNoYXJ0SUQgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmlkID8gVXRpbHMkMS5lc2NhcGVTdHJpbmcodGhpcy53LmNvbmZpZy5jaGFydC5pZCkgOiB0aGlzLncuZ2xvYmFscy5jdWlkO1xuICAgICAgdmFyIGluaXRDdHggPSBuZXcgSW5pdEN0eFZhcmlhYmxlcyh0aGlzKTtcbiAgICAgIGluaXRDdHguaW5pdE1vZHVsZXMoKTtcbiAgICAgIHRoaXMuY3JlYXRlID0gVXRpbHMkMS5iaW5kKHRoaXMuY3JlYXRlLCB0aGlzKTtcbiAgICAgIHRoaXMud2luZG93UmVzaXplSGFuZGxlciA9IHRoaXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50UmVzaXplSGFuZGxlciA9IHRoaXMuX3BhcmVudFJlc2l6ZUNhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IG1ldGhvZCB1c2VyIHdpbGwgY2FsbCB0byByZW5kZXIgdGhlIGNoYXJ0LlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQXBleENoYXJ0cywgW3tcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gbWFpbiBtZXRob2RcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAvLyBvbmx5IGRyYXcgY2hhcnQsIGlmIGVsZW1lbnQgZm91bmRcbiAgICAgICAgICBpZiAoX3RoaXMuZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQXBleC5fY2hhcnRJbnN0YW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIEFwZXguX2NoYXJ0SW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy53LmNvbmZpZy5jaGFydC5pZCkge1xuICAgICAgICAgICAgICBBcGV4Ll9jaGFydEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMudy5nbG9iYWxzLmNoYXJ0SUQsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IF90aGlzLncuY29uZmlnLmNoYXJ0Lmdyb3VwLFxuICAgICAgICAgICAgICAgIGNoYXJ0OiBfdGhpc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gLy8gc2V0IHRoZSBsb2NhbGUgaGVyZVxuXG5cbiAgICAgICAgICAgIF90aGlzLnNldExvY2FsZShfdGhpcy53LmNvbmZpZy5jaGFydC5kZWZhdWx0TG9jYWxlKTtcblxuICAgICAgICAgICAgdmFyIGJlZm9yZU1vdW50ID0gX3RoaXMudy5jb25maWcuY2hhcnQuZXZlbnRzLmJlZm9yZU1vdW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZm9yZU1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGJlZm9yZU1vdW50KF90aGlzLCBfdGhpcy53KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMuZXZlbnRzLmZpcmVFdmVudCgnYmVmb3JlTW91bnQnLCBbX3RoaXMsIF90aGlzLnddKTtcblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIF90aGlzLndpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgICAgYWRkUmVzaXplTGlzdGVuZXIoX3RoaXMuZWwucGFyZW50Tm9kZSwgX3RoaXMucGFyZW50UmVzaXplSGFuZGxlcik7IC8vIEFkZCBDU1MgaWYgbm90IGFscmVhZHkgYWRkZWRcblxuICAgICAgICAgICAgaWYgKCFfdGhpcy5jc3MpIHtcbiAgICAgICAgICAgICAgdmFyIHJvb3ROb2RlID0gX3RoaXMuZWwuZ2V0Um9vdE5vZGUgJiYgX3RoaXMuZWwuZ2V0Um9vdE5vZGUoKTtcblxuICAgICAgICAgICAgICB2YXIgaW5TaGFkb3dSb290ID0gVXRpbHMkMS5pcygnU2hhZG93Um9vdCcsIHJvb3ROb2RlKTtcbiAgICAgICAgICAgICAgdmFyIGRvYyA9IF90aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgIHZhciBnbG9iYWxDU1MgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoJ2FwZXhjaGFydHMtY3NzJyk7XG5cbiAgICAgICAgICAgICAgaWYgKGluU2hhZG93Um9vdCB8fCAhZ2xvYmFsQ1NTKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jc3MuaWQgPSAnYXBleGNoYXJ0cy1jc3MnO1xuICAgICAgICAgICAgICAgIF90aGlzLmNzcy50ZXh0Q29udGVudCA9IGNzc18yNDh6O1xuXG4gICAgICAgICAgICAgICAgaWYgKGluU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIGluIFNoYWRvdyBET00sIGFkZCB0byBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgICAgcm9vdE5vZGUucHJlcGVuZChfdGhpcy5jc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gPGhlYWQ+IG9mIGVsZW1lbnQncyBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgZG9jLmhlYWQuYXBwZW5kQ2hpbGQoX3RoaXMuY3NzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyYXBoRGF0YSA9IF90aGlzLmNyZWF0ZShfdGhpcy53LmNvbmZpZy5zZXJpZXMsIHt9KTtcblxuICAgICAgICAgICAgaWYgKCFncmFwaERhdGEpIHJldHVybiByZXNvbHZlKF90aGlzKTtcblxuICAgICAgICAgICAgX3RoaXMubW91bnQoZ3JhcGhEYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHMubW91bnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF90aGlzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy5tb3VudGVkKF90aGlzLCBfdGhpcy53KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLmV2ZW50cy5maXJlRXZlbnQoJ21vdW50ZWQnLCBbX3RoaXMsIF90aGlzLnddKTtcblxuICAgICAgICAgICAgICByZXNvbHZlKGdyYXBoRGF0YSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7IC8vIGhhbmRsZSBlcnJvciBpbiBjYXNlIG5vIGRhdGEgb3IgZWxlbWVudCBub3QgZm91bmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdFbGVtZW50IG5vdCBmb3VuZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjcmVhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoc2VyLCBvcHRzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgICB2YXIgaW5pdEN0eCA9IG5ldyBJbml0Q3R4VmFyaWFibGVzKHRoaXMpO1xuICAgICAgICBpbml0Q3R4LmluaXRNb2R1bGVzKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgICBnbC5ub0RhdGEgPSBmYWxzZTtcbiAgICAgICAgZ2wuYW5pbWF0aW9uRW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlLmNoZWNrUmVzcG9uc2l2ZUNvbmZpZyhvcHRzKTtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgdmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKHcuY29uZmlnKTtcbiAgICAgICAgICBkZWZhdWx0cy5jb252ZXJ0Q2F0VG9OdW1lcmljWGF4aXMody5jb25maWcsIHRoaXMuY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVsID09PSBudWxsKSB7XG4gICAgICAgICAgZ2wuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb3JlLnNldHVwRWxlbWVudHMoKTtcblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3RyZWVtYXAnKSB7XG4gICAgICAgICAgdy5jb25maWcuZ3JpZC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgdy5jb25maWcueWF4aXNbMF0uc2hvdyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsLnN2Z1dpZHRoID09PSAwKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgaGlkZGVuLCBza2lwIGRyYXdpbmdcbiAgICAgICAgICBnbC5hbmltYXRpb25FbmRlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tYm8gPSBDb3JlVXRpbHMuY2hlY2tDb21ib1NlcmllcyhzZXIpO1xuICAgICAgICBnbC5jb21ib0NoYXJ0cyA9IGNvbWJvLmNvbWJvQ2hhcnRzO1xuICAgICAgICBnbC5jb21ib0JhckNvdW50ID0gY29tYm8uY29tYm9CYXJDb3VudDtcbiAgICAgICAgdmFyIGFsbFNlcmllc0FyZUVtcHR5ID0gc2VyLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHMuZGF0YSAmJiBzLmRhdGEubGVuZ3RoID09PSAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VyLmxlbmd0aCA9PT0gMCB8fCBhbGxTZXJpZXNBcmVFbXB0eSkge1xuICAgICAgICAgIHRoaXMuc2VyaWVzLmhhbmRsZU5vRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudHMuc2V0dXBFdmVudEhhbmRsZXJzKCk7IC8vIEhhbmRsZSB0aGUgZGF0YSBpbnB1dHRlZCBieSB1c2VyIGFuZCBzZXQgc29tZSBvZiB0aGUgZ2xvYmFsIHZhcmlhYmxlcyAoZm9yIGVnLCBpZiBkYXRhIGlzIGRhdGV0aW1lIC8gbnVtZXJpYyAvIGNhdGVnb3J5KS4gRG9uJ3QgY2FsY3VsYXRlIHRoZSByYW5nZSAvIG1pbiAvIG1heCBhdCB0aGlzIHRpbWVcblxuICAgICAgICB0aGlzLmRhdGEucGFyc2VEYXRhKHNlcik7IC8vIHRoaXMgaXMgYSBnb29kIHRpbWUgdG8gc2V0IHRoZW1lIGNvbG9ycyBmaXJzdFxuXG4gICAgICAgIHRoaXMudGhlbWUuaW5pdCgpOyAvLyBhcyBtYXJrZXJzIGFjY2VwdHMgYXJyYXksIHdlIG5lZWQgdG8gc2V0dXAgZ2xvYmFsIG1hcmtlcnMgZm9yIGVhc2llciBhY2Nlc3NcblxuICAgICAgICB2YXIgbWFya2VycyA9IG5ldyBNYXJrZXJzKHRoaXMpO1xuICAgICAgICBtYXJrZXJzLnNldEdsb2JhbE1hcmtlclNpemUoKTsgLy8gbGFiZWxGb3JtYXR0ZXJzIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGRpbWVuc2lvbnMgYXMgaW4gZGltZW5zaW9ucyB3ZSBuZWVkIHRleHQgbGFiZWxzIHdpZHRoXG5cbiAgICAgICAgdGhpcy5mb3JtYXR0ZXJzLnNldExhYmVsRm9ybWF0dGVycygpO1xuICAgICAgICB0aGlzLnRpdGxlU3VidGl0bGUuZHJhdygpOyAvLyBsZWdlbmQgaXMgY2FsY3VsYXRlZCBoZXJlIGJlZm9yZSBjb3JlQ2FsY3VsYXRpb25zIGJlY2F1c2UgaXQgYWZmZWN0cyB0aGUgcGxvdHRhYmxlIGFyZWFcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgc29tZSBkYXRhIHRvIHNob3cgb3IgdXNlciBjb2xsYXBzZWQgYWxsIHNlcmllcywgdGhlbiBwcm9jZWVkIGRyYXdpbmcgbGVnZW5kXG5cbiAgICAgICAgaWYgKCFnbC5ub0RhdGEgfHwgZ2wuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA9PT0gZ2wuc2VyaWVzLmxlbmd0aCB8fCB3LmNvbmZpZy5sZWdlbmQuc2hvd0ZvclNpbmdsZVNlcmllcykge1xuICAgICAgICAgIHRoaXMubGVnZW5kLmluaXQoKTtcbiAgICAgICAgfSAvLyBjaGVjayB3aGV0aGVyIGluIG11bHRpcGxlIHNlcmllcywgYWxsIHNlcmllcyBzaGFyZSB0aGUgc2FtZSBYXG5cblxuICAgICAgICB0aGlzLnNlcmllcy5oYXNBbGxTZXJpZXNFcXVhbFgoKTsgLy8gY29yZUNhbGN1bGF0aW9ucyB3aWxsIGdpdmUgdGhlIG1pbi9tYXggcmFuZ2UgYW5kIHlheGlzL2F4aXMgdmFsdWVzLiBJdCBzaG91bGQgYmUgY2FsbGVkIGhlcmUgdG8gc2V0IHNlcmllcyB2YXJpYWJsZSBmcm9tIGNvbmZpZyB0byBnbG9iYWxzXG5cbiAgICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICB0aGlzLmNvcmUuY29yZUNhbGN1bGF0aW9ucygpO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgIT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICAgIC8vIGFzIHdlIGhhdmUgbWluWCBhbmQgbWF4WCB2YWx1ZXMsIGRldGVybWluZSB0aGUgZGVmYXVsdCBEYXRlVGltZUZvcm1hdCBmb3IgdGltZSBzZXJpZXNcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVycy5zZXRMYWJlbEZvcm1hdHRlcnMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmN0eC50b29sYmFyLm1pblggPSB3Lmdsb2JhbHMubWluWDtcbiAgICAgICAgICB0aGlzLmN0eC50b29sYmFyLm1heFggPSB3Lmdsb2JhbHMubWF4WDtcbiAgICAgICAgfSAvLyB3ZSBuZWVkIHRvIGdlbmVyYXRlIHlheGlzIGZvciBoZWF0bWFwIHNlcGFyYXRlbHkgYXMgd2UgYXJlIG5vdCBzaG93aW5nIG51bWVyaWNzIHRoZXJlLCBidXQgc2VyaWVzTmFtZXMuIFRoZXJlIGFyZSBzb21lIHR3ZWFrcyB3aGljaCBhcmUgcmVxdWlyZWQgZm9yIGhlYXRtYXAgdG8gYWxpZ24gbGFiZWxzIGNvcnJlY3RseSB3aGljaCBhcmUgZG9uZSBpbiBiZWxvdyBmdW5jdGlvblxuICAgICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgY2FsY3VsYXRpbmcgRGltZW5zaW9ucyBwbG90Q29vcmRzKCkgbWV0aG9kIG9mIERpbWVuc2lvbnNcblxuXG4gICAgICAgIHRoaXMuZm9ybWF0dGVycy5oZWF0bWFwTGFiZWxGb3JtYXR0ZXJzKCk7IC8vIGdldCB0aGUgbGFyZ2VzdCBtYXJrZXIgc2l6ZSB3aGljaCB3aWxsIGJlIG5lZWRlZCBpbiBkaW1lbnNpb25zIGNhbGNcblxuICAgICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzKTtcbiAgICAgICAgY29yZVV0aWxzLmdldExhcmdlc3RNYXJrZXJTaXplKCk7IC8vIFdlIGdvdCBwbG90dGFibGUgYXJlYSBoZXJlLCBuZXh0IHRhc2sgd291bGQgYmUgdG8gY2FsY3VsYXRlIGF4aXMgYXJlYXNcblxuICAgICAgICB0aGlzLmRpbWVuc2lvbnMucGxvdENvb3JkcygpO1xuICAgICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLmNvcmUueHlTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLmdyaWQuY3JlYXRlR3JpZE1hc2soKTtcbiAgICAgICAgdmFyIGVsR3JhcGggPSB0aGlzLmNvcmUucGxvdENoYXJ0VHlwZShzZXIsIHh5UmF0aW9zKTtcbiAgICAgICAgdmFyIGRhdGFMYWJlbHMgPSBuZXcgRGF0YUxhYmVscyh0aGlzKTtcbiAgICAgICAgZGF0YUxhYmVscy5icmluZ0ZvcndhcmQoKTtcblxuICAgICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5iYWNrZ3JvdW5kLmVuYWJsZWQpIHtcbiAgICAgICAgICBkYXRhTGFiZWxzLmRhdGFMYWJlbHNCYWNrZ3JvdW5kKCk7XG4gICAgICAgIH0gLy8gYWZ0ZXIgYWxsIHRoZSBkcmF3aW5nIGNhbGN1bGF0aW9ucywgc2hpZnQgdGhlIGdyYXBoaWNhbCBhcmVhIChhY3R1YWwgY2hhcnRzL2JhcnMpIGV4Y2x1ZGluZyBsZWdlbmRzXG5cblxuICAgICAgICB0aGlzLmNvcmUuc2hpZnRHcmFwaFBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBkaW0gPSB7XG4gICAgICAgICAgcGxvdDoge1xuICAgICAgICAgICAgbGVmdDogdy5nbG9iYWxzLnRyYW5zbGF0ZVgsXG4gICAgICAgICAgICB0b3A6IHcuZ2xvYmFscy50cmFuc2xhdGVZLFxuICAgICAgICAgICAgd2lkdGg6IHcuZ2xvYmFscy5ncmlkV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVsR3JhcGg6IGVsR3JhcGgsXG4gICAgICAgICAgeHlSYXRpb3M6IHh5UmF0aW9zLFxuICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgZ3JhcGhEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdyA9IG1lLnc7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgLy8gbm8gZGF0YSB0byBkaXNwbGF5XG4gICAgICAgICAgaWYgKG1lLmVsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm90IGVub3VnaCBkYXRhIHRvIGRpc3BsYXkgb3IgdGFyZ2V0IGVsZW1lbnQgbm90IGZvdW5kJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3JhcGhEYXRhID09PSBudWxsIHx8IHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIG1lLnNlcmllcy5oYW5kbGVOb0RhdGEoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZS5ncmlkID0gbmV3IEdyaWQobWUpO1xuICAgICAgICAgIHZhciBlbGdyaWQgPSBtZS5ncmlkLmRyYXdHcmlkKCk7XG4gICAgICAgICAgbWUuYW5ub3RhdGlvbnMgPSBuZXcgQW5ub3RhdGlvbnMobWUpO1xuICAgICAgICAgIG1lLmFubm90YXRpb25zLmRyYXdJbWFnZUFubm9zKCk7XG4gICAgICAgICAgbWUuYW5ub3RhdGlvbnMuZHJhd1RleHRBbm5vcygpO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQucG9zaXRpb24gPT09ICdiYWNrJykge1xuICAgICAgICAgICAgdmFyIF9lbGdyaWQkZWxHcmlkQm9yZGVycztcblxuICAgICAgICAgICAgaWYgKGVsZ3JpZCkge1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZChlbGdyaWQuZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxncmlkICE9PSBudWxsICYmIGVsZ3JpZCAhPT0gdm9pZCAwICYmIChfZWxncmlkJGVsR3JpZEJvcmRlcnMgPSBlbGdyaWQuZWxHcmlkQm9yZGVycykgIT09IG51bGwgJiYgX2VsZ3JpZCRlbEdyaWRCb3JkZXJzICE9PSB2b2lkIDAgJiYgX2VsZ3JpZCRlbEdyaWRCb3JkZXJzLm5vZGUpIHtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQoZWxncmlkLmVsR3JpZEJvcmRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyYXBoRGF0YS5lbEdyYXBoKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBncmFwaERhdGEuZWxHcmFwaC5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZChncmFwaERhdGEuZWxHcmFwaFtnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKGdyYXBoRGF0YS5lbEdyYXBoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgICAgdmFyIF9lbGdyaWQkZWxHcmlkQm9yZGVyczI7XG5cbiAgICAgICAgICAgIGlmIChlbGdyaWQpIHtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQoZWxncmlkLmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZ3JpZCAhPT0gbnVsbCAmJiBlbGdyaWQgIT09IHZvaWQgMCAmJiAoX2VsZ3JpZCRlbEdyaWRCb3JkZXJzMiA9IGVsZ3JpZC5lbEdyaWRCb3JkZXJzKSAhPT0gbnVsbCAmJiBfZWxncmlkJGVsR3JpZEJvcmRlcnMyICE9PSB2b2lkIDAgJiYgX2VsZ3JpZCRlbEdyaWRCb3JkZXJzMi5ub2RlKSB7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKGVsZ3JpZC5lbEdyaWRCb3JkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgICAgbWUuY3Jvc3NoYWlycy5kcmF3WENyb3NzaGFpcnMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbMF0uY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgICAgbWUuY3Jvc3NoYWlycy5kcmF3WUNyb3NzaGFpcnMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ3RyZWVtYXAnKSB7XG4gICAgICAgICAgICBtZS5heGVzLmRyYXdBeGlzKHcuY29uZmlnLmNoYXJ0LnR5cGUsIGVsZ3JpZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHhBeGlzID0gbmV3IFhBeGlzKF90aGlzMi5jdHgsIGVsZ3JpZCk7XG4gICAgICAgICAgdmFyIHlheGlzID0gbmV3IFlBeGlzKF90aGlzMi5jdHgsIGVsZ3JpZCk7XG5cbiAgICAgICAgICBpZiAoZWxncmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB4QXhpcy54QXhpc0xhYmVsQ29ycmVjdGlvbnMoZWxncmlkLnhBeGlzVGlja1dpZHRoKTtcbiAgICAgICAgICAgIHlheGlzLnNldFlBeGlzVGV4dEFsaWdubWVudHMoKTtcbiAgICAgICAgICAgIHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pZ25vcmVZQXhpc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgeWF4aXMueUF4aXNUaXRsZVJvdGF0ZShpbmRleCwgeWF4ZS5vcHBvc2l0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1lLmFubm90YXRpb25zLmRyYXdBeGVzQW5ub3RhdGlvbnMoKTtcblxuICAgICAgICAgIGlmICghdy5nbG9iYWxzLm5vRGF0YSkge1xuICAgICAgICAgICAgLy8gZHJhdyB0b29sdGlwcyBhdCB0aGUgZW5kXG4gICAgICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5lbmFibGVkICYmICF3Lmdsb2JhbHMubm9EYXRhKSB7XG4gICAgICAgICAgICAgIG1lLncuZ2xvYmFscy50b29sdGlwLmRyYXdUb29sdGlwKGdyYXBoRGF0YS54eVJhdGlvcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cyAmJiAody5nbG9iYWxzLmlzWE51bWVyaWMgfHwgdy5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljIHx8IHcuZ2xvYmFscy5pc1JhbmdlQmFyKSkge1xuICAgICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkIHx8IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbiAmJiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZW5hYmxlZCB8fCB3LmNvbmZpZy5jaGFydC5wYW4gJiYgdy5jb25maWcuY2hhcnQucGFuLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBtZS56b29tUGFuU2VsZWN0aW9uLmluaXQoe1xuICAgICAgICAgICAgICAgICAgeHlSYXRpb3M6IGdyYXBoRGF0YS54eVJhdGlvc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdG9vbHMgPSB3LmNvbmZpZy5jaGFydC50b29sYmFyLnRvb2xzO1xuICAgICAgICAgICAgICB2YXIgdG9vbHNBcnIgPSBbJ3pvb20nLCAnem9vbWluJywgJ3pvb21vdXQnLCAnc2VsZWN0aW9uJywgJ3BhbicsICdyZXNldCddO1xuICAgICAgICAgICAgICB0b29sc0Fyci5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdG9vbHNbdF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50b29sYmFyLnNob3cgJiYgIXcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgbWUudG9vbGJhci5jcmVhdGVUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5tZW1vcnkubWV0aG9kc1RvRXhlYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMubWVtb3J5Lm1ldGhvZHNUb0V4ZWMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgZm4ubWV0aG9kKGZuLnBhcmFtcywgZmFsc2UsIGZuLmNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF3Lmdsb2JhbHMuYXhpc0NoYXJ0cyAmJiAhdy5nbG9iYWxzLm5vRGF0YSkge1xuICAgICAgICAgICAgbWUuY29yZS5yZXNpemVOb25BeGlzQ2hhcnRzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBEZXN0cm95IHRoZSBjaGFydCBpbnN0YW5jZSBieSByZW1vdmluZyBhbGwgZWxlbWVudHMgd2hpY2ggYWxzbyBjbGVhbiB1cCBldmVudCBsaXN0ZW5lcnMgb24gdGhvc2UgZWxlbWVudHMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMud2luZG93UmVzaXplSGFuZGxlcik7XG4gICAgICAgIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKHRoaXMuZWwucGFyZW50Tm9kZSwgdGhpcy5wYXJlbnRSZXNpemVIYW5kbGVyKTsgLy8gcmVtb3ZlIHRoZSBjaGFydCdzIGluc3RhbmNlIGZyb20gdGhlIGdsb2JhbCBBcGV4Ll9jaGFydEluc3RhbmNlc1xuXG4gICAgICAgIHZhciBjaGFydElEID0gdGhpcy53LmNvbmZpZy5jaGFydC5pZDtcblxuICAgICAgICBpZiAoY2hhcnRJRCkge1xuICAgICAgICAgIEFwZXguX2NoYXJ0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICAgIGlmIChjLmlkID09PSBVdGlscyQxLmVzY2FwZVN0cmluZyhjaGFydElEKSkge1xuICAgICAgICAgICAgICBBcGV4Ll9jaGFydEluc3RhbmNlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXcgRGVzdHJveSh0aGlzLmN0eCkuY2xlYXIoe1xuICAgICAgICAgIGlzVXBkYXRpbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBbGxvd3MgdXNlcnMgdG8gdXBkYXRlIE9wdGlvbnMgYWZ0ZXIgdGhlIGNoYXJ0IGhhcyByZW5kZXJlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgbmV3IGNvbmZpZyBvYmplY3QgY2FuIGJlIHBhc3NlZCB3aGljaCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBjb25maWcgb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZHJhdyAtIHNob3VsZCByZWRyYXcgZnJvbSBiZWdpbm5pbmcgb3Igc2hvdWxkIHVzZSBleGlzdGluZyBwYXRocyBhbmQgcmVkcmF3IGZyb20gdGhlcmVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSAtIHNob3VsZCBhbmltYXRlIG9yIG5vdCBvbiB1cGRhdGluZyBPcHRpb25zXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cGRhdGVPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZWRyYXcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICB2YXIgYW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgICAgdmFyIHVwZGF0ZVN5bmNlZENoYXJ0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICAgICAgdmFyIG92ZXJ3cml0ZUluaXRpYWxDb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgICAgIHZhciB3ID0gdGhpcy53OyAvLyB3aGVuIGNhbGxlZCBleHRlcm5hbGx5LCBjbGVhciBzb21lIGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgICAgLy8gZml4ZXMgYXBleGNoYXJ0cy5qcyMxNDg4XG5cbiAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMpIHtcbiAgICAgICAgICB0aGlzLnNlcmllcy5yZXNldFNlcmllcyhmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzLmxlbmd0aCAmJiBvcHRpb25zLnNlcmllc1swXS5kYXRhKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlcmllcyA9IG9wdGlvbnMuc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLnVwZGF0ZUhlbHBlcnMuX2V4dGVuZFNlcmllcyhzLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gdXNlciB1cGRhdGVkIHRoZSBzZXJpZXMgdmlhIHVwZGF0ZU9wdGlvbnMoKSBmdW5jdGlvbi5cbiAgICAgICAgICAvLyBIZW5jZSwgd2UgbmVlZCB0byByZXNldCBheGlzIG1pbi9tYXggdG8gYXZvaWQgem9vbWluZyBpc3N1ZXNcblxuXG4gICAgICAgICAgdGhpcy51cGRhdGVIZWxwZXJzLnJldmVydERlZmF1bHRBeGlzTWluTWF4KCk7XG4gICAgICAgIH0gLy8gdXNlciBoYXMgc2V0IHgtYXhpcyBtaW4vbWF4IGV4dGVybmFsbHkgLSBoZW5jZSB3ZSBuZWVkIHRvIGZvcmNlZnVsbHkgc2V0IHRoZSB4YXhpcyBtaW4vbWF4XG5cblxuICAgICAgICBpZiAob3B0aW9ucy54YXhpcykge1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLnVwZGF0ZUhlbHBlcnMuZm9yY2VYQXhpc1VwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnlheGlzKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMudXBkYXRlSGVscGVycy5mb3JjZVlBeGlzVXBkYXRlKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLnNlcmllcy5jbGVhclByZXZpb3VzUGF0aHMoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiB1cGRhdGUgdGhlbWUgbW9kZSM0NTkgKi9cblxuXG4gICAgICAgIGlmIChvcHRpb25zLnRoZW1lKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMudGhlbWUudXBkYXRlVGhlbWVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSGVscGVycy5fdXBkYXRlT3B0aW9ucyhvcHRpb25zLCByZWRyYXcsIGFuaW1hdGUsIHVwZGF0ZVN5bmNlZENoYXJ0cywgb3ZlcndyaXRlSW5pdGlhbENvbmZpZyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEFsbG93cyB1c2VycyB0byB1cGRhdGUgU2VyaWVzIGFmdGVyIHRoZSBjaGFydCBoYXMgcmVuZGVyZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHthcnJheX0gc2VyaWVzIC0gTmV3IHNlcmllcyB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBleGlzdGluZ1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXBkYXRlU2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2VyaWVzKCkge1xuICAgICAgICB2YXIgbmV3U2VyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsU2VyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgICB0aGlzLnNlcmllcy5yZXNldFNlcmllcyhmYWxzZSk7XG4gICAgICAgIHRoaXMudXBkYXRlSGVscGVycy5yZXZlcnREZWZhdWx0QXhpc01pbk1heCgpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVIZWxwZXJzLl91cGRhdGVTZXJpZXMobmV3U2VyaWVzLCBhbmltYXRlLCBvdmVyd3JpdGVJbml0aWFsU2VyaWVzKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQWxsb3dzIHVzZXJzIHRvIGFwcGVuZCBhIG5ldyBzZXJpZXMgYWZ0ZXIgdGhlIGNoYXJ0IGhhcyByZW5kZXJlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBuZXdTZXJpZSAtIE5ldyBzZXJpZSB3aGljaCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBleGlzdGluZyBzZXJpZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFwcGVuZFNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFNlcmllcyhuZXdTZXJpZSkge1xuICAgICAgICB2YXIgYW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgdmFyIG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICAgIHZhciBuZXdTZXJpZXMgPSB0aGlzLncuY29uZmlnLnNlcmllcy5zbGljZSgpO1xuICAgICAgICBuZXdTZXJpZXMucHVzaChuZXdTZXJpZSk7XG4gICAgICAgIHRoaXMuc2VyaWVzLnJlc2V0U2VyaWVzKGZhbHNlKTtcbiAgICAgICAgdGhpcy51cGRhdGVIZWxwZXJzLnJldmVydERlZmF1bHRBeGlzTWluTWF4KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUhlbHBlcnMuX3VwZGF0ZVNlcmllcyhuZXdTZXJpZXMsIGFuaW1hdGUsIG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBbGxvd3MgdXNlcnMgdG8gYXBwZW5kIERhdGEgdG8gc2VyaWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IG5ld0RhdGEgLSBOZXcgZGF0YSBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgc2VyaWVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhcHBlbmREYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kRGF0YShuZXdEYXRhKSB7XG4gICAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsU2VyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS53Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBtZS5zZXJpZXMuZ2V0UHJldmlvdXNQYXRocygpO1xuICAgICAgICB2YXIgbmV3U2VyaWVzID0gbWUudy5jb25maWcuc2VyaWVzLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobmV3RGF0YVtpXSAhPT0gbnVsbCAmJiB0eXBlb2YgbmV3RGF0YVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RGF0YVtpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIG5ld1Nlcmllc1tpXS5kYXRhLnB1c2gobmV3RGF0YVtpXS5kYXRhW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS53LmNvbmZpZy5zZXJpZXMgPSBuZXdTZXJpZXM7XG5cbiAgICAgICAgaWYgKG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMpIHtcbiAgICAgICAgICBtZS53Lmdsb2JhbHMuaW5pdGlhbFNlcmllcyA9IFV0aWxzJDEuY2xvbmUobWUudy5jb25maWcuc2VyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiBcInJlcGxhY2VEYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZURhdGEobmV3RGF0YSkge1xuICAgICAgICB2YXIgb3ZlcndyaXRlSW5pdGlhbFNlcmllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUudy5nbG9iYWxzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgbWUuc2VyaWVzLmdldFByZXZpb3VzUGF0aHMoKTtcbiAgICAgICAgdmFyIG5ld1NlcmllcyA9IG1lLncuY29uZmlnLnNlcmllcy5zbGljZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5ld0RhdGFbaV0gIT09IG51bGwgJiYgdHlwZW9mIG5ld0RhdGFbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0RhdGFbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBuZXdTZXJpZXNbaV0uZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBuZXdTZXJpZXNbaV0uZGF0YVtsZW5ndGgtMV0gPSBuZXdEYXRhW2ldLmRhdGFbal07XG4gICAgICAgICAgICAgICAgLy9uZXdTZXJpZXNbaV0uZGF0YS5zcGxpY2UobGVuZ3RoLTEsIDEsIG5ld0RhdGFbaV0uZGF0YVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudy5jb25maWcuc2VyaWVzID0gbmV3U2VyaWVzO1xuXG4gICAgICAgIGlmIChvdmVyd3JpdGVJbml0aWFsU2VyaWVzKSB7XG4gICAgICAgICAgbWUudy5nbG9iYWxzLmluaXRpYWxTZXJpZXMgPSBVdGlscyQxLmNsb25lKG1lLncuY29uZmlnLnNlcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICB7XG4gICAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBuZXcgRGVzdHJveShfdGhpczQuY3R4KS5jbGVhcih7XG4gICAgICAgICAgICBpc1VwZGF0aW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgZ3JhcGhEYXRhID0gX3RoaXM0LmNyZWF0ZShfdGhpczQudy5jb25maWcuc2VyaWVzLCBvcHRpb25zKTtcblxuICAgICAgICAgIGlmICghZ3JhcGhEYXRhKSByZXR1cm4gcmVzb2x2ZShfdGhpczQpO1xuXG4gICAgICAgICAgX3RoaXM0Lm1vdW50KGdyYXBoRGF0YSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzNC53LmNvbmZpZy5jaGFydC5ldmVudHMudXBkYXRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpczQudy5jb25maWcuY2hhcnQuZXZlbnRzLnVwZGF0ZWQoX3RoaXM0LCBfdGhpczQudyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzNC5ldmVudHMuZmlyZUV2ZW50KCd1cGRhdGVkJywgW190aGlzNCwgX3RoaXM0LnddKTtcblxuICAgICAgICAgICAgX3RoaXM0LncuZ2xvYmFscy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoX3RoaXM0KTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogR2V0IGFsbCBjaGFydHMgaW4gdGhlIHNhbWUgXCJncm91cFwiIChpbmNsdWRpbmcgdGhlIGluc3RhbmNlIHdoaWNoIGlzIGNhbGxlZCB1cG9uKSB0byBzeW5jIHRoZW0gd2hlbiB1c2VyIHpvb21zIGluL291dCBvciBwYW4uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTeW5jZWRDaGFydHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTeW5jZWRDaGFydHMoKSB7XG4gICAgICAgIHZhciBjaGFydEdyb3VwcyA9IHRoaXMuZ2V0R3JvdXBlZENoYXJ0cygpO1xuICAgICAgICB2YXIgYWxsQ2hhcnRzID0gW3RoaXNdO1xuXG4gICAgICAgIGlmIChjaGFydEdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICBhbGxDaGFydHMgPSBbXTtcbiAgICAgICAgICBjaGFydEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgICAgYWxsQ2hhcnRzLnB1c2goY2gpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsbENoYXJ0cztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogR2V0IGNoYXJ0cyBpbiB0aGUgc2FtZSBcImdyb3VwXCIgKGV4Y2x1ZGluZyB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgY2FsbGVkIHVwb24pIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGUgb3RoZXIgY2hhcnRzIG9mIHRoZSBzYW1lIGdyb3VwIChlZy4sIHRvb2x0aXAgaG92ZXJpbmcpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRHcm91cGVkQ2hhcnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JvdXBlZENoYXJ0cygpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIEFwZXguX2NoYXJ0SW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgICBpZiAoY2guZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUudy5jb25maWcuY2hhcnQuZ3JvdXAgPT09IGNoLmdyb3VwID8gY2guY2hhcnQgOiBfdGhpczU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b2dnbGVTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVTZXJpZXMoc2VyaWVzTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXMudG9nZ2xlU2VyaWVzKHNlcmllc05hbWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoaWdobGlnaHRTZXJpZXNPbkxlZ2VuZEhvdmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGlnaGxpZ2h0U2VyaWVzT25MZWdlbmRIb3ZlcihlLCB0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllcy50b2dnbGVTZXJpZXNPbkhvdmVyKGUsIHRhcmdldEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaG93U2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd1NlcmllcyhzZXJpZXNOYW1lKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzLnNob3dTZXJpZXMoc2VyaWVzTmFtZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhpZGVTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlU2VyaWVzKHNlcmllc05hbWUpIHtcbiAgICAgICAgdGhpcy5zZXJpZXMuaGlkZVNlcmllcyhzZXJpZXNOYW1lKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNTZXJpZXNIaWRkZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Nlcmllc0hpZGRlbihzZXJpZXNOYW1lKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzLmlzU2VyaWVzSGlkZGVuKHNlcmllc05hbWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXNldFNlcmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U2VyaWVzKCkge1xuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlQ2hhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICAgIHZhciBzaG91bGRSZXNldFpvb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAgIHRoaXMuc2VyaWVzLnJlc2V0U2VyaWVzKHNob3VsZFVwZGF0ZUNoYXJ0LCBzaG91bGRSZXNldFpvb20pO1xuICAgICAgfSAvLyBQdWJsaWMgbWV0aG9kIHRvIGFkZCBldmVudCBsaXN0ZW5lciBvbiBjaGFydCBjb250ZXh0XG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSAvLyBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBvbiBjaGFydCBjb250ZXh0XG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRYYXhpc0Fubm90YXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRYYXhpc0Fubm90YXRpb24ob3B0cykge1xuICAgICAgICB2YXIgcHVzaFRvTWVtb3J5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuYW5ub3RhdGlvbnMuYWRkWGF4aXNBbm5vdGF0aW9uRXh0ZXJuYWwob3B0cywgcHVzaFRvTWVtb3J5LCBtZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFlheGlzQW5ub3RhdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFlheGlzQW5ub3RhdGlvbihvcHRzKSB7XG4gICAgICAgIHZhciBwdXNoVG9NZW1vcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBtZSA9IGNvbnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5hbm5vdGF0aW9ucy5hZGRZYXhpc0Fubm90YXRpb25FeHRlcm5hbChvcHRzLCBwdXNoVG9NZW1vcnksIG1lKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRBbm5vdGF0aW9uKG9wdHMpIHtcbiAgICAgICAgdmFyIHB1c2hUb01lbW9yeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIG1lID0gY29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmFubm90YXRpb25zLmFkZFBvaW50QW5ub3RhdGlvbkV4dGVybmFsKG9wdHMsIHB1c2hUb01lbW9yeSwgbWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhckFubm90YXRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9ucygpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIG1lID0gY29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmFubm90YXRpb25zLmNsZWFyQW5ub3RhdGlvbnMobWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVBbm5vdGF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQW5ub3RhdGlvbihpZCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuYW5ub3RhdGlvbnMucmVtb3ZlQW5ub3RhdGlvbihtZSwgaWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRDaGFydEFyZWFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFydEFyZWEoKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtaW5uZXInKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbFhSYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc1RvdGFsWFJhbmdlKG1pblgsIG1heFgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29yZVV0aWxzLmdldFNlcmllc1RvdGFsc1hSYW5nZShtaW5YLCBtYXhYKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SGlnaGVzdFZhbHVlSW5TZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIaWdoZXN0VmFsdWVJblNlcmllcygpIHtcbiAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5jdHgpO1xuICAgICAgICByZXR1cm4gcmFuZ2UuZ2V0TWluWU1heFkoc2VyaWVzSW5kZXgpLmhpZ2hlc3RZO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRMb3dlc3RWYWx1ZUluU2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG93ZXN0VmFsdWVJblNlcmllcygpIHtcbiAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5jdHgpO1xuICAgICAgICByZXR1cm4gcmFuZ2UuZ2V0TWluWU1heFkoc2VyaWVzSW5kZXgpLmxvd2VzdFk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFNlcmllc1RvdGFsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5zZXJpZXNUb3RhbHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRvZ2dsZURhdGFQb2ludFNlbGVjdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZURhdGFQb2ludFNlbGVjdGlvbihzZXJpZXNJbmRleCwgZGF0YVBvaW50SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSGVscGVycy50b2dnbGVEYXRhUG9pbnRTZWxlY3Rpb24oc2VyaWVzSW5kZXgsIGRhdGFQb2ludEluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiem9vbVhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tWChtaW4sIG1heCkge1xuICAgICAgICB0aGlzLmN0eC50b29sYmFyLnpvb21VcGRhdGVPcHRpb25zKG1pbiwgbWF4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TG9jYWxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZU5hbWUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24uc2V0Q3VycmVudExvY2FsZVZhbHVlcyhsb2NhbGVOYW1lKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGF0YVVSSVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFVUkkob3B0aW9ucykge1xuICAgICAgICB2YXIgZXhwID0gbmV3IEV4cG9ydHModGhpcy5jdHgpO1xuICAgICAgICByZXR1cm4gZXhwLmRhdGFVUkkob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4cG9ydFRvQ1NWXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0VG9DU1YoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIGV4cCA9IG5ldyBFeHBvcnRzKHRoaXMuY3R4KTtcbiAgICAgICAgcmV0dXJuIGV4cC5leHBvcnRUb0NTVihvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGFwZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5QYXBlcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3BhcmVudFJlc2l6ZUNhbGxiYWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcmVudFJlc2l6ZUNhbGxiYWNrKCkge1xuICAgICAgICBpZiAodGhpcy53Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgJiYgdGhpcy53LmNvbmZpZy5jaGFydC5yZWRyYXdPblBhcmVudFJlc2l6ZSkge1xuICAgICAgICAgIHRoaXMuX3dpbmRvd1Jlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSB3aW5kb3cgcmVzaXplIGFuZCByZS1kcmF3IHRoZSB3aG9sZSBjaGFydC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl93aW5kb3dSZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2luZG93UmVzaXplKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53Lmdsb2JhbHMucmVzaXplVGltZXIpO1xuICAgICAgICB0aGlzLncuZ2xvYmFscy5yZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYudy5nbG9iYWxzLnJlc2l6ZWQgPSB0cnVlO1xuICAgICAgICAgIF90aGlzNi53Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSBmYWxzZTsgLy8gd2UgbmVlZCB0byByZWRyYXcgdGhlIHdob2xlIGNoYXJ0IG9uIHdpbmRvdyByZXNpemUgKHdpdGggYSBzbWFsbCBkZWxheSkuXG5cbiAgICAgICAgICBfdGhpczYuY3R4LnVwZGF0ZSgpO1xuICAgICAgICB9LCAxNTApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfd2luZG93UmVzaXplSGFuZGxlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93aW5kb3dSZXNpemVIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcmVkcmF3ID0gdGhpcy53LmNvbmZpZy5jaGFydC5yZWRyYXdPbldpbmRvd1Jlc2l6ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlZHJhdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlZHJhdyA9IHJlZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVkcmF3ICYmIHRoaXMuX3dpbmRvd1Jlc2l6ZSgpO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImdldENoYXJ0QnlJRFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYXJ0QnlJRChpZCkge1xuICAgICAgICB2YXIgY2hhcnRJZCA9IFV0aWxzJDEuZXNjYXBlU3RyaW5nKGlkKTtcbiAgICAgICAgaWYgKCFBcGV4Ll9jaGFydEluc3RhbmNlcykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgYyA9IEFwZXguX2NoYXJ0SW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgICByZXR1cm4gY2guaWQgPT09IGNoYXJ0SWQ7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIHJldHVybiBjICYmIGMuY2hhcnQ7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEFsbG93cyB0aGUgdXNlciB0byBwcm92aWRlIGRhdGEgYXR0cnMgaW4gdGhlIGVsZW1lbnQgYW5kIHRoZSBjaGFydCB3aWxsIHJlbmRlciBhdXRvbWF0aWNhbGx5IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGVsZW1lbnRzIGNvbnRhaW5pbmcgJ2RhdGEtYXBleGNoYXJ0cycgYXR0cmlidXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbml0T25Mb2FkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdE9uTG9hZCgpIHtcbiAgICAgICAgdmFyIGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFwZXhjaGFydHNdJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWwgPSBlbHNbaV07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBKU09OLnBhcnNlKGVsc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3B0aW9ucycpKTtcbiAgICAgICAgICB2YXIgYXBleENoYXJ0ID0gbmV3IEFwZXhDaGFydHMoZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIGFwZXhDaGFydC5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2QgYWxsb3dzIHVzZXJzIHRvIGNhbGwgY2hhcnQgbWV0aG9kcyB3aXRob3V0IG5lY2Vzc2FyaWx5IGZyb20gdGhlXG4gICAgICAgKiBpbnN0YW5jZSBvZiB0aGUgY2hhcnQgaW4gY2FzZSB1c2VyIGhhcyBhc3NpZ25lZCBjaGFydElEIHRvIHRoZSB0YXJnZXRlZCBjaGFydC5cbiAgICAgICAqIFRoZSBjaGFydElEIGlzIHVzZWQgZm9yIG1hcHBpbmcgdGhlIGluc3RhbmNlIHN0b3JlZCBpbiBBcGV4Ll9jaGFydEluc3RhbmNlcyBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGhlbHBmdWwgaW4gY2FzZXMgd2hlbiB5b3UgZG9uJ3QgaGF2ZSByZWZlcmVuY2Ugb2YgdGhlIGNoYXJ0IGluc3RhbmNlXG4gICAgICAgKiBlYXNpbHkgYW5kIG5lZWQgdG8gY2FsbCB0aGUgbWV0aG9kIGZyb20gYW55d2hlcmUuXG4gICAgICAgKiBGb3IgZWcsIGluIFJlYWN0L1Z1ZSBhcHBsaWNhdGlvbnMgd2hlbiB5b3UgaGF2ZSBtYW55IHBhcmVudC9jaGlsZCBjb21wb25lbnRzLFxuICAgICAgICogYW5kIG5lZWQgZWFzeSByZWZlcmVuY2UgdG8gb3RoZXIgY2hhcnRzIGZvciBwZXJmb3JtaW5nIGR5bmFtaWMgb3BlcmF0aW9uc1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydElEIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjYWxsIG1ldGhvZHNcbiAgICAgICAqIG9uIHRoYXQgY2hhcnQgaW5zdGFuY2VcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIG1ldGhvZCBuYW1lIHRvIGNhbGxcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gVGhlIHBhcmFtZXRlcnMgd2hpY2ggYXJlIGFjY2VwdGVkIGluIHRoZSBvcmlnaW5hbCBtZXRob2Qgd2lsbCBiZSBwYXNzZWQgaGVyZSBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImV4ZWNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjKGNoYXJ0SUQsIGZuKSB7XG4gICAgICAgIHZhciBjaGFydCA9IHRoaXMuZ2V0Q2hhcnRCeUlEKGNoYXJ0SUQpO1xuICAgICAgICBpZiAoIWNoYXJ0KSByZXR1cm47IC8vIHR1cm4gb24gdGhlIGdsb2JhbCBleGVjIGZsYWcgdG8gaW5kaWNhdGUgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZFxuXG4gICAgICAgIGNoYXJ0LncuZ2xvYmFscy5pc0V4ZWNDYWxsZWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmV0ID0gbnVsbDtcblxuICAgICAgICBpZiAoY2hhcnQucHVibGljTWV0aG9kcy5pbmRleE9mKGZuKSAhPT0gLTEpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3B0cyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBvcHRzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXQgPSBjaGFydFtmbl0uYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWVyZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gVXRpbHMkMS5leHRlbmQodGFyZ2V0LCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBcGV4Q2hhcnRzO1xuICB9KCk7XG5cbiAgcmV0dXJuIEFwZXhDaGFydHMkMTtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apexcharts/dist/apexcharts.js\n");

/***/ }),

/***/ "./resources/js/graph.js":
/*!*******************************!*\
  !*** ./resources/js/graph.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _graph_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph_data */ \"./resources/js/graph_data.js\");\n/* harmony import */ var _graph_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph_service */ \"./resources/js/graph_service.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar _staticGraph;\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar graphData = {};\nvar mode = 'm1';\nfunction staticGraph() {\n  return (_staticGraph = _staticGraph || _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return (0,_graph_data__WEBPACK_IMPORTED_MODULE_0__.getGraphData)();\n        case 2:\n          graphData = _context.sent;\n          (0,_graph_service__WEBPACK_IMPORTED_MODULE_1__.drawGraph)(graphData, mode);\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }))).apply(this, arguments);\n}\n$(document).ready(function () {\n  staticGraph();\n  $('#m1').click(function () {\n    mode = 'm1';\n    (0,_graph_service__WEBPACK_IMPORTED_MODULE_1__.changeGraphMode)(graphData, mode);\n  });\n  $('#m5').click(function () {\n    mode = 'm5';\n    (0,_graph_service__WEBPACK_IMPORTED_MODULE_1__.changeGraphMode)(graphData, mode);\n    console.log(mode);\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBQTtVQUVUZ0UseURBQVMsQ0FBQ0ssU0FBUyxFQUFFQyxJQUFJLENBQUM7UUFBQztRQUFBO1VBQUEsT0FBQUssUUFBQSxDQUFBdkMsSUFBQTtNQUFBO0lBQUEsR0FBQXFDLE9BQUE7RUFBQSxDQUM5QixJQUFBakIsS0FBQSxPQUFBRCxTQUFBO0FBQUE7QUFFRHFCLENBQUMsQ0FBQ0MsUUFBUSxDQUFDLENBQUNDLEtBQUssQ0FBQyxZQUFVO0VBQ3hCUCxXQUFXLENBQUMsQ0FBQztFQUViSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUNHLEtBQUssQ0FBQyxZQUFXO0lBQ3RCVCxJQUFJLEdBQUcsSUFBSTtJQUNYRiwrREFBZSxDQUFDQyxTQUFTLEVBQUVDLElBQUksQ0FBQztFQUNwQyxDQUFDLENBQUM7RUFDRk0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDRyxLQUFLLENBQUMsWUFBVztJQUN0QlQsSUFBSSxHQUFHLElBQUk7SUFDWEYsK0RBQWUsQ0FBQ0MsU0FBUyxFQUFFQyxJQUFJLENBQUM7SUFDaENVLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDWCxJQUFJLENBQUM7RUFDckIsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2dyYXBoLmpzP2YyZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQge2dldEdyYXBoRGF0YSwgc2V0R3JhcGhEYXRhLCBnZXQ2MCwgZ2V0TmV4dCwgZ2VuZXJhdGVSZWFsVGltZURhdGF9IGZyb20gJy4vZ3JhcGhfZGF0YSc7XG5pbXBvcnQge2RyYXdHcmFwaCwgdXBkYXRlR3JhcGgsIGFwcGVuZEdyYXBoLCBhcHBlbmRJbmRpY2F0b3IsIGNoYW5nZUdyYXBoTW9kZX0gZnJvbSAnLi9ncmFwaF9zZXJ2aWNlJztcblxudmFyIGdyYXBoRGF0YSA9IHt9O1xuXG52YXIgbW9kZSA9ICdtMSc7XG5cbmFzeW5jIGZ1bmN0aW9uIHN0YXRpY0dyYXBoKCkge1xuICAgIGdyYXBoRGF0YSA9IGF3YWl0IGdldEdyYXBoRGF0YSgpO1xuXG4gICAgZHJhd0dyYXBoKGdyYXBoRGF0YSwgbW9kZSk7XG59XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgc3RhdGljR3JhcGgoKTtcblxuICAgICQoJyNtMScpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBtb2RlID0gJ20xJztcbiAgICAgICAgY2hhbmdlR3JhcGhNb2RlKGdyYXBoRGF0YSwgbW9kZSk7XG4gICAgfSk7XG4gICAgJCgnI201JykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGUgPSAnbTUnO1xuICAgICAgICBjaGFuZ2VHcmFwaE1vZGUoZ3JhcGhEYXRhLCBtb2RlKTtcbiAgICAgICAgY29uc29sZS5sb2cobW9kZSk7XG4gICAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJfcmVnZW5lcmF0b3JSdW50aW1lIiwiZSIsInQiLCJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwibiIsImhhc093blByb3BlcnR5IiwibyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJpIiwiU3ltYm9sIiwiYSIsIml0ZXJhdG9yIiwiYyIsImFzeW5jSXRlcmF0b3IiLCJ1IiwidG9TdHJpbmdUYWciLCJkZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ3cmFwIiwiR2VuZXJhdG9yIiwiY3JlYXRlIiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsInR5cGUiLCJhcmciLCJjYWxsIiwiaCIsImwiLCJmIiwicyIsInkiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwicCIsImQiLCJnZXRQcm90b3R5cGVPZiIsInYiLCJ2YWx1ZXMiLCJnIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiZm9yRWFjaCIsIl9pbnZva2UiLCJBc3luY0l0ZXJhdG9yIiwiaW52b2tlIiwiX3R5cGVvZiIsInJlc29sdmUiLCJfX2F3YWl0IiwidGhlbiIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiRXJyb3IiLCJkb25lIiwibWV0aG9kIiwiZGVsZWdhdGUiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJUeXBlRXJyb3IiLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJwdXNoIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsImlzTmFOIiwibGVuZ3RoIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJrZXlzIiwicmV2ZXJzZSIsInBvcCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJydmFsIiwiaGFuZGxlIiwiY29tcGxldGUiLCJmaW5pc2giLCJfY2F0Y2giLCJkZWxlZ2F0ZVlpZWxkIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJrZXkiLCJpbmZvIiwiZXJyb3IiLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwic2VsZiIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsImVyciIsInVuZGVmaW5lZCIsImdldEdyYXBoRGF0YSIsInNldEdyYXBoRGF0YSIsImdldDYwIiwiZ2V0TmV4dCIsImdlbmVyYXRlUmVhbFRpbWVEYXRhIiwiZHJhd0dyYXBoIiwidXBkYXRlR3JhcGgiLCJhcHBlbmRHcmFwaCIsImFwcGVuZEluZGljYXRvciIsImNoYW5nZUdyYXBoTW9kZSIsImdyYXBoRGF0YSIsIm1vZGUiLCJzdGF0aWNHcmFwaCIsIl9zdGF0aWNHcmFwaCIsIl9jYWxsZWUiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwiJCIsImRvY3VtZW50IiwicmVhZHkiLCJjbGljayIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/graph.js\n");

/***/ }),

/***/ "./resources/js/graph_data.js":
/*!************************************!*\
  !*** ./resources/js/graph_data.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateRealTimeData: () => (/* binding */ generateRealTimeData),\n/* harmony export */   getGraphData: () => (/* binding */ getGraphData),\n/* harmony export */   loadFutureData: () => (/* binding */ loadFutureData),\n/* harmony export */   loadGraphData: () => (/* binding */ loadGraphData),\n/* harmony export */   shiftData: () => (/* binding */ shiftData)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar formatCandlesData = function formatCandlesData(data) {\n  return $.map(data, function (n) {\n    var _n = _toArray(n),\n      time = _n[0],\n      prices = _n.slice(1);\n    return {\n      x: new Date(time * 1000),\n      y: prices\n    };\n  });\n};\nvar formatBbData = function formatBbData(data) {\n  var bbData = {\n    'sma': [],\n    'upper': [],\n    'lower': []\n  };\n  $.each(data, function (i, n) {\n    var _n2 = _slicedToArray(n, 5),\n      time = _n2[0],\n      sma = _n2[1],\n      sd = _n2[2],\n      upper = _n2[3],\n      lower = _n2[4];\n    bbData['sma'].push({\n      x: new Date(time * 1000),\n      y: sma\n    });\n    bbData['upper'].push({\n      x: new Date(time * 1000),\n      y: upper\n    });\n    bbData['lower'].push({\n      x: new Date(time * 1000),\n      y: lower\n    });\n  });\n  return bbData;\n};\nvar graphData = {\n  candles: [],\n  bb_data: []\n};\nvar futureData = {\n  candles: [],\n  bb_data: []\n};\nvar currentData = {};\nvar realTimeDatas = [];\nvar shiftCount = 0;\nfunction loadGraphData() {\n  return new Promise(function (resolve) {\n    $.getJSON('/graph/data/' + $('#start').val(), function (response) {\n      graphData = {\n        m1_candles: formatCandlesData(response.candles),\n        m1_bb_data: formatBbData(response.bb_data),\n        m5_candles: formatCandlesData(response.m5_candles),\n        m5_bb_data: formatBbData(response.m5_bb_data),\n        m15_candles: formatCandlesData(response.m15_candles),\n        m15_bb_data: formatBbData(response.m15_bb_data),\n        m60_candles: formatCandlesData(response.m60_candles),\n        m60_bb_data: formatBbData(response.m60_bb_data)\n      };\n      resolve(graphData);\n    });\n  });\n}\nfunction loadFutureData() {\n  return new Promise(function (resolve) {\n    $.getJSON('/graph/future_data/' + $('#start').val(), function (response) {\n      futureData = {\n        m1_candles: formatCandlesData(response.candles),\n        m1_bb_data: formatBbData(response.bb_data),\n        m5_candles: formatCandlesData(response.m5_candles),\n        m5_bb_data: formatBbData(response.m5_bb_data),\n        m15_candles: formatCandlesData(response.m15_candles),\n        m15_bb_data: formatBbData(response.m15_bb_data),\n        m60_candles: formatCandlesData(response.m60_candles),\n        m60_bb_data: formatBbData(response.m60_bb_data)\n      };\n      resolve(futureData);\n    });\n  });\n}\nfunction getGraphData(data) {\n  return graphData;\n}\nfunction shiftData() {\n  if (shiftCount % 10 == 0) {\n    currentData.m1_candles = futureData.m1_candles.shift();\n    currentData.m1_bb_data = {\n      sma: futureData.m1_bb_data.sma.shift(),\n      lower: futureData.m1_bb_data.lower.shift(),\n      upper: futureData.m1_bb_data.upper.shift()\n    };\n  }\n  if (shiftCount % 50 == 0) {\n    currentData.m5_candles = futureData.m5_candles.shift();\n    currentData.m5_bb_data = {\n      sma: futureData.m5_bb_data.sma.shift(),\n      lower: futureData.m5_bb_data.lower.shift(),\n      upper: futureData.m5_bb_data.upper.shift()\n    };\n  }\n  if (shiftCount % 150 == 0) {\n    currentData.m15_candles = futureData.m15_candles.shift();\n    currentData.m15_bb_data = {\n      sma: futureData.m15_bb_data.sma.shift(),\n      lower: futureData.m15_bb_data.lower.shift(),\n      upper: futureData.m15_bb_data.upper.shift()\n    };\n  }\n  if (shiftCount % 600 == 0) {\n    currentData.m60_candles = futureData.m60_candles.shift();\n    currentData.m60_bb_data = {\n      sma: futureData.m60_bb_data.sma.shift(),\n      lower: futureData.m60_bb_data.lower.shift(),\n      upper: futureData.m60_bb_data.upper.shift()\n    };\n  }\n  if (realTimeDatas.length === 0) {\n    var nextCandle = currentData.m1_candles;\n    realTimeDatas = generateRealTimeData(nextCandle);\n  }\n  var realTimeData = realTimeDatas.shift();\n  var currentM5Candle;\n  var currentM15Candle;\n  var currentM60Candle;\n  if (shiftCount % 10 === 0) {\n    graphData.m1_candles.push(realTimeData);\n    graphData.m1_bb_data.sma.push(currentData.m1_bb_data.sma);\n    graphData.m1_bb_data.upper.push(currentData.m1_bb_data.upper);\n    graphData.m1_bb_data.lower.push(currentData.m1_bb_data.lower);\n  } else {\n    graphData.m1_candles[graphData.m1_candles.length - 1] = realTimeData;\n  }\n  if (shiftCount % 50 === 0) {\n    currentM5Candle = {\n      x: realTimeData.x,\n      y: $.extend([], realTimeData.y)\n    };\n    graphData.m5_candles.push(currentM5Candle);\n    graphData.m5_bb_data.sma.push(currentData.m5_bb_data.sma);\n    graphData.m5_bb_data.upper.push(currentData.m5_bb_data.upper);\n    graphData.m5_bb_data.lower.push(currentData.m5_bb_data.lower);\n  } else {\n    currentM5Candle = graphData.m5_candles[graphData.m5_candles.length - 1];\n    currentM5Candle.y[3] = realTimeData.y[3];\n    if (currentM5Candle.y[1] < realTimeData.y[1]) {\n      currentM5Candle.y[1] = realTimeData.y[1];\n    }\n    if (currentM5Candle.y[2] > realTimeData.y[2]) {\n      currentM5Candle.y[2] = realTimeData.y[2];\n    }\n    graphData.m5_candles[graphData.m5_candles.length - 1] = currentM5Candle;\n  }\n  if (shiftCount % 150 === 0) {\n    currentM15Candle = {\n      x: realTimeData.x,\n      y: $.extend([], realTimeData.y)\n    };\n    graphData.m15_candles.push(currentM15Candle);\n    graphData.m15_bb_data.sma.push(currentData.m15_bb_data.sma);\n    graphData.m15_bb_data.upper.push(currentData.m15_bb_data.upper);\n    graphData.m15_bb_data.lower.push(currentData.m15_bb_data.lower);\n  } else {\n    currentM15Candle = graphData.m15_candles[graphData.m15_candles.length - 1];\n    currentM15Candle.y[3] = realTimeData.y[3];\n    if (currentM15Candle.y[1] < realTimeData.y[1]) {\n      currentM15Candle.y[1] = realTimeData.y[1];\n    }\n    if (currentM15Candle.y[2] > realTimeData.y[2]) {\n      currentM15Candle.y[2] = realTimeData.y[2];\n    }\n    graphData.m15_candles[graphData.m15_candles.length - 1] = currentM15Candle;\n  }\n  if (shiftCount % 600 === 0) {\n    currentM60Candle = {\n      x: realTimeData.x,\n      y: $.extend([], realTimeData.y)\n    };\n    graphData.m60_candles.push(currentM60Candle);\n    graphData.m60_bb_data.sma.push(currentData.m60_bb_data.sma);\n    graphData.m60_bb_data.upper.push(currentData.m60_bb_data.upper);\n    graphData.m60_bb_data.lower.push(currentData.m60_bb_data.lower);\n  } else {\n    currentM60Candle = graphData.m60_candles[graphData.m60_candles.length - 1];\n    currentM60Candle.y[3] = realTimeData.y[3];\n    if (currentM60Candle.y[1] < realTimeData.y[1]) {\n      currentM60Candle.y[1] = realTimeData.y[1];\n    }\n    if (currentM60Candle.y[2] > realTimeData.y[2]) {\n      currentM60Candle.y[2] = realTimeData.y[2];\n    }\n    graphData.m60_candles[graphData.m60_candles.length - 1] = currentM60Candle;\n  }\n  shiftCount++;\n  return [shiftCount - 1, realTimeData, currentData.m1_bb_data, currentM5Candle, currentData.m5_bb_data, currentM15Candle, currentData.m15_bb_data, currentM60Candle, currentData.m60_bb_data];\n}\nfunction generateRealTimeData(candle) {\n  var candles = [];\n  var openIndex = 0,\n    highIndex = 3,\n    lowIndex = 6,\n    closeIndex = 9;\n  var open, high, low, close;\n  for (var i = 0; i <= 3; i++) {\n    candle.y[i] = parseFloat(candle.y[i]);\n  }\n  for (var i = 0; i <= 9; i++) {\n    if (i == openIndex) {\n      open = high = low = close = candle.y[0];\n    } else if (i < highIndex) {\n      close = candle.y[0] + (candle.y[1] - candle.y[0]) * i / 3;\n      high = close;\n    } else if (i == highIndex) {\n      close = candle.y[1];\n      high = close;\n    } else if (i < lowIndex) {\n      close = candle.y[1] - (candle.y[1] - candle.y[2]) * (i - 3) / 3;\n      if (close < low) {\n        low = close;\n      }\n    } else if (i == lowIndex) {\n      close = candle.y[2];\n      low = close;\n    } else if (i < closeIndex) {\n      close = candle.y[2] + (candle.y[3] - candle.y[2]) * (i - 6) / 3;\n    } else if (i == closeIndex) {\n      close = candle.y[3];\n    }\n    candles[i] = {\n      x: candle.x,\n      y: [open.toFixed(2), high.toFixed(2), low.toFixed(2), close.toFixed(2)]\n    };\n  }\n  return candles;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3QyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQzZDLE1BQU0sQ0FBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzZDLE1BQU0sQ0FBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBS0ksQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDakUsQ0FBQyxNQUFNLElBQUlBLENBQUMsSUFBSTZDLFVBQVUsRUFBRTtNQUN4QkksS0FBSyxHQUFHUixNQUFNLENBQUM3QyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCO0lBQ0FhLE9BQU8sQ0FBQ1QsQ0FBQyxDQUFDLEdBQUc7TUFDVE4sQ0FBQyxFQUFFK0MsTUFBTSxDQUFDL0MsQ0FBQztNQUNYRSxDQUFDLEVBQUUsQ0FBQ2tELElBQUksQ0FBQ0ssT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFSixJQUFJLENBQUNJLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRUgsR0FBRyxDQUFDRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUVGLEtBQUssQ0FBQ0UsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUMxRSxDQUFDO0VBQ0w7RUFDQSxPQUFPMUMsT0FBTztBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9ncmFwaF9kYXRhLmpzPzg5MzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGZvcm1hdENhbmRsZXNEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiAkLm1hcCggZGF0YSwgZnVuY3Rpb24oIG4gKSB7XG4gICAgICAgIGNvbnN0IFt0aW1lLCAuLi5wcmljZXNdID0gbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBuZXcgRGF0ZSh0aW1lICogMTAwMCksXG4gICAgICAgICAgeTogcHJpY2VzXG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIGZvcm1hdEJiRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgYmJEYXRhID0ge1xuICAgICAgICAnc21hJyA6IFtdLFxuICAgICAgICAndXBwZXInIDogW10sXG4gICAgICAgICdsb3dlcicgOiBbXVxuICAgIH1cblxuICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbihpLCBuKSB7XG4gICAgICAgIGNvbnN0IFt0aW1lLCBzbWEsIHNkLCB1cHBlciwgbG93ZXJdID0gbjtcbiAgICAgICAgYmJEYXRhWydzbWEnXS5wdXNoKHtcbiAgICAgICAgICAgIHg6IG5ldyBEYXRlKHRpbWUgKiAxMDAwKSxcbiAgICAgICAgICAgIHk6IHNtYVxuICAgICAgICB9KTtcbiAgICAgICAgYmJEYXRhWyd1cHBlciddLnB1c2goe1xuICAgICAgICAgICAgeDogbmV3IERhdGUodGltZSAqIDEwMDApLFxuICAgICAgICAgICAgeTogdXBwZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGJiRGF0YVsnbG93ZXInXS5wdXNoKHtcbiAgICAgICAgICAgIHg6IG5ldyBEYXRlKHRpbWUgKiAxMDAwKSxcbiAgICAgICAgICAgIHk6IGxvd2VyXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBiYkRhdGE7XG59XG5cbnZhciBncmFwaERhdGEgPSB7XG4gICAgY2FuZGxlczogW10sXG4gICAgYmJfZGF0YTogW11cbn07XG52YXIgZnV0dXJlRGF0YSA9IHtcbiAgICBjYW5kbGVzOiBbXSxcbiAgICBiYl9kYXRhOiBbXVxufTtcblxudmFyIGN1cnJlbnREYXRhID0ge307XG52YXIgcmVhbFRpbWVEYXRhcyA9IFtdO1xudmFyIHNoaWZ0Q291bnQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEdyYXBoRGF0YSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgJC5nZXRKU09OKCcvZ3JhcGgvZGF0YS8nICsgJCgnI3N0YXJ0JykudmFsKCksIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBncmFwaERhdGEgPSB7XG4gICAgICAgICAgICAgICAgbTFfY2FuZGxlczogZm9ybWF0Q2FuZGxlc0RhdGEocmVzcG9uc2UuY2FuZGxlcyksXG4gICAgICAgICAgICAgICAgbTFfYmJfZGF0YTogZm9ybWF0QmJEYXRhKHJlc3BvbnNlLmJiX2RhdGEpLFxuICAgICAgICAgICAgICAgIG01X2NhbmRsZXM6IGZvcm1hdENhbmRsZXNEYXRhKHJlc3BvbnNlLm01X2NhbmRsZXMpLFxuICAgICAgICAgICAgICAgIG01X2JiX2RhdGE6IGZvcm1hdEJiRGF0YShyZXNwb25zZS5tNV9iYl9kYXRhKSxcbiAgICAgICAgICAgICAgICBtMTVfY2FuZGxlczogZm9ybWF0Q2FuZGxlc0RhdGEocmVzcG9uc2UubTE1X2NhbmRsZXMpLFxuICAgICAgICAgICAgICAgIG0xNV9iYl9kYXRhOiBmb3JtYXRCYkRhdGEocmVzcG9uc2UubTE1X2JiX2RhdGEpLFxuICAgICAgICAgICAgICAgIG02MF9jYW5kbGVzOiBmb3JtYXRDYW5kbGVzRGF0YShyZXNwb25zZS5tNjBfY2FuZGxlcyksXG4gICAgICAgICAgICAgICAgbTYwX2JiX2RhdGE6IGZvcm1hdEJiRGF0YShyZXNwb25zZS5tNjBfYmJfZGF0YSksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGdyYXBoRGF0YSk7XG4gICAgICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGdXR1cmVEYXRhKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAkLmdldEpTT04oJy9ncmFwaC9mdXR1cmVfZGF0YS8nICsgJCgnI3N0YXJ0JykudmFsKCksIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBmdXR1cmVEYXRhID0ge1xuICAgICAgICAgICAgICAgIG0xX2NhbmRsZXM6IGZvcm1hdENhbmRsZXNEYXRhKHJlc3BvbnNlLmNhbmRsZXMpLFxuICAgICAgICAgICAgICAgIG0xX2JiX2RhdGE6IGZvcm1hdEJiRGF0YShyZXNwb25zZS5iYl9kYXRhKSxcbiAgICAgICAgICAgICAgICBtNV9jYW5kbGVzOiBmb3JtYXRDYW5kbGVzRGF0YShyZXNwb25zZS5tNV9jYW5kbGVzKSxcbiAgICAgICAgICAgICAgICBtNV9iYl9kYXRhOiBmb3JtYXRCYkRhdGEocmVzcG9uc2UubTVfYmJfZGF0YSksXG4gICAgICAgICAgICAgICAgbTE1X2NhbmRsZXM6IGZvcm1hdENhbmRsZXNEYXRhKHJlc3BvbnNlLm0xNV9jYW5kbGVzKSxcbiAgICAgICAgICAgICAgICBtMTVfYmJfZGF0YTogZm9ybWF0QmJEYXRhKHJlc3BvbnNlLm0xNV9iYl9kYXRhKSxcbiAgICAgICAgICAgICAgICBtNjBfY2FuZGxlczogZm9ybWF0Q2FuZGxlc0RhdGEocmVzcG9uc2UubTYwX2NhbmRsZXMpLFxuICAgICAgICAgICAgICAgIG02MF9iYl9kYXRhOiBmb3JtYXRCYkRhdGEocmVzcG9uc2UubTYwX2JiX2RhdGEpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShmdXR1cmVEYXRhKTtcbiAgICAgICAgfSk7XG4gIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcmFwaERhdGEoZGF0YSkge1xuICAgIHJldHVybiBncmFwaERhdGE7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaWZ0RGF0YSgpIHtcblxuICAgIGlmIChzaGlmdENvdW50ICUgMTAgPT0gMCkge1xuICAgICAgICBjdXJyZW50RGF0YS5tMV9jYW5kbGVzID0gZnV0dXJlRGF0YS5tMV9jYW5kbGVzLnNoaWZ0KCk7XG4gICAgICAgIGN1cnJlbnREYXRhLm0xX2JiX2RhdGEgPSB7XG4gICAgICAgICAgICBzbWE6IGZ1dHVyZURhdGEubTFfYmJfZGF0YS5zbWEuc2hpZnQoKSxcbiAgICAgICAgICAgIGxvd2VyOiBmdXR1cmVEYXRhLm0xX2JiX2RhdGEubG93ZXIuc2hpZnQoKSxcbiAgICAgICAgICAgIHVwcGVyOiBmdXR1cmVEYXRhLm0xX2JiX2RhdGEudXBwZXIuc2hpZnQoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzaGlmdENvdW50ICUgNTAgPT0gMCkge1xuICAgICAgICBjdXJyZW50RGF0YS5tNV9jYW5kbGVzID0gZnV0dXJlRGF0YS5tNV9jYW5kbGVzLnNoaWZ0KCk7XG4gICAgICAgIGN1cnJlbnREYXRhLm01X2JiX2RhdGEgPSB7XG4gICAgICAgICAgICBzbWE6IGZ1dHVyZURhdGEubTVfYmJfZGF0YS5zbWEuc2hpZnQoKSxcbiAgICAgICAgICAgIGxvd2VyOiBmdXR1cmVEYXRhLm01X2JiX2RhdGEubG93ZXIuc2hpZnQoKSxcbiAgICAgICAgICAgIHVwcGVyOiBmdXR1cmVEYXRhLm01X2JiX2RhdGEudXBwZXIuc2hpZnQoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2hpZnRDb3VudCAlIDE1MCA9PSAwKSB7XG4gICAgICAgIGN1cnJlbnREYXRhLm0xNV9jYW5kbGVzID0gZnV0dXJlRGF0YS5tMTVfY2FuZGxlcy5zaGlmdCgpO1xuICAgICAgICBjdXJyZW50RGF0YS5tMTVfYmJfZGF0YSA9IHtcbiAgICAgICAgICAgIHNtYTogZnV0dXJlRGF0YS5tMTVfYmJfZGF0YS5zbWEuc2hpZnQoKSxcbiAgICAgICAgICAgIGxvd2VyOiBmdXR1cmVEYXRhLm0xNV9iYl9kYXRhLmxvd2VyLnNoaWZ0KCksXG4gICAgICAgICAgICB1cHBlcjogZnV0dXJlRGF0YS5tMTVfYmJfZGF0YS51cHBlci5zaGlmdCgpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHNoaWZ0Q291bnQgJSA2MDAgPT0gMCkge1xuICAgICAgICBjdXJyZW50RGF0YS5tNjBfY2FuZGxlcyA9IGZ1dHVyZURhdGEubTYwX2NhbmRsZXMuc2hpZnQoKTtcbiAgICAgICAgY3VycmVudERhdGEubTYwX2JiX2RhdGEgPSB7XG4gICAgICAgICAgICBzbWE6IGZ1dHVyZURhdGEubTYwX2JiX2RhdGEuc21hLnNoaWZ0KCksXG4gICAgICAgICAgICBsb3dlcjogZnV0dXJlRGF0YS5tNjBfYmJfZGF0YS5sb3dlci5zaGlmdCgpLFxuICAgICAgICAgICAgdXBwZXI6IGZ1dHVyZURhdGEubTYwX2JiX2RhdGEudXBwZXIuc2hpZnQoKVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgaWYgKHJlYWxUaW1lRGF0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBuZXh0Q2FuZGxlID0gY3VycmVudERhdGEubTFfY2FuZGxlcztcbiAgICAgICAgcmVhbFRpbWVEYXRhcyA9IGdlbmVyYXRlUmVhbFRpbWVEYXRhKG5leHRDYW5kbGUpO1xuICAgIH1cblxuICAgIHZhciByZWFsVGltZURhdGEgPSAgcmVhbFRpbWVEYXRhcy5zaGlmdCgpO1xuICAgIHZhciBjdXJyZW50TTVDYW5kbGU7XG4gICAgdmFyIGN1cnJlbnRNMTVDYW5kbGU7XG4gICAgdmFyIGN1cnJlbnRNNjBDYW5kbGU7XG5cbiAgICBpZiAoc2hpZnRDb3VudCAlIDEwID09PSAwKSB7XG4gICAgICAgIGdyYXBoRGF0YS5tMV9jYW5kbGVzLnB1c2gocmVhbFRpbWVEYXRhKTtcbiAgICAgICAgZ3JhcGhEYXRhLm0xX2JiX2RhdGEuc21hLnB1c2goY3VycmVudERhdGEubTFfYmJfZGF0YS5zbWEpO1xuICAgICAgICBncmFwaERhdGEubTFfYmJfZGF0YS51cHBlci5wdXNoKGN1cnJlbnREYXRhLm0xX2JiX2RhdGEudXBwZXIpO1xuICAgICAgICBncmFwaERhdGEubTFfYmJfZGF0YS5sb3dlci5wdXNoKGN1cnJlbnREYXRhLm0xX2JiX2RhdGEubG93ZXIpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ3JhcGhEYXRhLm0xX2NhbmRsZXNbZ3JhcGhEYXRhLm0xX2NhbmRsZXMubGVuZ3RoIC0gMV0gPSByZWFsVGltZURhdGE7XG4gICAgfVxuXG4gICAgaWYgKHNoaWZ0Q291bnQgJSA1MCA9PT0gMCkge1xuICAgICAgICBjdXJyZW50TTVDYW5kbGUgPSB7XG4gICAgICAgICAgICB4OiByZWFsVGltZURhdGEueCxcbiAgICAgICAgICAgIHk6ICQuZXh0ZW5kKFtdLCByZWFsVGltZURhdGEueSlcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoRGF0YS5tNV9jYW5kbGVzLnB1c2goY3VycmVudE01Q2FuZGxlKTtcbiAgICAgICAgZ3JhcGhEYXRhLm01X2JiX2RhdGEuc21hLnB1c2goY3VycmVudERhdGEubTVfYmJfZGF0YS5zbWEpO1xuICAgICAgICBncmFwaERhdGEubTVfYmJfZGF0YS51cHBlci5wdXNoKGN1cnJlbnREYXRhLm01X2JiX2RhdGEudXBwZXIpO1xuICAgICAgICBncmFwaERhdGEubTVfYmJfZGF0YS5sb3dlci5wdXNoKGN1cnJlbnREYXRhLm01X2JiX2RhdGEubG93ZXIpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE01Q2FuZGxlID0gZ3JhcGhEYXRhLm01X2NhbmRsZXNbZ3JhcGhEYXRhLm01X2NhbmRsZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgY3VycmVudE01Q2FuZGxlLnlbM10gPSByZWFsVGltZURhdGEueVszXTtcblxuICAgICAgICBpZiAoY3VycmVudE01Q2FuZGxlLnlbMV0gPCByZWFsVGltZURhdGEueVsxXSkge1xuICAgICAgICAgICAgY3VycmVudE01Q2FuZGxlLnlbMV0gPSByZWFsVGltZURhdGEueVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE01Q2FuZGxlLnlbMl0gPiByZWFsVGltZURhdGEueVsyXSkge1xuICAgICAgICAgICAgY3VycmVudE01Q2FuZGxlLnlbMl0gPSByZWFsVGltZURhdGEueVsyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoRGF0YS5tNV9jYW5kbGVzW2dyYXBoRGF0YS5tNV9jYW5kbGVzLmxlbmd0aCAtIDFdID0gY3VycmVudE01Q2FuZGxlO1xuICAgIH1cblxuICAgIGlmIChzaGlmdENvdW50ICUgMTUwID09PSAwKSB7XG4gICAgICAgIGN1cnJlbnRNMTVDYW5kbGUgPSB7XG4gICAgICAgICAgICB4OiByZWFsVGltZURhdGEueCxcbiAgICAgICAgICAgIHk6ICQuZXh0ZW5kKFtdLCByZWFsVGltZURhdGEueSlcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoRGF0YS5tMTVfY2FuZGxlcy5wdXNoKGN1cnJlbnRNMTVDYW5kbGUpO1xuICAgICAgICBncmFwaERhdGEubTE1X2JiX2RhdGEuc21hLnB1c2goY3VycmVudERhdGEubTE1X2JiX2RhdGEuc21hKTtcbiAgICAgICAgZ3JhcGhEYXRhLm0xNV9iYl9kYXRhLnVwcGVyLnB1c2goY3VycmVudERhdGEubTE1X2JiX2RhdGEudXBwZXIpO1xuICAgICAgICBncmFwaERhdGEubTE1X2JiX2RhdGEubG93ZXIucHVzaChjdXJyZW50RGF0YS5tMTVfYmJfZGF0YS5sb3dlcik7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50TTE1Q2FuZGxlID0gZ3JhcGhEYXRhLm0xNV9jYW5kbGVzW2dyYXBoRGF0YS5tMTVfY2FuZGxlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBjdXJyZW50TTE1Q2FuZGxlLnlbM10gPSByZWFsVGltZURhdGEueVszXTtcblxuICAgICAgICBpZiAoY3VycmVudE0xNUNhbmRsZS55WzFdIDwgcmVhbFRpbWVEYXRhLnlbMV0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRNMTVDYW5kbGUueVsxXSA9IHJlYWxUaW1lRGF0YS55WzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50TTE1Q2FuZGxlLnlbMl0gPiByZWFsVGltZURhdGEueVsyXSkge1xuICAgICAgICAgICAgY3VycmVudE0xNUNhbmRsZS55WzJdID0gcmVhbFRpbWVEYXRhLnlbMl07XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaERhdGEubTE1X2NhbmRsZXNbZ3JhcGhEYXRhLm0xNV9jYW5kbGVzLmxlbmd0aCAtIDFdID0gY3VycmVudE0xNUNhbmRsZTtcbiAgICB9XG5cbiAgICBpZiAoc2hpZnRDb3VudCAlIDYwMCA9PT0gMCkge1xuICAgICAgICBjdXJyZW50TTYwQ2FuZGxlID0ge1xuICAgICAgICAgICAgeDogcmVhbFRpbWVEYXRhLngsXG4gICAgICAgICAgICB5OiAkLmV4dGVuZChbXSwgcmVhbFRpbWVEYXRhLnkpXG4gICAgICAgIH1cblxuICAgICAgICBncmFwaERhdGEubTYwX2NhbmRsZXMucHVzaChjdXJyZW50TTYwQ2FuZGxlKTtcbiAgICAgICAgZ3JhcGhEYXRhLm02MF9iYl9kYXRhLnNtYS5wdXNoKGN1cnJlbnREYXRhLm02MF9iYl9kYXRhLnNtYSk7XG4gICAgICAgIGdyYXBoRGF0YS5tNjBfYmJfZGF0YS51cHBlci5wdXNoKGN1cnJlbnREYXRhLm02MF9iYl9kYXRhLnVwcGVyKTtcbiAgICAgICAgZ3JhcGhEYXRhLm02MF9iYl9kYXRhLmxvd2VyLnB1c2goY3VycmVudERhdGEubTYwX2JiX2RhdGEubG93ZXIpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE02MENhbmRsZSA9IGdyYXBoRGF0YS5tNjBfY2FuZGxlc1tncmFwaERhdGEubTYwX2NhbmRsZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgY3VycmVudE02MENhbmRsZS55WzNdID0gcmVhbFRpbWVEYXRhLnlbM107XG5cbiAgICAgICAgaWYgKGN1cnJlbnRNNjBDYW5kbGUueVsxXSA8IHJlYWxUaW1lRGF0YS55WzFdKSB7XG4gICAgICAgICAgICBjdXJyZW50TTYwQ2FuZGxlLnlbMV0gPSByZWFsVGltZURhdGEueVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE02MENhbmRsZS55WzJdID4gcmVhbFRpbWVEYXRhLnlbMl0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRNNjBDYW5kbGUueVsyXSA9IHJlYWxUaW1lRGF0YS55WzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JhcGhEYXRhLm02MF9jYW5kbGVzW2dyYXBoRGF0YS5tNjBfY2FuZGxlcy5sZW5ndGggLSAxXSA9IGN1cnJlbnRNNjBDYW5kbGU7XG4gICAgfVxuXG4gICAgc2hpZnRDb3VudCsrO1xuXG4gICAgcmV0dXJuIFtzaGlmdENvdW50IC0gMSwgcmVhbFRpbWVEYXRhLCBjdXJyZW50RGF0YS5tMV9iYl9kYXRhLCBjdXJyZW50TTVDYW5kbGUsIGN1cnJlbnREYXRhLm01X2JiX2RhdGEsIGN1cnJlbnRNMTVDYW5kbGUsIGN1cnJlbnREYXRhLm0xNV9iYl9kYXRhLCBjdXJyZW50TTYwQ2FuZGxlLCBjdXJyZW50RGF0YS5tNjBfYmJfZGF0YV07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmVhbFRpbWVEYXRhKGNhbmRsZSkge1xuICAgIHZhciBjYW5kbGVzID0gW107XG4gICAgdmFyIG9wZW5JbmRleCA9IDAsIGhpZ2hJbmRleCA9IDMsIGxvd0luZGV4ID0gNiwgY2xvc2VJbmRleCA9IDk7XG4gICAgdmFyIG9wZW4sIGhpZ2gsIGxvdywgY2xvc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgICAgY2FuZGxlLnlbaV0gPSBwYXJzZUZsb2F0KGNhbmRsZS55W2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSA5OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT0gb3BlbkluZGV4KSB7XG4gICAgICAgICAgICBvcGVuID0gaGlnaCA9IGxvdyA9IGNsb3NlID0gY2FuZGxlLnlbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGhpZ2hJbmRleCkge1xuICAgICAgICAgICAgY2xvc2UgPSBjYW5kbGUueVswXSArIChjYW5kbGUueVsxXSAtIGNhbmRsZS55WzBdKSAqIGkgLyAzO1xuICAgICAgICAgICAgaGlnaCA9IGNsb3NlO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPT0gaGlnaEluZGV4KSB7XG4gICAgICAgICAgICBjbG9zZSA9IGNhbmRsZS55WzFdO1xuICAgICAgICAgICAgaGlnaCA9IGNsb3NlO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPCBsb3dJbmRleCkge1xuICAgICAgICAgICAgY2xvc2UgPSBjYW5kbGUueVsxXSAtIChjYW5kbGUueVsxXSAtIGNhbmRsZS55WzJdKSAqIChpLTMpIC8gMztcbiAgICAgICAgICAgIGlmIChjbG9zZSA8IGxvdykge1xuICAgICAgICAgICAgICAgIGxvdyA9IGNsb3NlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGkgPT0gbG93SW5kZXgpIHtcbiAgICAgICAgICAgIGNsb3NlID0gY2FuZGxlLnlbMl07XG4gICAgICAgICAgICBsb3cgPSBjbG9zZTtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgY2xvc2VJbmRleCkge1xuICAgICAgICAgICAgY2xvc2UgPSBjYW5kbGUueVsyXSArIChjYW5kbGUueVszXSAtIGNhbmRsZS55WzJdKSAqIChpLTYpIC8gMztcbiAgICAgICAgfSBlbHNlIGlmIChpID09IGNsb3NlSW5kZXgpIHtcbiAgICAgICAgICAgIGNsb3NlID0gY2FuZGxlLnlbM107XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGxlc1tpXSA9IHtcbiAgICAgICAgICAgIHg6IGNhbmRsZS54LFxuICAgICAgICAgICAgeTogW29wZW4udG9GaXhlZCgyKSwgaGlnaC50b0ZpeGVkKDIpLCBsb3cudG9GaXhlZCgyKSwgY2xvc2UudG9GaXhlZCgyKV1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuZGxlcztcbn1cbiJdLCJuYW1lcyI6WyJmb3JtYXRDYW5kbGVzRGF0YSIsImRhdGEiLCIkIiwibWFwIiwibiIsIl9uIiwiX3RvQXJyYXkiLCJ0aW1lIiwicHJpY2VzIiwic2xpY2UiLCJ4IiwiRGF0ZSIsInkiLCJmb3JtYXRCYkRhdGEiLCJiYkRhdGEiLCJlYWNoIiwiaSIsIl9uMiIsIl9zbGljZWRUb0FycmF5Iiwic21hIiwic2QiLCJ1cHBlciIsImxvd2VyIiwicHVzaCIsImdyYXBoRGF0YSIsImNhbmRsZXMiLCJiYl9kYXRhIiwiZnV0dXJlRGF0YSIsImN1cnJlbnREYXRhIiwicmVhbFRpbWVEYXRhcyIsInNoaWZ0Q291bnQiLCJsb2FkR3JhcGhEYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJnZXRKU09OIiwidmFsIiwicmVzcG9uc2UiLCJtMV9jYW5kbGVzIiwibTFfYmJfZGF0YSIsIm01X2NhbmRsZXMiLCJtNV9iYl9kYXRhIiwibTE1X2NhbmRsZXMiLCJtMTVfYmJfZGF0YSIsIm02MF9jYW5kbGVzIiwibTYwX2JiX2RhdGEiLCJsb2FkRnV0dXJlRGF0YSIsImdldEdyYXBoRGF0YSIsInNoaWZ0RGF0YSIsInNoaWZ0IiwibGVuZ3RoIiwibmV4dENhbmRsZSIsImdlbmVyYXRlUmVhbFRpbWVEYXRhIiwicmVhbFRpbWVEYXRhIiwiY3VycmVudE01Q2FuZGxlIiwiY3VycmVudE0xNUNhbmRsZSIsImN1cnJlbnRNNjBDYW5kbGUiLCJleHRlbmQiLCJjYW5kbGUiLCJvcGVuSW5kZXgiLCJoaWdoSW5kZXgiLCJsb3dJbmRleCIsImNsb3NlSW5kZXgiLCJvcGVuIiwiaGlnaCIsImxvdyIsImNsb3NlIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/graph_data.js\n");

/***/ }),

/***/ "./resources/js/graph_service.js":
/*!***************************************!*\
  !*** ./resources/js/graph_service.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendGraph: () => (/* binding */ appendGraph),\n/* harmony export */   appendIndicator: () => (/* binding */ appendIndicator),\n/* harmony export */   changeGraphMode: () => (/* binding */ changeGraphMode),\n/* harmony export */   drawGraph: () => (/* binding */ drawGraph),\n/* harmony export */   updateGraph: () => (/* binding */ updateGraph)\n/* harmony export */ });\n/* harmony import */ var apexcharts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apexcharts */ \"./node_modules/apexcharts/dist/apexcharts.js\");\n/* harmony import */ var apexcharts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(apexcharts__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n\nvar getGraphOptions = function getGraphOptions() {\n  return {\n    series: [{\n      name: 'Candles',\n      type: 'candlestick',\n      data: []\n    }, {\n      name: 'Sma',\n      type: 'line',\n      data: []\n    }, {\n      name: 'Upper',\n      type: 'line',\n      data: []\n    }, {\n      name: 'Lower',\n      type: 'line',\n      data: []\n    }],\n    chart: {\n      type: 'candlestick',\n      height: 550\n    },\n    title: {\n      text: 'CandleStick Chart',\n      align: 'left'\n    },\n    stroke: {\n      curve: 'straight',\n      colors: ['#FF0000', '#CCCCCC', '#CCCCCC', '#CCCCCC']\n    },\n    xaxis: {\n      type: 'datetime',\n      labels: {\n        datetimeUTC: false\n      },\n      tooltip: {\n        enable: false\n      }\n    },\n    tooltip: {\n      x: {\n        format: 'HH:mm'\n      }\n    },\n    yaxis: {\n      tooltip: {\n        enabled: true\n      }\n    }\n  };\n};\nvar chart = {};\nfunction drawGraph(data, mode) {\n  var candles = data[mode + '_candles'];\n  var bbData = data[mode + '_bb_data'];\n  var options = getGraphOptions();\n  options.series[0].data = candles;\n  options.series[1].data = bbData.sma;\n  options.series[2].data = bbData.upper;\n  options.series[3].data = bbData.lower;\n  if (_typeof(data.orders) === 'object') {\n    $.each(data.orders, function (key, order) {\n      options.series.push({\n        name: 'Order ',\n        type: 'line',\n        data: [{\n          x: new Date(order.open_time * 1000),\n          y: order.open_price\n        }, {\n          x: new Date(order.close_time * 1000),\n          y: order.close_price\n        }]\n      });\n      options.stroke.colors.push(order.profit > 0 ? '#00FF00' : '#FF0000');\n    });\n  }\n  chart = new (apexcharts__WEBPACK_IMPORTED_MODULE_0___default())(document.querySelector(\"#chart\"), options);\n  chart.render();\n}\nfunction changeGraphMode(data, mode) {\n  var candles = data[mode + '_candles'];\n  var bbData = data[mode + '_bb_data'];\n  chart.updateSeries([{\n    data: candles\n  }, {\n    data: bbData.sma\n  }, {\n    data: bbData.upper\n  }, {\n    data: bbData.lower\n  }]);\n}\nfunction updateGraph(lastCandle) {\n  chart.replaceData([{\n    data: [lastCandle]\n  }]);\n}\nfunction appendGraph(lastCandle) {\n  chart.appendData([{\n    data: [lastCandle]\n  }]);\n}\nfunction appendIndicator(bbData) {\n  chart.appendData([{\n    data: []\n  }, {\n    data: [bbData.sma]\n  }, {\n    data: [bbData.upper]\n  }, {\n    data: [bbData.lower]\n  }]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVdBLENBQUNGLFVBQVUsRUFBRTtFQUNwQzdDLEtBQUssQ0FBQ2dELFVBQVUsQ0FBQyxDQUFDO0lBQUNqRCxJQUFJLEVBQUMsQ0FBQzhDLFVBQVU7RUFBQyxDQUFDLENBQUMsQ0FBQztBQUMzQztBQUNPLFNBQVNJLGVBQWVBLENBQUM3QixNQUFNLEVBQUU7RUFDcENwQixLQUFLLENBQUNnRCxVQUFVLENBQUMsQ0FDYjtJQUFDakQsSUFBSSxFQUFDO0VBQUUsQ0FBQyxFQUNUO0lBQUNBLElBQUksRUFBQyxDQUFDcUIsTUFBTSxDQUFDRSxHQUFHO0VBQUMsQ0FBQyxFQUNuQjtJQUFDdkIsSUFBSSxFQUFDLENBQUNxQixNQUFNLENBQUNHLEtBQUs7RUFBQyxDQUFDLEVBQ3JCO0lBQUN4QixJQUFJLEVBQUMsQ0FBQ3FCLE1BQU0sQ0FBQ0ksS0FBSztFQUFDLENBQUMsQ0FDeEIsQ0FBQztBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2dyYXBoX3NlcnZpY2UuanM/Y2I1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQXBleENoYXJ0cyBmcm9tICdhcGV4Y2hhcnRzJztcblxudmFyIGdldEdyYXBoT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdDYW5kbGVzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2FuZGxlc3RpY2snLFxuICAgICAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTbWEnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnVXBwZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnTG93ZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgICB0eXBlOiAnY2FuZGxlc3RpY2snLFxuICAgICAgICAgICAgIGhlaWdodDogNTUwXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgdGV4dDogJ0NhbmRsZVN0aWNrIENoYXJ0JyxcbiAgICAgICAgICAgICBhbGlnbjogJ2xlZnQnXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgY3VydmU6ICdzdHJhaWdodCcsXG4gICAgICAgICAgICBjb2xvcnM6IFsnI0ZGMDAwMCcsICcjQ0NDQ0NDJywgJyNDQ0NDQ0MnLCAnI0NDQ0NDQyddLFxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgIHR5cGU6ICdkYXRldGltZScsXG4gICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgIGRhdGV0aW1lVVRDOiBmYWxzZSxcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgICAgZW5hYmxlOiBmYWxzZVxuICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0hIOm1tJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBjaGFydCA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0dyYXBoKGRhdGEsIG1vZGUpIHtcbiAgICB2YXIgY2FuZGxlcyA9IGRhdGFbbW9kZSArICdfY2FuZGxlcyddO1xuICAgIHZhciBiYkRhdGEgPSBkYXRhW21vZGUgKyAnX2JiX2RhdGEnXTtcbiAgICB2YXIgb3B0aW9ucyA9IGdldEdyYXBoT3B0aW9ucygpO1xuXG4gICAgb3B0aW9ucy5zZXJpZXNbMF0uZGF0YSA9IGNhbmRsZXM7XG4gICAgb3B0aW9ucy5zZXJpZXNbMV0uZGF0YSA9IGJiRGF0YS5zbWE7XG4gICAgb3B0aW9ucy5zZXJpZXNbMl0uZGF0YSA9IGJiRGF0YS51cHBlcjtcbiAgICBvcHRpb25zLnNlcmllc1szXS5kYXRhID0gYmJEYXRhLmxvd2VyO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhLm9yZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgJC5lYWNoKGRhdGEub3JkZXJzLCBmdW5jdGlvbihrZXksIG9yZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdPcmRlciAnLFxuICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IG5ldyBEYXRlKG9yZGVyLm9wZW5fdGltZSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG9yZGVyLm9wZW5fcHJpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbmV3IERhdGUob3JkZXIuY2xvc2VfdGltZSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG9yZGVyLmNsb3NlX3ByaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlLmNvbG9ycy5wdXNoKG9yZGVyLnByb2ZpdCA+IDAgPyAnIzAwRkYwMCcgOiAnI0ZGMDAwMCcpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjaGFydCA9IG5ldyBBcGV4Q2hhcnRzKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjY2hhcnRcIiksIG9wdGlvbnMpO1xuICAgIGNoYXJ0LnJlbmRlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlR3JhcGhNb2RlKGRhdGEsIG1vZGUpIHtcbiAgICB2YXIgY2FuZGxlcyA9IGRhdGFbbW9kZSArICdfY2FuZGxlcyddO1xuICAgIHZhciBiYkRhdGEgPSBkYXRhW21vZGUgKyAnX2JiX2RhdGEnXTtcbiAgICBjaGFydC51cGRhdGVTZXJpZXMoW1xuICAgICAgICB7XG4gICAgICAgICAgICBkYXRhOiBjYW5kbGVzXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGE6IGJiRGF0YS5zbWFcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YTogYmJEYXRhLnVwcGVyXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGE6IGJiRGF0YS5sb3dlclxuICAgICAgICB9XG4gICAgXSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUdyYXBoKGxhc3RDYW5kbGUpIHtcbiAgICBjaGFydC5yZXBsYWNlRGF0YShbe2RhdGE6W2xhc3RDYW5kbGVdfV0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEdyYXBoKGxhc3RDYW5kbGUpIHtcbiAgICBjaGFydC5hcHBlbmREYXRhKFt7ZGF0YTpbbGFzdENhbmRsZV19XSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kSW5kaWNhdG9yKGJiRGF0YSkge1xuICAgIGNoYXJ0LmFwcGVuZERhdGEoW1xuICAgICAgICB7ZGF0YTpbXX0sXG4gICAgICAgIHtkYXRhOltiYkRhdGEuc21hXX0sXG4gICAgICAgIHtkYXRhOltiYkRhdGEudXBwZXJdfSxcbiAgICAgICAge2RhdGE6W2JiRGF0YS5sb3dlcl19LFxuICAgIF0pO1xufVxuIl0sIm5hbWVzIjpbIkFwZXhDaGFydHMiLCJnZXRHcmFwaE9wdGlvbnMiLCJzZXJpZXMiLCJuYW1lIiwidHlwZSIsImRhdGEiLCJjaGFydCIsImhlaWdodCIsInRpdGxlIiwidGV4dCIsImFsaWduIiwic3Ryb2tlIiwiY3VydmUiLCJjb2xvcnMiLCJ4YXhpcyIsImxhYmVscyIsImRhdGV0aW1lVVRDIiwidG9vbHRpcCIsImVuYWJsZSIsIngiLCJmb3JtYXQiLCJ5YXhpcyIsImVuYWJsZWQiLCJkcmF3R3JhcGgiLCJtb2RlIiwiY2FuZGxlcyIsImJiRGF0YSIsIm9wdGlvbnMiLCJzbWEiLCJ1cHBlciIsImxvd2VyIiwiX3R5cGVvZiIsIm9yZGVycyIsIiQiLCJlYWNoIiwia2V5Iiwib3JkZXIiLCJwdXNoIiwiRGF0ZSIsIm9wZW5fdGltZSIsInkiLCJvcGVuX3ByaWNlIiwiY2xvc2VfdGltZSIsImNsb3NlX3ByaWNlIiwicHJvZml0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwicmVuZGVyIiwiY2hhbmdlR3JhcGhNb2RlIiwidXBkYXRlU2VyaWVzIiwidXBkYXRlR3JhcGgiLCJsYXN0Q2FuZGxlIiwicmVwbGFjZURhdGEiLCJhcHBlbmRHcmFwaCIsImFwcGVuZERhdGEiLCJhcHBlbmRJbmRpY2F0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/graph_service.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/graph.js");
/******/ 	
/******/ })()
;